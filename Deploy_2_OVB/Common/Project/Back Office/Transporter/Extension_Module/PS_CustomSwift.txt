#
# Front Arena exported extension module.
# source          ""
# timestamp (utc) "2024-09-09 10:39:44.1"
# ***** DO NOT EDIT! *****
#
name        "PS_CustomSwift"
description "$Id$"

groups {
}

decls[FParameters] {
}

clx FObject [FParameters] {
  CashPairingViewEnabler =
  MTTypes=[]


  FFXMMConfirmationOut_Config =
  LocationCode={'BUENOS AIRES' : 'ARBA', 'VIENNA': 'ATVI', 'MELBOURNE' : 'AUME', 'SYDNEY' : 'AUSY', 'BRUSSELS' : 'BEBR', 'SAO PAULO':'BRSP', 'MONTREAL':'CAMO', 'TORONTO':'CATO', 'GENEVA':'CHGE', 'ZURICH':'CHZU', 'SANTIAGO':'CLSA', 'BEIJING':'CNBE', 'PRAGUE':'CZPR', 'EUROPEAN CENTRAL BANK':'DECB', 'FRANKFURT':'DEFR', 'COPENHAGEN':'DKCO', 'TALLINN':'EETA', 'MADRID':'ESMA', 'TARGET':'EUTA', 'HELSINKI':'FIHE', 'PARIS':'FRPA', 'LONDON':'GBLO', 'ATHENS':'GRAT', 'HONG KONG':'HKHK', 'BUDAPEST':'HUBU', 'JAKARTA':'IDJA', 'DUBLIN':'IEDU', 'TEL AVIV':'ILTA', 'MUMBAI':'INMU', 'MILAN':'ITMI', 'ROME':'ITRO', 'TOKYO':'JPTO', 'SEOUL':'KRSE', 'BEIRUT':'LBBE', 'COLOMBO':'LKCO', 'LUXEMBOURG':'LULU', 'MEXICO CITY':'MXMC', 'KUALA LUMPUR':'MYKL', 'AMSTERDAM':'NLAM', 'OSLO':'NOOS', 'NEW YORK FED':'NYFD', 'NEW YORK STOCK EXCHANGE':'NYSE', 'AUCKLAND':'NZAU', 'WELLINGTON':'NZWE', 'PANAMA CITY':'PAPC', 'MANILA':'PHMA', 'WARSAW':'PLWA', 'LISBON':'PTLI', 'BUCHAREST':'ROBU', 'MOSCOW':'RUMO', 'RIYADH':'SARI', 'STOCKHOLM':'SEST', 'SINGAPORE':'SGSI', 'BRATISLAVA':'SKBR', 'BANGKOK':'THBA', 'ANKARA':'TRAN', 'ISTANBUL':'TRIS', 'TAIPEI':'TWTA', 'CHICAGO':'USCH', 'U.S. GOVERNMENT SECURITIES':'USGS', 'LOS ANGELES':'USLA', 'NEW YORK':'USNY', 'HANOI':'VNHA', 'JOHANNESBURG':'ZAJO', 'JAKARTA':'IDJA'}


  FMT299NarrativeOut_Config =
  MT299Narrative_Party={'SettlementTemplate': 'ATTN MONEY TRANSFER DEPT\n\nPLEASE CREDIT OUR ACCOUNT WITH YOU\nFOR AMOUNT <CURRENCY> <AMOUNT> VALUE DATED <VALUE_DATE>\nFOR COVER WE CREDIT YOUR ACCOUNT\nTHRU <CORR_BANK> UNDER OUR REF. <REF>\nVALUE DATED <VALUE_DATE>\n\nTHANK YOU FOR YOUR KIND COOPERATION.\n\nKIND REGARDS,\n\nSETTLEMENT SECTIONS\nTREASURY OPERATIONS DEPT\nBANK MANDIRI HEAD OFFICE'}


  FMT300In_Config =
  Match={'BuyCurrency':{'FLIP_SIDE':['SellCurrency']}, 'BuyAmount':{'FLIP_SIDE':['SellAmount'], 'CMP_FUNC':'precision','ARG':'0.01'}, 'SellCurrency':{'FLIP_SIDE':['BuyCurrency']}, 'SellAmount':{'FLIP_SIDE':['BuyAmount'], 'CMP_FUNC':'precision','ARG':'0.01'}, 'Acquirer':{'FLIP_SIDE':['Counterparty'],'CMP_FUNC':'bic_comparator'}, 'Counterparty':{'FLIP_SIDE':['Acquirer'],'CMP_FUNC':'bic_comparator'}, 'TradeDate':{}, 'ValueDate':{}, 'ExchangeRate':{'CMP_FUNC':'precision','ARG':'0.01'}, 'BuyReceivingAgent':{'FLIP_SIDE':['SellReceivingAgent'],'CMP_FUNC':'bic_comparator_ndf'}, 'SellReceivingAgent':{'FLIP_SIDE':['BuyReceivingAgent'], 'CMP_FUNC':'bic_comparator_ndf'}, 'BuyIntermediary':{'FLIP_SIDE':['SellIntermediary'], 'CMP_FUNC':'bic_comparator', 'LEVEL':'O'}, 'SellIntermediary':{'FLIP_SIDE':['BuyIntermediary'], 'CMP_FUNC':'bic_comparator', 'LEVEL':'O'}}
  Pair={ 'BuyCurrency':{'FLIP_SIDE':['SellCurrency']}, 'BuyAmount':{'FLIP_SIDE':['SellAmount'], 'CMP_FUNC':'precision','ARG':'0.01'}, 'SellCurrency':{'FLIP_SIDE':['BuyCurrency']}, 'SellAmount':{'FLIP_SIDE':['BuyAmount','NEGATE'], 'CMP_FUNC':'precision','ARG':'0.01'}, 'Acquirer':{'FLIP_SIDE':['Counterparty'], 'CMP_FUNC':'bic_comparator'}, 'Counterparty':{'FLIP_SIDE':['Acquirer'],'CMP_FUNC':'bic_comparator'}, 'TradeDate':{}, 'ValueDate':{}, 'ExchangeRate':{'CMP_FUNC':'precision','ARG':'0.01' }}
  PairingViewBPRColumns=SendersReference,RelatedReference,Acquirer,Counterparty,TradeDate,ValueDate,ExchangeRate,BuyCurrency,BuyAmount,BuyIntermediary,BuyReceivingAgent,SellCurrency,SellAmount,SellIntermediary,SellReceivingAgent


  FMT305In_Config =
  Match={'IsCallOption':{}, 'ExerciseType':{}, 'DateContractAgreedAmended':{}, 'EarliestExerciseDate':{}, 'ExpiryDate':{}, 'FinalSettlementDate':{}, 'SettlementType':{}, 'UnderlyingCurrency':{}, 'UnderlyingAmount':{'CMP_FUNC':'precision','ARG':'0.01'}, 'StrikePrice':{'CMP_FUNC':'precision','ARG':'0.01'}, 'CounterCurrency':{}, 'CounterAmount':{}, 'Acquirer':{'FLIP_SIDE':['Counterparty'], 'CMP_FUNC':'bic_comparator'},'Counterparty':{'FLIP_SIDE':['Acquirer'],'CMP_FUNC':'bic_comparator'}, 'PremiumPrice':{'CMP_FUNC':'precision','ARG':'0.01'}, 'Premium':{'CMP_FUNC':'precision','ARG':'0.01'}, 'PremiumDate':{}, 'PremiumCurrency':{}, 'SendersCorrespondent':{'CMP_FUNC':'bic_comparator'}, 'AccountWithInstitution':{'CMP_FUNC':'bic_comparator'} }
  Pair={'IsCallOption':{}, 'ExerciseType':{}, 'DateContractAgreedAmended':{}, 'ExpiryDate':{}, 'UnderlyingCurrency':{}, 'UnderlyingAmount':{'CMP_FUNC':'precision','ARG':'0.01'}, 'CounterCurrency':{}, 'Acquirer':{'FLIP_SIDE':['Counterparty'], 'CMP_FUNC':'bic_comparator'},'Counterparty':{'FLIP_SIDE':['Acquirer'],'CMP_FUNC':'bic_comparator'}, 'Premium':{'CMP_FUNC':'precision','ARG':'0.01'}, 'PremiumDate':{}, 'PremiumCurrency':{}}


  FMT320In_Config =
  Match={'Currency':{},'PrincipalAmount':{'CMP_FUNC':'precision','ARG':'0.01'}, 'TradeDate':{}, 'AcquirerRole':{'FLIP_SIDE':['INVERT']},'ValueDate':{}, 'MaturityDate':{}, 'InterestAmount':{'FLIP_SIDE':['NEGATE'], 'CMP_FUNC':'precision','ARG':'0.0'},'InterestRate':{'CMP_FUNC':'precision','ARG':'0.0'},'Acquirer':{'FLIP_SIDE':['Counterparty'], 'CMP_FUNC':'bic_comparator'},'Counterparty':{'FLIP_SIDE':['Acquirer'], 'CMP_FUNC':'bic_comparator'}, 'CounterpartyReceivingAgent':{'FLIP_SIDE':['AcquirerReceivingAgent'], 'CMP_FUNC':'bic_comparator'}, 'AcquirerReceivingAgent':{'FLIP_SIDE':['CounterpartyReceivingAgent'], 'CMP_FUNC':'bic_comparator'}, 'CounterpartyIntermediary':{'FLIP_SIDE':['AcquirerIntermediary'], 'CMP_FUNC':'bic_comparator'}, 'AcquirerIntermediary':{'FLIP_SIDE':['CounterpartyIntermediary'], 'CMP_FUNC':'bic_comparator'}, 'DayCountFraction':{}}
  Pair={'Currency':{}, 'PrincipalAmount':{'CMP_FUNC':'precision','ARG':'0.01'}, 'TradeDate':{}, 'AcquirerRole':{'FLIP_SIDE':['INVERT']}, 'ValueDate':{}, 'MaturityDate':{}, 'InterestAmount':{'FLIP_SIDE':['NEGATE'], 'CMP_FUNC':'precision','ARG':'0.0'}, 'InterestRate':{'CMP_FUNC':'precision','ARG':'0.0'},'Acquirer':{'FLIP_SIDE':['Counterparty'], 'CMP_FUNC':'bic_comparator'},'Counterparty':{'FLIP_SIDE':['Acquirer'], 'CMP_FUNC':'bic_comparator'}, 'CounterpartyReceivingAgent':{'FLIP_SIDE':['AcquirerReceivingAgent'], 'CMP_FUNC':'bic_comparator'}, 'AcquirerReceivingAgent':{'FLIP_SIDE':['CounterpartyReceivingAgent'], 'CMP_FUNC':'bic_comparator'}}
  PairingViewBPRColumns=SendersReference,RelatedReference,Acquirer,Counterparty,TradeDate,ValueDate,MaturityDate,InterestRate,PrincipalAmount,Currency,CounterpartyIntermediary,CounterpartyReceivingAgent,AcquirerIntermediary,AcquirerReceivingAgent


  FMT518In_Config =
  Match={'SettlementDate': {}, 'TradeDate': {}, 'IdentificationOfFinancialInstrument': {}, 'BuySellIndicator': {'FLIP_SIDE':['INVERT']}, 'PaymentIndicator': {}, 'QuantityOfInstrument': {}, 'DealPrice': {}, 'Rate': {}, 'SettlementAmount':{}, 'AccruedInterestAmount':{}, 'Acquirer':{'FLIP_SIDE':['Counterparty'],'CMP_FUNC':'bic_comparator'}, 'Counterparty':{'FLIP_SIDE':['Acquirer'],'CMP_FUNC':'bic_comparator'}}
  Pair={'SettlementDate': {}, 'TradeDate': {}, 'IdentificationOfFinancialInstrument': {}, 'BuySellIndicator': {'FLIP_SIDE':['INVERT']},  'QuantityOfInstrument': {}, 'DealPrice': {}, 'Rate': {}, 'Acquirer':{'FLIP_SIDE':['Counterparty'],'CMP_FUNC':'bic_comparator'}, 'Counterparty':{'FLIP_SIDE':['Acquirer'],'CMP_FUNC':'bic_comparator'}}


  FMT599Out_Config =
  MT599_Party={'SettlementTemplate': 'ATTN MONEY TRANSFER DEPT\n\nPLEASE CREDIT OUR ACCOUNT WITH YOU\nFOR AMOUNT <CURRENCY> <AMOUNT> VALUE DATED <VALUE_DATE>\nFOR COVER WE CREDIT YOUR ACCOUNT\nTHRU <CORR_BANK> UNDER OUR REF. <REF>\nVALUE DATED <VALUE_DATE>\n\nTHANK YOU FOR YOUR KIND COOPERATION.\n\nKIND REGARDS,\n\nSETTLEMENT SECTIONS\nTREASURY OPERATIONS DEPT\nBANK MANDIRI HEAD OFFICE'}


  FSwiftReaderConfig =
  Modules=['FFXMMConfirmationInMain', 'FSecuritySettlementInMain']


  FSwiftSolutionConfig =
  AMBAddress=localhost:9100/mb


  FSwiftWriterConfig =
  Modules=['FFXMMConfirmationOutMain', 'FSecuritySettlementOutMain','FCashOutMain']
  RoundPerCurrency={'EUR':2, 'USD':2, 'JPY':0, 'KRW':0, 'TRY':0, 'KWD':3, 'AED':2, 'ARS':2, 'AUD':2, 'BAM':2, 'BRL':2, 'BGN':2, 'CAD':2, 'CNY':2, 'CZK':2, 'DKK':2, 'GBP':2, 'HKD':2, 'HRK':2, 'HUF':2, 'ISK':2, 'INR':2, 'IDR':2, 'LVL':2, 'MYR':2, 'MXN':2, 'MXV':2, 'NZD':2, 'NOK':2, 'PHP':2, 'SAR':2, 'SGD':2, 'ZAR':2, 'SEK':2, 'CHF':2, 'TWD':2, 'THB':2, 'VND':0}


  FXMMPairingViewEnabler =
  MTTypes=['300', '320', '305']


  SecurityPairingViewEnabler =
  MTTypes=['518', '544', '545', '546', '547']


}

decls[FPythonCode] {
}

clx FObject [FPythonCode] {
  FMT103Out
"""----------------------------------------------------------------------------
MODULE:
    FMT103Out

DESCRIPTION:
    This module provides the customizable class for the FMT103 outgoing implementation

CLASS:
    FMT103

VERSION: 3.6.3-0.5.6048
----------------------------------------------------------------------------"""
import FSwiftWriterLogger
notifier = FSwiftWriterLogger.FSwiftWriterLogger('CashSetlemnt', 'FCashOutNotify_Config')
import FMT103OutBase
import acm
import MT103
from FSwiftMLUtils import accepts
import xml.dom.minidom
from FSwiftWriterEngine import validate_with

@accepts([acm.FSettlement, MT103.CTD_ANON, xml.dom.minidom.Document])
class FMT103(FMT103OutBase.FMT103Base):

    def __init__(self, acm_obj, swift_obj):
        super(FMT103, self).__init__(acm_obj, swift_obj)

    # To override existing mappings use below methods to write your own logic

    """
    account_with_institution_57A
    account_with_institution_57C
    account_with_institution_57D
    bank_operation_code_23B
    beneficiary_customer_59A
    beneficiary_customer_59F
    beneficiary_customer_no_option_59
    details_of_charges_71A
    instructed_amount_33B
    instruction_code_23E
    intermediary_institution_56A
    intermediary_institution_56C
    intermediary_institution_56D
    ordering_customer_50A
    ordering_customer_50F
    ordering_customer_50K
    ordering_institution_52A
    ordering_institution_52D
    remittance_information_70
    senders_correspondent_53A
    senders_correspondent_53D
    senders_reference_20
    value_date_32A
    get_user_data

    """

    """
    To override the options provided, use below methods to write your own logic:-
    methods:- 
    get_ordering_customer_option (Tag-50 options:A/F/K)
    get_ordering_institution_option (Tag-52 options:A/D)
    get_senders_correspondent_option (Tag-53 options:A/D)
    get_intermediary_institution_option (Tag-56 options:A/C/D)
    get_account_with_institution_option (Tag-57 options:A/C/D)
    get_beneficiary_customer_option (Tag-59 options:A/NO OPTION/F)

    For example:
    def get_ordering_customer_option(self):
        condition = True
        if condition:
            return 'A'
        else:
            return 'F'

    """
    # ------------------------------ OVERRIDE START ---------------------------


    # ------------------------------------- SWIFT TAG 50A ---------------------
    def _format_ordering_customer_50A(self, val):
        ordering_customer_bic = val.get('BIC')
        if ordering_customer_bic:
            return str(ordering_customer_bic)   
    # ------------------------------------- SWIFT TAG 50A ---------------------

    # ------------------------------------- SWIFT TAG 52A ---------------------
    def _check_condition_set_OPTION_ordering_institution(self):
        return False
    # ------------------------------------- SWIFT TAG 52A ---------------------

    # ------------------------------------- SWIFT TAG 53A ---------------------
    def _check_condition_set_OPTION_senders_correspondent(self):
        return False
    # ------------------------------------- SWIFT TAG 53A ---------------------

    # ------------------------------------- SWIFT TAG 56A ---------------------
    def _format_intermediary_institution_56A(self, val):
        intermediary_institution_bic = val.get('BIC')
        if intermediary_institution_bic:
            return str(intermediary_institution_bic)        
    # ------------------------------------- SWIFT TAG 56A ---------------------

    # ------------------------------------- SWIFT TAG 57A ---------------------
    def _format_account_with_institution_57A(self, val):
        account_with_institution_bic = val.get('BIC')
        if account_with_institution_bic:
            return str(account_with_institution_bic)        
    # ------------------------------------- SWIFT TAG 57A ---------------------

    # ------------------------------------- SWIFT TAG 59A ---------------------
    '''
    def _format_beneficiary_customer_59A(self, val):
        beneficiary_customer_bic = val.get('BIC')
        if beneficiary_customer_bic:
            return str(beneficiary_customer_bic)        
    # ------------------------------------- SWIFT TAG 59A ---------------------
    '''
    
    # ------------------------------------- SWIFT TAG 72 ----------------------
    '''
    Sender to receiver information is kept in additional info on Trade per line.
    '''
    # getter
    def sender_to_receiver_info_72(self):
        ''' Returns sender to receiver information '''
        sender_to_receiver_info = []
        trade = self.acm_obj.Trade()
        if trade:
            add_info_obj = trade.ConnectedTrade().AdditionalInfo() if trade.TradeProcess() == 32768 else trade.AdditionalInfo()        
            for attr_name in ['SwiftSettleTag72_1', 'SwiftSettleTag72_2', 'SwiftSettleTag72_3',
                'SwiftSettleTag72_4', 'SwiftSettleTag72_5', 'SwiftSettleTag72_6']:
                attr_obj = getattr(add_info_obj, attr_name, None)
                attr_value = attr_obj() if attr_obj else ''
                if attr_value:
                    qualifier = '/BNF/' if attr_name == 'SwiftSettleTag72_1' else '//'
                    sender_to_receiver_info.append(qualifier + attr_value)

        return sender_to_receiver_info

    # formatter
    def _format_sender_to_receiver_info_72(self, val):
        MAX_LENGTH = 35
        temp_sender_to_receiver_info = [line[:MAX_LENGTH] for line in val]
        return "\n".join(temp_sender_to_receiver_info)

    # validator
    @validate_with(MT103.MT103_72_Type)
    def _validate_sender_to_receiver_info_72(self, val):
        return val

    # setter
    def _set_sender_to_receiver_info_72(self, val):
        self.swift_obj.SenderToReceiverInformation = val
        self.swift_obj.SenderToReceiverInformation.swiftTag = "72"
    # ------------------------------------- SWIFT TAG 72 ----------------------

    # ------------------------------ OVERRIDE -----------------------------------    
    
    # ------------------------------ OVERRIDE END -----------------------------


class FMT103MessageHeader(FMT103OutBase.FMT103OutBaseMessageHeader):

    def __init__(self, acm_obj, swift_msg_tags):
        self.acm_obj = acm_obj
        self.swift_msg_tags = swift_msg_tags
        super(FMT103MessageHeader, self).__init__(acm_obj, swift_msg_tags)

    # To override existing mappings use below methods to write your own logic

    """
    application_id
    service_id
    sender_logical_terminal_address
    session_number
    sequence_number
    input_or_output
    message_priority
    message_type
    receiver_logical_terminal_address
    delivery_monitoring
    non_delivery_notification_period
    service_identifier
    banking_priority_code
    message_user_reference
    validation_flag
    """


class FMT103NetworkRules(FMT103OutBase.FMT103OutBaseNetworkRules):

    def __init__(self, swift_message_obj, swift_message, acm_obj):
        super(FMT103NetworkRules, self).__init__(swift_message_obj, swift_message, acm_obj)


...

  FMT200Out
"""----------------------------------------------------------------------------
MODULE:
    FMT200Out

DESCRIPTION:
    This module provides the customizable class for the FMT200 outgoing implementation

CLASS:
    FMT200

VERSION: 3.6.3-0.5.6048
----------------------------------------------------------------------------"""
import MT200
import acm
import xml.dom.minidom
from FSwiftMLUtils import accepts

import FMT200OutBase
import FSwiftWriterLogger
from FSwiftWriterEngine import validate_with

notifier = FSwiftWriterLogger.FSwiftWriterLogger('CashSetlemnt', 'FCashOutNotify_Config')

@accepts([acm.FSettlement, MT200.CTD_ANON, xml.dom.minidom.Document])
class FMT200(FMT200OutBase.FMT200Base):

    def __init__(self, acm_obj, swift_obj):
        super(FMT200, self).__init__(acm_obj, swift_obj)

    # To override existing mappings use below methods to write your own logic
    """
    account_with_institution_57A
    account_with_institution_57D
    date_currency_amount_32A
    intermediary_56A
    intermediary_56D
    senders_correspondent_53B
    transaction_reference_20
    get_user_data
    """

    """
    To override the options provided, use below methods to write your own logic:-
    methods:- 
    get_intermediary_option (Tag-56 options:A/D)
    get_account_with_institution_option (Tag-57 options:A/D)

    For example:
    def get_intermediary_option(self):
        condition = True
        if condition:
            return 'A'
        else:
            return 'D'

    """
    # ------------------------------------- OVERRIDE START --------------------
    
    # ------------------------------------- SWIFT TAG 72 ----------------------

    '''
    Sender to receiver information is kept in additional info on Trade per line.
    '''
    # getter
    def sender_to_receiver_info_72(self):
        ''' Returns sender to receiver information '''
        sender_to_receiver_info = []
        trade = self.acm_obj.Trade()
        if trade:
            add_info_obj = trade.ConnectedTrade().AdditionalInfo() if trade.TradeProcess() == 32768 else trade.AdditionalInfo()        
            for attr_name in ['SwiftSettleTag72_1', 'SwiftSettleTag72_2', 'SwiftSettleTag72_3',
                'SwiftSettleTag72_4', 'SwiftSettleTag72_5', 'SwiftSettleTag72_6']:
                attr_obj = getattr(add_info_obj, attr_name, None)
                attr_value = attr_obj() if attr_obj else ''
                if attr_value:
                    qualifier = '/BNF/' if attr_name == 'SwiftSettleTag72_1' else '//'
                    sender_to_receiver_info.append(qualifier + attr_value)

        return sender_to_receiver_info

    # formatter
    def _format_sender_to_receiver_info_72(self, val):
        MAX_LENGTH = 35
        temp_sender_to_receiver_info = [line[:MAX_LENGTH] for line in val]
        return "\n".join(temp_sender_to_receiver_info)

    # validator
    @validate_with(MT200.MT200_72_Type)
    def _validate_sender_to_receiver_info_72(self, val):
        return val

    # setter
    def _set_sender_to_receiver_info_72(self, val):
        self.swift_obj.SenderToReceiverInformation = val
        self.swift_obj.SenderToReceiverInformation.swiftTag = "72"

    # ------------------------------------- SWIFT TAG 72 ----------------------

    # ------------------------------------- OVERRIDE END ----------------------


class FMT200MessageHeader(FMT200OutBase.FMT200OutBaseMessageHeader):

    def __init__(self, acm_obj, swift_msg_tags):
        self.acm_obj = acm_obj
        self.swift_msg_tags = swift_msg_tags
        super(FMT200MessageHeader, self).__init__(acm_obj, swift_msg_tags)

    # To override existing mappings use below methods to write your own logic

    """
    application_id
    service_id
    sender_logical_terminal_address
    session_number
    sequence_number
    input_or_output
    message_priority
    message_type
    receiver_logical_terminal_address
    delivery_monitoring
    non_delivery_notification_period
    service_identifier
    banking_priority_code
    message_user_reference
    validation_flag
    """

class FMT200NetworkRules(FMT200OutBase.FMT200OutBaseNetworkRules):

    def __init__(self, swift_message_obj, swift_message, acm_obj):
        super(FMT200NetworkRules, self).__init__(swift_message_obj, swift_message, acm_obj)


...

  FMT202Out
"""----------------------------------------------------------------------------
MODULE:
    FMT202Out

DESCRIPTION:
    This module provides the customizable class for the FMT202 outgoing implementation

CLASS:
    FMT202

VERSION: 3.6.3-0.5.6048
----------------------------------------------------------------------------"""
import MT202
import acm
import xml.dom.minidom
from FSwiftMLUtils import accepts

import FMT202OutBase

import FSwiftWriterLogger
from FSwiftWriterEngine import validate_with
import FMTUtils, FCashOutUtils

notifier = FSwiftWriterLogger.FSwiftWriterLogger('CashSetlemnt', 'FCashOutNotify_Config')

# ------------------------------ OVERRIDE START ---------------------------
import FSwiftMLUtils
import InterfaceSettingUtils
PVP_APPLICABLE = True if InterfaceSettingUtils.get_env_name() == 'HK' else False
# ------------------------------ OVERRIDE END -----------------------------

@accepts([acm.FSettlement, MT202.CTD_ANON, xml.dom.minidom.Document])
class FMT202(FMT202OutBase.FMT202Base):

    def __init__(self, acm_obj, swift_obj):
        super(FMT202, self).__init__(acm_obj, swift_obj)
        

    # To override existing mappings use below methods to write your own logic
    """
    account_with_institution_57A
    account_with_institution_57D
    beneficiary_institution_58A
    beneficiary_institution_58D
    date_currency_amount_32A
    intermediary_56A
    intermediary_56D
    ordering_institution_52A
    ordering_institution_52D
    related_reference_21
    senders_correspondent_53A
    senders_correspondent_53D
    transaction_reference_20
    get_user_data
    """
    """
    To override the options provided, use below methods to write your own logic:-
    methods:- 
    get_ordering_institution_option (Tag-52 options:A/D)
    get_senders_correspondent_option (Tag-53 options:A/D)
    get_intermediary_option (Tag-56 options:A/D)
    get_account_with_institution_option (Tag-57 options:A/D)
    get_beneficiary_institution_option (Tag-58 options:A/D)
    
    For example:
    def get_ordering_institution_option(self):
        condition = True
        if condition:
            return 'A'
        else:
            return 'D'

    """
    # ------------------------------ OVERRIDE START ---------------------------
    
    # ------------------------------------- SWIFT TAG 52A ---------------------
    def _check_condition_set_OPTION_ordering_institution(self):
        if PVP_APPLICABLE:
            trade = FMTUtils.getNettedTradefromSettlement(self.acm_obj)
            if FMTUtils.isFXAddInfoPaymentPVP(trade):
                return True
        return False
        
        # getter
    def ordering_institution_52A(self):
        """ Returns dictionary as {'ACCOUNT':<value>, 'BIC':<value>}"""
        party_details = FCashOutUtils.get_acquirer_details(self.acm_obj)
        party_details['BIC'] = FCashOutUtils.get_senders_bic(self.acm_obj)
        return party_details
        
    # formatter
    def _format_ordering_institution_52A(self, val):
        ordering_institution_account = val.get('ACCOUNT')
        ordering_institution_bic = val.get('BIC')
        if ordering_institution_bic:
            val = str(ordering_institution_bic)
        return val
    # ------------------------------------- SWIFT TAG 52A ---------------------
    

    # ------------------------------------- SWIFT TAG 53A ---------------------
    def _check_condition_set_OPTION_senders_correspondent(self):
        ret_val = False
        if PVP_APPLICABLE or FMTUtils.isRTGSNetwork(self.acm_obj): 
            ret_val = False
        elif self.acm_obj and self.acm_obj.Type() == 'Account Transfer':
            ret_val = True
        return False
        
    def _format_senders_correspondent_53A(self, val):
        correspondent_bic = val.get('BIC', None)
        if correspondent_bic:
            return str(correspondent_bic)
        
        return correspondent_bic
    # ------------------------------------- SWIFT TAG 53A ---------------------


    
    # ------------------------------------- SWIFT TAG 56A ---------------------
    def _format_intermediary_56A(self, val):
        intermediary_bic = val.get('BIC')
        if intermediary_bic:
            return str(intermediary_bic)
    # ------------------------------------- SWIFT TAG 56A ---------------------
    
    
    # ------------------ Intermediary_56A-----------------------
    def _check_condition_set_OPTION_intermediary(self):
        # Condition to generate tag 56
        # network is RTGS CorrespondentBank3 is defined OR
        # network is SWIFT and CorrespondentBank2 is define
        trade = FMTUtils.getNettedTradefromSettlement(self.acm_obj)
        checkIntermediary =  True
        
        if PVP_APPLICABLE and FMTUtils.isFXAddInfoPaymentPVP(trade):
            checkIntermediary =  False
        return checkIntermediary
             
    # ------------------------------------- SWIFT TAG 56A ---------------------
    
    # ------------------------------------- SWIFT TAG 72 ----------------------
    '''
    Sender to receiver information is kept in additional info on Trade per line.
    '''
        # getter
    def getFXTAG72SecondLine(self, settlement, trade, paymentCode):
        tradeCurrency1Name = trade.CurrencyPair().Currency1().Name()
        tradeCurrency2Name = trade.CurrencyPair().Currency2().Name()
        settlementCurrencyName = settlement.Currency().Name()
        secondLine = None
        mtCurrency = tradeCurrency1Name if tradeCurrency2Name == settlementCurrencyName else tradeCurrency2Name
        mtCurrency = 'CNY' if FMTUtils.replaceCNHtoCNY(mtCurrency) else mtCurrency       
        tradePremium = trade.Premium()
        tradeQuantity = trade.Quantity()
        amount = abs(tradePremium) if tradePremium > tradeQuantity else abs(tradeQuantity)
        settlementAmount = str("{0:,.2f}".format(abs(amount)))
        if paymentCode == '/SPRO/08':
            #settlementAmount = str("{0:.2f}".format(abs(amount))) if FMTUtils.isFXAddInfoPaymentPVP(trade) else str("{0:,.2f}".format(abs(amount)))
            settlementAmount = FMTUtils.convertDotToCommaSeparator(amount) if FMTUtils.isFXAddInfoPaymentPVP(trade) else str("{0:,.2f}".format(abs(amount)))
            secondLine = '/OCMT/' + mtCurrency + settlementAmount + '/'            
        elif paymentCode == '/SPRO/02':
            secondLine = '//PURCHASE OF ' + mtCurrency + settlementAmount
        else:
            secondLine = None
            
        if len(secondLine) > 35:
            secondLine = secondLine[0:35]
            
        return secondLine
        
    def getFXTAG72LastLine(self, settlement, trade, paymentCode):
        lastLine = None
        if paymentCode == '/SPRO/08':
            lastLine = '//PVP SETTLEMENT'
            return lastLine
        elif paymentCode == '/SPRO/02':
            tradePrice = str(trade.Price())
            tardeDate = str(dt.datetime.strptime(trade.TradeTime(),'%Y-%m-%d %H:%M:%S').strftime('%b %d, %Y').upper())
            lastLine = '//AT ' + tradePrice + ' DONE ON ' + tardeDate
        else:
            lastLine = None
            
        if len(lastLine) > 35:
            lastLine = lastLine[0:35]
        return lastLine
        
    def paymentCodefor72FX(self, acm_obj):
        paymentCode = settlementAmount = lastLine = secondLine = tradePrice = tardeDate = temp_cptAccRef_AddInfo = None
        settlement = self.acm_obj
        settlement_CptAccRef_AddInfo = self.acm_obj.CounterpartyAccountRef().AdditionalInfo()
        tag72FX = []
        trade = FMTUtils.getNettedTradefromSettlement(self.acm_obj)
        if FMTUtils.cptAccRef_AddInfo_to_receiver_info_72(self.acm_obj, settlement_CptAccRef_AddInfo):
            temp_cptAccRef_AddInfo = FMTUtils.cptAccRef_AddInfo_to_receiver_info_72(self.acm_obj, settlement_CptAccRef_AddInfo)
            temp_cptAccRef_AddInfo = "\n".join(temp_cptAccRef_AddInfo)
        if FMTUtils.isFXAddInfoPaymentPVP(trade):
            #if trade.AdditionalInfo().Payment_Method_FX() == 'PVP':
            paymentCode = '/SPRO/08'
            tag72FX.append(paymentCode)
            tag72FX.append(self.getFXTAG72SecondLine(settlement, trade, paymentCode))
            tag72FX.append(self.getFXTAG72LastLine(settlement, trade, paymentCode))
            if temp_cptAccRef_AddInfo and len(tag72FX) == 3:
                del tag72FX[-1]
                tag72FX.append(temp_cptAccRef_AddInfo)
        else:
            paymentCode = '/SPRO/02'
            tag72FX.append(paymentCode)
            tag72FX.append(self.getFXTAG72SecondLine(settlement, trade, paymentCode))
            tag72FX.append(self.getFXTAG72LastLine(settlement, trade, paymentCode))
        return tag72FX
    
    def paymentCodefor72Deposit(self, acm_obj):
        paymentCode = settlementAmount = secondLine =  lastLine = None
        settlement = self.acm_obj
        tag72Deposite = []
        trade = FMTUtils.getNettedTradefromSettlement(self.acm_obj)
        if trade.AdditionalInfo().Payment_Method_MM() == 'Thru CCASS':
            paymentCode = '/SPRO/57'
            tag72Deposite.append(paymentCode)
        elif trade.AdditionalInfo().Payment_Method_MM() == 'Optimzer Payment':
            paymentCode = '/SPRO/37'
            tag72Deposite.append(paymentCode)
        elif trade.TradeCategory() == 'Collateral' and trade.AdditionalInfo().Payment_Method_MM() == None:
            paymentCode = '/SPRO/02'
            secondLine = '//COLLATERAL PAYMENT'
            tag72Deposite.append(paymentCode)
            tag72Deposite.append(secondLine)
        elif not FMTUtils.isLoan(settlement):
            if (settlement.SettlementType() == 'Fixed Amount' or settlement.SettlementType() ==  'None') or \
                ((trade.AdditionalInfo().Payment_Method_MM() == None) and \
                not (trade.TradeCategory() == 'Collateral')):
                paymentCode = '/SPRO/04'
                secondLine = '//REPAYMENT OF DEPOSIT WITH US'
                tag72Deposite.append(paymentCode)
                tag72Deposite.append(secondLine)
        elif (trade.Counterparty().Swift() == 'HKMAHKHHXXX' and FMTUtils.isLoan(settlement)) and \
            ((trade.AdditionalInfo().Payment_Method_MM() == None) and \
                not trade.TradeCategory() == 'Collateral'):
                    paymentCode = '/SPRO/09'
                    tag72Deposite.append(paymentCode)
        elif (not trade.Counterparty().Swift() == 'HKMAHKHHXXX' and FMTUtils.isLoan(settlement)) and \
            (( trade.AdditionalInfo().Payment_Method_MM() == None) and \
                not trade.TradeCategory() == 'Collateral'):
                    paymentCode = '/SPRO/03'
                    tag72Deposite.append(paymentCode)
        
        return tag72Deposite
    
    def paymentCodefor72(self, acm_obj):
        '''
        Instrument	        Type	                                Payment Code return
        ---------------------------------------------------------------------------------
        Cash Payment	Brokerage fee	                        02
        Fund Transfer		                                02
        Deposit/Loan	Thru CCASS selected	                57
                            Optimizer Payment selected	        37
                            Loan to HKMA (FUNDHKYY)	                09
                            Loan to other counterparties (not HKMA)	03
                            SCB deposit repayment on maturity date	04
        FX	            FX Option	                        02
                            FX Spot, FX Forward 	                08
                            PVP selected	
                            FX Spot, FX Forward 	                02
                            PVP unselected	
        '''
        paymentCode = tradeCurrency = settlementAmount = lastLine = secondLine = tradePrice = tardeDate = None
        tag72 = []
        settlement = self.acm_obj
        trade = FMTUtils.getNettedTradefromSettlement(self.acm_obj)
        if FMTUtils.isRTGSNetwork(settlement):
            paymentCode = '/SPRO/02'
            tag72.append(paymentCode)
            if trade.Instrument().InsType() == 'Curr':
                if FMTUtils.isFXTrade(trade):
                    tag72 = self.paymentCodefor72FX(settlement)
            elif FMTUtils.isDepositLoanTrade(trade):
                tag72 = self.paymentCodefor72Deposit(settlement)
        return tag72
        
    # getter
    def sender_to_receiver_info_72(self):
        ''' Returns sender to receiver information '''
        temp_sender_to_receiver_info = CptAccRef_AddInfo = tag72 = []
        sender_to_receiver_info = None
        settlement = self.acm_obj
        if PVP_APPLICABLE:            
            settlement_CptAccRef_AddInfo = settlement.CounterpartyAccountRef().AdditionalInfo()
            trade = FMTUtils.getNettedTradefromSettlement(self.acm_obj)
            trade_AddInfo = trade.AdditionalInfo()
            CptAccRef_AddInfo = FMTUtils.cptAccRef_AddInfo_to_receiver_info_72(settlement, settlement_CptAccRef_AddInfo)
            # Tag72 is populated in following order
            # 1. RTGS and Payment_Method_FX and InsType in [Option, FXSpot, FXForward]
            # 2. RTGS and Payment_Method_MM and InsType in [Depoist]
            # 3. Using Trade Additonal info
            # 4. Using CounterpartyAccountRef Additonal info
            tag72 = self.paymentCodefor72(self.acm_obj)
        if tag72:
            if trade.AdditionalInfo().Payment_Method_FX():
                if FMTUtils.isCashPaymentTrade(trade):
                    trade_AddInfo = FMTUtils.trade_AddInfo_to_receiver_info_72(self.acm_obj, trade_AddInfo)
                    temp_sender_to_receiver_info = "\n".join(trade_AddInfo)
                    tag72.append(temp_sender_to_receiver_info)
            elif not ((settlement.SettlementType() == 'Fixed Amount') or (settlement.SettlementType() ==  'None')) and CptAccRef_AddInfo:
                temp_sender_to_receiver_info = "\n".join(CptAccRef_AddInfo)
                tag72.append(temp_sender_to_receiver_info)
            sender_to_receiver_info = "\n".join(tag72)
        else:
            trade = self.acm_obj.Trade()
            temp_sender_to_receiver_info_list = []
            if trade:
                add_info_obj = trade.ConnectedTrade().AdditionalInfo() if trade.TradeProcess() == 32768 else trade.AdditionalInfo()        
                for attr_name in ['SwiftSettleTag72_1', 'SwiftSettleTag72_2', 'SwiftSettleTag72_3', 'SwiftSettleTag72_4', 'SwiftSettleTag72_5', 'SwiftSettleTag72_6']:
                    attr_obj = getattr(add_info_obj, attr_name, None)
                    attr_value = attr_obj() if attr_obj else ''
                    if attr_value:
                        qualifier = '/BNF/' if attr_name == 'SwiftSettleTag72_1' else '//'
                        temp_sender_to_receiver_info.append(qualifier + attr_value)
                
                MAX_LENGTH = 35
                temp_sender_to_receiver_info_list = [line[:MAX_LENGTH] for line in temp_sender_to_receiver_info]
                sender_to_receiver_info = "\n".join(temp_sender_to_receiver_info_list)

        return sender_to_receiver_info

    # formatter
    def _format_sender_to_receiver_info_72(self, val):
        return val

    # validator
    @validate_with(MT202.MT202_72_Type)
    def _validate_sender_to_receiver_info_72(self, val):
        return val

    # setter
    def _set_sender_to_receiver_info_72(self, val):
        self.swift_obj.SenderToReceiverInformation = val
        self.swift_obj.SenderToReceiverInformation.swiftTag = "72"
    # ------------------------------------- SWIFT TAG 72 ----------------------
    

    #----------------------------------SWIFT TAG 21--------------------------------
    def get_conf_from_trade(self, trade_obj):
        if trade_obj:
            for conf in trade_obj.Confirmations():
                if conf.IsNewestInConfirmationChain():
                    return conf
        return None   

    def get_ext_obj(self, conf_obj, msg_types=[]):
        ext_obj = None
        for msg_type in msg_types:
            ext_obj = FSwiftMLUtils.FSwiftExternalObject.get_external_object(acm_obj=conf_obj, msg_typ=msg_type, integration_type='Outgoing')
            if ext_obj: 
                break
        return ext_obj   

    def get_reference(self, ext_obj):
        _related_reference= 'NONREF'
        bpr = FSwiftMLUtils.FSwiftExternalObject.get_business_process_from_external_object(ext_obj)
        if bpr:
            swift_data = FSwiftMLUtils.get_swift_data_from_bpr(bpr)
            if swift_data:
                _related_reference = FSwiftMLUtils.get_field_value(swift_data, '22C')
                if not _related_reference:
                    _related_reference = FSwiftMLUtils.get_field_value(swift_data, '22')
                    _related_reference = _related_reference.split('/')[-1]
        return _related_reference   

    def related_reference_21(self):
        _related_reference= 'NONREF'
        conf_obj = self.get_conf_from_trade(self.acm_obj.Trade())
        if conf_obj:
            ext_obj = self.get_ext_obj(conf_obj, ['MT300', 'MT320', 'MT305'])
            if ext_obj:
                _related_reference = self.get_reference(ext_obj)
        return _related_reference
    
    #----------------------------------SWIFT TAG 21--------------------------------

    # ------------------------------ OVERRIDE END -----------------------------


class FMT202MessageHeader(FMT202OutBase.FMT202OutBaseMessageHeader):

    def __init__(self, acm_obj, swift_msg_tags):
        self.acm_obj = acm_obj
        self.swift_msg_tags = swift_msg_tags
        super(FMT202MessageHeader, self).__init__(acm_obj, swift_msg_tags)

    # To override existing mappings use below methods to write your own logic

    """
    application_id
    service_id
    sender_logical_terminal_address
    session_number
    sequence_number
    input_or_output
    message_priority
    message_type
    receiver_logical_terminal_address
    delivery_monitoring
    non_delivery_notification_period
    service_identifier
    banking_priority_code
    message_user_reference
    validation_flag
    """
    
    """def message_user_reference(self):
        '''MUR is sent in the format FAC-SEQNBR of confirmation-VersionID'''
        return FMTUtils.Get_Message_User_Reference(self.acm_obj, self.mt_typ)"""
        
    def service_identifier(self):
        """returns service identifier"""
        if PVP_APPLICABLE and FMTUtils.isRTGSNetwork(self.acm_obj):
            return "{103:%s}" % 'HKL'
        else:
            return super(FMT202MessageHeader, self).service_identifier()
        
    def receiver_logical_terminal_address(self):
        '''LT code is hardcoded as X for sender'''
        if PVP_APPLICABLE:
            counterparty_account = self.acm_obj.CounterpartyAccountRef()
            acquirer_account = self.acm_obj.AcquirerAccountRef()
            terminal_address = receivers_bic = ''
            receivers_bic = FCashOutUtils.get_receivers_bic(self.acm_obj)
            if FMTUtils.isRTGSNetwork(self.acm_obj):
                trade = self.acm_obj.Trade()      
                if trade and FMTUtils.isFXAddInfoPaymentPVP(trade):
                    receivers_bic = counterparty_account.Bic().Alias()
                else:
                    if counterparty_account.Bic5():
                        receivers_bic = counterparty_account.Bic5().Alias()   
                    elif counterparty_account.Bic4():
                        receivers_bic = counterparty_account.Bic4().Alias()    
                    elif counterparty_account.Bic3():
                        receivers_bic = counterparty_account.Bic3().Alias()
                    elif counterparty_account.Bic2():
                        receivers_bic = counterparty_account.Bic2().Alias()
                    elif counterparty_account.Bic():
                        receivers_bic = counterparty_account.Bic().Alias()
                    else:
                        receivers_bic = self.acm_obj.Counterparty().Swift()
            terminal_address = self.logical_terminal_address(receivers_bic, "X")
        else:
            terminal_address = super(FMT202MessageHeader, self).receiver_logical_terminal_address()
        return terminal_address


class FMT202NetworkRules(FMT202OutBase.FMT202OutBaseNetworkRules):

    def __init__(self, swift_message_obj, swift_message, acm_obj):
        super(FMT202NetworkRules, self).__init__(swift_message_obj, swift_message, acm_obj)



...

  FMT210Out
"""----------------------------------------------------------------------------
MODULE:
    FMT210Out

DESCRIPTION:
    This module provides the customizable class for the FMT210 outgoing implementation

CLASS:
    FMT210

VERSION: 3.6.3-0.5.6048
----------------------------------------------------------------------------"""
import MT210
import acm
import xml.dom.minidom
from FSwiftMLUtils import accepts

import FMT210OutBase
import FSwiftWriterLogger
from FSwiftWriterEngine import validate_with

notifier = FSwiftWriterLogger.FSwiftWriterLogger('CashSetlemnt', 'FCashOutNotify_Config')

# ------------------------------ OVERRIDE START ---------------------------
import FSwiftMLUtils
# ------------------------------ OVERRIDE END -----------------------------

@accepts([acm.FSettlement, MT210.CTD_ANON, xml.dom.minidom.Document])
class FMT210(FMT210OutBase.FMT210Base):

    def __init__(self, acm_obj, swift_obj):
        super(FMT210, self).__init__(acm_obj, swift_obj)

    # To override existing mappings use below methods to write your own logic
    """
    account_identification_25
    currency_code_amount_32B
    intermediary_56A
    intermediary_56D
    ordering_customer_50C
    ordering_customer_50F
    ordering_customer_No_Option_50
    ordering_institution_52A
    ordering_institution_52D
    related_reference_21
    transaction_reference_number_20
    value_date_30
    get_user_data

    """

    """
    To override the options provided, use below methods to write your own logic:-
    methods:- 
    get_ordering_customer_option (Tag-50 options:NO OPTION/C/F)
    get_ordering_institution_option (Tag-52 options:A/D)
    get_intermediary_option (Tag-56 options:A/D)

    For example:
    def get_ordering_customer_option(self):
        condition = True
        if condition:
            return 'NO OPTION'
        else:
            return 'C'

    """
    # ------------------------------------- OVERRIDE START --------------------

    # ------------------------------------- SWIFT TAG 25 ---------------------

    # formatter
    def _format_account_identification_25(self, accnt_id):
        """Formats the value provided by getter method"""
        if accnt_id:
            return '/' + accnt_id

    # ------------------------------------- SWIFT TAG 25 ---------------------   
    
    # ------------------------------------- SWIFT TAG 52A ---------------------
    def ordering_institution_52A(self, block):
        '''returns ordering institution details in the form of dictionary'''
        values_dict = super(FMT210, self).ordering_institution_52A(block)
        if self.acm_obj.Trade() and self.acm_obj.Trade().Type() == "Account Transfer":
            counterparty_correspondent_bic = ''
            if self.acm_obj.CounterpartyAccountRef() and self.acm_obj.CounterpartyAccountRef().Bic():
                counterparty_correspondent_bic = self.acm_obj.CounterpartyAccountRef().Bic().Alias() 
            values_dict['ordering_institution_bic'] = counterparty_correspondent_bic
        elif self.acm_obj.Counterparty():
            counterparty_bic = self.acm_obj.Counterparty().Swift()
            if counterparty_bic:
                values_dict['ordering_institution_bic'] = counterparty_bic
        
        return values_dict

    def _format_ordering_institution_52A(self, val):
        ordering_institution_bic = val.get('ordering_institution_bic')
        if ordering_institution_bic:
            return ordering_institution_bic
    # ------------------------------------- SWIFT TAG 52A ---------------------
    
    # ------------------------------------- SWIFT TAG 56A ---------------------
    def _format_intermediary_56A(self, val):
        intermediary_bic = val.get('intermediary_bic')
        if intermediary_bic:
            return intermediary_bic
    # ------------------------------------- SWIFT TAG 56A ---------------------

    #----------------------------------SWIFT TAG 21--------------------------------
    def get_conf_from_trade(self, trade_obj):
        if trade_obj:
            for conf in trade_obj.Confirmations():
                if conf.IsNewestInConfirmationChain():
                    return conf
        return None   

    def get_ext_obj(self, conf_obj, msg_types=[]):
        ext_obj = None
        for msg_type in msg_types:
            ext_obj = FSwiftMLUtils.FSwiftExternalObject.get_external_object(acm_obj=conf_obj, msg_typ=msg_type, integration_type='Outgoing')
            if ext_obj: 
                break
        return ext_obj   

    def get_reference(self, ext_obj):
        _related_reference= 'NONREF'
        bpr = FSwiftMLUtils.FSwiftExternalObject.get_business_process_from_external_object(ext_obj)
        if bpr:
            swift_data = FSwiftMLUtils.get_swift_data_from_bpr(bpr)
            if swift_data:
                _related_reference = FSwiftMLUtils.get_field_value(swift_data, '22C')
                if not _related_reference:
                    _related_reference = FSwiftMLUtils.get_field_value(swift_data, '22')
                    _related_reference = _related_reference.split('/')[-1]
        return _related_reference   

    def related_reference_21(self, block):
        _related_reference= 'NONREF'
        conf_obj = self.get_conf_from_trade(self.acm_obj.Trade())
        if conf_obj:
            ext_obj = self.get_ext_obj(conf_obj, ['MT300', 'MT320', 'MT305'])
            if ext_obj:
                _related_reference = self.get_reference(ext_obj)
        return _related_reference
    
    #----------------------------------SWIFT TAG 21--------------------------------

    # ------------------------------------- OVERRID END -----------------------


class FMT210MessageHeader(FMT210OutBase.FMT210OutBaseMessageHeader):

    def __init__(self, acm_obj, swift_msg_tags):
        self.acm_obj = acm_obj
        self.swift_msg_tags = swift_msg_tags
        super(FMT210MessageHeader, self).__init__(acm_obj, swift_msg_tags)

    # To override existing mappings use below methods to write your own logic

    """
    application_id
    service_id
    sender_logical_terminal_address
    session_number
    sequence_number
    input_or_output
    message_priority
    message_type
    receiver_logical_terminal_address
    delivery_monitoring
    non_delivery_notification_period
    service_identifier
    banking_priority_code
    message_user_reference
    validation_flag
    """


class FMT210NetworkRules(FMT210OutBase.FMT210OutBaseNetworkRules):

    def __init__(self, swift_message_obj, swift_message, acm_obj):
        super(FMT210NetworkRules, self).__init__(swift_message_obj, swift_message, acm_obj)





...

  FMT299NarrativeOut
"""----------------------------------------------------------------------------
MODULE:
    FMT299NarrativeOut

DESCRIPTION:
    OPEN EXTENSION MODULE
    FMT299Narrative class for user customization.
    This class can be populated using either swift data or an acm object.
    See FMT699OutBase for extracting the values from acm

VERSION: 3.6.3-0.5.6048
----------------------------------------------------------------------------"""

import FMTx99OutBase
import FSwiftWriterLogger
import FCashOutUtils
import FSwiftMTx99Utils

notifier = FSwiftWriterLogger.FSwiftWriterLogger('CashSetlemnt', 'FCashOutNotify_Config')

# ------------------------------ OVERRIDE START ---------------------------
import FSwiftWriterUtils
# ------------------------------ OVERRIDE END -----------------------------

class FMT299Narrative(FMTx99OutBase.FMTx99Base):

	def __init__(self, acm_obj, swift_obj):
		swift_message_type = 'MT299Narrative'
		super(FMT299Narrative, self).__init__(acm_obj, swift_message_type, swift_obj)


	# To override existing mappings use below methods to write your own logic
	"""
	narrative_79
	related_reference_21
	transaction_reference_20
	get_user_data
	"""

        # ------------------------------ OVERRIDE START ---------------------------    
        # ------------------------------ AR-19833 ---------------------------------
	# formatter
	def _format_narrative_79(self, val):
           
            # Below code taken from FSwiftWriterUtils.format_narrative_retaining_user_fomatting(narrative)
            # Existing code has bug. As per Swift specifictaion max line 35 and each line can have 48 chars 
            # Also extended characters needs to be replaced before checking this limit.
            narrtive_text = val.get('narrative')
            narrtive_text = FSwiftWriterUtils.remove_non_swift_characters(narrtive_text)
            
            text = []
            narrative = narrtive_text.split('\n')
            formatted_narrative = ''
            try:
                for values in narrative:
                    values = values.strip('\r')
                    if values == "":
                        line = ['\n']
                    else:
                        line = FSwiftWriterUtils.split_text_on_character_limit(values, 48)
                    text.extend(line)
                formatted_text = ""
                for each_text in text:
                    formatted_text += each_text
                    if each_text != '\n':
                        formatted_text += '\n'
                formatted_narrative = '\n'.join(formatted_text.split('\n')[:35])
            except Exception as e:
                notifier.ERROR(
                    "Error in formatting narrative tag: %s. Sending original text " % (str(e)))
            if not formatted_narrative:
                formatted_narrative = narrtive_text
            return formatted_narrative
        # ------------------------------ AR-19833 ---------------------------------
        # ------------------------------ OVERRIDE END ---------------------------    


class FMT299NarrativeMessageHeader(FMTx99OutBase.FMTx99OutBaseMessageHeader):

	def __init__(self, acm_obj, swift_msg_tags):
		self.acm_obj = acm_obj
		self.swift_msg_tags = swift_msg_tags
		self.mt_type = '299'
		super(FMT299NarrativeMessageHeader, self).__init__(acm_obj, self.mt_type, swift_msg_tags)

	# To override existing mappings use below methods to write your own logic
	"""
	application_id
	service_id
	sender_logical_terminal_address
	session_number
	sequence_number
	input_or_output
	message_priority
	message_type
	receiver_logical_terminal_address
	delivery_monitoring
	non_delivery_notification_period
	service_identifier
	banking_priority_code
	message_user_reference
	validation_flag
	"""

	def logical_terminal_address(self, bic_code, lt_code):
		""" create terminal address for the party
		:param bic_code: bic of the party
		:param lt_code: code for the party
		:return:
		"""
		terminal_address = ""
		branch_code = "XXX"
		if bic_code:
			if len(str(bic_code)) == 8:
				terminal_address = str(bic_code) + lt_code + branch_code
			elif len(str(bic_code)) == 11:
				branch_code = bic_code[8:]
				terminal_address = str(bic_code[:8]) + lt_code + branch_code
			else:
				raise Exception("Invalid BIC <%s>)" % bic_code)
		return terminal_address

	def receiver_logical_terminal_address(self):
		"""receiver logical terminal address"""
		receivers_bic = None
		if self.acm_obj.RecordType() == "Settlement":
			receivers_bic = FCashOutUtils.get_receivers_bic(self.acm_obj)
		elif self.acm_obj.RecordType() == "Party":
			receivers_bic = FSwiftMTx99Utils.get_bic_from_party(self.acm_obj)
		elif self.acm_obj.RecordType() == "Trade":
			receivers_bic = FMTx99OutBase.get_value_from_bpr_diary(self.acm_obj, "MT" + self.mt_type, 'ReceiverBIC')
		if not receivers_bic:
			raise Exception("RECEIVER_BIC is a mandatory field for Swift message header")
		terminal_address = self.logical_terminal_address(receivers_bic, "X")
		return terminal_address


class FMT299NarrativeNetworkRules(FMTx99OutBase.FMTx99OutBaseNetworkRules):

	def __init__(self, swift_message_obj, swift_message, acm_obj):
		super(FMT299NarrativeNetworkRules, self).__init__(swift_message_obj, swift_message, acm_obj)

...

  FMT300In
"""----------------------------------------------------------------------------
MODULE:
    FMT300In

DESCRIPTION:
    OPEN EXTENSION MODULE
    FMTIn300 class for user customization.
    User can override the mapping defined in the base class FMT300InBase.
    This class can be populated using either swift data or an acm object.
    See FMT300InBase for extracting the values from swift or an acm

VERSION: 3.6.3-0.5.6048
----------------------------------------------------------------------------"""

# ------------------------------------- OVERRIDE START ----------------------------------------------
import acm
import FSwiftReaderLogger
notifier = FSwiftReaderLogger.FSwiftReaderLogger('FXMMConfIn', 'FFXMMConfirmationInNotify_Config')
# ------------------------------------- OVERRIDE END ------------------------------------------------

import FMT300InBase


class FMT300(FMT300InBase.FMT300Base):
    """ FMT300 class for user customization"""
    def __init__(self, source, direction):
        super(FMT300, self).__init__(source, direction)

    def CustomMappings(self):
        """ Override/add mappings"""
        ''''
        if self.source == 'SWIFT':
            self.set_color()
        elif self.source == 'ACM':
            self.set_color_from_trade()
        '''
        pass

    def SetAttributes(self):
        super(FMT300,self).SetAttributes()
        self.CustomMappings()

    # ------------------------------------- OVERRIDE START -------------------------------------------------
    
    # ---------------------------------------------------- AR-25630 ----------------------------------------
    # FMT300 Inbound : Incorrect mapping for tag 30V
    def set_value_date_from_trade(self):
        try:
            self._value_date = self.acm_obj.Trade().ValueDay()
            trade = self.acm_obj.Trade()
            if trade:
                ins = trade.Instrument()
                if ins and ins.IsKindOf(acm.FFuture):
                    self._value_date = ins.SettlementDate()
            
        except Exception as e:
            notifier.DEBUG("Exception occurred in set_value_date_from_trade : %s" % str(e))
    # ---------------------------------------------------- AR-25630 ----------------------------------------
    
    # ---------------------------------------------------- AR-25633 ----------------------------------------
    # FX NDF MT300 Inbound and Outbound : Closing events are missing
    def set_money_flows(self):
        super(FMT300, self).set_money_flows()
        if self.acm_obj.Trade().Instrument().IsKindOf(acm.FFuture):
            if not self.is_confirmation_closing_NDF and self.acm_obj.EventType() in ["Close", "Partial Close", "Close Amendment", "Partial Close Amendment"]:
                self.is_confirmation_closing_NDF = True
    # ---------------------------------------------------- AR-25633 ----------------------------------------        

    # ---------------------------------------------------- AR-25632 ----------------------------------------
    # FX NDF MT300 Inbound - Incorrect acquirer and counterparty mapping for fixing NDF
    def set_acquirer_counterparty_from_trade(self):
        # Added self.is_confirmation_closing_NDF check
        try:
            if self.simulated_closing_NDF_settlement or self.is_confirmation_closing_NDF:
                for flw in self._money_flows:
                    counter_party_account = flw.CounterpartyAccount()
                    self.counterparty = counter_party_account.NetworkAlias().Name() if (
                            counter_party_account and counter_party_account.NetworkAlias()) else self.acm_obj.Counterparty().Swift()
    
                    acquirer_party_account = flw.AcquirerAccount()
                    self.acquirer = acquirer_party_account.NetworkAlias().Name() if (
                            acquirer_party_account and acquirer_party_account.NetworkAlias()) else self.acm_obj.Acquirer().Swift()
            else:
                super(FMT300, self).set_acquirer_counterparty_from_trade()

        except Exception as e:
            notifier.DEBUG("Exception occurred in set_acquirer_counterparty_from_trade : %s" % str(e))
    # ---------------------------------------------------- AR-25632 ----------------------------------------    

    # ------------------------------------- OVERRIDE END ---------------------------------------------------    
    @staticmethod
    def GetColumnMetaData():
        """User can modify or extend the column metadata in this method and return it. This metadata will be used for creating columns for specific message type"""
        column_metadata = FMT300InBase.FMT300Base.GetColumnMetaData()
        return column_metadata

    '''
    # Following is the sample code to add a new attribute for mapping e.g. Color
    def set_color(self):
        try:
            self.__color = self.python_object.TRADDET.Color.value()
        except Exception, e:
            self.notifier.DEBUG("Exception occurred in set_color : %s"%str(e))

    def set_color_from_trade(self):
        try:
            if self.acm_obj.Color():
                self.__color = self.acm_obj.Color()
        except Exception, e:
            self.notifier.DEBUG("Exception occurred in set_color_from_settlement : %s"%str(e))

    def Color(self):
        """ Get the color attribute"""
        return self.__color
    '''



...

  FMT300Out
"""----------------------------------------------------------------------------
MODULE:
    FMT300Out

DESCRIPTION:
    This module provides the customizable class for the FMT300 outgoing implementation

CLASS:
    FMT300

VERSION: 3.6.3-0.5.6048
----------------------------------------------------------------------------"""

import MT300
import acm
import xml.dom.minidom
from FSwiftMLUtils import accepts

import FMT300OutBase
import FSwiftWriterLogger
from FSwiftWriterEngine import validate_with

notifier = FSwiftWriterLogger.FSwiftWriterLogger('FXMMConfOut', 'FFXMMConfirmationOutNotify_Config')

# ------------------------------------- OVERRIDE START ---------------------
import FFXMMConfirmationOutUtils
import FMTConfirmationWrapper
import FMTSettlementWrapper
# ------------------------------------- OVERRIDE END -----------------------
    
@accepts([acm.FConfirmation, MT300.CTD_ANON, xml.dom.minidom.Document])
class FMT300(FMT300OutBase.FMT300Base):

    def __init__(self, acm_obj, swift_obj):
        super(FMT300, self).__init__(acm_obj, swift_obj)
        self.check_NDF()

    # To override existing mappings use below 'tag_name' methods to write your own logic

    """
    block_trade_indicator_17T
    buy_delivery_agent_53A
    buy_delivery_agent_53J
    buy_intermediary_56A
    buy_intermediary_56J
    buy_receiving_agent_57A
    buy_receiving_agent_57J
    common_reference_22C
    counterpartys_reference_26H
    currency_amount_bought_32B
    currency_amount_sold_33B
    exchange_rate_36
    partyA_82A
    partyA_82J
    partyB_87A
    partyB_87J
    related_reference_21
    scope_of_operation_94A
    sell_beneficiary_institution_58A
    sell_beneficiary_institution_58J
    sell_delivery_agent_53A
    sell_delivery_agent_53J
    sell_intermediary_56A
    sell_intermediary_56J
    sell_receiving_agent_57A
    sell_receiving_agent_57J
    senders_reference_20
    split_settlement_indicator_17U
    terms_and_conditions_77D
    trade_date_30T
    type_of_operation_22A
    value_date_30V
    get_user_data
    """

    """
    To override the options provided, use below methods to write your own logic:-
    methods:-
     get_partyA_option (Tag-82 options:A/J)
     get_partyB_option (Tag-87 options:A/J)
     get_buy_delivery_agent_option (Tag-53 options:A/J)
     get_buy_intermediary_option (Tag-56 options:A/J)
     get_buy_receiving_agent_option (Tag-57 options:A/J) 
     get_sell_delivery_agent_option (Tag-53 options:A/J)
     get_sell_intermediary_option (Tag-56 options:A/J)
     get_sell_receiving_agent_option (Tag-57 options:A/J) 
     get_sell_beneficiary_institution_option(Tag-58 options:A/J)


    For example:
    def get_partyA_option(self):
        condition = True
        if condition:
            return 'A'
        else:
            return 'J'

    """
    # ------------------------------------- OVERRIDE START --------------------

    # ---------------------------------------------------- AR-25633 ----------------------------------------    
    # FX NDF MT300 Inbound and Outbound : Closing events are missing
    def check_NDF(self):
        if self.acm_obj.Trade().Instrument().IsKindOf(acm.FFuture):
            # Adding check for Close events
            if self.is_confirmation_closing_NDF == False and self.acm_obj.EventType() in ["Close", "Partial Close", "Close Amendment", "Partial Close Amendment"]:
                self.is_confirmation_closing_NDF = True
    # ---------------------------------------------------- AR-25633 ----------------------------------------    
    
    # ------------------------------------- SWIFT TAG 53 ----------------------
    def _check_condition_set_OPTION_buy_delivery_agent(self):
        return False

    def _check_condition_set_OPTION_sell_delivery_agent(self):
        return False
    # ------------------------------------- SWIFT TAG 53 ----------------------

    # ---------------------------------------------------- AR-25625 ----------------------------------------
    # MT300 Outbound FX NDF - Intermediary details in tag 56 is missing for settlement currency amount
    # ------------------------------------- SWIFT TAG 56A ---------------------
    def _format_buy_intermediary_56A(self, val):
        bic = val.get('BIC')
        if bic:
            return str(bic)

    def _format_sell_intermediary_56A(self, val):
        bic = val.get('BIC')
        if bic:
            return str(bic)

    def sell_intermediary_56A(self):
        # FX NDF needs tag 56A, only for settle currency
        values_dict = super(FMT300, self).sell_intermediary_56A()
        if self.simulated_closing_NDF_settlement or self.is_confirmation_closing_NDF:
            if self.acm_obj.Trade().Instrument().Currency().Name() == self.get_NDF_buy_sell_currency(False):
                values_dict = self.get_counterparty_intermediary_details_NDF()
        return values_dict

    def buy_intermediary_56A(self):
        # FX NDF needs tag 56A, only for settle currency
        values_dict = super(FMT300, self).buy_intermediary_56A()
        if self.simulated_closing_NDF_settlement or self.is_confirmation_closing_NDF:
            if self.get_NDF_buy_sell_currency(True) == self.acm_obj.Trade().Instrument().Currency().Name():
                values_dict = self.get_acquirer_intermediary_details_NDF()
        return values_dict
    
    def get_acquirer_intermediary_details_NDF(self):
        values_dict = {}
        wrapper_obj = None
        if self.simulated_closing_NDF_settlement:
            import FMTSettlementWrapper
            wrapper_obj = FMTSettlementWrapper.FMTSettlementWrapper(self.simulated_closing_NDF_settlement)
        else:
            wrapper_obj = FMTConfirmationWrapper.FMTConfirmationWrapper(self.acm_obj)

        money_flow = wrapper_obj.sell_money_flow()
        # buy_money_flow sell_money_flow will populate in multi curr scenario for single curr cases we need money_flow
        if not money_flow:
            money_flow = wrapper_obj.buy_money_flow()
        if money_flow:
            party = money_flow.AcquirerAccount().CorrespondentBank2()
            party_account = money_flow.AcquirerAccount()
            values_dict = FFXMMConfirmationOutUtils.get_party_details(party, party_account, "INTERMEDIARY")

        return values_dict

    def get_counterparty_intermediary_details_NDF(self):
        values_dict = {}
        wrapper_obj = None
        if self.simulated_closing_NDF_settlement:
            import FMTSettlementWrapper
            wrapper_obj = FMTSettlementWrapper.FMTSettlementWrapper(self.simulated_closing_NDF_settlement)
        else:
            wrapper_obj = FMTConfirmationWrapper.FMTConfirmationWrapper(self.acm_obj)

        money_flow = wrapper_obj.sell_money_flow()
        # buy_money_flow sell_money_flow will populate in multi curr scenario for single curr cases we need money_flow
        if not money_flow:
            money_flow = wrapper_obj.buy_money_flow()
        if money_flow:
            party = money_flow.CounterpartyAccount().CorrespondentBank2()
            party_account = money_flow.CounterpartyAccount()
            values_dict = FFXMMConfirmationOutUtils.get_party_details(party, party_account, "INTERMEDIARY")

        return values_dict
     # ------------------------------------- SWIFT TAG 56A ---------------------
    # ---------------------------------------------------- AR-25625 ----------------------------------------    
    
    # ------------------------------------- SWIFT TAG 57A ---------------------
    def _format_buy_receiving_agent_57A(self, val):
        bic = val.get('BIC')
        if bic:
            return str(bic)

    def _format_sell_receiving_agent_57A(self, val):
        bic = val.get('BIC')
        if bic:
            return str(bic)

    # ------------------------------------- SWIFT TAG 57A ---------------------

    # ------------------------------------- SWIFT TAG 82A ---------------------
    def _format_partyA_82A(self, val):
        bic = val.get('BIC', None)
        if bic:
            return str(bic)
    # ------------------------------------- SWIFT TAG 82A ---------------------
    

    # ------------------------------------- SWIFT TAG 87A ---------------------
    def _format_partyB_87A(self, val):
        bic = val.get('BIC', None)
        if bic:
            return str(bic)
    # ------------------------------------- SWIFT TAG 87A ---------------------


    # ------------------------------------- SWIFT TAG 72 ----------------------
    '''
    Sender to receiver information is kept in additional info on Trade per line.
        line 1 : '/BNF/' + SwiftConfTag72_1
        line 2 : '//' + SwiftConfTag72_2
        line 3 : '//' + SwiftConfTag72_3
        line 4 : '//' + SwiftConfTag72_4
        line 5 : '//' + SwiftConfTag72_5
        line 6 : '//' + SwiftConfTag72_6                 
    '''
    # getter
    def sender_to_receiver_info_72(self):
        ''' Returns sender to receiver information '''
        sender_to_receiver_info = []
        trade = self.acm_obj.Trade() 
        add_info_obj = trade.ConnectedTrade().AdditionalInfo() if trade.TradeProcess() == 32768 else trade.AdditionalInfo()        
        for attr_name in ['SwiftConfTag72_1', 'SwiftConfTag72_2', 'SwiftConfTag72_3', 
            'SwiftConfTag72_4', 'SwiftConfTag72_5', 'SwiftConfTag72_6']:
            attr_obj = getattr(add_info_obj, attr_name, None)
            attr_value = attr_obj() if attr_obj else ''
            if attr_value:
                qualifier = '/BNF/' if attr_name == 'SwiftConfTag72_1' else '//'
                sender_to_receiver_info.append(qualifier + attr_value)
        return sender_to_receiver_info

    # formatter
    def _format_sender_to_receiver_info_72(self, val):
        MAX_LENGTH = 35
        temp_sender_to_receiver_info = [line[:MAX_LENGTH] for line in val]
        return "\n".join(temp_sender_to_receiver_info)

    # validator
    @validate_with(MT300.MT300_SequenceC_OptionalGeneralInformation_72_Type_Pattern)
    def _validate_sender_to_receiver_info_72(self, val):
        return val

    # setter
    def _set_sender_to_receiver_info_72(self, val):
        if not self.swift_obj.SequenceC_OptionalGeneralInformation:
            self.swift_obj.SequenceC_OptionalGeneralInformation = MT300.MT300_SequenceC_OptionalGeneralInformation()
            self.swift_obj.SequenceC_OptionalGeneralInformation.swiftTag = "15C"
            self.swift_obj.SequenceC_OptionalGeneralInformation.formatTag = "False"
    
        self.swift_obj.SequenceC_OptionalGeneralInformation.SenderToReceiverInformation = val
        self.swift_obj.SequenceC_OptionalGeneralInformation.SenderToReceiverInformation.swiftTag = "72"
    # ------------------------------------- SWIFT TAG 72 ----------------------

    # ------------------------------------- SWIFT TAG 24D ---------------------

    def _check_condition_set_dealing_method(self):
        """return True or False depending on the condition provided"""
        return True if self.acm_obj.Trade().Broker() else False

        
    # getter
    def dealing_method(self):
        ''' Returns sender to receiver information '''
        broker = self.acm_obj.Trade().Broker() 
        return 'BROK' if broker else ''


    # formatter
    def _format_dealing_method(self, val):
        return val

    # validator
    @validate_with(MT300.MT300_SequenceC_OptionalGeneralInformation_24D_Type_Pattern)
    def _validate_dealing_method(self, val):
        return val

    # setter
    def _set_dealing_method(self, val):
        if not self.swift_obj.SequenceC_OptionalGeneralInformation:
            self.swift_obj.SequenceC_OptionalGeneralInformation = MT300.MT300_SequenceC_OptionalGeneralInformation()
            self.swift_obj.SequenceC_OptionalGeneralInformation.swiftTag = "15C"
            self.swift_obj.SequenceC_OptionalGeneralInformation.formatTag = "False"
        self.swift_obj.SequenceC_OptionalGeneralInformation.DealingMethod = val
        self.swift_obj.SequenceC_OptionalGeneralInformation.DealingMethod.swiftTag = "24D"

    # ------------------------------------- SWIFT TAG 24D ---------------------

    # ------------------------------------- SWIFT TAG 88D ---------------------

    def _check_condition_set_broker_identification(self):
        """return True or False depending on the condition provided"""
        return True if self.acm_obj.Trade().Broker() and self.acm_obj.Trade().Broker().Id2() else False
        
    # getter
    def broker_identification(self):
        ''' Returns sender to receiver information '''
        import FSwiftWriterUtils
        val=''
        broker = self.acm_obj.Trade().Broker()
        broker_alias = broker.Id2() if broker else ''
        if broker_alias:
            broker_alias = FSwiftWriterUtils.split_text_and_prefix(broker_alias, 35)
            val = FSwiftWriterUtils.allocate_space_for_name_address_without_constraint(broker_alias)
        return val


    # formatter
    def _format_broker_identification(self, val):
        return val

    # validator
    @validate_with(MT300.MT300_SequenceC_OptionalGeneralInformation_88D_Type_Pattern)
    def _validate_broker_identification(self, val):
        return val

    # setter
    def _set_broker_identification(self, val):
        if not self.swift_obj.SequenceC_OptionalGeneralInformation:
            self.swift_obj.SequenceC_OptionalGeneralInformation = MT300.MT300_SequenceC_OptionalGeneralInformation()
            self.swift_obj.SequenceC_OptionalGeneralInformation.swiftTag = "15C"
            self.swift_obj.SequenceC_OptionalGeneralInformation.formatTag = "False"
        self.swift_obj.SequenceC_OptionalGeneralInformation.BrokerIdentification_D = val
        self.swift_obj.SequenceC_OptionalGeneralInformation.BrokerIdentification_D.swiftTag = "88D"

    # ------------------------------------- SWIFT TAG 24D ---------------------

    # ------------------------------------- SWIFT TAG 36 ----------------------

    def exchange_rate_36(self):
        
        exchange_rate = super(FMT300, self).exchange_rate_36()
        try:
            exchange_rate = acm.Math.RoundTo(exchange_rate, 12)
        except Exception as e:
            pass
        
        return exchange_rate

    # ------------------------------------- SWIFT TAG 36 ----------------------

    # ------------------------------------- SWIFT TAG 22C ----------------------

    def common_reference_22C(self):
        
        val_dict = super(FMT300, self).common_reference_22C()
        exchange_rate = self.exchange_rate_36()
        val_dict['EXCHANGE_RATE'] =  str(exchange_rate)
        return val_dict

    # ------------------------------------- SWIFT TAG 22C ----------------------
    
    # ------------------------------------- SWIFT TAG 17T ---------------------

    def block_trade_indicator_17T(self):
        return ''

    # ------------------------------------- SWIFT TAG 17T ---------------------        


    # ------------------------------------- SWIFT TAG 17U ---------------------

    def split_settlement_indicator_17U(self):
        return ''

    # ------------------------------------- SWIFT TAG 17U ---------------------

    # ------------------------------------- AR-25629 --------------------------
    # MT300 Outbound FX NDF - Incorrect mapping for tag 30V
    # ------------------------------------- SWIFT TAG 30V ---------------------
    
    def value_date_30V(self):
        '''Returns value date as string'''
        value_date = super(FMT300, self).value_date_30V()
        trade = self.acm_obj.Trade()
        # Fix for FX DNDF
        if trade.Instrument().IsKindOf(acm.FFuture):
            value_date = trade.Instrument().SettlementDate()
        return value_date
        
    # ------------------------------------- SWIFT TAG 30V ---------------------
    # ------------------------------------- AR-25629 --------------------------
    
    # ------------------------------------- AR-19797/AR-25633 -----------------
    # FX NDF MT300 Inbound and Outbound : Closing events are missing
    def init_NDF(self):
        # Support amendement on close trade and partial close for FX NDF
        super(FMT300, self).init_NDF()
        if self.acm_obj.Trade().Instrument().IsKindOf(acm.FFuture):
            if not self.is_confirmation_closing_NDF and self.acm_obj.EventType() in ["Close", "Partial Close", "Close Amendment", "Partial Close Amendment"]:
                self.is_confirmation_closing_NDF = True

    # ------------------------------------- AR-19797/AR-25633 -----------------
    
    # ------------------------------------- OVERRIDE END ----------------------



class FMT300MessageHeader(FMT300OutBase.FMT300OutBaseMessageHeader):
    def __init__(self, acm_obj, swift_msg_tags):
        self.acm_obj = acm_obj
        self.swift_msg_tags = swift_msg_tags
        super(FMT300MessageHeader, self).__init__(acm_obj, swift_msg_tags)

    # To override existing mappings use below methods to write your own logic

    """
    application_id
    service_id
    sender_logical_terminal_address
    session_number
    sequence_number
    input_or_output
    message_priority
    message_type
    receiver_logical_terminal_address
    delivery_monitoring
    non_delivery_notification_period
    service_identifier
    banking_priority_code
    message_user_reference
    validation_flag
    continuous_linked_settlement
    """

class FMT300NetworkRules(FMT300OutBase.FMT300OutBaseNetworkRules):
    def __init__(self, swift_message_obj, swift_message, acm_obj):
        super(FMT300NetworkRules, self).__init__(swift_message_obj, swift_message, acm_obj)





...

  FMT305Out
"""----------------------------------------------------------------------------
MODULE:
    FMT305Out

DESCRIPTION:
    This module provides the customizable class for the FMT305 outgoing implementation

CLASS:
    FMT305

VERSION: 3.6.3-0.5.6048
----------------------------------------------------------------------------"""

import MT305
import acm
import xml.dom.minidom
from FSwiftMLUtils import accepts

import FMT305OutBase
import FSwiftWriterLogger, math, FSwiftGeneralUtils
from FSwiftWriterEngine import validate_with

notifier = FSwiftWriterLogger.FSwiftWriterLogger('FXMMConfOut', 'FFXMMConfirmationOutNotify_Config')

# ------------------------------------- OVERRIDE START --------------------
import FFXMMConfirmationOutUtils
# ------------------------------------- OVERRIDE START --------------------

@accepts([acm.FConfirmation, MT305.CTD_ANON, xml.dom.minidom.Document])
class FMT305(FMT305OutBase.FMT305Base):

    def __init__(self, acm_obj, swift_obj):
        super(FMT305, self).__init__(acm_obj, swift_obj)

    # To override existing mappings use below 'tag_name' methods to write your own logic

    """
    code_common_reference_22
    counter_currency_amount_33B
    date_contract_agreed_amended_30
    earliest_exercise_date_31C
    expiry_details_31G
    final_settlement_date_31E
    further_identification_23
    intermediary_56A
    partyA_82A
    partyB_87A
    premium_payment_34P
    premium_payment_34R
    premium_price_37K
    related_reference_21
    sell_account_with_institution_57A
    sender_to_receiver_info_72
    senders_correspondent_53A
    settlement_type_26F
    strike_price_36
    transaction_reference_number_20
    underlying_currency_amount_32B
    get_user_data
    """

    """
    To override the options provided, use below methods to write your own logic:-
    methods:-
    get_partyA_option (Tag-82 options:A)
    get_partyB_option (Tag-87 options:A)
    get_premium_payment_option (Tag-34 options:R/P)
    get_senders_correspondent_option (Tag-53 options:A)
    get_intermediary_option (Tag-56 options:A)
    get_account_with_institution_option (Tag-57 options:A)

    For example:
    def get_partyA_option(self):
        condition = True
        if condition:
            return 'A'
        
        """
    # ------------------------------------- OVERRIDE START --------------------
    
    # ------------------------------------- SWIFT TAG 82A ---------------------
    def _format_partyA_82A(self, val):
        bic = val.get('BIC', None)
        if bic:
            return str(bic)
    # ------------------------------------- SWIFT TAG 82A ---------------------
    

    # ------------------------------------- SWIFT TAG 87A ---------------------
    def _format_partyB_87A(self, val):
        bic = val.get('BIC', None)
        if bic:
            return str(bic)
    # ------------------------------------- SWIFT TAG 87A ---------------------
    
    # ------------------------------------- SWIFT TAG 37K ----------------------
    
    #getter
    def premium_price_37K(self):
        """ This function adjusts the decimal value for the total length of Swift length 12
            e.g.
            #1. 3.45 => 3.45
            #2. 0.98765123456789 = > 0.9876512346
            #3. 1234.98765123456789 = > 1234.9876512
            #4. 12343423456.056 = > 12343423456.0
        """
        
        premium_price = super(FMT305, self).premium_price_37K()
        try:
            SWIFT_FLD_LEN = 12
            decimal_part = math.modf(premium_price)[0]
            int_part = math.modf(premium_price)[1]
            int_part_len = len(str(int(int_part)))
            total_precision = SWIFT_FLD_LEN-int_part_len-1
            premium_price = acm.Math.RoundTo(premium_price, total_precision)                        
        except Exception as e:
            notifier.ERROR("Error in premium_price_37K. Error : {}.".format(e))
        
        return premium_price
        
        
    # validator
    @validate_with(MT305.MT305_SequenceA_GeneralInformation_37K_Type)
    def _validate_premium_price_37K(self, val):
        price = FSwiftGeneralUtils.get_amount_from_currency_amount(val)
        FFXMMConfirmationOutUtils.validateAmount(price.replace('.', ','), 12, "Premium Price")
        return val

    # ------------------------------------- SWIFT TAG 37K ----------------------
    
    # ------------------------------------- SWIFT TAG 72 ----------------------
    '''
    Sender to receiver information is kept in additional info on Trade per line.
        line 1 : '/BNF/' + SwiftConfTag72_1
        line 2 : '//' + SwiftConfTag72_2
        line 3 : '//' + SwiftConfTag72_3
        line 4 : '//' + SwiftConfTag72_4
        line 5 : '//' + SwiftConfTag72_5
        line 6 : '//' + SwiftConfTag72_6                 
    '''
    # getter
    def sender_to_receiver_info_72(self):
        ''' Returns sender to receiver information '''
        sender_to_receiver_info = []
        trade = self.acm_obj.Trade() 
        add_info_obj = trade.ConnectedTrade().AdditionalInfo() if trade.TradeProcess() == 32768 else trade.AdditionalInfo()        
        for attr_name in ['SwiftConfTag72_1', 'SwiftConfTag72_2', 'SwiftConfTag72_3', 
            'SwiftConfTag72_4', 'SwiftConfTag72_5', 'SwiftConfTag72_6']:
            attr_obj = getattr(add_info_obj, attr_name, None)
            attr_value = attr_obj() if attr_obj else ''
            if attr_value:
                qualifier = '/BNF/' if attr_name == 'SwiftConfTag72_1' else '//'
                sender_to_receiver_info.append(qualifier + attr_value)
        return sender_to_receiver_info

    # formatter
    def _format_sender_to_receiver_info_72(self, val):
        MAX_LENGTH = 35
        temp_sender_to_receiver_info = [line[:MAX_LENGTH] for line in val]
        return "\n".join(temp_sender_to_receiver_info)
        
    # ------------------------------------- SWIFT TAG 72 ----------------------

    # ------------------------------------- SWIFT TAG 17F ----------------------
    # getter
    def non_deliverable_indicator(self):
        nd_indicator = 'Y'
        ins = self.acm_obj.Trade().Instrument()
        if ins and ins.SettlementType() == 'Physical Delivery':
            nd_indicator = 'N'
        return nd_indicator

    # formatter
    def _format_non_deliverable_indicator(self, val):
        return val

    # validator
    @validate_with(MT305.MT305_SequenceA_GeneralInformation_17F_Type)
    def _validate_non_deliverable_indicator(self, val):
        return val

    # setter
    def _set_non_deliverable_indicator(self, val):
        self.swift_obj.SequenceA_GeneralInformation.NonDeliverableIndicator = val
        self.swift_obj.SequenceA_GeneralInformation.NonDeliverableIndicator.swiftTag = "17F"
    # ------------------------------------- SWIFT TAG 17F ----------------------

    # ------------------------------------- SWIFT TAG 32E ----------------------

    def _check_condition_set_settlement_currency_32E(self):
        return True if self.non_deliverable_indicator() == 'Y' else False

    # getter
    def settlement_currency_32E(self):
        '''Returns terms and conditions as string'''
        sett_curr = ''
        trade = self.acm_obj.Trade()
        if trade:
            sett_curr = trade.Currency().Name()
        return sett_curr

    # formatter
    def _format_settlement_currency_32E(self, val):
        return val

    # validator
    @validate_with(MT305.MT305_SequenceA_GeneralInformation_32E_Type)
    def _validate_settlement_currency_32E(self, val):
        return val

    # setter
    def _set_settlement_currency_32E(self, val):
        self.swift_obj.SequenceA_GeneralInformation.SettlementCurrency = val
        self.swift_obj.SequenceA_GeneralInformation.SettlementCurrency.swiftTag = "32E"

    # ------------------------------------- SWIFT TAG 32E ----------------------

    # ------------------------------------- SWIFT TAG 14S ----------------------

    def _check_condition_set_settlement_rate_source_14S(self):
        return True if self.non_deliverable_indicator() == 'Y' else False

    # Code used from MT300OutBase
    # Getter
    def settlement_rate_source_14S(self):
        settlement_rate_source_dict = {}
        ret_val = None
        ins = self.acm_obj.Trade().Instrument()
        if ins:
            fixing_source_party = ins.FixingSource()
            if fixing_source_party:
                settlement_rate_source_dict['CUTT_OFF'] = fixing_source_party.ExternalCutOff()
                location = fixing_source_party.City()
                if location:
                    location_code = FFXMMConfirmationOutUtils.get_location_code(location)
                    settlement_rate_source_dict['LOCATION'] = location_code
                for alias in fixing_source_party.Aliases():
                    if alias.Type().Name() == 'ISDASettlementSrc':
                        if alias.Alias():
                            settlement_rate_source_dict['RATE_SOURCE'] = alias.Alias()
                            ret_val = settlement_rate_source_dict
                        break

                if ret_val is None:
                    notifier.ERROR(
                        "Set party alias 'ISDASettlementSrc' on MTMMarket parties and specify settlement source code as its value."
                        "It is required to populate field 14S in MT305.")
        return ret_val

    # formatter
    def _format_settlement_rate_source_14S(self, val):
        settlement_rate_source_dict = val
        formatted_value = ''
        cutt_off = settlement_rate_source_dict.get('CUTT_OFF', None)
        location = settlement_rate_source_dict.get('LOCATION', None)
        rate_source = settlement_rate_source_dict.get('RATE_SOURCE', None)

        formatted_value = rate_source
        # If the user has specified EMT00 in party alias we skip cut off and location
        if rate_source != 'EMT00':
            if cutt_off:
                formatted_value += '/' + str(cutt_off)

            if location:
                formatted_value += '/' + location

        return formatted_value

    # validator
    @validate_with(MT305.MT305_SequenceA_GeneralInformation_14S_Type)
    def _validate_settlement_rate_source_14S(self, val):
        return val

    # setter
    def _set_settlement_rate_source_14S(self, val):
        settlement_rate_source_seq = MT305.MT305_SequenceA_GeneralInformation().SettlementRateSource

        settlement_rate_source_seq.SettlementRateSource = val
        settlement_rate_source_seq.SettlementRateSource.swiftTag = "14S"

        self.swift_obj.SequenceA_GeneralInformation.SettlementRateSource.append(
            settlement_rate_source_seq.SettlementRateSource)

    # ------------------------------------- SWIFT TAG 14S ----------------------

    # ------------------------------------- OVERRIDE END ----------------------


class FMT305MessageHeader(FMT305OutBase.FMT305OutBaseMessageHeader):

    def __init__(self, acm_obj, swift_msg_tags):
        self.acm_obj = acm_obj
        self.swift_msg_tags = swift_msg_tags
        super(FMT305MessageHeader, self).__init__(acm_obj, swift_msg_tags)

    # To override existing mappings use below methods to write your own logic

    """
    application_id
    service_id
    sender_logical_terminal_address
    session_number
    sequence_number
    input_or_output
    message_priority
    message_type
    receiver_logical_terminal_address
    delivery_monitoring
    non_delivery_notification_period
    service_identifier
    banking_priority_code
    message_user_reference
    validation_flag
    """


class FMT305NetworkRules(FMT305OutBase.FMT305OutBaseNetworkRules):

    def __init__(self, swift_message_obj, swift_message, acm_obj):
        super(FMT305NetworkRules, self).__init__(swift_message_obj, swift_message, acm_obj)




...

  FMT320Out
"""----------------------------------------------------------------------------
MODULE:
    FMT320Out

DESCRIPTION:
    This module provides the customizable class for the FMT320 outgoing implementation

CLASS:
    FMT320

VERSION: 3.6.3-0.5.6048
----------------------------------------------------------------------------"""
import MT320
import acm
import xml.dom.minidom
from FSwiftMLUtils import accepts

import FMT320OutBase
import FSwiftWriterLogger
from FSwiftWriterEngine import validate_with

notifier = FSwiftWriterLogger.FSwiftWriterLogger('FXMMConfOut', 'FFXMMConfirmationOutNotify_Config')

# ------------------------------------- OVERRIDE START ---------------------
import FFXMMConfirmationOutUtils
# ------------------------------------- OVERRIDE END   ---------------------

@accepts([acm.FConfirmation, MT320.CTD_ANON, xml.dom.minidom.Document])
class FMT320(FMT320OutBase.FMT320Base):

    def __init__(self, acm_obj, swift_obj):
        super(FMT320, self).__init__(acm_obj, swift_obj)
    # To override existing mappings use below methods to write your own logic
    """
    amount_to_be_settled_32H
    common_reference_22C
    currency_interest_amount_34E
    currency_principal_amount_32B
    day_count_fraction_14D
    interest_rate_37G
    intermediary_PartyA_56A
    intermediary_PartyA_56D
    intermediary_PartyB_56A
    intermediary_PartyB_56D
    maturity_date_30P
    next_interest_due_date_30X
    partyA_82A
    partyA_82D
    partyB_87A
    partyB_87D
    party_As_role_17R
    receiving_agent_PartyA_57A
    receiving_agent_PartyA_57D
    receiving_agent_PartyB_57A
    receiving_agent_PartyB_57D
    related_reference_21
    senders_reference_20
    terms_and_conditions_77D
    trade_date_30T
    type_of_event_22B
    type_of_operation_22A
    value_date_30V
    get_user_data
    """

    """
    To override the options provided, use below methods to write your own logic:-
    methods:-
    get_partyA_option (Tag-82 options:A/D)
    get_partyB_option (Tag-87 options:A/D)
    get_intermediary_PartyA_option (Tag-56 options:A/D)
    get_delivery_agent_PartyA_option (Tag-53 options:A/D)
    get_receiving_agent_PartyA_option (Tag-57 options:A/D)
    get_intermediary_PartyB_option (Tag-56 options:A/D)
    get_receiving_agent_PartyB_option (Tag-57 options:A/D)


    For example:
    def get_partyA_option(self):
        condition = True
        if condition:
            return 'A'
        else:
            return 'D'

    """
    # ------------------------------------- OVERRIDE START --------------------

    # ------------------------------------- SWIFT TAG 56 ----------------------

    def _format_intermediary_PartyA_56A(self, val):
        bic = val.get('bic')
        if bic:
            return str(bic)
    # ------------------------------------- SWIFT TAG 56 ----------------------
 
    # ------------------------------------- SWIFT TAG 82 ----------------------
    def _format_partyA_82A(self, val):
        bic = val.get('BIC', None)
        if bic:
            return str(bic)
    # ------------------------------------- SWIFT TAG 82 ----------------------


    # ------------------------------------- SWIFT TAG 87 ----------------------
    def _format_partyB_87A(self, val):
        bic = val.get('BIC', None)
        if bic:
            return str(bic)
    # ------------------------------------- SWIFT TAG 87 ----------------------

    # ------------------------------------- SWIFT TAG 77D ---------------------

    def _check_condition_set_terms_and_conditions_77D(self):
        return False

    # ------------------------------------- SWIFT TAG 77D --------------------- 
    
    # ------------------------------------- SWIFT TAG 72 ----------------------
    '''
    Sender to receiver information is kept in additional info on Trade per line.
        line 1 : '/BNF/' + SwiftConfTag72_1
        line 2 : '//' + SwiftConfTag72_2
        line 3 : '//' + SwiftConfTag72_3
        line 4 : '//' + SwiftConfTag72_4
        line 5 : '//' + SwiftConfTag72_5
        line 6 : '//' + SwiftConfTag72_6                 
    '''
    # getter
    def sender_to_receiver_info_72(self):
        # Returns sender to receiver information 
        sender_to_receiver_info = []
        trade = self.acm_obj.Trade() 
        add_info_obj = trade.ConnectedTrade().AdditionalInfo() if trade.TradeProcess() == 32768 else trade.AdditionalInfo()        
        for attr_name in ['SwiftConfTag72_1', 'SwiftConfTag72_2', 'SwiftConfTag72_3', 
            'SwiftConfTag72_4', 'SwiftConfTag72_5', 'SwiftConfTag72_6']:
            attr_obj = getattr(add_info_obj, attr_name, None)
            attr_value = attr_obj() if attr_obj else ''
            if attr_value:
                qualifier = '/BNF/' if attr_name == 'SwiftConfTag72_1' else '//'
                sender_to_receiver_info.append(qualifier + attr_value)
        return sender_to_receiver_info

    # formatter
    def _format_sender_to_receiver_info_72(self, val):
        MAX_LENGTH = 35
        temp_sender_to_receiver_info = [line[:MAX_LENGTH] for line in val]
        return "\n".join(temp_sender_to_receiver_info)

    # validator
    @validate_with(MT320.MT320_SequenceH_AdditionalInformation_72_Type_Pattern)
    def _validate_sender_to_receiver_info_72(self, val):
        return val

    # setter
    def _set_sender_to_receiver_info_72(self, val):
        if not self.swift_obj.SequenceH_AdditionalInformation:
            self.swift_obj.SequenceH_AdditionalInformation = MT320.MT320_SequenceH_AdditionalInformation()
            self.swift_obj.SequenceH_AdditionalInformation.swiftTag = "15H"
            self.swift_obj.SequenceH_AdditionalInformation.formatTag = "False"
        self.swift_obj.SequenceH_AdditionalInformation.SenderToReceiverInformation = val
        self.swift_obj.SequenceH_AdditionalInformation.SenderToReceiverInformation.swiftTag = "72"

    # ------------------------------------- SWIFT TAG 72 ----------------------

    # ------------------------------------- SWIFT TAG 24D ---------------------

    def _check_condition_set_dealing_method(self):
        """return True or False depending on the condition provided"""
        return True if self.acm_obj.Trade().Broker() else False

        
    # getter
    def dealing_method(self):
        ''' Returns sender to receiver information '''
        broker = self.acm_obj.Trade().Broker() 
        return 'BROK' if broker else ''


    # formatter
    def _format_dealing_method(self, val):
        return val

    # validator
    @validate_with(MT320.MT320_SequenceH_AdditionalInformation_24D_Type_Pattern)
    def _validate_dealing_method(self, val):
        return val

    # setter
    def _set_dealing_method(self, val):
        if not self.swift_obj.SequenceH_AdditionalInformation:
            self.swift_obj.SequenceH_AdditionalInformation = MT320.MT320_SequenceH_AdditionalInformation()
            self.swift_obj.SequenceH_AdditionalInformation.swiftTag = "15H"
            self.swift_obj.SequenceH_AdditionalInformation.formatTag = "False"
        self.swift_obj.SequenceH_AdditionalInformation.DealingMethod = val
        self.swift_obj.SequenceH_AdditionalInformation.DealingMethod.swiftTag = "24D"

    # ------------------------------------- SWIFT TAG 24D ---------------------


    # ------------------------------------- SWIFT TAG 88D ---------------------

    def _check_condition_set_broker_identification(self):
        """return True or False depending on the condition provided"""
        return True if self.acm_obj.Trade().Broker() and self.acm_obj.Trade().Broker().Id2() else False
        
    # getter
    def broker_identification(self):
        ''' Returns sender to receiver information '''
        import FSwiftWriterUtils
        val=''
        broker = self.acm_obj.Trade().Broker()
        broker_alias = broker.Id2() if broker else ''
        if broker_alias:
            broker_alias = FSwiftWriterUtils.split_text_and_prefix(broker_alias, 35)
            val = FSwiftWriterUtils.allocate_space_for_name_address_without_constraint(broker_alias)
        return val


    # formatter
    def _format_broker_identification(self, val):
        return val

    # validator
    @validate_with(MT320.MT320_SequenceH_AdditionalInformation_88D_Type_Pattern)
    def _validate_broker_identification(self, val):
        return val

    # setter
    def _set_broker_identification(self, val):
        if not self.swift_obj.SequenceH_AdditionalInformation:
            self.swift_obj.SequenceH_AdditionalInformation = MT320.MT320_SequenceH_AdditionalInformation()
            self.swift_obj.SequenceH_AdditionalInformation.swiftTag = "15H"
            self.swift_obj.SequenceH_AdditionalInformation.formatTag = "False"
        self.swift_obj.SequenceH_AdditionalInformation.BrokerIdentification_D = val
        self.swift_obj.SequenceH_AdditionalInformation.BrokerIdentification_D.swiftTag = "88D"

    # ------------------------------------- SWIFT TAG 24D ---------------------

    # ------------------------------------- PARTY A SWIFT TAG 58A  -------------

    # option getter
    def get_partyA_beneficiary_institution_option(self):
        """Returns default option if override is not provided"""
        option = 'A'
        return option

    # setter
    def _set_OPTION_partyA_beneficiary_institution(self):
        partyA_beneficiary_institution_option = self.get_partyA_beneficiary_institution_option()

        if partyA_beneficiary_institution_option == "A":
            return 'partyA_beneficiary_institution_58A'
        return 'partyA_beneficiary_institution_58A'

    # getter
    def partyA_beneficiary_institution_58A(self):
        '''Returns dictionary with keys  'ACCOUNT',  'BIC' and their corresponding values '''

        values_dict = FFXMMConfirmationOutUtils.get_beneficiary_institution_details(self.acm_obj)
        return values_dict

    # formatter
    def _format_partyA_beneficiary_institution_58A(self, val):
        account = val.get('ACCOUNT')
        bic = val.get('BIC')
        if bic:
            field_value = str(bic)
            if account:
                field_value = "/" + str(account) + "\n" + str(field_value)
            return field_value            
            
    # validator
    @validate_with(MT320.MT320_SequenceC_SettlementInstructionsforAmountsPayablebyPartyA_58A_Type)
    def _validate_partyA_beneficiary_institution_58A(self, val):
        return val

    # setter
    def _setpartyA_beneficiary_institution_58A(self, val):
        self.swift_obj.SequenceC_SettlementInstructionsforAmountsPayablebyPartyA.BeneficiaryInstitution_A = val
        self.swift_obj.SequenceC_SettlementInstructionsforAmountsPayablebyPartyA.BeneficiaryInstitution_A.swiftTag = "58A"

    # ------------------------------------- PARTY A SWIFT TAG 58A  -------------

    def interest_rate_37G(self):
        interest_rate = super(FMT320, self).interest_rate_37G()
        try:
            interest_rate = acm.Math.RoundTo(interest_rate, 12)
        except Exception as e:
            pass
        
        return interest_rate
    

    # ------------------------------------- OVERRIDE END ----------------------


class FMT320MessageHeader(FMT320OutBase.FMT320OutBaseMessageHeader):

    def __init__(self, acm_obj, swift_msg_tags):
        self.acm_obj = acm_obj
        self.swift_msg_tags = swift_msg_tags
        super(FMT320MessageHeader, self).__init__(acm_obj, swift_msg_tags)

    # To override existing mappings use below methods to write your own logic

    """
    application_id
    service_id
    sender_logical_terminal_address
    session_number
    sequence_number
    input_or_output
    message_priority
    message_type
    receiver_logical_terminal_address
    delivery_monitoring
    non_delivery_notification_period
    service_identifier
    banking_priority_code
    message_user_reference
    validation_flag
    """


class FMT320NetworkRules(FMT320OutBase.FMT320OutBaseNetworkRules):

    def __init__(self, swift_message_obj, swift_message, acm_obj):
        super(FMT320NetworkRules, self).__init__(swift_message_obj, swift_message, acm_obj)



...

  FMT518Out
"""----------------------------------------------------------------------------
MODULE:
    FMT518Out

DESCRIPTION:
    This module provides the customizable class for the FMT518 outgoing implementation

CLASS:
    FMT518

VERSION: 3.6.3-0.5.6048
----------------------------------------------------------------------------"""
import MT518
import acm
import xml.dom.minidom
from FSwiftMLUtils import accepts

import FMT518OutBase
import FSwiftWriterLogger
from FSwiftWriterEngine import validate_with

notifier = FSwiftWriterLogger.FSwiftWriterLogger('SecSetOut', 'FSecuritySettlementOutNotify_Config')

@accepts([acm.FConfirmation, MT518.CTD_ANON, xml.dom.minidom.Document])
class FMT518(FMT518OutBase.FMT518Base):

    def __init__(self, acm_obj, swift_obj):
        super(FMT518, self).__init__(acm_obj, swift_obj)
        self._accru_amount = 0

    # To override existing mappings use below methods to write your own logic
    """
    settlement_indicator_22F
    transaction_type_22F
    acquirer_party
    counter_party
    quantity_of_instrument_36B
    get_settlement_datetime_98_option
    date_time_98A
    get_acquirer_party_option
    get_counter_party_option
    get_party_95_option
    get_party_safekeeping_97_option
    settlement_parties
    settlement_party_95P
    settlement_party_95R
    settlement_party_9C
    settlement_party_95Q
    party_safekeeping_account_97A
    get_indicator_22_option
    indicator_22H
    identification_of_financial_ins_35B
    linkages_20C_16R
    senders_message_reference_20C
    amount_19A
    flag_17B
    option_for_deal_price
    deal_price_90A
    deal_price_90B
    function_of_message_23G
    date_time_98A_seqE
    date_time_98B_seqE
    indicator_22F
    rate_92A
    rate_92C
    amount_19A_seqE
    
    
    
    """

    """
       To override the options provided, use below methods to write your own logic:-
       methods:-
       get_acquirer_party_option  (options:P/Q)  default:P
       get_counter_party_option   (options:P/Q)  default:P
       get_party_95_option (options:C/P/Q/R) default:P
       get_party_safekeeping_97_option (options:A/B) default:A
       get_settlement_datetime_98_option (option:A/B/C) default:A
       get_deal_price_90_option (option:A/B) default:A
       get_date_time_98a_seqE_option (option:A,B,C) default:A
       get_rate_92a_option (option:A,C) default:A
       
       For example:
       def get_party_95_option(self):
           condition = True
           if condition:
               return 'P'
           else:
               return 'Q'
               
        #this is to remove all the settlement party tags
        def settlement_parties(self):
            return {}
    
        #This to remove all the safe keeping account
        def party_safekeeping_account_97A(self, party_dict):
            #Returns a dictionary as {k1:v1,k2:v2}
            return None
    
        #This is to override quantity qualifier
        def quantity_of_instrument_36B(self):
            '''
            Returns a list of dictionaries as [{k1:v1,k2:v2},{k1:v3,k2:v4}]
            '''
            values = super(FMT518, self).quantity_of_instrument_36B()
            values['QUANTITY_TYPE_CODE'] = 'UNIT'
            return values
    """
    # ------------------------------------- OVERRIDE START --------------------
    
                    
    # ------------------------------------- SWIFT TAG 16R SETPRTY -------------
    
    
    def get_premium(self, confirmation):
        import FSwiftWriterUtils
        currency = confirmation.Trade().Currency().Name()
        premium_amount = confirmation.Trade().Premium()
        return FSwiftWriterUtils.apply_rounding(currency, premium_amount)       
    

    def party_safekeeping_account_97A(self, party_dict):
        #Returns a dictionary as {k1:v1,k2:v2}
        return None
            
    # this is to remove all the settlement party tags
    def settlement_parties(self):
        val_list = super(FMT518, self).settlement_parties()
        # Keep only REAG or DEAG qualifiers
        for val_dict in list(val_list):
            try:
                if val_dict['PARTY_P']['qualifier'] not in ['REAG', 'DEAG']:
                    val_list.remove(val_dict)
            except Exception as e:
                pass
        return val_list

    # ------------------------------------- SWIFT TAG 16R SETPRTY -------------

    # ------------------------------------- SWIFT TAG 16R AMT -----------------
    def _set_amounts(self, val_dict):
        """ Set value for the amount block"""
        super(FMT518, self)._set_amounts(val_dict)
        if self._accru_amount:
            for amt_obj in self.swift_obj.SequenceC_SettlementDetails.SubSequenceC3_Amounts:
                if amt_obj.Amount[0].value().startswith(':SETT'):
                    amt_obj.Flag.append(':ACRU//Y')
                    amt_obj.Flag[-1].swiftTag = "17B"
                
                    
    def amounts(self):
        amounts_block_details = super(FMT518, self).amounts()

        # Remove FLAG_BLOCKS
        amounts_block_details['FLAG_BLOCKS'] = []
        
        # Create DEAL AMOUNT BLOCK
        curr = ''
        premium_amount = abs(self.get_premium(self.acm_obj))
        for amount in amounts_block_details['AMOUNT_BLOCKS']:
            curr = amount['AMOUNT_CURRENCY_CODE']
            if amount['AMOUNT_QUALIFIER'] == 'SETT':
                amount['AMOUNT_AMOUNT'] = premium_amount
            elif amount['AMOUNT_QUALIFIER'] == 'ACRU':
                self._accru_amount = amount['AMOUNT_AMOUNT']
                
                
        deal_amount_block = {}
        deal_amount_block['AMOUNT_QUALIFIER'] = 'DEAL'
        deal_amount_block['AMOUNT_CURRENCY_CODE'] = curr
        deal_amount_block['AMOUNT_AMOUNT'] = premium_amount - abs(self._accru_amount)
        
        amounts_block_details['AMOUNT_BLOCKS'].insert(0, deal_amount_block)
        
        return amounts_block_details

    # ------------------------------------- SWIFT TAG 16R AMT -----------------

    # ------------------------------------- SWIFT TAG 16R CONFPRTY ------------
    def _set_counter_party(self, val):

        super(FMT518, self)._set_counter_party(val)

        # Add counterparty safe keeping account
        import FSecurityConfirmationOutUtils
        account = FSecurityConfirmationOutUtils.get_counter_party_account_ref(self.acm_obj)
        if account:
            conf_pty = self.swift_obj.SequenceB_ConfirmationDetails.SubSequenceB1_ConfirmationParties[-1]
            conf_pty.Account_A.append(f':SAFE//{account.Account()}')
            conf_pty.Account_A[-1].swiftTag = "97A" 
    
    
    def _set_acquirer_party(self, val):

        super(FMT518, self)._set_acquirer_party(val)

        # Add acquirer safe keeping account
        import FSecurityConfirmationOutUtils
        account = FSecurityConfirmationOutUtils.get_acquirer_party_account_ref(self.acm_obj)
        if account:
            conf_pty = self.swift_obj.SequenceB_ConfirmationDetails.SubSequenceB1_ConfirmationParties[-1]
            conf_pty.Account_A.append(f':SAFE//{account.Account()}')
            conf_pty.Account_A[-1].swiftTag = "97A"

    # ------------------------------------- SWIFT TAG 16R CONFPRTY ------------
    
    # ------------------------------------- SWIFT TAG 23G FUNCTION ------------
    def function_of_message_23G(self):
        """ Returns a string containing value of fuction_of_message """
        val = super(FMT518, self).function_of_message_23G()
        if not val:
            val = 'NEWM' if self.acm_obj.EventChlItem().Name() in ['Exercise'] and self.acm_obj.Type() in ['Default', 'Resend'] else None
        return val
    
    # ------------------------------------- SWIFT TAG 23G FUNCTION ------------

    # ------------------------------------- OVERRIDE END ----------------------


class FMT518MessageHeader(FMT518OutBase.FMT518OutBaseMessageHeader):

    def __init__(self, acm_obj, swift_msg_tags):
        self.acm_obj = acm_obj
        self.swift_msg_tags = swift_msg_tags
        super(FMT518MessageHeader, self).__init__(acm_obj, swift_msg_tags)

    # To override existing mappings use below methods to write your own logic

    """
    message_type
    sender_logical_terminal_address
    receiver_logical_terminal_address
    logical_terminal_address
    input_or_output
    message_user_reference
    """

class FMT518NetworkRules(FMT518OutBase.FMT518OutBaseNetworkRules):

    def __init__(self, swift_message_obj, swift_message, acm_obj):
        super(FMT518NetworkRules, self).__init__(swift_message_obj, swift_message, acm_obj)

...

  FMT540Out
"""----------------------------------------------------------------------------
MODULE:
    FMT540Out

DESCRIPTION:
    This module provides the customizable class for the FMT540 outgoing implementation

CLASS:
    FMT540

VERSION: 3.6.3-0.5.6048
----------------------------------------------------------------------------"""
import MT540
import acm
import xml.dom.minidom
from FSwiftMLUtils import accepts

import FMT540OutBase
import FSwiftWriterLogger
from FSwiftWriterEngine import validate_with

notifier = FSwiftWriterLogger.FSwiftWriterLogger('SecSetOut', 'FSecuritySettlementOutNotify_Config')

# ------------------------------------- OVERRIDE START ---------------------------
import FSwiftWriterUtils
# ------------------------------------- OVERRIDE END -----------------------------

@accepts([acm.FSettlement, MT540.CTD_ANON, xml.dom.minidom.Document])
class FMT540(FMT540OutBase.FMT540Base):

    def __init__(self, acm_obj, swift_obj):
        super(FMT540, self).__init__(acm_obj, swift_obj)

    # To override existing mappings use below methods to write your own logic
    """
    account_97A
    date_time_98A
    function_of_message_23G
    identification_of_financial_ins_35B
    indicator_22F
    linkages_20C_16R
    party_safekeeping_account_97A
    place_of_safekeeping_94F
    quantity_of_instrument_36B
    senders_message_reference_20C
    settlement_party_95C
    settlement_party_95P
    settlement_party_95Q
    settlement_party_95R
    get_user_data
    """

    """
    To override the options provided, use below methods to write your own logic:-
    methods:-
    get_settlement_datetime_98_option (options:A/C/E)
    get_account_97_option (options:A/B/E)
    get_party_95_option (options:C/L/P/Q/R/S)
    get_party_safekeeping_97_option (options:A/B)
    get_quantity_of_instrument_option (options:B/D)

    For example:
    def get_party_95_option(self):
        condition = True
        if condition:
            return 'P'
        else:
            return 'C'
    """
    # ------------------------------------- OVERRIDE START ---------------------------

    # ------------------------------------- SWIFT TAG 35B ----------------------

    def identification_of_financial_ins_35B(self):

        values_dict = super(FMT540, self).identification_of_financial_ins_35B()

        # SWIFT: Description = Instrument name
        ins_desc = self.acm_obj.Instrument().Name() if self.acm_obj.Instrument() else ''
        values_dict['description_of_security'] = ins_desc

        return values_dict
    # ------------------------------------- SWIFT TAG 35B ----------------------
    
    def IsBasketRepo(self):
        basket_repo = False
        margining_set = self.acm_obj.Trade().MarginingSet()
        if margining_set:
            exposure_ins = margining_set.SingleSetExposureInstrument()
            if exposure_ins and exposure_ins.InsType() == 'BasketRepo/Reverse':
                basket_repo = True
        return basket_repo
        
    # ------------------------------------- SWIFT TAG 22F ----------------------

    def indicator_22F(self):

        # STCO indicator is not required
        indicator_blocks = super(FMT540, self).indicator_22F()
        
        for block in list(indicator_blocks):
            if str(block.get('INDICATOR_QUALIFIER', '')) == 'STCO':
                indicator_blocks.remove(block)
                
            if self.acm_obj.Trade() and self.IsBasketRepo():
                if str(block['INDICATOR_QUALIFIER']) == 'SETR':
                    block['INDICATOR_INDICATOR'] = 'TRAD'
        
        return indicator_blocks
    # ------------------------------------- SWIFT TAG 22F ----------------------

    # ------------------------------------- SWIFT TAG 97A ----------------------
    # SAFE keeping account for parties are not required for SWIFT
    def party_safekeeping_account_97A(self, party_dict):
    
        values_dict = {}
        return values_dict

    def _format_party_safekeeping_account_97A(self, val):
    
        party_safekeeping_account_A = ''
        return party_safekeeping_account_A

    # ------------------------------------- SWIFT TAG 97A ----------------------

    # ------------------------------------- SWIFT TAG 95 SELL/BUYR -------------

    # SWIFT 95P:SELL/BUYR needs to be set to 95Q
    def settlement_parties(self):

        parties = super(FMT540, self).settlement_parties()

        try:
            for party in parties:
                if 'PARTY_P' in party and party['PARTY_P']['qualifier'] in ['SELL', 'BUYR']:
                    party_q = {}
                    party_q['PARTY_Q'] = party['PARTY_P']
                    party_q['PARTY_Q']['name'] = self.acm_obj.Counterparty().Fullname()
                    parties.remove(party)
                    parties.insert(0, party_q)
                    break
        except Exception as e:
            notifier.WARN("Error in settlement_parties %s"%(str(e)))

        return parties

    def _format_settlement_party_95Q(self, val):

        qualifier = val.get('qualifier')
        name = val.get('name')
        if name:
            name = FSwiftWriterUtils.split_text_and_prefix(name, 35)
            val = FSwiftWriterUtils.allocate_space_for_name_address_without_constraint(name)
        settlement_party_Q = ":" + str(qualifier) + "//" + val

        return settlement_party_Q

    # ------------------------------------- SWIFT TAG 95 SELL/BUYR -------------

    # ------------------------------------- OVERRIDE END ---------------------------


class FMT540MessageHeader(FMT540OutBase.FMT540OutBaseMessageHeader):

    def __init__(self, acm_obj, swift_msg_tags):
        self.acm_obj = acm_obj
        self.swift_msg_tags = swift_msg_tags
        super(FMT540MessageHeader, self).__init__(acm_obj, swift_msg_tags)

    # To override existing mappings use below methods to write your own logic

    """
    application_id
    service_id
    sender_logical_terminal_address
    session_number
    sequence_number
    input_or_output
    message_priority
    message_type
    receiver_logical_terminal_address
    delivery_monitoring
    non_delivery_notification_period
    service_identifier
    banking_priority_code
    message_user_reference
    validation_flag
    """


class FMT540NetworkRules(FMT540OutBase.FMT540OutBaseNetworkRules):

    def __init__(self, swift_message_obj, swift_message, acm_obj):
        super(FMT540NetworkRules, self).__init__(swift_message_obj, swift_message, acm_obj)


...

  FMT541Out
"""----------------------------------------------------------------------------
MODULE:
    FMT541Out

DESCRIPTION:
    This module provides the customizable class for the FMT541 outgoing implementation

CLASS:
    FMT541

VERSION: 3.6.3-0.5.6048
----------------------------------------------------------------------------"""
import MT541
import acm
import xml.dom.minidom
from FSwiftMLUtils import accepts

import FMT541OutBase
import FSwiftWriterLogger
from FSwiftWriterEngine import validate_with

notifier = FSwiftWriterLogger.FSwiftWriterLogger('SecSetOut', 'FSecuritySettlementOutNotify_Config')

# ------------------------------------- OVERRIDE START ---------------------------
import FSwiftWriterUtils
import FSwiftMLUtils
import FSecuritySettlementOutUtils

CALC_SPACE_TRADE_SHEET = acm.Calculations().CreateCalculationSpace(acm.GetDefaultContext(), 'FTradeSheet')

def get_basket_repo_trade(sett):
    basket_repo_trade = None
    if sett.Trade().TradeCategory() == 'Collateral':
        collateral_trade = sett.Trade()
        m_set = collateral_trade.MarginingSet()
        for trd_lnk in m_set.TradeAgreementLinks():
            if trd_lnk.Trade().Instrument().IsKindOf(acm.FBasketRepo):
                basket_repo_trade = trd_lnk.Trade()  
                break

    return basket_repo_trade
# ------------------------------------- OVERRIDE END -----------------------------

@accepts([acm.FSettlement, MT541.CTD_ANON, xml.dom.minidom.Document])
class FMT541(FMT541OutBase.FMT541Base):

    def __init__(self, acm_obj, swift_obj):
        super(FMT541, self).__init__(acm_obj, swift_obj)

    # To override existing mappings use below methods to write your own logic
    """
    account_97A
    amounts
    date_time_98A
    function_of_message_23G
    identification_of_financial_ins_35B
    indicator_22F
    linkages_20C_16R
    party_safekeeping_account_97A
    place_of_safekeeping_94F
    quantity_of_instrument_36B
    senders_message_reference_20C
    settlement_party_95C
    settlement_party_95P
    settlement_party_95Q
    settlement_party_95R
    get_user_data
    """

    """
    To override the options provided, use below methods to write your own logic:-
    methods:-
    get_settlement_datetime_98_option (options:A/C/E)
    get_account_97_option (options:A/B/E)
    get_party_95_option (options:C/L/P/Q/R/S)
    get_party_safekeeping_97_option (options:A/B)
    get_quantity_of_instrument_option (options:B/D)

    For example:
    def get_party_95_option(self):
        condition = True
        if condition:
            return 'P'
        else:
            return 'C'
    """
    # ------------------------------------- OVERRIDE START ---------------------------

    # ------------------------------------- SWIFT TAG 35B ----------------------

    def identification_of_financial_ins_35B(self):

        values_dict = super(FMT541, self).identification_of_financial_ins_35B()

        # SWIFT: Description = Instrument name
        ins_desc = self.acm_obj.Instrument().Name() if self.acm_obj.Instrument() else ''
        values_dict['description_of_security'] = ins_desc

        return values_dict
    # ------------------------------------- SWIFT TAG 35B ----------------------

    # ------------------------------------- SWIFT TAG FIA ----------------------
    # SWIFT message does not need block FIA
    def _message_sequences(self):
        
        super(FMT541, self)._message_sequences()
        self.swift_obj.SequenceB_TradeDetails.SubSequenceB1_FinancialInstrumentAttributes = None

    # ------------------------------------- TAG 98A FIA ------------------------

    def _check_condition_set_subsequenceb1_date_time(self):
        """return True or False depending on the condition provided"""
        return False

    # ------------------------------------- TAG 98A FIA ------------------------

    # ------------------------------------- TAG 92A FIA ------------------------

    def _check_condition_set_subsequenceb1_rate(self):
        """return True or False depending on the condition provided"""
        return False

    # ------------------------------------- TAG 92A FIA ------------------------

    # ------------------------------------- SWIFT TAG FIA ----------------------
    
    # ------------------------------------- SWIFT TAG 97A ----------------------
    # SAFE keeping account for parties are not required for SWIFT
    def party_safekeeping_account_97A(self, party_dict):
    
        values_dict = {}
        return values_dict

    def _format_party_safekeeping_account_97A(self, val):
    
        party_safekeeping_account_A = ''
        return party_safekeeping_account_A

    # ------------------------------------- SWIFT TAG 97A ----------------------

    # ------------------------------------- SWIFT TAG 95 SELL/BUYR -------------

    # SWIFT 95P:SELL/BUYR needs to be set to 95Q
    def settlement_parties(self):

        parties = super(FMT541, self).settlement_parties()
        
                
        try:
            for party in parties:
                if 'PARTY_P' in party and party['PARTY_P']['qualifier'] in ['SELL', 'BUYR']:
                    party_q = {}
                    party_q['PARTY_Q'] = party['PARTY_P']
                    party_q['PARTY_Q']['name'] = self.acm_obj.Counterparty().Fullname()
                    parties.remove(party)
                    parties.insert(0, party_q)
                    break
        except Exception as e:
            notifier.WARN("Error in settlement_parties %s"%(str(e)))

        return parties

    def _format_settlement_party_95Q(self, val):

        qualifier = val.get('qualifier')
        name = val.get('name')
        if name:
            name = FSwiftWriterUtils.split_text_and_prefix(name, 35)
            val = FSwiftWriterUtils.allocate_space_for_name_address_without_constraint(name)
        settlement_party_Q = ":" + str(qualifier) + "//" + val

        return settlement_party_Q

    # ------------------------------------- SWIFT TAG 95 SELL/BUYR -------------

    # ------------------------------------- SWIFT TAG 16R AMT ------------------
    # Code taken from FSecuritySettlementOutUtils
    def security_value(self, settlement):
        trade = settlement.Trade()
        td = acm.FBusinessLogicDecorator.WrapObject(trade)
        secValue = td.SecurityValue(td.CollateralActionType(), None)
        if  trade.BoFxRate():
            securityvalue = secValue * trade.BoFxRate()
        else:
            securityvalue = secValue
        return securityvalue
        
    def repo_security_value(self, settlement):
        sec_val=0
        trd=get_basket_repo_trade(settlement)
        if trd:
            if trd.Premium()<0:
                sec_val=trd.Premium()
            else:
                sec_val=CALC_SPACE_TRADE_SHEET.CalculateValue(trd, "Standard Calculations Projected Factor").Value().Number()
        else:
            sec_val=security_value(settlement)
            
        return sec_val
        
        
    def amounts(self):

        amounts = super(FMT541, self).amounts()

        # ---------------- SSSTL-404 FIX START ---------------------------------------------
        # Can be removed either after fix of SSSTL-404 or PRIME-106274
        if self.acm_obj.Trade() and self.IsBasketRepo():
            amount = self.repo_security_value(self.acm_obj)
            if abs(amount) > 0.0:
                for sett_amount in list(amounts.get('AMOUNT_BLOCKS')):
                    if 'SETT' == sett_amount['AMOUNT_QUALIFIER']:
                        amounts['AMOUNT_BLOCKS'].remove(sett_amount)
                val_dict = dict()
                val_dict['AMOUNT_QUALIFIER'] = 'SETT'
                val_dict['AMOUNT_CURRENCY_CODE'] = FSecuritySettlementOutUtils.get_currency_code(self.acm_obj)
                val_dict['AMOUNT_AMOUNT'] = abs(FSecuritySettlementOutUtils.apply_currency_precision(val_dict['AMOUNT_CURRENCY_CODE'], amount))
                val_dict['AMOUNT_SIGN'] = FSecuritySettlementOutUtils.get_sign_from_amount(amount, self.swift_message_type)

                amounts['AMOUNT_BLOCKS'].append(val_dict)
        # ---------------- SSSTL-404 FIX END  ----------------------------------------------
        
        # SWIFT requires only SETT tags
        for amount in list(amounts.get('AMOUNT_BLOCKS')):
            if 'SETT' not in amount['AMOUNT_QUALIFIER']:
                amounts['AMOUNT_BLOCKS'].remove(amount)

        # CNH to CNY conversion
        for amount in list(amounts.get('AMOUNT_BLOCKS')):
            if amount['AMOUNT_CURRENCY_CODE'] == 'CNH':
                amount['AMOUNT_CURRENCY_CODE'] = 'CNY'

        amounts['FLAG_BLOCKS'] = []

        return amounts
    # ------------------------------------- SWIFT TAG 16R AMT ------------------

    # ------------------------------------- SSSTL-404 FIX START ----------------
    # Can be removed either after fix of SSSTL-404 or PRIME-106274

    # ------------------------------------- SWIFT TAG 22F IND ------------------
    
    def IsBasketRepo(self):
        basket_repo = False
        margining_set = self.acm_obj.Trade().MarginingSet()
        if margining_set:
            exposure_ins = margining_set.SingleSetExposureInstrument()
            if exposure_ins and exposure_ins.InsType() == 'BasketRepo/Reverse':
                basket_repo = True
        return basket_repo
    
    def indicator_22F(self):
        indicator_blocks = super(FMT541, self).indicator_22F()
        
        for block in list(indicator_blocks):

            if str(block.get('INDICATOR_QUALIFIER', '')) == 'STCO':
                indicator_blocks.remove(block)
        
            if self.acm_obj.Trade() and self.IsBasketRepo():
                if str(block['INDICATOR_QUALIFIER']) == 'SETR':
                    block['INDICATOR_INDICATOR'] = 'TRAD'                        
        return indicator_blocks
    # ------------------------------------- SWIFT TAG 22F IND ------------------

    # ------------------------------------- SSSTL-404 FIX END ------------------

    # ------------------------------------- OVERRIDE END ---------------------------

class FMT541MessageHeader(FMT541OutBase.FMT541OutBaseMessageHeader):

    def __init__(self, acm_obj, swift_msg_tags):
        self.acm_obj = acm_obj
        self.swift_msg_tags = swift_msg_tags
        super(FMT541MessageHeader, self).__init__(acm_obj, swift_msg_tags)


    # To override existing mappings use below methods to write your own logic

    """
    application_id
    service_id
    sender_logical_terminal_address
    session_number
    sequence_number
    input_or_output
    message_priority
    message_type
    receiver_logical_terminal_address
    delivery_monitoring
    non_delivery_notification_period
    service_identifier
    banking_priority_code
    message_user_reference
    validation_flag
    """

class FMT541NetworkRules(FMT541OutBase.FMT541OutBaseNetworkRules):

    def __init__(self, swift_message_obj, swift_message, acm_obj):
        super(FMT541NetworkRules, self).__init__(swift_message_obj, swift_message, acm_obj)


...

  FMT542Out
"""----------------------------------------------------------------------------
MODULE:
    FMT542Out

DESCRIPTION:
    This module provides the customizable class for the FMT542 outgoing implementation

CLASS:
    FMT542

VERSION: 3.6.3-0.5.6048
----------------------------------------------------------------------------"""
import MT542
import acm
import xml.dom.minidom
from FSwiftMLUtils import accepts

import FMT542OutBase
import FSwiftWriterLogger
from FSwiftWriterEngine import validate_with

notifier = FSwiftWriterLogger.FSwiftWriterLogger('SecSetOut', 'FSecuritySettlementOutNotify_Config')

# ------------------------------------- OVERRIDE START ---------------------------
import FSwiftWriterUtils
# ------------------------------------- OVERRIDE END -----------------------------


@accepts([acm.FSettlement, MT542.CTD_ANON, xml.dom.minidom.Document])
class FMT542(FMT542OutBase.FMT542Base):

    def __init__(self, acm_obj, swift_obj):
        super(FMT542, self).__init__(acm_obj, swift_obj)

    # To override existing mappings use below methods to write your own logic
    """
    account_97A
    date_time_98A
    function_of_message_23G
    identification_of_financial_ins_35B
    indicator_22F
    linkages_20C_16R
    party_safekeeping_account_97A
    place_of_safekeeping_94F
    quantity_of_instrument_36B
    senders_message_reference_20C
    settlement_party_95C
    settlement_party_95P
    settlement_party_95Q
    settlement_party_95R
    get_user_data
    """

    """
    To override the options provided, use below methods to write your own logic:-
    methods:-
    get_settlement_datetime_98_option (options:A/C/E)
    get_account_97_option (options:A/B/E)
    get_party_95_option (options:C/L/P/Q/R/S)
    get_party_safekeeping_97_option (options:A/B)
    get_quantity_of_instrument_option (options:B/D)

    For example:
    def get_party_95_option(self):
        condition = True
        if condition:
            return 'P'
        else:
            return 'C'
    """
    # ------------------------------------- OVERRIDE START ---------------------------

    # ------------------------------------- SWIFT TAG 35B ----------------------

    def identification_of_financial_ins_35B(self):

        values_dict = super(FMT542, self).identification_of_financial_ins_35B()

        # SWIFT: Description = Instrument name
        ins_desc = self.acm_obj.Instrument().Name() if self.acm_obj.Instrument() else ''
        values_dict['description_of_security'] = ins_desc

        return values_dict
    # ------------------------------------- SWIFT TAG 35B ----------------------

    # ------------------------------------- SWIFT TAG 22F ----------------------

    def IsBasketRepo(self):
        basket_repo = False
        margining_set = self.acm_obj.Trade().MarginingSet()
        if margining_set:
            exposure_ins = margining_set.SingleSetExposureInstrument()
            if exposure_ins and exposure_ins.InsType() == 'BasketRepo/Reverse':
                basket_repo = True
        return basket_repo
        
    def indicator_22F(self):

        # STCO indicator is not required
        indicator_blocks = super(FMT542, self).indicator_22F()
        
        for block in list(indicator_blocks):
            if str(block.get('INDICATOR_QUALIFIER', '')) == 'STCO':
                indicator_blocks.remove(block)
                
            if self.acm_obj.Trade() and self.IsBasketRepo():
                if str(block['INDICATOR_QUALIFIER']) == 'SETR':
                    block['INDICATOR_INDICATOR'] = 'TRAD'
        
        return indicator_blocks
    # ------------------------------------- SWIFT TAG 22F ----------------------

    # ------------------------------------- SWIFT TAG 97A ----------------------
    # SAFE keeping account for parties are not required for SWIFT
    def party_safekeeping_account_97A(self, party_dict):
    
        values_dict = {}
        return values_dict

    def _format_party_safekeeping_account_97A(self, val):
    
        party_safekeeping_account_A = ''
        return party_safekeeping_account_A

    # ------------------------------------- SWIFT TAG 97A ----------------------

    # ------------------------------------- SWIFT TAG 95 SELL/BUYR -------------

    # SWIFT 95P:SELL/BUYR needs to be set to 95Q
    def settlement_parties(self):

        parties = super(FMT542, self).settlement_parties()

        try:
            for party in parties:
                if 'PARTY_P' in party and party['PARTY_P']['qualifier'] in ['SELL', 'BUYR']:
                    party_q = {}
                    party_q['PARTY_Q'] = party['PARTY_P']
                    party_q['PARTY_Q']['name'] = self.acm_obj.Counterparty().Fullname()
                    parties.remove(party)
                    parties.insert(0, party_q)
                    break
        except Exception as e:
            notifier.WARN("Error in settlement_parties %s"%(str(e)))

        return parties

    def _format_settlement_party_95Q(self, val):

        qualifier = val.get('qualifier')
        name = val.get('name')
        if name:
            name = FSwiftWriterUtils.split_text_and_prefix(name, 35)
            val = FSwiftWriterUtils.allocate_space_for_name_address_without_constraint(name)
        settlement_party_Q = ":" + str(qualifier) + "//" + val

        return settlement_party_Q

    # ------------------------------------- SWIFT TAG 95 SELL/BUYR -------------

    # ------------------------------------- OVERRIDE END ---------------------------


class FMT542MessageHeader(FMT542OutBase.FMT542OutBaseMessageHeader):

    def __init__(self, acm_obj, swift_msg_tags):
        self.acm_obj = acm_obj
        self.swift_msg_tags = swift_msg_tags
        super(FMT542MessageHeader, self).__init__(acm_obj, swift_msg_tags)

    # To override existing mappings use below methods to write your own logic

    """
    application_id
    service_id
    sender_logical_terminal_address
    session_number
    sequence_number
    input_or_output
    message_priority
    message_type
    receiver_logical_terminal_address
    delivery_monitoring
    non_delivery_notification_period
    service_identifier
    banking_priority_code
    message_user_reference
    validation_flag
    """

class FMT542NetworkRules(FMT542OutBase.FMT542OutBaseNetworkRules):

    def __init__(self, swift_message_obj, swift_message, acm_obj):
        super(FMT542NetworkRules, self).__init__(swift_message_obj, swift_message, acm_obj)


...

  FMT543Out
"""----------------------------------------------------------------------------
MODULE:
    FMT543Out

DESCRIPTION:
    This module provides the customizable class for the FMT543 outgoing implementation

CLASS:
    FMT543

VERSION: 3.6.3-0.5.6048
----------------------------------------------------------------------------"""
import MT543
import acm
import xml.dom.minidom
from FSwiftMLUtils import accepts

import FMT543OutBase
import FSwiftWriterLogger
from FSwiftWriterEngine import validate_with

notifier = FSwiftWriterLogger.FSwiftWriterLogger('SecSetOut', 'FSecuritySettlementOutNotify_Config')

# ------------------------------------- OVERRIDE START ---------------------------
import FSwiftWriterUtils
import FSwiftMLUtils
import FSecuritySettlementOutUtils

CALC_SPACE_TRADE_SHEET = acm.Calculations().CreateCalculationSpace(acm.GetDefaultContext(), 'FTradeSheet')

def get_basket_repo_trade(sett):
    basket_repo_trade = None
    if sett.Trade().TradeCategory() == 'Collateral':
        collateral_trade = sett.Trade()
        m_set = collateral_trade.MarginingSet()
        for trd_lnk in m_set.TradeAgreementLinks():
            if trd_lnk.Trade().Instrument().IsKindOf(acm.FBasketRepo):
                basket_repo_trade = trd_lnk.Trade()  
                break

    return basket_repo_trade
# ------------------------------------- OVERRIDE END -----------------------------

@accepts([acm.FSettlement, MT543.CTD_ANON, xml.dom.minidom.Document])
class FMT543(FMT543OutBase.FMT543Base):

    def __init__(self, acm_obj, swift_obj):
        super(FMT543, self).__init__(acm_obj, swift_obj)

    # To override existing mappings use below methods to write your own logic
    """
    account_97A
    amounts
    date_time_98A
    function_of_message_23G
    identification_of_financial_ins_35B
    indicator_22F
    linkages_20C_16R
    party_safekeeping_account_97A
    place_of_safekeeping_94F
    quantity_of_instrument_36B
    senders_message_reference_20C
    settlement_party_95C
    settlement_party_95P
    settlement_party_95Q
    settlement_party_95R
    get_user_data
    """

    """
    To override the options provided, use below methods to write your own logic:-
    methods:-
    get_settlement_datetime_98_option (options:A/C/E)
    get_account_97_option (options:A/B/E)
    get_party_95_option (options:C/L/P/Q/R/S)
    get_party_safekeeping_97_option (options:A/B)
    get_quantity_of_instrument_option (options:B/D)

    For example:
    def get_party_95_option(self):
        condition = True
        if condition:
            return 'P'
        else:
            return 'C'
    """
    # ------------------------------------- OVERRIDE START ---------------------------

    # ------------------------------------- SWIFT TAG 35B ----------------------

    def identification_of_financial_ins_35B(self):

        values_dict = super(FMT543, self).identification_of_financial_ins_35B()

        # SWIFT: Description = Instrument name
        ins_desc = self.acm_obj.Instrument().Name() if self.acm_obj.Instrument() else ''
        values_dict['description_of_security'] = ins_desc

        return values_dict
    # ------------------------------------- SWIFT TAG 35B ----------------------

    # ------------------------------------- SWIFT TAG FIA ----------------------
    # SWIFT message does not need block FIA
    def _message_sequences(self):
        
        super(FMT543, self)._message_sequences()
        self.swift_obj.SequenceB_TradeDetails.SubSequenceB1_FinancialInstrumentAttributes = None

    # ------------------------------------- TAG 98A FIA ------------------------

    def _check_condition_set_subsequenceb1_date_time(self):
        """return True or False depending on the condition provided"""
        return False

    # ------------------------------------- TAG 98A FIA ------------------------

    # ------------------------------------- TAG 92A FIA ------------------------

    def _check_condition_set_subsequenceb1_rate(self):
        """return True or False depending on the condition provided"""
        return False

    # ------------------------------------- TAG 92A FIA ------------------------

    # ------------------------------------- SWIFT TAG FIA ----------------------

    # ------------------------------------- SWIFT TAG 97A ----------------------
    # SAFE keeping account for parties are not required for SWIFT
    def party_safekeeping_account_97A(self, party_dict):
    
        values_dict = {}
        return values_dict

    def _format_party_safekeeping_account_97A(self, val):
    
        party_safekeeping_account_A = ''
        return party_safekeeping_account_A

    # ------------------------------------- SWIFT TAG 97A ----------------------

    # ------------------------------------- SWIFT TAG 95 SELL/BUYR -------------

    # SWIFT 95P:SELL/BUYR needs to be set to 95Q
    def settlement_parties(self):

        parties = super(FMT543, self).settlement_parties()

        try:
            for party in parties:
                if 'PARTY_P' in party and party['PARTY_P']['qualifier'] in ['SELL', 'BUYR']:
                    party_q = {}
                    party_q['PARTY_Q'] = party['PARTY_P']
                    party_q['PARTY_Q']['name'] = self.acm_obj.Counterparty().Fullname()
                    parties.remove(party)
                    parties.insert(0, party_q)
                    break
        except Exception as e:
            notifier.WARN("Error in settlement_parties %s"%(str(e)))

        return parties

    def _format_settlement_party_95Q(self, val):

        qualifier = val.get('qualifier')
        name = val.get('name')
        if name:
            name = FSwiftWriterUtils.split_text_and_prefix(name, 35)
            val = FSwiftWriterUtils.allocate_space_for_name_address_without_constraint(name)
        settlement_party_Q = ":" + str(qualifier) + "//" + val

        return settlement_party_Q

    # ------------------------------------- SWIFT TAG 95 SELL/BUYR -------------
    
    
    # ------------------------------------- SWIFT TAG 16R AMT ------------------
    # Code taken from FSecuritySettlementOutUtils
    def security_value(self, settlement):
        trade = settlement.Trade()
        td = acm.FBusinessLogicDecorator.WrapObject(trade)
        secValue = td.SecurityValue(td.CollateralActionType(), None)
        if  trade.BoFxRate():
            securityvalue = secValue * trade.BoFxRate()
        else:
            securityvalue = secValue
        return securityvalue
        
    def repo_security_value(self, settlement):
        sec_val=0
        trd=get_basket_repo_trade(settlement)
        if trd:
            if trd.Premium()>0:
                sec_val=trd.Premium()
            else:
                sec_val=CALC_SPACE_TRADE_SHEET.CalculateValue(trd, "Standard Calculations Projected Factor").Value().Number()
        else:
            sec_val=security_value(settlement)
            
        return sec_val

    def amounts(self):

        amounts = super(FMT543, self).amounts()
        
        # ---------------- SSSTL-404 FIX START ---------------------------------------------
        # Can be removed either after fix of SSSTL-404 or PRIME-106274
        if self.acm_obj.Trade() and self.IsBasketRepo():
            amount = self.repo_security_value(self.acm_obj)
            if abs(amount) > 0.0:
                for sett_amount in list(amounts.get('AMOUNT_BLOCKS')):
                    if 'SETT' == sett_amount['AMOUNT_QUALIFIER']:
                        amounts['AMOUNT_BLOCKS'].remove(sett_amount)
                val_dict = dict()
                val_dict['AMOUNT_QUALIFIER'] = 'SETT'
                val_dict['AMOUNT_CURRENCY_CODE'] = FSecuritySettlementOutUtils.get_currency_code(self.acm_obj)
                val_dict['AMOUNT_AMOUNT'] = abs(FSecuritySettlementOutUtils.apply_currency_precision(val_dict['AMOUNT_CURRENCY_CODE'], amount))
                val_dict['AMOUNT_SIGN'] = FSecuritySettlementOutUtils.get_sign_from_amount(amount, self.swift_message_type)

                amounts['AMOUNT_BLOCKS'].append(val_dict)
        # ---------------- SSSTL-404 FIX END  ----------------------------------------------
        
        # SWIFT requires only SETT tags
        for amount in list(amounts.get('AMOUNT_BLOCKS')):
            if 'SETT' not in amount['AMOUNT_QUALIFIER']:
                amounts['AMOUNT_BLOCKS'].remove(amount)

        # CNH to CNY conversion
        for amount in list(amounts.get('AMOUNT_BLOCKS')):
            if amount['AMOUNT_CURRENCY_CODE'] == 'CNH':
                amount['AMOUNT_CURRENCY_CODE'] = 'CNY'

        amounts['FLAG_BLOCKS'] = []

        return amounts

    # ------------------------------------- SWIFT TAG 16R AMT ------------------

    # ------------------------------------- SSSTL-404 FIX START ----------------
    # Can be removed either after fix of SSSTL-404 or PRIME-106274

    # ------------------------------------- SWIFT TAG 22F IND ------------------
    
    def IsBasketRepo(self):
        basket_repo = False
        margining_set = self.acm_obj.Trade().MarginingSet()
        if margining_set:
            exposure_ins = margining_set.SingleSetExposureInstrument()
            if exposure_ins and exposure_ins.InsType() == 'BasketRepo/Reverse':
                basket_repo = True
        return basket_repo
    
    def indicator_22F(self):
        indicator_blocks = super(FMT543, self).indicator_22F()
       
        for block in list(indicator_blocks):

            if str(block.get('INDICATOR_QUALIFIER', '')) == 'STCO':
                indicator_blocks.remove(block)
        
            if self.acm_obj.Trade() and self.IsBasketRepo():
                if str(block['INDICATOR_QUALIFIER']) == 'SETR':
                    block['INDICATOR_INDICATOR'] = 'TRAD'                        
        return indicator_blocks

    # ------------------------------------- SWIFT TAG 22F IND ------------------

    # ------------------------------------- SSSTL-404 FIX END ------------------
    
    # ------------------------------------- OVERRIDE END ---------------------------


class FMT543MessageHeader(FMT543OutBase.FMT543OutBaseMessageHeader):

    def __init__(self, acm_obj, swift_msg_tags):
        self.acm_obj = acm_obj
        self.swift_msg_tags = swift_msg_tags
        super(FMT543MessageHeader, self).__init__(acm_obj, swift_msg_tags)

    # To override existing mappings use below methods to write your own logic

    """
    application_id
    service_id
    sender_logical_terminal_address
    session_number
    sequence_number
    input_or_output
    message_priority
    message_type
    receiver_logical_terminal_address
    delivery_monitoring
    non_delivery_notification_period
    service_identifier
    banking_priority_code
    message_user_reference
    validation_flag
    """

class FMT543NetworkRules(FMT543OutBase.FMT543OutBaseNetworkRules):

    def __init__(self, swift_message_obj, swift_message, acm_obj):
        super(FMT543NetworkRules, self).__init__(swift_message_obj, swift_message, acm_obj)


...

  FMT548In
"""----------------------------------------------------------------------------
MODULE:
    FMT548In

DESCRIPTION:
    OPEN EXTENSION MODULE
    FMT548 class for user customization.
    User can override the mapping defined in the base class FMT548InBase.
    This class can be populated using either swift data or an acm object.
    See FMT548InBase for extracting the values from swift #or an acm

VERSION: 3.6.3-0.5.6048
----------------------------------------------------------------------------"""
import FMT548InBase

# ------------------------------ OVERRIDE START ---------------------------
import acm
# ------------------------------ OVERRIDE END -----------------------------


class FMT548(FMT548InBase.FMT548Base):
    """ FMT547 class for user customization"""

    def __init__(self, source, direction):
        super(FMT548, self).__init__(source, direction, 'MT548')

    def CustomMappings(self):
        """ Override/add mappings"""
        ''''
        if self.source == 'SWIFT':
            self.set_color()
        elif self.source == 'ACM':
            self.set_color_from_settlement()
        '''
        pass

    def SetAttributes(self):
        super(FMT548, self).SetAttributes()
        self.CustomMappings()

    @staticmethod
    def GetColumnMetaData():
        """User can modify or extend the column metadata in this method and return it. This metadata will be used for creating columns for specific message type"""
        column_metadata = {}
        return column_metadata

    '''
    # Following is the sample code to add a new attribute for mapping e.g. Color
    def set_color(self):
        try:
            self.__color = self.python_object.TRADDET.Color.value()
        except Exception as e:
            self.notifier.DEBUG("Exception occurred in set_color : %s"%str(e))

    def set_color_from_settlement(self):
        try:
            if self.acm_obj.Color():
                self.__color = self.acm_obj.Color()
        except Exception as e:
            self.notifier.DEBUG("Exception occurred in set_color_from_settlement : %s"%str(e))

    def Color(self):
        """ Get the color attribute"""
        return self.__color
    '''

# ------------------------------ OVERRIDE START ---------------------------

    # Took base from module FMT54XInBase
    def UniquePair(self):
        """Lookup the unique identifier in the MT54X message and search for the specific settlement.
        If customization done for tag 20C in 540,541,542,543 outgoing then this method has to override
         in order to identify the settlement number"""
        pair_object = None
        if self.Type() in ['MT548']:
            #settlement_num = self.Identifier()
            if self.Identifier():
                import FSecuritySettlementOutUtils
                settlement_prefix = FSecuritySettlementOutUtils.get_settlement_reference_prefix()
                start_pos = len(settlement_prefix) if settlement_prefix else 0
                settlement_num = self.Identifier()[start_pos:-2]
                pair_object = acm.FSettlement[str(settlement_num)]
                if not pair_object: #keeping it backward compatible if outgoing send with old structure of tag 20 and
                    # then upgrade  to new version then below code required
                    settlement_num = self.Identifier().split('-')[0] if len(self.Identifier().split('-')) == 1 else \
                        self.Identifier().split('-')[1]
                    pair_object = acm.FSettlement[str(settlement_num)]
                if not pair_object:
                    import FSwiftWriterUtils
                    security_out_config = FSwiftWriterUtils.get_config_from_fparameter('FSecuritySettlementOut_Config')
                    include_tradeno_in_tag_20 = FSwiftMLUtils.incude_trade_no_in_tag20(security_out_config)
                    if FSwiftMLUtils.str_to_bool(include_tradeno_in_tag_20):
                        settlement_num = self.Identifier()[1:self.Identifier().find('T')-1]
                        pair_object = acm.FSettlement[str(settlement_num)]
                if not pair_object:
                    notifier.INFO('Settlement ' + str(settlement_num) + ' not found' + '\n' + self.SwiftData())
        return pair_object

# ------------------------------ OVERRIDE END -----------------------------


...

  FMT599Out
"""----------------------------------------------------------------------------
MODULE:
    FMT599Out

DESCRIPTION:
    OPEN EXTENSION MODULE
    FMT599 class for user customization.
    User can override the mapping defined in the base class FMTx99OutBase.
    This class can be populated using either swift data or an acm object.


VERSION: 3.6.3-0.5.6048
----------------------------------------------------------------------------"""

import FMTx99OutBase
import FSwiftWriterLogger
notifier = FSwiftWriterLogger.FSwiftWriterLogger('SecSetOut', 'FSecuritySettlementOutNotify_Config')

# ------------------------------ OVERRIDE START ---------------------------
import FSwiftWriterUtils
# ------------------------------ OVERRIDE END -----------------------------


class FMT599(FMTx99OutBase.FMTx99Base):

	def __init__(self, acm_obj, swift_obj):
		swift_message_type = 'MT599'
		super(FMT599, self).__init__(acm_obj, swift_message_type, swift_obj)
	# To override existing mappings use below methods to write your own logic
	"""
	narrative_79
	related_reference_21
	transaction_reference_20
	get_user_data
	"""
        # ------------------------------ OVERRIDE START ---------------------------
        # ------------------------------ AR-19833 ---------------------------------
	# formatter
	def _format_narrative_79(self, val):
           
            # Below code taken from FSwiftWriterUtils.format_narrative_retaining_user_fomatting(narrative)
            # Existing code has bug. As per Swift specifictaion max line 35 and each line can have 48 chars 
            # Also extended characters needs to be replaced before checking this limit.
            narrtive_text = val.get('narrative')
            narrtive_text = FSwiftWriterUtils.remove_non_swift_characters(narrtive_text)
            
            text = []
            narrative = narrtive_text.split('\n')
            formatted_narrative = ''
            try:
                for values in narrative:
                    values = values.strip('\r')
                    if values == "":
                        line = ['\n']
                    else:
                        line = FSwiftWriterUtils.split_text_on_character_limit(values, 48)
                    text.extend(line)
                formatted_text = ""
                for each_text in text:
                    formatted_text += each_text
                    if each_text != '\n':
                        formatted_text += '\n'
                formatted_narrative = '\n'.join(formatted_text.split('\n')[:35])
            except Exception as e:
                notifier.ERROR(
                    "Error in formatting narrative tag: %s. Sending original text " % (str(e)))
            if not formatted_narrative:
                formatted_narrative = narrtive_text
            return formatted_narrative
        # ------------------------------ AR-19833 ---------------------------------
        # ------------------------------ OVERRIDE END ---------------------------    


class FMT599MessageHeader(FMTx99OutBase.FMTx99OutBaseMessageHeader):

	def __init__(self, acm_obj, swift_msg_tags):
		self.acm_obj = acm_obj
		self.swift_msg_tags = swift_msg_tags
		self.mt_type = '599'
		super(FMT599MessageHeader, self).__init__(acm_obj, self.mt_type, swift_msg_tags)

	# To override existing mappings use below methods to write your own logic
	"""
	application_id
	service_id
	sender_logical_terminal_address
	session_number
	sequence_number
	input_or_output
	message_priority
	message_type
	receiver_logical_terminal_address
	delivery_monitoring
	non_delivery_notification_period
	service_identifier
	banking_priority_code
	message_user_reference
	validation_flag
	"""


class FMT599NetworkRules(FMTx99OutBase.FMTx99OutBaseNetworkRules):

	def __init__(self, swift_message_obj, swift_message, acm_obj):
		super(FMT599NetworkRules, self).__init__(swift_message_obj, swift_message, acm_obj)




...

  FMTCustomComparator
"""----------------------------------------------------------------------------
MODULE
    FMTCustomComparator

DESCRIPTION
    OPEN EXTENSION MODULE.
    Possible to define custom functions for comparisons
    in the Pairing and/or Matching logic. The calling of the function is defined
    in the corresponding FParameters, either FMTnnn_Pair or FMTnnn_Match,
    with function parameters. The function should follow the prototype
    func_name(their_object, our_object, arguments, attribute_to_check)

    # Sample method for customizing precision
    def myprecision(theirs, ours, compare_mode, tolerance = 0, attribute = None):
        is_match = False
        if attribute:
            # Override the tolerance from FParameter
            curr = getattr(theirs, 'Currency')()
            if curr == 'JPY':
                tolerance = 99
            their_value = getattr(theirs, attribute)()
            our_value = getattr(ours, attribute)()
            if abs(float(our_value) - float(their_value)) <= float(tolerance):
                is_match = True
        return is_match

VERSION: 3.6.3-0.5.6048
----------------------------------------------------------------------------"""

'''
# Sample method for customizing precision
def myprecision(theirs, ours, compare_mode, tolerance = 0, attribute = None):
    is_match = False
    if attribute:
        # Override the tolerance from FParameter
        curr = getattr(theirs, 'Currency')()
        if curr == 'JPY':
            tolerance = 99
        their_value = getattr(theirs, attribute)()
        our_value = getattr(ours, attribute)()
        if abs(float(our_value) - float(their_value)) <= float(tolerance):
            is_match = True
    return is_match
'''
# ------------------------------------- OVERRIDE START -------------------------------------------------

import FMTStandardComparator
import FSwiftReaderLogger

notifier = FSwiftReaderLogger.FSwiftReaderLogger('SwiftReader', 'FSwiftReaderNotifyConfig')

def bic_comparator_ndf(theirs, ours, compare_mode, arg=None, attribute=None, their_attribute=None):
    is_match = False
    our_value = None
    if attribute:
        if their_attribute:
            their_value = FMTStandardComparator.get_attribute_value(their_attribute, theirs, True, compare_mode)
        else:
            their_value = FMTStandardComparator.get_attribute_value(attribute, theirs, True, compare_mode)    
        our_value = FMTStandardComparator.get_attribute_value(attribute, ours, False, compare_mode)
        
        if our_value and ('NDFS' in our_value):
            is_match = True
            notifier.INFO(
                'bic_comparator_ndf : %s --> Theirs: %s Ours: %s isMatch: %r' % (attribute, their_value, our_value, is_match))
        else:
            is_match = FMTStandardComparator.bic_comparator(theirs, ours, compare_mode, arg, attribute, their_attribute)
    return is_match

# ------------------------------------- OVERRIDE END ---------------------------------------------------    

...

  FMTHooks
"""----------------------------------------------------------------------------
MODULE:
    FMTHooks

DESCRIPTION:
    OPEN EXTENSION MODULE
    This module provides extension points for user customization at the entry
    point of the message processing, to allow for detailed filtering and even
    modification of the incoming message, and at the two points before and after
    the pairing and the matching functionality

FUNCTIONS:
    on_entry(mt_object):
        a) Provision to override the FParameters FMTnnn_Config
        b) Option to ignore certain MT message types.
        Since the available object is the incoming MT message, it is possible
        to do direct Swift attribute controls and checks.
        Returns the resulting mt_object.

    message_entry_hook(swift_data, param='IncomingMessage'):
        Provision to override the swift data before any processing takes place.
        Returns swift message object in swift message format.

    pre_pair(mt_object):
        method to override the default pairing logic to identify an object in
        the database. Input is the corresponding MT class object which has
        various access methods to allow the user to write the logic.
        If you do not want any further (default) pairing logic after the
        pre_pair (you have established that there is no suitable pair) you can
        raise an exception, and the processing will be stopped, and the BPR will
        land in the Unpaired state.
        Returns the resulting mt_object.

    post_pair(mt_object, paired_objects):
        Method to enhance the default pairing logic.
        Input is the MT class object and paired confirmations/settlements if found.
        User can add additional checks or adjustments here, for example logic
        to choose when more than one object is paired.
        Returns the resulting mt_object

    pre_match(their_mt_object, our_mt_object):
        User specific logic to be performed just before the matching functionality.
        Return a tuple with possibly modified their_mt_object and our_mt_object.

    post_match(their_mt_object, our_mt_object, cmp_success, cmp_result):
        User specific logic for adding functionality post matching.
        Returns a tuple (cmp _success, cmp_result) where cmp_success (in and out)
        is a Boolean and cmp_result is a dictionary of tuples (their, our).
        E.g. the cmp_result could be { "amount":("3000","4000") }

    post_processing_before_commit(swift_message, commit_dict):
        Customisation only specific to MT535-
        User specific logic for changing input commit_dict
        The dictionary of trades and instruments for a given ISIN before commit are provided for any changes to be done
        Returns dict consisting of key as ISIN and tuple of trade, instrument for the respective ISIN.

    trigger_reconciliation_flow_extension(swift_message, safekeeping_account_number):
        Customisation only specific to MT535-
        User specific logic for determining whether reconciliation flow should be triggered.
        Input : swift_message to infer the incoming message,
                safekeeping_account_number to infer the account number from the incoming message
                for determining account and its party linked
        Function should return tuple: boolean value 'True' and party object to which message should be linked,
        if user wants reconciliation flow to be triggered.
        Function should return tuple: boolean value 'False' and party_object = None,
        if user wants trade creation flow to be triggered


VERSION: 3.6.3-0.5.6048
----------------------------------------------------------------------------"""
import FSwiftReaderLogger, traceback
SWIFT_FTP_KEY = 'YFIH3304'

notifier = FSwiftReaderLogger.FSwiftReaderLogger('SwiftReader', 'FSwiftReaderNotifyConfig')

# ---------------------------- OVERRIDE START ----------------------------
import FSwiftMLUtils
# ---------------------------- OVERRIDE END ------------------------------

def on_entry(mt_object):
    """
    # Sample to change the pairing attribute list/matching attribute list/eligibility query
    # If want to compare attribute with multiple attributes having possibility of OR condition, then use CMP_OR as mentioned below
    mt_type = mt_object.Type()
    if mt_type == 'MT123':
        if mt_object.Counterparty() == 'XYZ':
            setattr(mt_object.config_param, 'Pair', "{'Amount':{'CMP_OR':['AttributeToCompareWith_1', 'AttributeToCompareWith_2',...], 'CMP_FUNC':'myprecision','ARG':'100','LEVEL':'M'}, 'ValueDate':{'LEVEL':'O'}}")
            setattr(mt_object.config_param, 'EligibilityQuery', 'MyEligibility')
            setattr(mt_object.config_param, 'Match', "{'Amount':{'CMP_OR':['AttributeToCompareWith_1', 'AttributeToCompareWith_2',...], 'CMP_FUNC':'myprecision','ARG':'100','LEVEL':'M'}, 'ValueDate':{'LEVEL':'O'}}")
    return mt_object
    # Sample to ignore message
    mt_type = mt_object.Type()
    if mt_type == 'MT456':
        return None
    elif mt_type == 'MT123' and mt_object.Counterparty() == 'XYZ':
        return None
    """
    return mt_object


def message_entry_hook(swift_data, param='IncomingMessage'):
    ''' User can override the swift data before any processing takes place.  '''

    """If user does not want this message to be processed for any specific reason, then this extension point should return None"""
    '''if param == 'AckNack':
        return swift_data
    if param == 'IncomingMessage':
        return swift_data
    '''
    # ---------------------------- OVERRIDE START ----------------------------
    ret_val = swift_data
    try:
        mt_type = ''
        mt_type = FSwiftMLUtils.get_mt_type_from_swift(swift_data)
        if mt_type == 'MT535':
            import CustodySystemEuroClearInHoldingPositionUtils
            msg_id = CustodySystemEuroClearInHoldingPositionUtils.get_message_identifier_from_message(swift_data)
            print("CustodySystemEuroClearInHoldingPosition: Processing MT535 with Sender's Message Reference {}.".format(msg_id))
            success_result, failed_result, process_log = CustodySystemEuroClearInHoldingPositionUtils.process_swift_data(swift_data)
            ret_val = None  # Do not process this message in SwiftReader
            if success_result:
                print('CustodySystemEuroClearInHoldingPosition: Instrument with ISIN {} updated in ADS.'.format(
                    ','.join(success_result)))

            if failed_result:
                print('CustodySystemEuroClearInHoldingPosition: No instrument with ISIN {} found in ADS.'.format(
                    ','.join(failed_result)))
            
            if process_log:
                print(process_log)
        elif mt_type == 'MT950':
            import IRSCitynetMT950InUtils
            msg_id = IRSCitynetMT950InUtils.get_message_identifier_from_message(swift_data)
            print('IRSCitynetMT950In: Processing MT950 with Transaction Reference Number {}.'.format(msg_id))
            success_result, failed_result, process_log = IRSCitynetMT950InUtils.process_swift_data(swift_data)
            ret_val = None  # Do not process this message in SwiftReader
            if success_result:
                print('IRSCitynetMT950In: Account number {} updated with closing balance in ADS.'.format(','.join(success_result)))

            if failed_result:
                print('IRSCitynetMT950In: Account number {} not found in ADS.'.format(','.join(failed_result)))
                
            if process_log:
                print(process_log)

    except ImportError as impErr:
        print('Error in FMTHooks.message_entry_hook {}'.format(impErr))
    except Exception as err:
        print('Exception in FMTHooks.message_entry_hook {}'.format(err))
        print(traceback.print_exc())
        ret_val = swift_data
    return ret_val
    # ---------------------------- OVERRIDE END ------------------------------


def pre_pair(mt_object):
    """ User specific logic to find the paring object. If object is determined then that will be used for pairing"""
    return ''


# ---------------------------- OVERRIDE START ----------------------------------
def post_pair(mt_object, paired_objects):
    """  User specific logic for additional checks or adjustments"""
    pair_object = None
    if len(paired_objects) == 1:
        pair_object = paired_objects[0]
        notifier.INFO('Selecting object %s with oid %d for pairing'%(pair_object.Class().Name(), pair_object.Oid()))
        
    if len(paired_objects) > 1:
        notifier.INFO('Customization : More than one object found for pairing. Selecting one of them')
        for eligible_object in paired_objects:
            if FSwiftMLUtils.get_business_process(eligible_object) is None:
                pair_object = eligible_object
                notifier.INFO('Selecting object %s with oid %d for pairing'%(pair_object.Class().Name(), pair_object.Oid()))
                break        
    return pair_object
# ---------------------------- OVERRIDE END -----------------------------------


def pre_match(their_mt_object, our_mt_object):
    """ User specific logic to be performed just before matching functionality"""
    return their_mt_object, our_mt_object


def post_match(their_mt_object, our_mt_object, cmp_success, cmp_result):
    """ User specific logic for adding functionality post matching. Returns tuple (match_success, cmp_result)"""
    return cmp_success, cmp_result


def eligibility_extension(eligible_objects, mt_object):
    """ User specific logic for filtering eligible objects for pairing using incoming message"""
    return eligible_objects


def eligibility_query_extension(eligibility_query_list, mt_type, mt_object):
    '''User specific logic for extending the existing eligibility query

    :param eligibility_query_list: list of eligibility query
    :param mt_type: swift mt type
    :param mt_object: object of message specific base class
    :return: list of eligibility query

    '''
    import acm
    import FSwiftMLUtils
    if mt_type == 'MT300':
        query = acm.CreateFASQLQuery(acm.FConfirmation, 'AND')
        node = query.AddOpNode('AND')
        if FSwiftMLUtils.get_acm_version() < 2020.1:
            node.AddAttrNodeNumerical('Documents.SwiftMessageType', '300', '300')
        else:
            node.AddAttrNodeString('Documents.SwiftMessageType', '300', 'RE_LIKE_NOCASE')

        node.AddAttrNodeEnum('Status', ['Pending Matching'])
        node.AddAttrNodeEnum('Type', 'Cancellation').Not(True)
        # ------------------------------------- OVERRIDE START ---------------------
        
        # ------------------------------------- AR-25631 ---------------------------
        # FX NDF MT300 Inbound - Pairing is not working for fixing NDF confirmation
        if mt_object.SettlementRateSource() is None:
            node.AddAttrNodeUTCTime('trade.valueDay', mt_object.ValueDate(), mt_object.ValueDate())
        # ------------------------------------- AR-25631 ---------------------------
        
        # ------------------------------------- OVERRIDE END ------------------------
        storedQuery = acm.FStoredASQLQuery()
        storedQuery.Query(query)

        if storedQuery:
            eligibility_query_list = []
            eligibility_query_list.append(storedQuery)

    return eligibility_query_list


def post_processing_before_commit(swift_message, commit_dict):
    """Customisation only specific to MT535
     The dictionary of trades and instruments for a given ISIN before commit are provided for any changes to be done"""
    # sample code to set the counterparty is as show below
    '''
    import acm
    key = commit_dict.keys()[0]
    val = commit_dict[key]
    if not val[0].Counterparty():
        val[0].Counterparty(acm.FParty['____'])
    commit_dict[key] = val
    '''
    return commit_dict


def trigger_reconciliation_flow_extension(swift_message, safekeeping_account_number):
    """
    Customisation only specific to MT535-
    User specific logic for determining whether reconciliation flow should be triggered.
    Input : swift_message to infer the incoming message,
            safekeeping_account_number to infer the account number from the incoming message
            for determining account and its party linked
    Function should return tuple: boolean value 'True' and party object to which message should be linked,
    if user wants reconciliation flow to be triggered.
    Function should return tuple: boolean value 'False' and party_object = None,
    if user wants trade creation flow to be triggered
    """
    import acm
    flag = None
    party_object = None
    """
    #Ex:
    flag = True

    if flag:
        party_name = "Goldman Sachs London"
        party_object = acm.FParty[party_name]
    """

    return flag, party_object


def statement_message_validation_check(settlement_obj, statement_line, statement_line_obj, cmp_success=None):
    """function to check that settlement_obj need to process for MT950 message
    settlement_obj : acm object of settlement or some time None in case if not paired with any settlement object
    statement_line : line correspond to settlement in statement
    statement_line_obj : Object of statement line
    cmp_success : True/False depend on matching result
    """

    '''
    
    import acm
    write your logic
    '''
    return True


def alter_external_object(external_object):
    """
    This function lets you specify the attributes on the FExternalObject and the linked FCustomTextObject
    before it is committed to database.
    :param external_object: FExternalObject infant object
    :return: FExternalObject
    e.g.
    if external_object.Settlement():
        parent_owner = external_object.Settlement().Owner()
    elif external_object.Confirmation():
        parent_owner = external_object.Confirmation().Owner()
    else:
        parent_owner = acm.FUser['ARENASYS']
    """
    import acm
    parent_owner = None
    if parent_owner:
        external_object.Owner(parent_owner)
        f_custom_text_object = external_object.Data()
        f_custom_text_object.Owner(parent_owner)

    return external_object


...

  FMTUtils

from builtins import str
from builtins import range
import FSwiftOperationsAPI
import acm
import FCashOutUtils
import FFXMMConfirmationOutUtils
import FSecuritySettlementOutBase
import FSecuritySettlementOutUtils
from FSecuritySettlementOutBase import FSecuritySettlementOutBase
from FSettlementEnums import RelationType
import FSwiftWriterLogger


# --------------------------------- Common_Funtions -------------------------------------------
def isRTGSNetwork(acm_obj):
    if (acm_obj.AcquirerAccountSubNetworkName() == acm_obj.CounterpartyAccountSubNetworkName() == "RTGS"):
        return True
    return False

def isCNHCLSNetwork(acm_obj):
    if (acm_obj.AcquirerAccountSubNetworkName() == acm_obj.CounterpartyAccountSubNetworkName() == "CNH CLS"):
        return True
    return False
        
def IsNet(acm_obj):
    if acm_obj.RelationType() in (RelationType.AD_HOC_NET, RelationType.NET):
        return True
    return False

def isAccountTransfer(settlement):
    trade = getNettedTradefromSettlement(settlement)
    isAccountTransfer = False
    if trade:
        if trade.Instrument().InsType() == 'Curr' and trade.Type() == 'Account Transfer':
            isAccountTransfer = True
    return isAccountTransfer

def getLeastNetTrade(acm_obj):
    children = acm_obj.Children()
    children = [child for child in children if child.Trade() != None]
    if len(children) == 0:
        return None
    return min(children, key = lambda child: child.Trade().Oid())

def getNettedTradefromSettlement(acm_obj):
    trade = acm_obj.Trade()
    if not acm_obj.Trade():
        if IsNet(acm_obj):
            settle = getLeastNetTrade(acm_obj)
            trade = settle.Trade()
    return trade

def isLoan(acm_obj):
    trade = acm_obj.Trade()
    trade = getNettedTradefromSettlement(acm_obj)
    if trade.Premium() < 0:
        return True
    return False

def _get_paymentMethod_fx(acm_obj):
    return acm_obj.Trade().AdditionalInfo().Payment_Method_FX()
        
def isFXAddInfoPaymentPVP(trade):
    if trade.AdditionalInfo().Payment_Method_FX() == 'PvP':
        return True
    else:
        if (trade.Instrument().InsType() == "Curr" and trade.ContractTrdnbr() != trade.ConnectedTrdnbr() and trade.TradeProcessesToString() == "Swap Far Leg" and trade.ConnectedTrade()):
            if trade.ConnectedTrade().AdditionalInfo().Payment_Method_FX() == 'PvP':
                return True
        return False

def represent_amount_in_four_digits(amount):
    '''
        1. take the rightmost non zero digit.
        2. attach 3 digits to the left of it
        3. If there are no digits left then attach 0 to the left till the length is 4
        4. return amount_part of length 4
        Error code T22
    '''
    amount_part = []
    got_rightmost_non_zero_digit = False
    for each_char in reversed(amount):
        if each_char not in ['0', '.'] and not got_rightmost_non_zero_digit:
            amount_part.insert(0, each_char)
            got_rightmost_non_zero_digit = True
        elif got_rightmost_non_zero_digit and each_char != '.':
            amount_part.insert(0, each_char)
    while len(amount_part) < 4:
        amount_part.insert(0, '0')
    return ''.join(amount_part[-4:])

def isFXTrade(trade):
    if trade.AdditionalInfo().Payment_Method_FX():
        if trade.IsFxSpot() or trade.IsFxForward() or trade.IsFxSwap():
            return True
        else:
            return False
            
def isDepositLoanTrade(trade):
    #if trade.AdditionalInfo().Payment_Method_MM():
    if trade.Instrument().InsType() == 'Deposit':
        return True
    else:
        return False

def isCashPaymentTrade(trade):
    if trade.Type() == 'Normal' and trade.Premium() == 0.0 and trade.Price() == 0.0:
        return True
    else:
        return False

def isSettlementUSStyle(acm_obj):
    if acm_obj.CounterpartyAccountRef().CorrespondentBank().Country() == 'U.S.A.':
        return True
    else:
        return False
            
def convertDotToCommaSeparator(amount):
    amount = str("{0:.2f}".format(abs(amount)))
    amount = amount.replace(".", ",")
    return amount
        
def get_acquirer_intermediary_details(settlement):
    """ Method to return acquirer intermediary details from given settlement """
    party = settlement.AcquirerAccountRef().CorrespondentBank2()
    party_account = settlement.AcquirerAccountRef()
    return FCashOutUtils.get_party_details(party, party_account, 'INTERMEDIARY')
        
def get_instrument_leg_type(acm_obj):
    '''
    Check the leg type of the instrument.
    :param confirmation:
    :return: (str) : type of leg
    '''
    assert acm_obj.Trade().Instrument().Legs(), "The instrument referenced by the trade referenced by the " \
                                                     "confirmation has no legs"
    leg = acm_obj.Trade().Instrument().Legs().First()
    return  leg.LegType()
    
def get_reset_from_cashflow(acm_obj, cash_flow_type):
    '''
    Get the reset for the Confirmation from the cash flow
    :param confirmation: Confirmation acm object for the trade.
    :return reset(acm Reset object): reset for the cash flow of the Confirmation.
    '''
    reset = None
    cash_flow = get_cash_flow(acm_obj, cash_flow_type)
    if cash_flow:
        reset = cash_flow.Resets()[0]
    return reset

def get_cash_flow(acm_obj, cash_flow_type=None):
    '''
    Get cash flow for the confirmations with given type
    :param confirmation:
    :param cash_flow_type:
    :return:
    '''
    leg = acm_obj.Trade().Instrument().Legs().First()
    selection = acm.FCashFlow.Select('leg = %d and cashFlowType = "%s"' % (leg.Oid(), cash_flow_type))
    if (selection.Size() > 0):
        return selection.SortByProperty('StartDate').First()
    return None
    
def get_interest_rate(acm_obj):
    '''
    Get the interest rate for the deposit loan, Fix interest rate or (float + spread)
    :param Confirmation: Confirmation acm object for the trade.
    :return: (Float): interest_rate
    '''
    try:
        #from FOperationsEnums import LegType, SettleType, ExerciseType, BarrierOptionType,\
        #    ExoticEventType, BarrierMonitoring,CashFlowType
        LegType = FSwiftOperationsAPI.GetLegTypeEnum()
        CashFlowType = FSwiftOperationsAPI.GetCashFlowTypeEnum()
    except:
        pass
    interest_rate = 0.0 
    leg_type = get_instrument_leg_type(acm_obj)
    if leg_type == LegType.FLOAT:
        reset = get_reset_from_cashflow(acm_obj, CashFlowType.FLOAT_RATE)
        if reset:
            float_rate = reset.FixingValue()
            if float_rate:
                cf = get_cash_flow(acm_obj, CashFlowType.FLOAT_RATE)
                spread_rate = cf.Spread()
                interest_rate = float(float_rate) + float(spread_rate)
    else:
        cash_flow = get_cash_flow(acm_obj, CashFlowType.FIXED_RATE)
        if cash_flow:
            interest_rate = cash_flow.FixedRate()
    if acm.Operations.IsValueInfNanOrQNan(interest_rate):
        interest_rate = 0.0

    return interest_rate

def get_exchange_rate(acm_obj):
    rate = ''
    if not acm_obj.IsKindOf(acm.FConfirmation):
        trade = getNettedTradefromSettlement(acm_obj)
    else:
        trade = acm_obj.Trade()
    if trade:
        rate = trade.Price()
    return rate

def replaceCNHtoCNY(curr):
    if str(curr) ==  'CNH':
        return True
    return False

# Swift MT54x messages common custom
def get_party_95_option(dummyPartyDetails=None):
    condition = True
    if dummyPartyDetails:
        if dummyPartyDetails.At('qualifier') in ['BUYR', 'SELL']:
            return 'P'
        elif dummyPartyDetails.At('datasourcescheme') != '':
            return 'R'
    if condition:
        return 'P'
    else:
        return 'C'

def get_party_safekeeping_97_option ():
    condition = True
    if condition:
        return 'A'
    else:
        return 'B'

# ------------------ settlement parties -----------------------
"""
Copied from Base to add some custom logic.
"""
def settlement_parties_custom(acm_obj, swift_obj, party_details_list, multiplePartyDetails):
    notifier = FSwiftWriterLogger.FSwiftWriterLogger('SecSetOut', 'FSecuritySettlementOutNotify_Config')
    val_list = []
    securitySettlementOutBaseObj = FSecuritySettlementOutBase(acm_obj, swift_obj)
    party_safekeeping_option = get_party_safekeeping_97_option()
    #Custom Code
    for partyDetails in multiplePartyDetails:
        val_dict = {}
        each_block = {}
        for item in party_details_list:
            if item not in ['PARTY_SAFEKEEPING_OPTION', 'PARTY_OPTION']:
                item_getter_cmd = 'FSecuritySettlementOutUtils.get_' + item.lower() + '(partyDetails)'
                each_block[item] = eval(item_getter_cmd)
            else:
                party_option = get_party_95_option(partyDetails)
                each_block['PARTY_SAFEKEEPING_OPTION'] = party_safekeeping_option
                each_block['PARTY_OPTION'] = party_option
        #Custom Code
        if not (isSettlementUSStyle(acm_obj)) and not (acm_obj.CounterpartyAccountRef().AdditionalInfo().Set_CID()) and\
            (each_block['PARTY_QUALIFIER'] in ['BUYR', 'SELL']):
                continue
                
        if each_block and each_block['PARTY_OPTION'] not in ['P','C','Q','R']:
            notifier.WARN("Option %s is not supported for tag %s. Mapping default option: P" %
                            (each_block['PARTY_OPTION'], 'Party_95a'))
            each_block['PARTY_OPTION'] = 'P'
        #Custom Code
        if acm_obj.CounterpartyAccountRef().NationalClearingCode() and \
            each_block['PARTY_QUALIFIER'] in ['SELL', 'BUYR']:
            each_block['PARTY_OPTION'] = 'R'
        
        if each_block['PARTY_OPTION'] == 'P':
            val_dict['PARTY_P'] = securitySettlementOutBaseObj.settlement_party_95P(each_block)
            
        if each_block['PARTY_OPTION'] == 'C':
            val_dict['PARTY_C'] = securitySettlementOutBaseObj.settlement_party_95C(each_block)
            
        if each_block['PARTY_OPTION'] == 'Q':
            val_dict['PARTY_Q'] = securitySettlementOutBaseObj.settlement_party_95Q(each_block)
            
        if each_block['PARTY_OPTION'] == 'R':
            val_dict['PARTY_R'] = securitySettlementOutBaseObj.settlement_party_95R(each_block)
            
        #Custom Code
        if (each_block['PARTY_QUALIFIER'] != "PSET" and each_block['PARTY_OPTION'] == 'P') or \
            ((each_block['PARTY_QUALIFIER'] not in ['BUYR', 'SELL']) and (each_block['PARTY_OPTION'] == 'R')):
            if each_block and each_block['PARTY_SAFEKEEPING_OPTION'] not in ["A"]:
                notifier.WARN("Option %s is not supported for tag %s. Mapping default option: A" %
                                (each_block['PARTY_SAFEKEEPING_OPTION'], 'SafekeepingAccount_97a'))
                each_block['PARTY_SAFEKEEPING_OPTION'] = "A"
            if each_block['PARTY_SAFEKEEPING_OPTION'] == "A":
                if isSettlementUSStyle(acm_obj):
                    if (each_block['PARTY_SAFEKEEPING_ACCOUNT'] or each_block['PARTY_PROPRIETARY_CODE']):
                        val_dict['SafekeepingAccount_A'] = self.party_safekeeping_account_97A(each_block)
        val_list.append(val_dict)
    return val_list

"""
Copied from Base to remove for some custom logic.
"""
def set_agent_details(qualifier, account, details):
    bic = ''
    party = ''
    partyproprietarycode = ''
    dss = ''
    safekeepingaccount = ''
    if account.CorrespondentBank2():
        if account.DataSourceScheme2():
            partyproprietarycode = account.Account()
            dss = account.DataSourceScheme2().Alias()
        else:
            safekeepingaccount = account.Account()
            if account.Bic():
                bic = account.Bic().Alias()
        party = account.CorrespondentBank()
    elif account.CorrespondentBank():
        if account.DataSourceScheme():
            partyproprietarycode = account.Account()
            dss = account.DataSourceScheme().Alias()
        else:
            safekeepingaccount = account.Account()
            if account.NetworkAlias():
                bic = account.NetworkAlias().Alias()
        party = account.CorrespondentBank()
    partyInfo = FSecuritySettlementOutUtils.get_party_info(qualifier, bic, party, partyproprietarycode, dss, safekeepingaccount)
    details.append(partyInfo)

'''
# This function is used to decide which bic is placed first for commonreference tag in MT messages tag22C, tag21
'''
def IsSenderFirst(senders_bic, receivers_bic):
    senders_bic   = senders_bic[0:4] + senders_bic[6:8]
    receivers_bic = receivers_bic[0:4] + receivers_bic[6:8]
    
    for i in range(6):
        charS = senders_bic[i]
        charR = receivers_bic[i]
        if charS.isdigit() and charR.isdigit():
            if charS == charR:
                pass
            elif charS < charR:
                return True
            elif charS > charR:
                return False
                
        elif charS.isdigit() and not charR.isdigit():
            return False
        elif not charS.isdigit() and charR.isdigit():
            return True
        elif not charS.isdigit() and not charR.isdigit():
            if charS == charR:
                pass
            elif charS < charR:
                return True
            elif charS > charR:
                return False
    
    return False
    
def Get_Common_Reference_22C(settlement):
    val=''
    senders_bic=receivers_bic=exchange_rate_part=None
    #Before  Upgrade it was :  if settlement.Amount > 0
    if settlement.Amount() > 0:
        senders_bic = acm.FAccount.Select01("party='%s' and name='%s'" % (settlement.Counterparty().Name(),settlement.CounterpartyAccName()),None)
        
        receivers_bic = acm.FAccount.Select01("party='%s' and name='%s'" % (settlement.Acquirer().Name(),settlement.AcquirerAccName()),None)
        #Upgrade Change
        if senders_bic and senders_bic.NetworkAlias():
            senders_bic=senders_bic.NetworkAlias().Name()
        else:
            senders_bic = None
        if receivers_bic and receivers_bic.NetworkAlias():
            receivers_bic= receivers_bic.NetworkAlias().Name()
        else:
            receivers_bic = None
        
    else:
        senders_bic = acm.FAccount.Select01("party='%s' and name='%s'" % (settlement.Acquirer().Name(),settlement.AcquirerAccName()),None)
        receivers_bic = acm.FAccount.Select01("party='%s' and name='%s'" % (settlement.Counterparty().Name(),settlement.CounterpartyAccName()),None)
        #Upgrade Change
        if senders_bic and senders_bic.NetworkAlias():
            senders_bic=senders_bic.NetworkAlias().Name()
        else:
            senders_bic = None
        if receivers_bic and receivers_bic.NetworkAlias():
            receivers_bic= receivers_bic.NetworkAlias().Name()
        else:
            receivers_bic = None
        
    exchange_rate= None
    trade = settlement.Trade()
    if trade:
        exchange_rate = str(trade.Price())
    if exchange_rate:  
        exchange_rate_part = represent_amount_in_four_digits(exchange_rate)
    if senders_bic and receivers_bic and exchange_rate_part:
        if IsSenderFirst(senders_bic, receivers_bic):
            val = senders_bic[0:4] + senders_bic[6:8] + exchange_rate_part + receivers_bic[0:4] + receivers_bic[6:8]
        else:
            val = receivers_bic[0:4] + receivers_bic[6:8] + exchange_rate_part + senders_bic[0:4] + senders_bic[6:8]
        return str(val)
    return val

def GetTag20Value(settNo):    
    tag20Value = str(settNo)
    if settNo > 999999:
        tag20Value = str(settNo)[-6:]
    return tag20Value

def format_message_version_number(message_version):
    if int(message_version) > 9:
        message_version = str(message_version)[-1]
    return message_version

def Get_Senders_Reference_20(prefix, settOrConfObj, mtType, IsConfirmation = False, IsSecuritySettlement = False):
    senders_reference = ""
    if prefix:
        val = GetTag20Value(settOrConfObj.Oid())
        message_version_number = format_message_version_number(FCashOutUtils.get_message_version_number(settOrConfObj))
        if IsConfirmation:
            senders_reference = '{}-{}-{}'.format(prefix, val, str(message_version_number))
        else:
            if IsSecuritySettlement:
                senders_reference = '{}-{}-{}'.format(prefix, val, str(message_version_number))
            else:
                senders_reference = '{}-{}-{}-{}'.format(prefix, val, str(message_version_number), mtType)
        return senders_reference
            
def Get_Message_User_Reference(settOrConfObj, mtType, IsConfirmation = False, IsSecuritySettlement = False):
    '''MUR is sent in the format FAC-SEQNBR of confirmation-VersionID'''
    prefix = ""
    prv_AccNetwork = present_AccNetwork = None
    if IsConfirmation:
        prefix = FFXMMConfirmationOutUtils.get_confirmation_reference_prefix()
    else:
        prefix = FCashOutUtils.get_settlement_reference_prefix()
    
    val = Get_Senders_Reference_20(prefix, settOrConfObj, mtType, IsConfirmation, IsSecuritySettlement)
    # Below condition added for CR29, JIRA 1923 for CLSNET
    #if IsConfirmation and settOrConfObj.Trade().AdditionalInfo().Payment_Method_FX() == 'CLSNET':
    if IsConfirmation:
        try:
            prv_AccNetwork = settOrConfObj.Trade().AdditionalInfo().Z_PrevAccNetwork()
            present_AccNetwork = settOrConfObj.Trade().AdditionalInfo().Z_Account_Network()
        except:
            prv_AccNetwork=None
            present_AccNetwork = None
        if present_AccNetwork == 'CLSNET':
            if prv_AccNetwork and not (prv_AccNetwork == 'CLSNET') \
                and settOrConfObj.EventType() == 'New Trade Cancellation' :
                    return "{108:%s}" % val 
            else:
                return "{103:CLN}"
        else:
            if prv_AccNetwork == 'CLSNET' and settOrConfObj.EventType() == 'New Trade Cancellation':
                return "{103:CLN}"
    return "{108:%s}" % val

def trade_AddInfo_to_receiver_info_72(acm_obj, trade_AddInfo):
    tag72 = []
    SwiftTag72  = ['SwiftSettleTag72_1', 'SwiftSettleTag72_2', 'SwiftSettleTag72_3', 'SwiftSettleTag72_4', 'SwiftSettleTag72_5', 'SwiftSettleTag72_6']
    for attr_name in SwiftTag72:
        attr_obj = getattr(trade_AddInfo, attr_name, None)
        if attr_obj():
            tag72.append(attr_obj())
    return tag72

def cptAccRef_AddInfo_to_receiver_info_72(settlement, settlement_CptAccRef_AddInfo):
    tag72 = []
    if settlement_CptAccRef_AddInfo.Ac_Tag72_1():
        tag72.append(settlement_CptAccRef_AddInfo.Ac_Tag72_1()[:35])
    if settlement_CptAccRef_AddInfo.Ac_Tag72_2():
        tag72.append(settlement_CptAccRef_AddInfo.Ac_Tag72_2()[:35])
    if settlement_CptAccRef_AddInfo.Ac_Tag72_3():
        tag72.append(settlement_CptAccRef_AddInfo.Ac_Tag72_3()[:35])
    if settlement_CptAccRef_AddInfo.Ac_Tag72_4():
        tag72.append(settlement_CptAccRef_AddInfo.Ac_Tag72_4()[:35])
        
    return tag72

# This funtion is used to get agreement details from Master Agreement instead of CounterParty -> Agreements 
def get_type_and_version_from_master_agreement(acm_obj):
    notifier = FSwiftWriterLogger.FSwiftWriterLogger('FIRDConfOut', 'FIRDConfirmationOutNotify_Config')
    agreement_standards_to_check_for = ["AFB", "DERV", "FBF", "FEOMA" , "ICOM", "IFEMA","ISDA"]
    val_dict = {}
    if acm_obj.Trade().AgreementLinks():
        for agreementlink in acm_obj.Trade().AgreementLinks():
            if agreementlink.MasterAgreement().DocumentType().Name() in agreement_standards_to_check_for:
                val_dict['type_of_agreement'] = agreementlink.MasterAgreement().DocumentType().Name()
            else:
                val_dict['type_of_agreement'] = "OTHER"
            for collateralAnnex in agreementlink.MasterAgreement().CollateralAnnexes():
                val_dict['agreement_date'] = collateralAnnex.ValidFrom()
                if collateralAnnex.Version():
                    val_dict['version_of_agreement'] = collateralAnnex.Version()
                else:
                    notifier.ERROR("Agreement %s with collateralAnnex %s does not have any version details" % (
                            agreementlink.MasterAgreement().Name(), collateralAnnex.Name()))
                break
            break
    else:
        notifier.ERROR("Trade %s is not linked to any master agreement" % (
            str(acm_obj.Trade().Oid())))
    return val_dict
        

...

  FSwiftFXMMConfirmationIn
"""----------------------------------------------------------------------------
MODULE:
    FSwiftFXMMConfirmationIn

DESCRIPTION:
    OPEN EXTENSION MODULE
    Business process state callbacks.

FUNCTIONS:
    For sample state xxx there are always the four standard extension points:
        condition_entry_state_xxx():
            To control if all the pre-requisites to performing the action and
            entering the state are defined.
        on_entry_state_xxx():
            Is the place to perform the action.
            For example, the on_ entry_state_matched is the place to set the
            confirmation status to Matched
        condition_exit_state_xxx():
            To control that all pre-requisites for performing the next action
            are fulfilled.
        on_exit_state_xxx():
             Is the place to reset values that you set in the state entry, if
             you are leaving the state to go backwards in the workflow.
             For example if you exit from the "Matched" state to go and re-pair,
             or to manually cancel, then you would want to remove the
             confirmation Matched status

VERSION: 3.6.3-0.5.6048
----------------------------------------------------------------------------"""
# --------------------------- OVERRIDE ------------------------------------

import acm
import FSwiftMLUtils
import FSwiftReaderLogger
import InterfaceSettingUtils

notifier = FSwiftReaderLogger.FSwiftReaderLogger('FXMMConfIn', 'FFXMMConfirmationInNotify_Config')
# --------------------------- OVERRIDE ------------------------------------

from FFXMMConfirmationInCallbacks import FFXMMConfirmationInCallbacks

fxMMConfInMsgCallbacks = FFXMMConfirmationInCallbacks()
# The context parameter is an instance of FBusinessProcessCallbackContext
# Conditions return True or False
# Name convention is
# 'condition_' + 'entry_'/'exit_' + state name in lowercase and underscore
def condition_entry_state_ready(context):
    return fxMMConfInMsgCallbacks.condition_entry_state_ready(context)

def condition_entry_state_paired(context):
    return fxMMConfInMsgCallbacks.condition_entry_state_paired(context)

def condition_entry_state_matched(context):
    return fxMMConfInMsgCallbacks.condition_entry_state_matched(context)

def condition_entry_state_unpaired(context):
    return fxMMConfInMsgCallbacks.condition_entry_state_unpaired(context)

def condition_entry_state_cancelled(context):
    return fxMMConfInMsgCallbacks.condition_entry_state_cancelled(context)

def condition_entry_state_difference(context):
    return fxMMConfInMsgCallbacks.condition_entry_state_difference(context)

def condition_entry_state_amended(context):
    return fxMMConfInMsgCallbacks.condition_entry_state_amended(context)

# Entry/Exit callbacks do not return anything
#
# Name convention is
# 'on_' + 'entry_'/'exit_' + state name in lowercase and underscore
#

def on_entry_state_ready(context):
    fxMMConfInMsgCallbacks.on_entry_state_ready(context)

def on_entry_state_paired(context):
    fxMMConfInMsgCallbacks.on_entry_state_paired(context)

def on_entry_state_matched(context):
    #context.Subject().Subject().Status('Matched')
    fxMMConfInMsgCallbacks.on_entry_state_matched(context)
        
    # --------------------------- OVERRIDE ------------------------------------
    try:
        if InterfaceSettingUtils.get_env_name() == 'HO':
            bpr = context.CurrentStep().BusinessProcess()
            conf_obj = FSwiftMLUtils.get_acm_object_from_bpr(bpr)
            trade = conf_obj.Trade()
            
            # Set trade status to BO-BO Confirmed
            try:
                acm.BeginTransaction()

                if trade.Status() == 'BO Confirmed':
                    trade.Status('BO-BO Confirmed')
                    FSwiftMLUtils.commit_and_retry(trade)
                    notifier.INFO("on_entry_state_matched: Setting trade %s status to BO-BO Confirmed"%(trade.Oid()))

                farLeg = trade.FxSwapFarLeg()
                if farLeg and farLeg.Status() == 'BO Confirmed':
                    farLeg.Status('BO-BO Confirmed')
                    FSwiftMLUtils.commit_and_retry(farLeg)
                    notifier.INFO("on_entry_state_matched: Setting trade %s status to BO-BO Confirmed"%(farLeg.Oid()))
                
                acm.CommitTransaction()
            except Exception as error:
                notifier.ERROR("Error occurred in on_entry_state_matched while setting trade status to BO-BO Confirmed: %s"%str(error))
                acm.AbortTransaction()
            
    except Exception as error:
        notifier.ERROR("Error occurred in on_entry_state_matched: %s"%str(error))
        notifier.DEBUG(str(error), exc_info=1)
    # --------------------------- OVERRIDE ------------------------------------    

def on_entry_state_unpaired(context):
    fxMMConfInMsgCallbacks.on_entry_state_unpaired(context)

def on_entry_state_cancelled(context):
    fxMMConfInMsgCallbacks.on_entry_state_cancelled(context)

def on_entry_state_difference(context):
    fxMMConfInMsgCallbacks.on_entry_state_difference(context)

def on_entry_state_amended(context):
    fxMMConfInMsgCallbacks.on_entry_state_amended(context)



...

  FSwiftMTCalculatorHook
"""-------------------------------------------------------------------------------
MODULE:
      FSwiftMTCalculatorHook

DESCRIPTION:
      This module is used to override the message type returned by FSwiftMTCalculator

FUNCTIONS:
    calculate_swift_message_type():
       Override this function to return customized mt type

VERSION: 3.6.3-0.5.6048

-------------------------------------------------------------------------------"""
import FSwiftMTCalculatorBase

# ------------------------------------- OVERRIDE START ---------------------
import acm
# ------------------------------------- OVERRIDE END -----------------------

class ConfirmationSwiftTypeCalculator(FSwiftMTCalculatorBase.ConfirmationSwiftTypeCalculatorBase):
    """ This class implements the attributes used in the message type calculator
        Override the following functions to provide your implementation optionally.
    """
    def __init__(self, acm_object):
        self._acm_object = acm_object
        super(ConfirmationSwiftTypeCalculator, self).__init__(acm_object)

    '''
    def Entitytype(self):
        return customized value

    def InstType(self):
        return customized value

    def UnderInst(self):
        return customized value

    def ExoticType(self):
        return customized value

    def Digital(self):
        return customized value

    def ExerciseType(self):
        return customized value

    def OpenEndStrip(self):
        return customized value

    def Reset(self):
        return customized value

    def ProdEntry(self):
        return customized value

    def IsCOV(self):
        return customized value

    def IsMX(self):
        return customized value
    '''

class SettlementSwiftTypeCalculator(FSwiftMTCalculatorBase.SettlementSwiftTypeCalculatorBase):
    """
        This class implements the attributes used in the message type calculator
        Override the following functions to provide your implementation optionally.


        When you migrate from MT messages to MX messages, it is recommended to choose the
        criteria to differentiate the two message types based on some generic logic e.g. date of
        creation of settlements. This helps to show the correct message types for existing MT and new MX settlements
        in Operations Manager. To achieve the MX message types you use the extension points
        like IsMXRtgsSAMOS, IsMXRtgsTarget2 and IsMXCBPRPlus and the following example shows how you can differentiate
        between MX and MT types based on settlement creation date.

        def IsMXRtgsSAMOS(self):
            import acm
            migration_date = acm.Time.DateFromYMD(2022,1,1) # Migrate to MX SAMOS messages staring 1st January 2022

            object_creation_time = self._acm_object.CreateTime()
            object_creation_date = acm.Time.DateFromTime(object_creation_time)

            is_settlement_created_after_migration = True if acm.Time.DateDifference(object_creation_date,migration_date) >= 0 else False

            return is_settlement_created_after_migration

    """
    def __init__(self, acm_object):
        self._acm_object = acm_object
        super(SettlementSwiftTypeCalculator, self).__init__(acm_object)

    '''
    def Amount(self):
        return customized value

    def SettlementCashAmount_541(self):
        return customized value

    def SettlementCashAmount_543(self):
        return customized value

    def CPType(self):
        return customized value

    def HasBIC(self):
        return customized value

    def Relation(self):
        return customized value

    def Status(self):
        return customized value

    def TARGET2(self):
        return customized value

    def EBA(self):
        return customized value

    def NotifyReceipt(self):
        return customized value

    def DeliveryType(self):
        return customized value

    def TradeType(self):
        return customized value

    def IsCOV(self):
        """ Valid return values : True or False """
        return customized value

    def IsMX(self):
        """ Valid return values : True or False """
        return customized value
    
    def IsThirdPartyFX(self):
        """ Boolean method to denote whether the trade is third party foreign exchange deal
        i.e ThirdPartyFX """
        return customized value
    
    def IsMXRtgsTarget2(self):
        """This function use to generate MX RTGS T2 messages. Valid return values : True or False """
        return customized value
        
    def IsLiquidityCashTransfer(self):
        """ This hook provides flexibility to user to restrict camt.050 message generation to certain
        set of liquidity credit transfers between accounts such as DCA2DCA, DCA2MCA etc. 
        When set to True (without specific conditions), camt.050 message would be generated for all liquidity credit transfers
        Valid return values : True or False """
        return customized value
        
    def IsMXRtgsSAMOS(self):
        """This function use to generate MX RTGS SAMOS messages. Valid return values : True or False """
        return customized value
    
    def IsMXCBPRPlus(self):
        """This function use to generate MX CBPR Plus messages. Valid return values : True or False """
        return customized value    
    '''

# ------------------------------------- OVERRIDE START ---------------------

def is_account_transfer(acm_obj):
    is_account_transfer = False
    settlement = acm_obj
    if settlement.Trade():
        if settlement.Trade().Instrument().InsType() == 'Curr' and settlement.Trade().Type() == 'Account Transfer':
            is_account_transfer = True
    return is_account_transfer    


def calculate_swift_message_type(acm_obj, message_type_from_mt_calculator):
    """This hook is called after FSwiftMTCalculator calculates the swift message type corresponding
    to the acm object. User can customize the swift message to be generated for an acm object from this
    hook."""
    """
    # Ex- For generating MT101 - 
    if message_type_from_mt_calculator in ['200', '202']:        
        if (acm_obj.Counterparty() and acm_obj.Counterparty().Name() == 'OUR_BANK') and (acm_obj.Currency() and acm_obj.Currency().Name() == 'USD'):        
            message_type_from_mt_calculator = '101'
            if acm_obj.RelationType() == 'Good Value':
                message_type_from_mt_calculator = '199'
            elif acm_obj.RelationType() == 'Cancellation':
                message_type_from_mt_calculator = '192'
    """

    if acm_obj.IsKindOf(acm.FSettlement):
        # For Account transfer always generate MT202 instead of MT200
        if message_type_from_mt_calculator == '200' and is_account_transfer(acm_obj):
            message_type_from_mt_calculator = '202'

        # For MT103 always generate MT202
        elif message_type_from_mt_calculator == '103':
            message_type_from_mt_calculator = '202'

    return message_type_from_mt_calculator

# ------------------------------------- OVERRIDE END ------------------------

# Override the following dictionary to alter the existing attributes.
# e.g. override_calculator_mapping = {'103':{'CPType':'Counterparty'}}
override_calculator_mapping = {}


...

  FSwiftParameters
""" Compiled: 2023-08-18 09:34:41 """

#__src_file__ = "extensions/swift/etc/templates/FSwiftParametersTemplate.py"
"""----------------------------------------------------------------------------
MODULE
    FSwiftParameter - Module with variables needed by the SWIFT framework

    (c) Copyright 2012,2022 FIS Group/Fidelity Information Services Front Arena AB. All rights reserved.

DESCRIPTION


DATA-PREP
    After customisation save this module as FSwiftParameters and restart
    the documentation ATS.

----------------------------------------------------------------------------"""

OPTIONS = {}

OPTIONS[103] = {'ORDERING_CUSTOMER':'A',
                'INTERMEDIARY_INSTITUTION':'A',
                'BENEFICIARY_CUSTOMER':'A',
                'ACCOUNT_WITH_INSTITUTION':'A',
                'SENDERS_CORRESPONDENT': 'A',
                'ORDERING_INSTITUTION':'A'}

OPTIONS[192] = {}

OPTIONS[199] = {}

OPTIONS[200] = {'ACCOUNT_WITH_INSTITUTION':'A',
                'INTERMEDIARY':'A'}

OPTIONS[202] = {'ACCOUNT_WITH_INSTITUTION':'A',
                'BENEFICIARY_INSTITUTION':'A',
                'SENDERS_CORRESPONDENT': 'A',
                'INTERMEDIARY':'A', 'ORDERING_INSTITUTION':'A'}
OPTIONS[210] = {'ORDERING_CUSTOMER':'C', 'ORDERING_INSTITUTION':'A',
                 'INTERMEDIARY':'A'}
OPTIONS[292] = {}

OPTIONS[299] = {}

OPTIONS[300] = {'PARTY_A':'A', 'PARTY_B':'A', 'SELL_RECEIVING_AGENT':'A',
                'BUY_RECEIVING_AGENT':'A', 'BUY_DELIVERY_AGENT':'A',
                'SELL_DELIVERY_AGENT':'A', 'SELL_BENEFICIARY_INSTITUTION':'A',
                'BUY_INTERMEDIARY':'A', 'SELL_INTERMEDIARY':'A',
                'REPORTING_PARTY' : 'A'}
OPTIONS[305] = {'PARTY_A':'A', 'PARTY_B':'A', 'ACCOUNT_WITH_INSTITUTION':'A',
                'SENDER_CORRESPONDENT':'A', 'INTERMEDIARY':'A',
                'REPORTING_PARTY' : 'A'}
OPTIONS[306] = {'PARTY_A':'A', 'PARTY_B':'A', 'SIP_PARTY_RECEIVING_AGENT':'A',
                'PAYOUT_RECEIVING_AGENT':'J','CALCULATION_AGENT':'A'}
OPTIONS[320] = {'PARTY_A':'A', 'PARTY_B':'A',
                'SIA_PARTY_A_INTERMEDIARY':'A',
                'SIA_PARTY_B_INTERMEDIARY':'A',
                'SIA_PARTY_A_RECEIVING_AGENT':'A',
                'SIA_PARTY_B_RECEIVING_AGENT':'A'}

OPTIONS[330] = {'PARTY_A':'A', 'PARTY_B':'A',
                'SIA_PARTY_A_RECEIVING_AGENT':'A',
                'SIA_PARTY_B_RECEIVING_AGENT':'A'}

OPTIONS[362] = {'PARTY_A':'A', 'PARTY_B':'A',
                'NAP_PARTY_A_RECEIVING_AGENT':'A',
                'NAP_PARTY_B_RECEIVING_AGENT':'A'}

OPTIONS[395] = {}

OPTIONS[540] = {'SETTLEMENT_DATETIME':'A', 'ACCOUNT':'A',
                'PARTY':'P', 'SAFEKEEPING_ACCOUNT':'A'}

OPTIONS[541] = {'SETTLEMENT_DATETIME':'A', 'ACCOUNT':'A',
                'PARTY':'P', 'SAFEKEEPING_ACCOUNT':'A'}

OPTIONS[542] = {'SETTLEMENT_DATETIME':'A', 'ACCOUNT':'A',
                'PARTY':'P', 'SAFEKEEPING_ACCOUNT':'A'}

OPTIONS[543] = {'SETTLEMENT_DATETIME':'A', 'ACCOUNT':'A',
                'PARTY':'P', 'SAFEKEEPING_ACCOUNT':'A'}

TERMS_CONDITIONS = '/FIDU/'

FAS = 'FAS'
FAC = 'FAC'

USED_MT_MESSAGES_SETTLEMENT = [(103, 'Yes'), (192, 'Yes'), (199, 'Yes'),
                               (200, 'Yes'), (202, 'Yes'), (292, 'Yes'),
                               (299, 'Yes'), (210, 'Yes'), (540, 'Yes'),
                               (541, 'Yes'), (542, 'Yes'), (543, 'Yes')]

USED_MT_MESSAGES_CONFIRMATION = [(300, 'Yes'), (305, 'Yes'),
                                 (306, 'Yes'), (320, 'Yes'),
                                 (330, 'Yes'), (362, 'Yes'), (395, 'Yes')]

MT_MANDATORY_FIELDS = {
                   300 : ['15A','20','22A', '22C','82A','87A','15B','30T','30V','36','32B','57A','33B'],
                   305 : ['20','21','22','22C','30','82A','31G','26F','32B','36','33B','37K','34A','57A'],
                   306 : ['15A','20','22A','22C','21N','12F','12E','17A','17F','22K','82A','87A','77H','15B','17V','30T','30X','29R','30F'],
                   320 : ['15A','20','22A','22B','22C','82A','87A','15B','17R','30T','30V','30P','32B','34E','37G','14D','15C','57A','15D'],
                   330 : ['15A','20','22A','22B','22C','82A','87A','15B','17R','30T','30V','38A','32B','37G','14D','15C','57A'],
                   362 : ['15A','20','22A','22C','23A','21N','30V','30P','82A','87A']
                    }

SWIFT_SUB_NETWORKS = ['EBA', 'TARGET2']

SWIFT_SERVICE_CODE = {'TARGET2':'TGT', 'EBA':'EBA'}

BANKING_PRIORITY = {'TARGET2':'NYNN', 'EBA':''}

NATIONAL_CLEARING_SYSTEM = {'Fedwire' : 'FW'}

ROUND_PER_CURR = {'EUR':2, 'USD':2, 'JPY':0, 'KRW':0, 'TRY':0, 'KWD':3, 'AED':2,
                  'ARS':2, 'AUD':2, 'BAM':2, 'BRL':2, 'BGN':2, 'CAD':2, 'CNY':2,
                  'CZK':2, 'DKK':2, 'GBP':2, 'HKD':2, 'HRK':2, 'HUF':2, 'ISK':2,
                  'INR':2, 'IDR':2, 'LVL':2, 'MYR':2, 'MXN':2, 'MXV':2, 'NZD':2,
                  'NOK':2, 'PHP':2, 'SAR':2, 'SGD':2, 'ZAR':2, 'SEK':2, 'CHF':2,
                  'TWD':2, 'THB':2}

USE_PARTY_FULLNAME = 0

SEPARATOR = 'newline'

CODEWORD_NEWLINE = 'codeword'

SWIFT_LOOPBACK = 0

SENDER_BIC_LOOPBACK    = ""

RECEIVER_BIC_LOOPBACK  = ""

dict_trans = {0: ' ', 1: ' ', 2: ' ', 3: ' ', 4: ' ',
5: ' ', 6: ' ', 7: ' ', 8: ' ', 9: ' ', 10: '\n',
11: ' ', 12: ' ', 13: '\r', 14: ' ', 15: ' ', 16: ' ',
17: ' ', 18: ' ', 19: ' ', 20: ' ', 21: ' ', 22: ' ',
23: ' ', 24: ' ', 25: ' ', 26: ' ', 27: ' ', 28: ' ',
29: ' ', 30: ' ', 31: ' ', 32: ' ', 33: ' ', 34: ' ', 35: ' ',
36: ' ', 37: ' ', 38: ' ',39: "'", 40: '(', 41: ')', 42: ' ', 43: '+',
44: ',', 45: '-', 46: '.', 47: '/', 48: '0', 49: '1', 50: '2', 51: '3',
52: '4', 53: '5', 54: '6',55: '7', 56: '8', 57: '9', 58: ':', 59: ';',
60: ' ', 61: '=', 62: ' ', 63: ' ', 64: '@', 65: 'A', 66: 'B', 67: 'C',
68: 'D', 69: 'E', 70: 'F', 71: 'G', 72: 'H', 73: 'I', 74: 'J', 75: 'K',
76: 'L', 77: 'M', 78: 'N', 79: 'O', 80: 'P', 81: 'Q', 82: 'R', 83: 'S',
84: 'T', 85: 'U', 86: 'V', 87: 'W', 88: 'X', 89: 'Y', 90: 'Z', 91: ' ',
92: '/', 93: ' ', 94: ' ', 95: ' ', 96: ' ', 97: 'a', 98: 'b', 99: 'c',
100: 'd', 101: 'e', 102: 'f', 103: 'g', 104: 'h', 105: 'i', 106: 'j',
107: 'k', 108: 'l', 109: 'm', 110: 'n', 111: 'o', 112: 'p', 113: 'q',
114: 'r', 115: 's', 116: 't', 117: 'u', 118: 'v', 119: 'w', 120: 'x',
121: 'y', 122: 'z', 123: ' ', 124: ' ', 125: ' ', 126: ' ',
127: ' ', 128: ' ', 129: ' ', 130: ' ', 131: ' ', 132: ' ',
133: ' ', 134: ' ', 135: ' ', 136: ' ', 137: ' ', 138: ' ',
139: ' ', 140: ' ', 141: ' ', 142: ' ', 143: ' ', 144: ' ',
145: ' ', 146: ' ', 147: ' ', 148: ' ', 149: ' ', 150: ' ',
151: ' ', 152: ' ', 153: ' ', 154: ' ', 155: ' ', 156: ' ',
157: ' ', 158: ' ', 159: ' ', 160: ' ', 161: ' ', 162: ' ',
163: ' ', 164: ' ', 165: ' ', 166: ' ', 167: ' ', 168: ' ',
169: ' ', 170: ' ', 171: ' ', 172: ' ', 173: ' ', 174: ' ',
175: ' ', 176: ' ', 177: ' ', 178: ' ', 179: ' ', 180: ' ',
181: ' ', 182: ' ', 183: ' ', 184: ' ', 185: ' ', 186: ' ',
187: ' ', 188: ' ', 189: ' ', 190: ' ', 191: ' ', 192: ' ',
193: ' ', 194: ' ', 195: ' ', 196: ' ', 197: ' ', 198: ' ',
199: ' ', 200: ' ', 201: ' ', 202: ' ', 203: ' ', 204: ' ',
205: ' ', 206: ' ', 207: ' ', 208: ' ', 209: ' ', 210: 'O',
211: 'O', 212: 'O', 213: 'O', 214: 'O', 215: ' ', 216: ' ',
217: 'U', 218: 'U', 219: 'U', 220: 'U', 221: 'Y', 222: ' ',
223: ' ', 224: 'a', 225: 'a', 226: 'a', 227: 'a', 228: 'a',
229: 'a', 230: ' ', 231: 'c', 232: 'e', 233: 'e', 234: 'e',
235: 'e', 236: 'i', 237: 'i', 238: 'i', 239: 'i', 240: ' ',
241: 'n', 242: 'o', 243: 'o', 244: 'o', 245: 'o', 246: 'o',
247: ' ', 248: ' ', 249: 'u', 250: 'u', 251: 'u', 252: 'u',
253: 'y', 254: ' ', 255: 'y'}

POPULATE_RELEASE_DAY = 0

city_dict = {'BUENOS AIRES' : 'ARBA',
             'VIENNA'      : 'ATVI',
             'MELBOURNE'   : 'AUME',
             'SYDNEY'      : 'AUSY',
             'BRUSSELS'    : 'BEBR',
             'SAO PAULO':'BRSP',
             'MONTREAL':'CAMO',
             'TORONTO':'CATO',
             'GENEVA':'CHGE',
             'ZURICH':'CHZU',
             'SANTIAGO':'CLSA',
             'BEIJING':'CNBE',
             'PRAGUE':'CZPR',
             'EUROPEAN CENTRAL BANK':'DECB',
             'FRANKFURT':'DEFR',
             'COPENHAGEN':'DKCO',
             'TALLINN':'EETA',
             'MADRID':'ESMA',
             'TARGET':'EUTA',
             'HELSINKI':'FIHE',
             'PARIS':'FRPA',
             'LONDON':'GBLO',
             'ATHENS':'GRAT',
             'HONG KONG':'HKHK',
             'BUDAPEST':'HUBU',
             'JAKARTA':'IDJA',
             'DUBLIN':'IEDU',
             'TEL AVIV':'ILTA',
             'MUMBAI':'INMU',
             'MILAN':'ITMI',
             'ROME':'ITRO',
             'TOKYO':'JPTO',
             'SEOUL':'KRSE',
             'BEIRUT':'LBBE',
             'COLOMBO':'LKCO',
             'LUXEMBOURG':'LULU',
             'MEXICO CITY':'MXMC',
             'KUALA LUMPUR':'MYKL',
             'AMSTERDAM':'NLAM',
             'OSLO':'NOOS',
             'NEW YORK FED':'NYFD',
             'NEW YORK STOCK EXCHANGE':'NYSE',
             'AUCKLAND':'NZAU',
             'WELLINGTON':'NZWE',
             'PANAMA CITY':'PAPC',
             'MANILA':'PHMA',
             'WARSAW':'PLWA',
             'LISBON':'PTLI',
             'BUCHAREST':'ROBU',
             'MOSCOW':'RUMO',
             'RIYADH':'SARI',
             'STOCKHOLM':'SEST',
             'SINGAPORE':'SGSI',
             'BRATISLAVA':'SKBR',
             'BANGKOK':'THBA',
             'ANKARA':'TRAN',
             'ISTANBUL':'TRIS',
             'TAIPEI':'TWTA',
             'CHICAGO':'USCH',
             'U.S. GOVERNMENT SECURITIES':'USGS',
             'LOS ANGELES':'USLA',
             'NEW YORK':'USNY',
             'HANOI':'VNHA',
             'JOHANNESBURG':'ZAJO'}

...

  FSwiftSecurityConfirmationIn
"""----------------------------------------------------------------------------
MODULE:
    FSwiftSecurityConfirmationIn

DESCRIPTION:
    OPEN EXTENSION MODULE
    Business process state callbacks.

FUNCTIONS:
    For sample state xxx there are always the four standard extension points:
        condition_entry_state_xxx():
            To control if all the pre-requisites to performing the action and
            entering the state are defined.
        on_entry_state_xxx():
            Is the place to perform the action.
            For example, the on_ entry_state_settled is the place to set the
            settlement status to Settled
        condition_exit_state_xxx():
            To control that all pre-requisites for performing the next action
            are fulfilled.
        on_exit_state_xxx():
             Is the place to reset values that you set in the state entry, if
             you are leaving the state to go backwards in the workflow.
             For example if you exit from the "Settled" state to go and re-pair,
             or to manually cancel, then you would want to remove the Settled
             status

VERSION: 3.6.3-0.5.6048
----------------------------------------------------------------------------"""
# --------------------------- OVERRIDE ------------------------------------

import FSwiftMLUtils
import FSwiftReaderLogger

import InterfaceSettingUtils

notifier = FSwiftReaderLogger.FSwiftReaderLogger('SecSetlConf', 'FSecuritySettlementInNotify_Config')
# --------------------------- OVERRIDE ------------------------------------

from FSecurityConfirmationInCallbacks import FSecurityConfirmationInCallbacks

securitySettlementConfMsgCallbacks = FSecurityConfirmationInCallbacks()

# The context parameter is an instance of FBusinessProcessCallbackContext
# Conditions return True or False
# Name convention is
# 'condition_' + 'entry_'/'exit_' + state name in lowercase and underscore
def condition_entry_state_ready(context):
    return securitySettlementConfMsgCallbacks.condition_entry_state_ready(context)

def condition_entry_state_paired(context):
    return securitySettlementConfMsgCallbacks.condition_entry_state_paired(context)

def condition_entry_state_matched(context):
    return securitySettlementConfMsgCallbacks.condition_entry_state_matched(context)

def condition_entry_state_unpaired(context):
    return securitySettlementConfMsgCallbacks.condition_entry_state_unpaired(context)

def condition_entry_state_difference(context):
    return securitySettlementConfMsgCallbacks.condition_entry_state_difference(context)

# Entry/Exit callbacks do not return anything
#
# Name convention is
# 'on_' + 'entry_'/'exit_' + state name in lowercase and underscore
#
def on_entry_state_ready(context):
    securitySettlementConfMsgCallbacks.on_entry_state_ready(context)

def on_entry_state_paired(context):
    securitySettlementConfMsgCallbacks.on_entry_state_paired(context)

def on_entry_state_matched(context):
    securitySettlementConfMsgCallbacks.on_entry_state_matched(context)
    # --------------------------- OVERRIDE ------------------------------------
    try:
        if InterfaceSettingUtils.get_env_name() == 'HO':
            bpr = context.CurrentStep().BusinessProcess()
            conf_obj = FSwiftMLUtils.get_acm_object_from_bpr(bpr)
            trade = conf_obj.Trade()
            
            # Set trade status to BO-BO Confirmed
            if trade.Status() == 'BO Confirmed':
                trade.Status('BO-BO Confirmed')
                FSwiftMLUtils.commit_and_retry(trade)
                notifier.INFO("on_entry_state_matched: Setting trade %s status to BO-BO Confirmed"%(trade.Oid()))
        
    except Exception as error:
        notifier.ERROR("Error occurred in on_entry_state_matched: %s"%str(error))
        notifier.DEBUG(str(error), exc_info=1)
    # --------------------------- OVERRIDE ------------------------------------    

def on_entry_state_unpaired(context):
    securitySettlementConfMsgCallbacks.on_entry_state_unpaired(context)

def on_entry_state_difference(context):
    securitySettlementConfMsgCallbacks.on_entry_state_difference(context)



...

  RunSwiftDataPrep
"""----------------------------------------------------------------------------
  RunSwiftDataPrep : Run initial and post data preparation scripts    
----------------------------------------------------------------------------"""

import acm

ael_variables = [
('modules', 'Modules ', 'string', None, None, 1, 0, '', None, True),
('context', 'Target context', 'string', acm.FExtensionContext.Select(''), acm.GetDefaultContext().Name(),
  1, 0, "Select the Context in which you want to install the Swift packages.", None, True)
]


def RunDataPrep(parameters):
    print ('Running data preparation scripts..')
    print ('Input parameters ', parameters)
    
    context = parameters.get('context', 'Standard')
    data_prep_module_names = [module.strip() for module in parameters.get('modules', '').split(',')]
    
    print ('Data preparation scripts to be run ', data_prep_module_names)    

    for data_prep_file in data_prep_module_names:
        try:
            imp_module = __import__(data_prep_file)
            imp_module.run_data_prep(context)
        except Exception as e:
            print ('Unable to load module ', data_prep_file)

    print ('Finished running data preparation scripts.')
    
def ael_main(parameters):
    RunDataPrep(parameters)





...

}

