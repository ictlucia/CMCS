#
# Front Arena exported extension module.
# source          ""
# timestamp (utc) "2023-06-20 10:19:41.9"
# ***** DO NOT EDIT! *****
#
name        "FFTPLibrary"
description "FFTPLibrary 2.0.7 Copyright 2009-2014 FIS FRONT ARENA"

groups {
}

decls[FParameters] {
}

clx FObject [FParameters] {
  FFTPAMBSettings =
  FFTP_APPLICATION_NAME=FFTPLib
  MB_MESSAGE_BODY_ONLY=FALSE
  MESSAGE_BROKER=
  MESSAGE_FILE_NAME=
  MESSAGE_PROPERTIES={'message_source':{'TYPE': '', 'VERSION': '', 'SOURCE':'', 'MESSAGE_TAG':'', 'FILE_DATA_TAG':'' }}
  MESSAGE_RECEIVER=FFTP_MESSAGE_RECEIVER
  MESSAGE_SENDER=FFTP_MESSAGE_SENDER


  FFTPLogSettings =
  LOGGING_LEVEL=DEBUG  # choose INFO, WARNING, ERROR, DEBUG
  NOTIFICATION_MEDIA=OFF  # choose  MAIL, MESSAGE, PRIME_LOG, PRIME_LOG_TRANSIENT, OFF
  NOTIFY_LEVEL=TRACK  # choose DEBUG, TRACK, SUCCESS, WARNING, ERROR
  NOTIFY_USER=
  SMTP_SERVER=
  USER_EMAIL=


  FFTPModeSettings =
  MODE=# AMB-DIR, AMB-FTP, AMB-SFTP, AMB-AMB, DIR-DIR, DIR-AMB, DIR-FTP, DIR-SFTP, FTP-FTP, FTP-AMB, FTP-DIR, FTP-SFTP, SFTP-SFTP, SFTP-AMB, SFTP-FTP, SFTP-DIR


  FFTPSettings =
  CERT_P12_OR_PFX_FILE_READ=
  CERT_P12_OR_PFX_FILE_WRITE=
  CERT_P12_OR_PFX_PASSWORD_READ=
  CERT_P12_OR_PFX_PASSWORD_WRITE=
  FFTP_APPLICATION_NAME=FFTPLib-SFTP
  FFTPLib_APPLICATION_NAME=FFTPLib-FTP
  FTP_TRANSACTION_LOG_PATH=
  POLL_INTERVAL=0
  POLL_RETRY=0
  POLL_TIMEOUT=0
  READ_HOST=
  READ_PASSWORD=
  READ_PORT=
  READ_USER=
  WRITE_HOST=
  WRITE_PASSWORD=
  WRITE_PORT=
  WRITE_USER=


  FFTPSystemSettings =
  FFTPLIBRARY_BUILD_DATE=08-Jun-2023
  FFTPLIBRARY_VERSION=2.0.7-0.0.1013
  TIME_INTERVAL=20


}

decls[FPythonCode] {
  "FFTPLibraryInstalledComponent" ( "installed component" ) "";
}

clx FObject [FPythonCode] {
  FFTPAMBOperations
"""--------------------------------------------------------------------
MODULE
    FFTPAMBOperations -  AMB operations like reading from AMB and writing to AMB database

DESCRIPTION
    This script handles the AMB operations.

VERSION: 2.0.7

--------------------------------------------------------------------"""

import os
import tempfile
import acm
import amb

import FFTPNotification
import FFTPConfig
import FFTPLibHooks
import FIntegrationUtils
from FFTPDIROperations import DIROperations
utilsobj= FIntegrationUtils.FIntegrationUtils()

logger = FFTPNotification.FFTPLogger('FFTPLibrary')

mode_config_param = None
message_file_name = ''
amb_connected = False
config_variables_obj = FFTPConfig.FTPConfigSingleton('FFTPLibrary')


def event_cb_reader(channel, event, arg):
    '''
    Call back function to read message from AMB for the subscribed subject
    Args:
          channel: Channel to get
          event:

    '''
    global message_file_name
    global amb_connected
    eventstring = amb.mb_event_type_to_string(event.event_type)
    if eventstring == 'Message':
        buf = amb.mbf_create_buffer_from_data(event.message.data_p)
        org_amb_message = buf.mbf_read()
        message_obj_type = type(org_amb_message)
        msg_subject = event.message.subject
        logger.DEBUG("Received amb message with subject: {}".format(msg_subject))
        msg_source = None
        source_tag = org_amb_message.mbf_find_object('SOURCE', 'MBFE_BEGINNING')
        if source_tag:
            msg_source = source_tag.mbf_get_value()
            logger.DEBUG("AMB message source is : {}".format(msg_source))
        mode_config_param = ''
        mb_message = ''
        if org_amb_message:
            read_mode = None
            write_mode = None
            file_path = None
            file_name = None
            temp_download = False
            process_msg = 1
            if len(arg) >= 2:
                write_source_lst, file_name, msg_subject_lst, temp_file_path, mode = arg[0], arg[1], arg[2], arg[3], \
                                                                                     arg[4]
                if write_source_lst and msg_subject_lst:
                    logger.DEBUG("Get the directory path for downloading amb message for TASK")
                    if msg_subject not in msg_subject_lst:
                        logger.DEBUG("Cannot process message as the message subject: {} not in subject list: {}".format(
                            msg_subject, msg_subject_lst))
                        process_msg = 0
                    else:
                        logger.INFO("Received amb message with subject {}.".format(msg_subject))
                        # write mode is dir
                        if mode: 
                            logger.DEBUG("Write mode is {}".format(mode.split('-')[1]))
                        if mode and mode.split('-')[1] == 'DIR':
                            if len(write_source_lst) == 1:
                                file_path = write_source_lst[0]
                            elif len(write_source_lst) > 1 and len(write_source_lst) == len(msg_subject_lst):
                                source_dict = dict(list(zip(write_source_lst, msg_subject_lst)))
                                file_path = source_dict.get(msg_subject, write_source_lst[0])
                        else:
                            file_path = temp_file_path
                        
                        if not mode:
                            if len(write_source_lst) == 1:
                                file_path = write_source_lst[0]
                                
            if (not file_path or not file_name):
                logger.DEBUG("Get the directory path for downloading amb message")
                config_param = FFTPConfig.Parameters('FFTPModeSettings')
                mode = getattr(config_param, 'MODE', '')
                mode_lst = FFTPConfig.string_as_list(mode)
                for each_mode in mode_lst:
                    if each_mode.split('-')[0] == 'AMB':
                        logger.DEBUG("Processing amb message for mode : {}".format(each_mode))
                        read_mode, write_mode = each_mode.split('-')
                        mode_config_param = FFTPConfig.Parameters('FFTPModeSettings_' + each_mode)
                        msg_file_name = message_file_name
                        read_source_obj = getattr(mode_config_param, 'READ_SOURCE', '')
                        read_source = FFTPConfig.string_as_list(read_source_obj)
                        write_source_obj = getattr(mode_config_param, 'WRITE_SOURCE', '')
                        write_source = FFTPConfig.string_as_list(write_source_obj)
                        temp_file_path = getattr(mode_config_param, 'TEMP_FILE_PATH', '')
                        logger.DEBUG("AMB  message file name is : {}".format(msg_file_name))
                        for source in read_source:
                            file_path = None
                            file_name = None
                            subject = source
                            if subject == msg_subject:
                                process_msg = 1
                                logger.INFO("Received amb message with subject {}.".format(msg_subject))
                                org_amb_message_str = org_amb_message.mbf_object_to_string()
                                # Apply export entry hook on amb message
                                amb_message_hook, destination_path = FFTPLibHooks.fftplibrary_export_entry(read_mode,
                                                                                                           write_mode,
                                                                                                           org_amb_message_str,
                                                                                                           org_amb_message,
                                                                                                           msg_subject=msg_subject,
                                                                                                           msg_source=msg_source)

                                logger.DEBUG("Applied fftplibrary_export_entry on amb message")
                                if type(amb_message_hook) == message_obj_type:
                                    org_amb_message = amb_message_hook
                                elif amb_message_hook and isinstance(amb_message_hook, str):
                                    org_amb_message = string_to_mbf_object(amb_message_hook)
                                else:
                                    org_amb_message = None

                                if org_amb_message:
                                    logger.DEBUG("Get the path for downloading amb message")
                                    file_name = msg_file_name
                                    if write_mode == 'DIR':
                                        if destination_path:
                                            file_path = destination_path
                                        if len(write_source) == 1:
                                            file_path = write_source[0]
                                        elif len(write_source) == len(read_source):
                                            source_dict = dict(list(zip(read_source, write_source)))
                                            file_path = source_dict[source]
                                    else:
                                        file_path = temp_file_path
                                        temp_download = True
                                    break
                                else:
                                    logger.WARN("Applied export entry hook, amb message is filtered")
                                    process_msg = 0
                        logger.DEBUG("Directory path for downloading amb message is {}".format(file_path))

            if file_path == None:
                process_msg = 0

            if process_msg:
                logger.DEBUG("Process amb message")
                file_path = os.path.join(file_path, msg_subject.replace('/', '_'))
                filename, file_extension = os.path.splitext(file_name)
                mb_message_body_only = ''
                entity_name = ''

                if mode_config_param:
                    mb_message_body_only = getattr(mode_config_param, 'MB_MESSAGE_BODY_ONLY', False)

                if not mb_message_body_only:
                    amb_config_param = FFTPConfig.Parameters('FFTPAMBSettings')
                    mb_message_body_only = getattr(amb_config_param, 'MB_MESSAGE_BODY_ONLY', False)
                    
                logger.DEBUG("Value of FParameter MB_MESSAGE_BODY_ONLY is {}".format(mb_message_body_only))

                if mb_message_body_only and str(mb_message_body_only).upper() != 'FALSE':
                    if not str(mb_message_body_only).startswith('//'):
                        logger.ERROR("Incorrect format used in Parameter MB_MESSAGE_BODY_ONLY. Use Format //root/child")
                    else:
                        mb_message_body_only_lst = str(mb_message_body_only).split('//')[1].split('/')
                        mb_message_body_only_lst = mb_message_body_only_lst[1:]
                        amb_message_tmp = org_amb_message
                        entity_name = ''
                        logger.DEBUG("Content to read from amb message is : {}".format(mb_message_body_only_lst))
                        for contents in mb_message_body_only_lst:
                            entity = amb_message_tmp.mbf_find_object(contents, 'MBFE_BEGINNING')
                            if entity:
                                entity_name = entity.mbf_get_name()
                                logger.DEBUG("AMB message entity to read is : {}".format(entity_name))
                                amb_message_tmp = entity
                                if entity.mbf_is_list():
                                    mb_message = convert_mbf_message_to_string(entity)
                                else:
                                    mb_message = entity.mbf_get_value()
                            else:
                                logger.ERROR("Tag {} not found in amb message".format(contents))
                                mb_message = ''
                        if mb_message:
                            download_amb_message(file_name, file_path, entity_name, msg_source, read_mode, write_mode,
                                                 mb_message, org_amb_message, temp_download)
                else:
                    mb_message = convert_mbf_message_to_string(org_amb_message)
                    # mb_message = org_amb_message.mbf_object_to_string()
                    if mb_message:
                        download_amb_message(file_name, file_path, entity_name, msg_source, read_mode, write_mode,
                                             mb_message, org_amb_message, temp_download)
                try:
                    amb.mb_queue_accept(channel, event.message, 'Message processing done')

                except Exception as ex:
                    logger.ERROR("Error while mb_queue_accept : {}".format(str(ex)))
            else:
                logger.DEBUG("AMB message cannot be processed")

    elif eventstring == 'Disconnect':
        amb_connected = False


def create_message_buffer(messageObj, message_buffer=''):
    """Create string from the mbg object by reading each tag"""
    if messageObj:
        message_buffer += "[{}]\n".format(messageObj.mbf_get_name())
        msg_obj = messageObj.mbf_first_object()
        while msg_obj:
            if msg_obj.mbf_is_list():
                message_buffer = create_message_buffer(msg_obj, message_buffer)
            else:
                message_buffer += msg_obj.mbf_get_name() + '=' + msg_obj.mbf_get_value()
                message_buffer += '\n'

            msg_obj = messageObj.mbf_next_object()
        else:
            message_buffer += "[/{}]\n".format(messageObj.mbf_get_name())
    return message_buffer


def convert_mbf_message_to_string(mb_object):
    """Method to convert mb message object to string"""
    logger.DEBUG("Convert amb message to string")
    message_buffer = mb_object.mbf_object_to_string()

    # Read each tag and create a message string from mbf object
    message_string = create_message_buffer(mb_object, '')
    if message_string:
        try:
            # Convert message string to mbf object and get indented message
            msg_buf = amb.mbf_create_buffer_from_data(message_string)
            mbf_object_new = msg_buf.mbf_read()
            message_string = mbf_object_new.mbf_object_to_string()
            message_buffer = message_string
        except Exception as ex:
            #logger.WARN("Cannot convert message string to mbf object")
            message_buffer = message_string
    #else:
    #    logger.WARN("Cannot convert mbf_message to string")
    return message_buffer


def download_amb_message(file_name, file_path, entity_name, msg_source, read_mode, write_mode, mb_message,
                         org_amb_message, temp_download):
    logger.DEBUG("Download amb message to file")
    org_file_path = file_path
    config_data = config_variables_obj.config_data
    logger.DEBUG("AMB message file name: {} and file path: {} before customization".format(file_name, file_path))
    file_path, file_name = get_message_file_name(file_name, file_path, entity_name, msg_source, mb_message, org_amb_message)

    # Apply export exit hook on amb message
    mb_message_obj = string_to_mbf_object(mb_message)
    mb_message, destination_path = FFTPLibHooks.fftplibrary_export_exit(read_mode, write_mode, mb_message,
                                                            mb_message_obj, destination_path=file_path)

    if type(mb_message) == type(org_amb_message):
        mb_message = convert_mbf_message_to_string(mb_message)

    if mb_message:
        if destination_path:
            logger.DEBUG("AMB message download path returned from export exit hook is: {}".format(destination_path))
            file_path = destination_path

        if temp_download:
            msg_file_path = os.path.join(org_file_path, file_name)
            msg_file_path = write_mb_message_to_file(msg_file_path, mb_message, org_amb_message)
            # Set the temperory path in config for the customized path
            if os.path.abspath(file_path) != os.path.abspath(org_file_path):
                logger.DEBUG("Adding destination path in the config dictionary, \
                                        customized by user in the extension points")
                temp_path_key = 'TEMP_{}-{}'.format(read_mode, write_mode)
                if temp_path_key not in config_data:
                    config_data[temp_path_key]={}
                config_data[temp_path_key][msg_file_path] = file_path
        else:
            msg_file_path = os.path.join(file_path, file_name)
            write_mb_message_to_file(msg_file_path, mb_message, org_amb_message)


def string_to_mbf_object(amb_message_string):
    logger.DEBUG("Convert amb message string to message object")
    mb_object = None
    try:
        buf = amb.mbf_create_buffer_from_data(str(amb_message_string))
        mb_object = buf.mbf_read()
    except Exception as ex:
        logger.WARN("Cannot convert amb message string to mbf object")
    return mb_object


def get_message_file_name(file_name, file_path, entity_name, msg_source, mb_message_to_export, org_amb_message):
    """get the message file name with the timestamp, message source and entity name
    """
    logger.DEBUG("Get amb message file name")
    filename, file_extension = os.path.splitext(file_name)
    local_time = acm.Time.RealDateNow() + ' ' + acm.Time.TimeOnlyMs()
    if not file_extension:
        file_extension = '.txt'
        logger.DEBUG("Default file extension is {}".format(file_extension))

    tmp_file_name = str(local_time).replace(':', '') + file_extension
    if entity_name:
        tmp_file_name = entity_name + '_' + tmp_file_name

    if file_name:
        file_name = file_name + '_' + tmp_file_name
    else:
        logger.WARN("FParameter <MESSAGE_FILE_NAME> is not set, using AMB message source: {} for file name".format(msg_source))
        file_name = msg_source + '_' + tmp_file_name

    # Apply extension point
    try:
        file_path_cust, file_name = FFTPLibHooks.amb_message_file_name(file_name, mb_message_to_export, org_amb_message, file_path=file_path)
        logger.DEBUG("AMB message file name after applying hook is {}".format(file_name))
        logger.DEBUG("AMB message file path after applying hook is {}".format(file_path_cust))
        if file_path_cust:
            file_path = file_path_cust
    except Exception as e:
        logger.ERROR("Exception in extension point amb_message_file_name : {}".format(str(e)))

    file_name = validate_file_name(file_name)
    logger.DEBUG("AMB message file name after validation: {}".format(file_name))
    return file_path, file_name


def write_mb_message_to_file(msg_file_path, mb_message_to_export, org_amb_message):
    # Apply extension point for message content
    logger.DEBUG("Write amb message content to file")

    try:
        mb_message_to_export = FFTPLibHooks.amb_message_content(msg_file_path, mb_message_to_export, org_amb_message)
    except Exception as e:
        logger.ERROR("Exception in extension point amb_message_content : {}".format(str(e)))

    if mb_message_to_export:
        try:
            file_path, file_name = os.path.split(msg_file_path)
            if not os.path.exists(file_path):
                os.makedirs(file_path)

            # if file already exist with same name, then create unique file name
            if os.path.exists(msg_file_path):
                filename, file_extension = os.path.splitext(msg_file_path)
                temp_string = next(tempfile._get_candidate_names())
                logger.WARN("File name: {} already exists, adding string: {} to make unique file name".format(file_name, temp_string))
                msg_file_path = filename + '_' + temp_string + file_extension

            file = open(msg_file_path, 'wb')
            file.write(mb_message_to_export.encode('UTF-8'))
            file.close()
            logger.DEBUG("AMB message is written to file : {}".format(msg_file_path))
        except Exception as ex:
            logger.ERROR("Error while writing the amb message to file_name {}".format(str(ex)))
    return msg_file_path

def event_cb_writer(channel, event, arg):
    """ Callback function for amb writer """
    (channel, amb.mb_event_type_to_string(event.event_type))
    eventstring = amb.mb_event_type_to_string(event.event_type)
    if eventstring == 'Message':
        pass


class AMBOperations(object):
    """ Class for AMB operations to read and write data within mb database using AMB APIs"""

    def __init__(self, amb_address=None, application_name='', config_variables_obj=None, *args):
        self.amb_address = amb_address
        self.is_connected = True  # self.init_amb_connection()
        self.message_prop = None
        self.application_name = application_name
        config_data = config_variables_obj.config_data if config_variables_obj else {}
        self.read_mode = config_data.get('FROM_MODE', 'FTP')
        self.write_mode = config_data.get('TO_MODE', '')
        
    def split_amb_details(self):
        amb_addr = None
        ambUser = None
        ambPassword = None
        amb_details = self.amb_address.split("/")
        if len(amb_details) > 0 and amb_details[0]:
            amb_addr = amb_details[0]
        if len(amb_details) > 1 and amb_details[1]:
            ambUser = amb_details[1]
        if len(amb_details) > 2 and amb_details[2]:
            ambPassword = amb_details[2]
        amb_detail = (amb_addr, ambUser, ambPassword)
        return amb_detail    
            

    def init_amb_connection(self):
        """ Connect to AMB """
        global amb_connected
        is_connected = False
        amb_detail = self.split_amb_details()
        if self.amb_address:
            
            try:
                is_connected = utilsobj.connect_amb(self.application_name, self.amb_address)                 
                if is_connected :
                    if amb_detail[0] and len(amb_detail) > 1 and  amb_detail[1]:
                        logger.INFO('AMB: <{0}> Connected for user <{1}> '.format(amb_detail[0], amb_detail[1]))
                    else:
                        logger.INFO('AMB: <{0}> Connected '.format(amb_detail[0]))
                else:
                    logger.ERROR("Could not connect to AMB {0}".format(amb_detail[0]))
                                    
            except Exception as ex:     
                if amb_detail[0] and amb_detail[1]:           
                    error_message = "Connection to AMB <{0}> for user <{1}> failed : {2}".format(amb_detail[0], amb_detail[1], str(ex))
                else:
                    error_message = "Connection to AMB <{0}> failed : {1}".format(amb_detail[0], str(ex))    
                logger.ERROR(error_message)
                is_connected = False
        amb_connected = is_connected
        return is_connected

    @staticmethod
    def get_message_broker(mode, task_parameters, reader):
        """Get the amb address from the configured FParameters."""
        mode_config_param = FFTPConfig.Parameters('FFTPModeSettings_' + mode)
        amb_config_param = FFTPConfig.Parameters('FFTPAMBSettings')
        read_mode, write_mode = mode.split('-')
        amb_address = getattr(amb_config_param, 'MESSAGE_BROKER', '')
        if read_mode == 'AMB' and reader:
            if getattr(mode_config_param, 'READ_MESSAGE_BROKER', ''):
                amb_address = getattr(mode_config_param, 'READ_MESSAGE_BROKER', '')
        elif write_mode == 'AMB':
            if getattr(mode_config_param, 'WRITE_MESSAGE_BROKER', ''):
                amb_address = getattr(mode_config_param, 'WRITE_MESSAGE_BROKER', '')
        return amb_address

    @staticmethod
    def get_mode_params(param, mode, task_parameters=None):
        """Get the mode specific parameters"""
        mode_config_param = FFTPConfig.Parameters('FFTPModeSettings_' + mode)
        amb_config_param = FFTPConfig.Parameters('FFTPAMBSettings')
        param_value = getattr(mode_config_param, param, '')
        if task_parameters:
            param_value = task_parameters.get(param, '')
        else:
            if not param_value:
                param_value = getattr(amb_config_param, param, {})
        return param_value

    @classmethod
    def initialize(cls, mode, reader, task_parameters=None, config_variables_obj=None):
        """ Initialize the AMB connection"""
        global mode_config_param
        global message_file_name
        mode_config_param = FFTPConfig.Parameters('FFTPModeSettings_' + mode)
        amb_config_param = FFTPConfig.Parameters('FFTPAMBSettings')
        amb_address = cls.get_message_broker(mode, task_parameters, reader)
        read_source = cls.get_mode_params('READ_SOURCE', mode, task_parameters)
        write_source = cls.get_mode_params('WRITE_SOURCE', mode, task_parameters)
        if len(write_source) == 0 :
            write_source = getattr(mode_config_param, 'WRITE_SOURCE', None)
            if len(write_source) == 0:
                logger.ERROR("AMB write subject is empty, please set AMB write subject") 
                return None
        if mode.split('-')[0] == 'AMB':
            message_file_name = cls.get_mode_params('MESSAGE_FILE_NAME', mode, task_parameters)
        temp_file_path = cls.get_mode_params('TEMP_FILE_PATH', mode, task_parameters)

        if not amb_address:
            logger.ERROR(
                "Configuration parameter MESSAGE_BROKER is missing. Please check FFTPAMBSettings or mode settings ")
            return None
        application_name = getattr(amb_config_param, 'FFTP_APPLICATION_NAME', '')
        obj = cls(amb_address, application_name, config_variables_obj=config_variables_obj)
        if not obj.is_connected:
            return None

        # subscribe to the incomming or outgoing channel
        if reader:
            receiver_channel = getattr(amb_config_param, 'MESSAGE_RECEIVER', '')
            subject_list = FFTPConfig.string_as_list(read_source)
            if task_parameters:
                msg_reader = obj.open_amb_reader_channel(receiver_channel, write_source, message_file_name,
                                                         subject_list, temp_file_path, mode)
            else:
                msg_reader = obj.open_amb_reader_channel(receiver_channel, None, None, None, None, None)

            if not msg_reader:
                return None
            amb_msg_subscribed = obj.subscribe_receive_msg_subject(msg_reader, subject_list)
            if not amb_msg_subscribed:
                return None
        else:
            message_prop_dict = {}
            sender_channel = getattr(amb_config_param, 'MESSAGE_SENDER', '')
            message_prop = cls.get_mode_params('MESSAGE_PROPERTIES', mode)
            try:
                message_prop_dict = eval(message_prop)
            except Exception as e:
                logger.ERROR("Incorrect data dictionary specified at FParameter MESSAGE_PROPERTIES : {}".format(
                    str(message_prop)))
                return None

            obj.message_prop = message_prop_dict  # need to check
            writer = obj.open_amb_writer_channel(sender_channel)
            if not writer:
                logger.ERROR("AMB is not initialised")
                return None
        return obj

    def read(self, subject, dest_dir, file_filter):
        """ Read downloaded amb message from AMB """
        source = None
        global amb_connected
        file_path_list = []
        logger.INFO("Checking for amb messages with subject {}.".format(subject))
        if not amb_connected:
            self.is_connected = False

        subject_source = subject.replace('/', '_')  # example BO_SETTLEMENT
        source = subject.split('/')[0]  # BO
        mfile_path = os.path.join(dest_dir, subject_source)
        if os.path.exists(mfile_path):
            file_list = os.listdir(mfile_path)
            if file_list:
                file_path_list = [os.path.join(mfile_path, each_file) for each_file in file_list]
        return file_path_list

    def write(self, file_path_list, subject, temp_dest_dict={}):
        """ Writes message to AMB """
        files_written_to_dest = []
        for file_path in file_path_list:
            if temp_dest_dict:
                temp_dest = temp_dest_dict.get(file_path)
                if temp_dest:
                    subject = temp_dest

            result = self.send_file_to_amb(file_path, subject, self.message_prop)
            if result:
                files_written_to_dest.append(file_path)
        return files_written_to_dest

    def open_amb_reader_channel(self, channel, msg_file_path, msg_file_name, msg_subject_lst, temp_file_path, mode):
        """ Iniialize AMB reader channels """
        message_rcv = None
        try:
            message_rcv = amb.mb_queue_init_reader(channel, event_cb_reader,
                                                   (
                                                   msg_file_path, msg_file_name, msg_subject_lst, temp_file_path, mode))
            self.reader = message_rcv
            logger.DEBUG('Initialized channel : {}'.format(channel))
            # amb.mb_poll()
        except Exception as e:
            if str(e) == 'Not Connected':
                amb_detail = self.split_amb_details()
                if amb_detail[1] and amb_detail[0]:
                    logger.DEBUG("AMB not connected, Connecting again {}".format(amb_detail[0] + '/' +amb_detail[1]))
                elif amb_detail[0]:  
                    logger.DEBUG("AMB not connected, Connecting again {}".format(amb_detail[0]))
                    
                self.is_connected = self.init_amb_connection()
                if self.is_connected:
                    message_rcv = self.open_amb_reader_channel(channel, msg_file_path, msg_file_name, msg_subject_lst,
                                                               temp_file_path, mode)
            else:
                error_message = "Error while initializing reader, Check if you have channel " \
                                "<{0}> in db : {1}".format(channel, str(e))
                logger.ERROR(error_message)

        return message_rcv

    def subscribe_receive_msg_subject(self, reader, subject_lst):
        """ subscribe to a AMB subject """
        amb_msg_subscribed = False
        if reader:
            try:
                for subject in subject_lst:
                    amb.mb_queue_enable(reader, subject)
                    logger.INFO('Subscribed to AMB message subject : {}'.format(subject))
                    amb.mb_poll()
                amb_msg_subscribed = True
            except Exception as e:
                logger.ERROR(str(e))
                amb_msg_subscribed = False
        else:
            w_msg = "AMB message subject is not provided"
            logger.WARN(w_msg)

        return amb_msg_subscribed

    def open_amb_writer_channel(self, channel):
        """ Initialize AMB writer """
        self.writer = 0
        try:
            self.writer = amb.mb_queue_init_writer \
                (channel, event_cb_writer, None)
            logger.DEBUG('Initialized writer channel : {}'.format(channel))
        except Exception as e:
            if str(e) == 'Not Connected':
                amb_details = self.split_amb_details()
                if amb_details[1] and amb_details[0]:
                    logger.DEBUG("AMB not connected, Connecting again {}".format(amb_details[0] + '/' +amb_details[1]))
                elif amb_details[0]:  
                    logger.DEBUG("AMB not connected, Connecting again {}".format(amb_details[0]))
                self.is_connected = self.init_amb_connection()
                if self.is_connected:
                    self.writer = self.open_amb_writer_channel(channel)
            else:
                error_message = "Error while initializing writer, Check if you have channel " \
                                "<{0}> in db : {1}".format(channel, str(e))
                logger.ERROR(error_message)
        return self.writer

    def create_amb_buffer(self, message, writer, subject):
        """creates buffer for messages"""
        if not message:
            logger.ERROR("Message is empty, check if AMB message is formed properly")
            return 0

        message_str = message.mbf_object_to_string()
        message = FFTPLibHooks.fftplibrary_import_exit(self.read_mode, self.write_mode, message_str, message)

        if message and isinstance(message, str):
            buf = amb.mbf_create_buffer_from_data(str(message_str))
            message = buf.mbf_read()

        if message:
            try:
                logger.DEBUG("Message writer: {}".format(writer))
                logger.DEBUG("Message Subject: {}".format(subject))
                # logger.DEBUG("Write message to AMB buffer: \n %s" %message)
                amb_buffer = amb.mbf_create_buffer()
                message.mbf_generate(amb_buffer)
                amb.mb_queue_write(writer, subject, \
                                   amb_buffer.mbf_get_buffer_data(), \
                                   amb_buffer.mbf_get_buffer_data_size(), 'ok')
                return 1
            except Exception as e:
                if str(e) == 'Not Connected':
                    error_message = "mbf_create_buffer failed: Not connected to AMB"
                    logger.ERROR(error_message)
                    self.is_connected = False
                    return 0
                else:
                    error_message = "Error encountered while processing AMB buffer: {}".format(str(e))
                    logger.ERROR(error_message)
                    self.is_connected = False
                    return 0

    def send_messages_to_amb(self, amb_message, writer, subject):
        """This method creates an AMB buffer and writes the message to
        the AMB buffer

        """
        res = 0
        try:
            if amb_message and writer > 0:
                res = self.create_amb_buffer(amb_message, writer, subject)
                if res:
                    logger.DEBUG("Successfully sent message to AMB")
        except Exception as ex:
            res = 0
            logger.ERROR("Error while sending message to AMB : {}".format(str(ex)))

        return res

    def send_file_to_amb(self, file_path, subject, msg_properties):
        """ Send file to AMB """
        try:
            file_sent = 0
            file_name = os.path.split(file_path)[-1]
            file_content = ''
            if file_path:
                with open(file_path, 'r') as f:
                    file_content = f.read()
                    f.close()
            if file_content:
                file_content = FFTPLibHooks.fftplibrary_import_entry(self.read_mode, self.write_mode, file_content)
                if file_content and isinstance(file_content, str):
                    amb_message = self.create_amb_message(file_content, subject, msg_properties)
                    if amb_message:
                        subject = subject.split(':')[0]
                        file_sent = self.send_messages_to_amb(amb_message, self.writer, subject)
                        if file_sent:
                            logger.INFO("Successfully sent message to AMB for file {}".format(file_name))
                else:
                    logger.ERROR("fftplibrary_import_entry does not return amb message as string")
            else:
                logger.ERROR("File {} has no contents hence ignoring the operation!".format(file_name))
        except Exception as ex:
            logger.ERROR("Error : {}".format(str(ex)))
        return file_sent

    def create_amb_message(self, amb_message, subject_str, msg_properties):
        """ Create amb message """
        mtype = 'INSERT_FTP_MESSAGE'
        mversion = '1.1'
        mtime = str(acm.Time.TimeNow())
        msource = 'FFTPLibrary'
        mtag = 'FTP_MESSAGE'
        mfield = 'MESSAGE_CONTENT'

        if msg_properties and type(msg_properties) == type({}):
            source_dict = msg_properties.get(subject_str, {})
            for key, val in list(source_dict.items()):
                if key.upper() == 'TYPE':
                    mtype = val
                elif key.upper() == 'VERSION':
                    mversion = val
                elif key.upper() == 'SOURCE':
                    msource = val
                elif key.upper() == 'MESSAGE_TAG':
                    mtag = val
                elif key.upper() == 'FILE_DATA_TAG':
                    mfield = val
        message = amb.mbf_start_message(None, mtype, mversion, mtime, msource)
        mb_msg = message.mbf_start_list(mtag)
        mb_msg.mbf_add_string(mfield, amb_message)
        mb_msg.mbf_end_list()
        message.mbf_end_message()
        return message

    def close_connection(self):
        """ Close AMB connection """
        try:
            pass
            #amb.mb_close()
        except Exception as ex:
            logger.ERROR("Error while closing AMB connection: {}".format(str(ex)))


def validate_file_name(file_name):
    """ Validate file name """
    valid_file_name = ''
    for char_i in file_name:
        if char_i in ['/', '\\']:
            char_i = '_'
        elif char_i in ['<', '>', ':', '"', '|', '?', '*']:
            char_i = ''
        valid_file_name += char_i
    if file_name != valid_file_name:
        logger.ERROR("File name:{} is not valid, replacing with file name:{}".format(file_name, valid_file_name))
    return valid_file_name

def validate_params(app_name, connstr, subject_list, file_path):
    """checks parametrs are empty or not """
    res_subject = '' in subject_list
    res_file_path = '' in file_path
    validataion_param = True
    if app_name == '':
        logger.ERROR('Application name is empty, please provide Application name')
        validataion_param = False
    if  connstr == '' :
        logger.ERROR("Please give host, port, username, password(optional) in format HOST:PORT:USERNAME:PASSWORD")
        validataion_param = False  
    if res_file_path:
        logger.ERROR('File path is empty, please provide file path')
        validataion_param = False
    
    if res_subject:
        logger.ERROR('AMB Subject is empty, please provide subject')
        validataion_param = False     
    return validataion_param

def read_from_amb(app_name, subject_list, file_path, file_name='', connstr='', channel=''):
    """ API to read data from AMB
    Input:
    subject_list : Mandatory. Subject of the AMB message to read. It can be a string and list
    file_path : Mandatory. Directory path to store the AMB message. It can be a string and list
    file_name : Optional. Name of file to store the AMB message in directory.
    connstr : Mandatory. AMB host:port 
    channel : AMB receiver channel name
    app_name : Mandatory application_name 

    """
    try:

        result = 0
        amb_obj = AMBOperations(connstr, app_name)
        subject_list = FFTPConfig.string_as_list(subject_list)
        file_path = FFTPConfig.string_as_list(file_path)
        if not validate_params(app_name, connstr, subject_list, file_path):
            return 0
        
        for destination_dir in file_path:
             if not os.path.isdir(destination_dir):
                 logger.ERROR("Destination directory <%s> does not exist"%destination_dir)
                 return 0
        
        reader = amb_obj.open_amb_reader_channel(channel, file_path, file_name, subject_list, None, None)
        if reader:
            result_sub = amb_obj.subscribe_receive_msg_subject(reader, subject_list)
            if result_sub == True:
                result = 1
        else:
            logger.ERROR("AMB Reader is not initialized") 
            result = 0    
        amb_obj.close_connection()
    except Exception as exp:
        logger.ERROR("Error in read_from_amb %s"%exp)
        result = 0 
    return result

def write_to_amb(app_name, file_path, subject, connstr, channel = '', file_name = '', msg_properties={}):
    """ API to write data to AMB
    Input:
    file_path : Mandatory. Directory path to read the AMB message from. It can be a string and list
    subject : Mandatory. Subject of the AMB message to read. It can be a string and list
    connstr : Mandatory. AMB host:port and application_name
    file_name : Optional. Name of file to store the AMB message in directory.
    channel : AMB receiver channel name
    msg_properties : Optional.
    app_name : Mandatory application_name 

    """
    try:
        file_path = FFTPConfig.string_as_list(file_path)
        subject = FFTPConfig.string_as_list(subject)
        if not validate_params(app_name, connstr, subject, file_path):
            return 0
        amb_obj = AMBOperations(connstr, app_name)
        writer = amb_obj.open_amb_writer_channel(channel)
        if writer == 0 :
            logger.ERROR("AMB Writer is not initialized")
            return 0
        read_sources = []
    
        dest = ''
        source_dict = {}
        result = 1
        if len(subject) == 1:
            dest = subject[0]
        elif len(subject) == len(file_path):
            source_dict = dict(list(zip(file_path, subject)))
        else:
            logger.ERROR("Invalid file_path / subject pass to method.")
            result = 0
            return result
        
        if file_name:
            file_name_list = FFTPConfig.string_as_list(file_name) 
            if '*' in file_name:
                dir_obj = DIROperations()
                dest_dir = ''
                
                for read_source in file_path:
                    output_list = dir_obj.read(read_source, dest_dir, file_name_list)
                    read_sources.extend(output_list)                
            else:
                for file_names in file_name_list:
                    for read_source in file_path:
                        read_source = os.path.join(read_source, file_names)
                        read_sources.append(read_source)
        
            for source in read_sources:
                if source_dict:
                    dest = source_dict.get(source, '')
                amb_result = amb_obj.send_file_to_amb(source, dest, msg_properties)
                if amb_result == 0:
                    result = 0
                    logger.ERROR("File %s is not sent to AMB"%source)
                else:
                    logger.DEBUG("File %s is sent to AMB"%source)
        else:        
            for source in file_path:
                if source_dict:
                    dest = source_dict.get(source, '')
                for files in os.listdir(source):
                    file_to_open = os.path.join(source, files)
                    amb_result = amb_obj.send_file_to_amb(file_to_open, dest, msg_properties)
                    if amb_result == 0:
                        result = 0
                        logger.ERROR("File %s is not sent to AMB"%source)
                    else:
                        logger.DEBUG("File %s is sent to AMB"%source)
        
        amb_obj.close_connection()
    except Exception as exp:
        logger.ERROR('Error in write_to_amb %s'%exp)
        result = 0
    return result



...

  FFTPATSOperations
"""--------------------------------------------------------------------
MODULE
    FTPATSOperations -  This is a continuous ATS uploading/downloading file
                        over FTP which can be defined for either of modes
                        as given below.
                        1.Listen to a subject on the AMB and send the
                          message as a file over FTP.

                        2.Subscribe to the contents of a directory and send
                          every new file to a FTP directory at the Customer
                          site. The sent file will be archived.

                        3.Poll an FTP directory at the Customer site at
                          intervals, receiving the contents there to a local
                          (in the hosted environment) directory.

                        4.Poll a FTP directory at the Customer site at intervals,
                          receiving the contents and submitting each file as a
                          message on the AMB.

DESCRIPTION
    This script creates configurable
    variables from FParameters.

VERSION: 2.0.7

--------------------------------------------------------------------"""
import time

import FFTPConfig
import FFTPController
import FFTPNotification

mode_config_param = FFTPConfig.Parameters('FFTPModeSettings')
logger = FFTPNotification.FFTPLogger('FFTPLibrary')

controller_objs = []
mode_initialized = True

system_config_param = FFTPConfig.Parameters('FFTPSystemSettings')
time_interval = getattr(system_config_param, 'TIME_INTERVAL', '')


valid_modes = ['AMB-DIR', 'AMB-FTP', 'AMB-SFTP', 'AMB-AMB', 'DIR-DIR', 'DIR-AMB', 'DIR-FTP', 'DIR-SFTP', 'FTP-FTP', 'FTP-AMB', 'FTP-DIR', \
                'FTP-SFTP', 'SFTP-SFTP', 'SFTP-AMB', 'SFTP-FTP', 'SFTP-DIR']
def start():
    """ ATS start """
    global controller_objs
    read_write_mode = getattr(mode_config_param, 'MODE', '')
    if not read_write_mode:
        logger.ERROR("No mode specified at FFTPModeSettings. Please specify modes from {}".format(valid_modes))
        return

    mode_lst = FFTPConfig.string_as_list(read_write_mode)
    for each_mode in mode_lst:
        if each_mode not in valid_modes:
            logger.ERROR("Invalid mode {0} specified at FFTPModeSettings. Please specify valid modes from {1}".format(each_mode, valid_modes))
            return
        controller_obj = FFTPController.FTPController(each_mode)
        if controller_obj and controller_obj.is_initialized:
            controller_objs.append(controller_obj)


def stop():
    """ ATS stop """
    global controller_objs
    
    for controller_obj in controller_objs:
        try:
            controller_obj.close_connection()
        except Exception as ex:
            logger.ERROR("Error while closing mode's connection : {}".format(str(ex)))

def work():
    """ ATS work """
    global controller_objs
    if controller_objs:
        logger.INFO("******************************* Work Start *************************************")
        for controller_obj in controller_objs:
            try:
                controller_obj.main()
                logger.INFO("*"*80)
            except Exception as ex:
                logger.ERROR("Error while performing read/write mode operations : {}".format(str(ex)))
        logger.INFO("Check for file(s)/AMB Message(s) at interval of : {}".format(str(time_interval)))
        time.sleep(float(time_interval))






...

  FFTPConfig
"""--------------------------------------------------------------------
MODULE
    FTPConfig - creates config data dictonary.

DESCRIPTION
    This script creates configurable 
    variables from FParameters.

VERSION: 2.0.7

--------------------------------------------------------------------"""
import acm
import FLogger

#logger = FLogger.FLogger("FFTPLibrary", level=2, keep=True, logOnce=True, \
#                                logToConsole=False, logToPrime=True, )
                                
class Singleton(object):

    """Singleton design pattern to avoid the use of global variables.
    
    """
    _instance = None
    

    def __new__(cls, *args, **kwargs):
        if not cls._instance:
            cls._instance = super(Singleton, cls).__new__(cls)
        return cls._instance


class FTPConfigSingleton(Singleton):
    
    def __init__(self, module, user=None, *args):
    
        """used to initialize the configuration variables either from 
        dictionaries, lists, tuples sent as arguments
        """
        self.__config_data = {}
        
        if module:
            self.read_config_parameters(module, user)
            
    def add_user_to_config_data(self, user):
        if self.__config_data:
            self.__config_data['USER'] = acm.UserName()
            
    def read_config_parameters(self, module, user=None):
        if module:
            self.get_config_params_from_std_module(module)
            self.get_config_params_from_customize_module(module)
            if user:
                self.add_user_to_config_data(user)
                
            read_write_data_dic = self._add_read_write_source_in_config('READ_WRITE_SOURCE')
            if read_write_data_dic:
                self.__config_data.update(read_write_data_dic)
                
            self.normalize_config_data()
            
    def get_config_params_from_std_module(self, module):
        ext_module = acm.FExtensionModule[module]
        if ext_module:
            # Read all PFarameters from specific module
            extensions_list = ext_module.GetAllExtensions('FParameters')
            if extensions_list:
                for a_extension in extensions_list:
                    fftplib_params = self._get_param_dict_from_extension(a_extension)
                    self.__config_data.update(fftplib_params) 
                
        
    def get_config_params_from_customize_module(self, module):
        custom_params_dict = {}
        context = acm.GetDefaultContext()
        ext_module = acm.FExtensionModule[module]
        if ext_module:
            # Read all PFarameters from specific module
            extensions_list = ext_module.GetAllExtensions('FParameters')
            if extensions_list:
                # Check if same FParameter is customized in other module
                for a_extension in extensions_list:
                    merged_extension = context.GetExtension("FParameters", "FObject", a_extension.Name())
                    if merged_extension:
                        merged_extension_module = context.GetModulesImplementing("FParameters", "FExtension", a_extension.Name())
                        if merged_extension_module and merged_extension_module[0].Name() != module:
                                                        
                            ext_module = acm.FExtensionModule[merged_extension_module[0].Name()]
                            if ext_module:
                                extension = ext_module.GetExtension('FParameters', \
                                    'FObject', merged_extension.Name())
                                custom_params_dict = self._get_param_dict_from_extension(extension)

                    if custom_params_dict:
                        self.__config_data.update(custom_params_dict)
                                
    def _get_param_dict_from_extension(self, extension):
        config_keys = []
        config_vals = []
        ext_params_dict = {}
        bool_vals = ['True', 'False']
        for key in extension.Value().Keys():
            config_keys.append(str(key))
            
        for vals in extension.Value().Values():
            val = str(vals).split('  ')[0]
            if val in bool_vals:
                config_vals.append(eval(val))
            else:
                config_vals.append(str(val))
        if config_keys and config_vals:
            ext_params_dict = dict(list(zip(config_keys, config_vals)))
        return ext_params_dict
        
                        
    def _add_read_write_source_in_config(self, param):
        '''
        Get the value of source, archive and destination 
        from FParameter READ_WRITE_SOURCE. 
        '''
        read_write_data_dic = {'SOURCE' : [], 'ARCHIVE' : [], 'DESTINATION' : []}
        read_write_source = {}
        try:
            read_write_source = self.__config_data.get(param, [])
            read_write_source = eval(read_write_source)
        except :
            pass
            
            
            
        if read_write_source and type(read_write_source) == type([]):
            for each_tpl in read_write_source:
                
                if each_tpl and len(each_tpl) == 3:
                    read_write_data_dic.get('SOURCE', []).append(each_tpl[0])
                    read_write_data_dic.get('ARCHIVE', []).append(each_tpl[1])
                    read_write_data_dic.get('DESTINATION', []).append(each_tpl[2])
                else:
                    read_write_source.remove(each_tpl)
                    #logger.WLOG("FParameter <READ_WRITE_SOURCE> not has valid tuple : %s" %str(each_tpl))  
            self.__config_data[param] = read_write_source
        return read_write_data_dic
        
    def normalize_config_data(self):
        if self.__config_data:
            if self.__config_data:                
                for key in self.__config_data:
                    value = self.__config_data[key]            
                    try :
                        value = eval(value)                            
                    except:
                        value = value
                            
                    self.__config_data[key] = value
                                        
    @property
    def config_data(self):
        """I'm the '__config_data' property."""
        return self.__config_data
        

def string_as_list(strng):
    lst = []
    if type(strng) == type(''):
        try:
            result = eval(strng)
            if type(result)==type([]):
                lst = result
            elif result:
                lst.append(str(result))
        except Exception:
            strng_split = strng.split(',')
            for data in strng_split:
                lst.append(data.strip())
    elif type(strng) == type([]):
        lst = strng
    return lst

class Parameters(object):
    """ Class to read FParameters"""
    def __init__(self, *names):
        try:
            self.param_name_list = []
            self.get_data(*names)
        except Exception as error:
            raise error
            #Not sure where we are using this , hence skipping it for now
            #self.get_local_data(*names)

    def get_data(self, *names):
        """ Read the FParameters from the Extension Manager"""
        for fparam in names:
            ext_context = acm.FExtensionContext[acm.GetDefaultContext().Name()]
            param_object = ext_context.GetExtension('FParameters',
                                                    'FObject', fparam)
            try:
                template = param_object.Value()
            except AttributeError as error:
                if not param_object:
                    raise Exception("FParameter %s not present" % fparam)
                else:
                    raise Exception("Unable to get content of FParameter %s. Exception : %s" % (fparam, error))

            for k in template.Keys():  #First set all the parameters
                param_name = str(k)
                attribute_name = str(template.At(k)).split('#')[0].strip()
                setattr(self, param_name, attribute_name)
                self.param_name_list.append(param_name)

            '''for k in template.Keys():  #Now override the value of old over new
                param_name = str(k)
                param_name_supp = self.suppress_deprecated_attribute(fparam, param_name)
                if param_name_supp != param_name:
                    attribute_name = str(template.At(k)).split('#')[0].strip()
                    setattr(self, param_name_supp, attribute_name)'''
            self.module_name = param_object.Module().Name()

    def get_local_data(self, *names):
        """ Read the FParameters from the Extension Manager"""
        for fparam in names:
            import os
            file_name = os.path.join('Parameters', fparam + '.py')
            try :
                with open(file_name) as file_handle:
                    for line in file_handle:
                        param_value = line.split('#')[0].strip()
                        lhs, rhs = param_value.split('=')
                        setattr(self, lhs, rhs)
            except Exception as e:
                pass

    def get_param_name_list(self):
        """ return parameters list """
        return self.param_name_list





...

  FFTPController
"""--------------------------------------------------------------------
MODULE
FTPController - This is a continuous ATS uploading/downloading file
                over FTP which can be defined for either of modes
                as given below.
                1.Listen to a subject on the AMB and send the
                message as a file over FTP.

                2.Subscribe to the contents of a directory and send
                every new file to a FTP directory at the Customer
                site. The sent file will be archived.

                3.Poll an FTP directory at the Customer site at
                intervals, receiving the contents there to a local
                (in the hosted environment) directory.

                4.Poll a FTP directory at the Customer site at
                intervals, receiving the contents and submitting
                each file as a message on the AMB.

VERSION: 2.0.7

--------------------------------------------------------------------"""
import os
import ntpath

import FFTPNotification
import FFTPConfig

from FFTPAMBOperations import AMBOperations
from FFTPOperations import FTPOperations
from FSFTPOperations import SFTPOperations
from FFTPDIROperations import DIROperations
from FFTPTLSOperations import FTPTLSOperations
from datetime import datetime
import ael
logger = FFTPNotification.FFTPLogger('FFTPLibrary')

config_variables_obj = FFTPConfig.FTPConfigSingleton('FFTPLibrary')
config_data = config_variables_obj.config_data
class FTPController(object):
    """ Controller class to invoke read and write operations for different modes """
    def __init__(self, mode, task_params=None):
        self.read_obj = None
        self.write_obj = None
        self.read_mode = None
        self.write_mode = None
        self.mode = mode
        self.is_initialized = True
        self.transactiondict = None

        if self.mode:
            config_data['TEMP_{}'.format(self.mode)] = {}
            mode_split = self.mode.split('-')
            if mode_split and len(mode_split) > 1:
                self.read_mode = mode_split[0]
                self.write_mode = mode_split[1]
                config_data['FROM_MODE'] = self.read_mode
                config_data['TO_MODE'] = self.write_mode

        self.transaction_log_filename_path = None
        self.transaction_log_delimiter  = '; '
        if self.mode.startswith('FTP'):
            ftp_config_param = FFTPConfig.Parameters('FFTPSettings')
            self.ftp_log_file_path = getattr(ftp_config_param, 'FTP_TRANSACTION_LOG_PATH', None)
            if self.ftp_log_file_path:                
                transaction_log_filename = 'Transaction_Log_%s.txt' % (self.read_mode)                
                self.transaction_log_filename_path = os.path.join(self.ftp_log_file_path, transaction_log_filename)
                self.transactiondict = self.read_from_transactionlog_file()
            else:
                logger.ERROR("No path specified in FFTPSettings FParameter<FTP_TRANSACTION_LOG_PATH>, transaction log functionality wont work!")

        read_mode_ftptls, write_mode_ftptls = None, None
        if task_params:
            self.task_params = task_params
            self.read_source = task_params.get('READ_SOURCE', '')
            self.write_source = task_params.get('WRITE_SOURCE', '')
            if len(self.write_source) == 0 and self.write_mode == "AMB" :
                mode_config_param = 'FFTPModeSettings_' + self.mode 
                self.set_amb_subject(mode_config_param) 
            self.archive_file_path = task_params.get('ARCHIVE_PATH', '')
            self.temp_file_path = task_params.get('TEMP_FILE_PATH', '')
            read_mode_ftptls = task_params.get('READ_FTPTLS', None) if self.read_mode == 'FTP' else None
            write_mode_ftptls = task_params.get('WRITE_FTPTLS', None) if self.write_mode == 'FTP' else None
        else:
            mode_config_param = FFTPConfig.Parameters('FFTPModeSettings_' + self.mode)
            read_source = getattr(mode_config_param, 'READ_SOURCE', None)
            write_source = getattr(mode_config_param, 'WRITE_SOURCE', None)
            self.read_source = FFTPConfig.string_as_list(read_source)
            self.write_source = FFTPConfig.string_as_list(write_source)
            self.archive_file_path = getattr(mode_config_param, 'ARCHIVE_PATH', '')
            self.temp_file_path = getattr(mode_config_param, 'TEMP_FILE_PATH', '')
            read_mode_ftptls = getattr(mode_config_param, 'READ_FTPTLS', None) if self.read_mode == 'FTP' else None
            write_mode_ftptls = getattr(mode_config_param, 'WRITE_FTPTLS', None) if self.write_mode == 'FTP' else None

        ftp_params = FFTPConfig.Parameters('FFTPSettings')
        systemsettings_param = FFTPConfig.Parameters('FFTPSystemSettings')
        self.no_timestamp = getattr(systemsettings_param, 'DONOT_TIMESTAMP_ARCHIVE_FILES', '')
        
        if not self.read_mode or not self.write_mode:
            logger.ERROR("Read mode: %s or Write mode: %s not configured properly" %(self.read_mode, self.write_mode))
            self.is_initialized = False
        elif len(self.write_source) > 1 and (len(self.write_source) != len(self.read_source)):
            logger.ERROR("Read Source <%s> or Write Source <%s> not configured properly for mode <%s>" %(self.read_source, self.write_source, self.mode))
            self.is_initialized = False
        else:
            try:
                read_mode, write_mode = self.read_mode, self.write_mode
                if read_mode == 'FTP' and read_mode_ftptls and int(read_mode_ftptls)==1:
                    read_mode = 'FTPTLS'
                    logger.DEBUG("Using FTP TLS connection in Read mode")
                if write_mode == 'FTP' and write_mode_ftptls and int(write_mode_ftptls)==1:
                    write_mode = 'FTPTLS'
                    logger.DEBUG("Using FTP TLS connection in Write mode")
                
                logger.INFO("Initializing the mode {} connection(s)".format(self.mode))
                read_class = str(read_mode) + \
                'Operations.initialize(self.mode, reader = True, task_parameters={0}, config_variables_obj=config_variables_obj)'.format(task_params)
                write_class = str(write_mode) + \
                'Operations.initialize(self.mode, reader = False, task_parameters={0}, config_variables_obj=config_variables_obj)'.format(task_params)

                self.read_obj = eval(read_class)
                self.write_obj = eval(write_class)
            except Exception as ex:
                logger.ERROR("ERROR while initializing reader or writer mode: %s" % str(ex))

        self.dir_obj = DIROperations(self.no_timestamp)
        if not self.read_obj or not self.write_obj:
            self.is_initialized = False

    def set_amb_subject(self, mode_config_param):
        """Set AMB subject according to FParamter WRITE_SOURCE  if in GUI it is empty"""
        try:
            config_param = FFTPConfig.Parameters(mode_config_param)
            write_source = getattr(config_param, 'WRITE_SOURCE', None)
            self.write_source = FFTPConfig.string_as_list(write_source)
        except Exception as e:
            logger.ERROR("Error while initializing writer mode %s" %str(e))

    def main(self):
        """ Controller main to invoke read and write operations """
        logger.INFO("                 Running mode {}                 ".format(self.mode))
        files_written_to_dest = []
        file_path_list = []

        success = 0
        destination = ''
        if self.write_source:
            destination = self.write_source[0]

        # Retry the amb connection as for AMB
        if self.read_obj and self.write_obj:
            if self.write_mode == 'AMB' and not self.write_obj.is_connected:
                logger.DEBUG("Write AMB connection has failed, retrying the connection")
                write_obj = AMBOperations.initialize(self.mode, reader=False)
                if write_obj:
                    self.write_obj = write_obj
                else:
                    logger.ERROR("Write AMB connection retry has failed")
            if self.read_mode == 'AMB' and not self.read_obj.is_connected:
                logger.DEBUG("Read AMB connection has failed, retrying the connection")
                read_obj = AMBOperations.initialize(self.mode, reader=True)
                if read_obj:
                    self.read_obj = read_obj
                else:
                    logger.ERROR("Read AMB connection retry has failed")
        else:
            logger.ERROR("Cannot proceed with mode: {} as the read and write mode are not initialized".format(self.mode))
            return 0

        if self.read_obj and self.write_obj:
            not_exists = 0
            if self.read_mode == 'DIR':
                for source in self.read_source:
                    dir_path, filter = ntpath.split(os.path.expandvars(source))
                    if os.path.isdir(dir_path):
                        logger.DEBUG("Source directory <%s> exist"%dir_path)
                    else:
                        logger.ERROR("Source directory <%s> does not exist"%dir_path)
                        not_exists = 1
            if self.write_mode == 'DIR':
                for source in self.write_source:
                    if os.path.isdir(source):
                        logger.DEBUG("Destination directory <%s> exist"%source)
                    else:
                        logger.ERROR("Destination directory <%s> does not exist"%source)
                        not_exists = 1
            if not_exists:
                return 0

            
            self.check_read_write_source()
            
            source_dict = {}
            for source in self.read_source:
                files_written_to_dest = []
                if len(self.write_source) > 1 and (len(self.read_source) == len(self.write_source)):
                    source_dict = dict(list(zip(self.read_source, self.write_source)))
                    destination = source_dict[source]
                elif not destination:
                    logger.ERROR("Destination directory doesnt exist")

                #Reconnection in case FTP disconnected. 
                if self.write_mode == 'FTP':
                    self.write_obj.retry_ftp_connection_if_disconnected()
                if self.read_mode == 'FTP':
                    self.read_obj.retry_ftp_connection_if_disconnected()

                if self.write_mode == 'DIR':
                    # Set the source path to read and filter
                    if self.read_mode in ['FTP', 'DIR', 'SFTP']:
                        dir_path, filter = ntpath.split(os.path.expandvars(source))
                    else:
                        filter = None
                        dir_path = source

                    # Read files/message from the source
                    # for cases like FTP/SFTP/AMB when write mode is DIR, files/messages downloaded
                    # to destination directory in read operation only , no needd to call write
                    if self.read_mode == 'FTP' :
                        success, file_path_list = self.read_transaction_log(dir_path, destination, filter)
                    else:
                        file_path_list = self.read_obj.read(dir_path, destination, [filter])
                        if file_path_list:
                            success = 1
                else:
                    #When the write mode is other than DIR, files/messages downloaded to temp directory

                    # Set the source path to read and filter
                    if self.read_mode in ['FTP', 'DIR', 'SFTP']:
                        dir_path, filter = ntpath.split(os.path.expandvars(source))
                    else:
                        filter = None
                        dir_path = source

                    # Read files/message from the source
                    if self.read_mode == 'FTP' :
                        success, file_path_list = self.read_transaction_log(dir_path, self.temp_file_path, filter)
                    else:
                        file_path_list = self.read_obj.read(dir_path, self.temp_file_path, [filter])
                        if file_path_list:
                            success = 1

                #Writes the downloaded file from source to destination
                # for mode with no DIR, Writes files from temp to destination
                # for mode with DIR, write return the downloaded files
                if file_path_list:  # If files available from read mode to write
                    if self.mode != 'AMB-DIR':
                        temp_mode_dict = config_data.get('TEMP_{}'.format(self.mode))
                        files_written_to_dest = self.write_obj.write(file_path_list, destination, temp_mode_dict)
                        if self.read_mode == 'FTP' :
                            for file in files_written_to_dest:
                                destination_dir, filename = os.path.split(file)
                                if self.file_details_dict: # file_details_dict = {filename: [self.mode, timestamp]}
                                    for fullfile_name in self.file_details_dict.keys():
                                        destination_dir, file = os.path.split(fullfile_name)
                                        if file == filename:
                                            self.write_to_transactiondict(fullfile_name, self.file_details_dict[fullfile_name][0], str(self.read_obj.utc_to_local(self.file_details_dict[fullfile_name][1])))

                if files_written_to_dest:
                    success = 1

                # Remove temp files
                if self.read_mode != 'DIR' and self.write_mode != 'DIR':
                    self.dir_obj.remove_files(file_path_list)


                # Archive files in case of reading from DIR/remote DIR
                if self.archive_file_path:
                    if not os.path.exists(self.archive_file_path) and self.read_mode == 'DIR' and file_path_list :
                        try:
                            logger.DEBUG("Directory set in ARCHIVE_PATH does not exist, hence creating directory %s as set in FParameter ARCHIVE_PATH" % self.archive_file_path)
                            os.makedirs(self.archive_file_path)
                            self.dir_obj.archive_files(file_path_list, self.archive_file_path)
                        except Exception as ex:
                            self.create_log_dir_and_move_archive_files(self.archive_file_path, file_path_list)                            
                    elif os.path.exists(self.archive_file_path) and self.read_mode == 'DIR' and file_path_list :
                        try:
                            self.dir_obj.archive_files(file_path_list, self.archive_file_path)
                        except Exception as ex:
                            self.create_log_dir_and_move_archive_files(self.archive_file_path, file_path_list)
                elif self.archive_file_path == "" and self.read_mode == 'DIR' and file_path_list:
                        self.create_log_dir_and_move_archive_files(self.archive_file_path, file_path_list)                                
  
            config_data['TEMP_{}'.format(self.mode)] = {}
        else:
            logger.ERROR("Cannot proceed with mode: {} as the read and write mode are not initialized".format(self.mode))
        return success
    
    def check_read_write_source(self):
        """ Check read and write source  """
        if len(self.read_source) :
            if self.read_source[0] == "": 
                logger.ERROR("Read source empty, please check READ_SOURCE FParameter in %s mode " %('FFTPModeSettings_' + self.mode)) 
        if len(self.read_source) == 0 :  
               logger.ERROR("Read source is not provided, please enter READ_SOURCE FParameter in %s mode" %('FFTPModeSettings_' + self.mode))
        if len(self.write_source) :
            if self.write_source[0] == "": 
                logger.ERROR("Write source is empty, please check WRITE_SOURCE FParameter in %s mode " %('FFTPModeSettings_' + self.mode)) 
        if len(self.write_source) == 0 :  
               logger.ERROR("Write source is not provided, please enter WRITE_SOURCE FParameter in %s mode" %('FFTPModeSettings_' + self.mode))
            
    
    def create_log_dir_and_move_archive_files(self, archive_dir, file_path_list):
        " create archive folder in log directory and file will be archived "
        log_file_path = ""
        log_file_path = ael.get_config_var('logdir')
        if log_file_path == None:
            logger.INFO("Parameter logdir is not set in configuration. Please set logdir to create archive directory")
            return 
        archive_files_folder = "ARCHIVE_FILES"
        log_archive_dir = os.path.join(log_file_path, archive_files_folder)
        dir_created = True
        if archive_dir == "" :
            logger.INFO("FParameter ARCHIVE_PATH is not set, hence creating archive path %s" % (log_archive_dir))
        else:    
            logger.INFO("Unable to create archive directory at %s, creating archive directory at %s" % (archive_dir, log_archive_dir))
        if not os.path.exists(log_archive_dir):
            try:
                os.makedirs(log_archive_dir)                
            except Exception as ex:
                dir_created = False
                logger.ERROR("Error while creating archive directory %s" % (ex))
                
        if dir_created:        
            self.dir_obj.archive_files(file_path_list, log_archive_dir)
            
    def close_connection(self):
        """ Close connection """
        if self.read_obj:
            self.read_obj.close_connection()
        if self.write_obj:
            self.write_obj.close_connection()
        if self.mode.startswith('FTP'):
            self.transactionlog_write_from_list_to_file()

    def read_from_transactionlog_file(self):
        """ Read from transaction log file """
        transaction_dict = {}
        full_filepath = self.transaction_log_filename_path
        filepath, filename = os.path.split(full_filepath)

        if os.path.exists(filepath):
            if os.path.isfile(full_filepath):
                with open(full_filepath, "r") as filehandler:
                    transaction_list = filehandler.readlines()
                    transaction_dict = self.create_transactiondict(transaction_list)
        else:
            logger.ERROR("<FTP_TRANSACTION_LOG_PATH=%s> does not exist"%(filepath))
        return transaction_dict


    def transactionlog_write_from_list_to_file(self):
        """ Write to transaction log file """
        if self.ftp_log_file_path:
            file_handler = open(self.transaction_log_filename_path, "w")
            if self.transactiondict:
                transaction_log_list = self.create_list_from_transactiondict(self.transactiondict)
                with open(self.transaction_log_filename_path, 'w') as file_handler:
                    for list_item in transaction_log_list:
                        file_handler.write("{}\n".format(list_item.strip("r\n")))


    def check_if_file_already_read(self, filename, dir_path):
        """ Check if file timestamp is equal to timestamp from log """
        already_read_flag = False
        file_details_dict = {}        
        filename_with_dirpath = os.path.join(dir_path, filename) #Same file name can be present in 2 dir_path
        timestamp = self.read_obj.get_file_modified_timestamp(filename, dir_path) #In reconnect, need to set dir path again.        
        if timestamp:
            file_details_dict = {filename_with_dirpath: [self.mode, timestamp]}

        if self.transactiondict and timestamp:
            if filename_with_dirpath in self.transactiondict:
                if self.mode in list(self.transactiondict[filename_with_dirpath].keys()):
                    timestamp_in_log = self.transactiondict[filename_with_dirpath][self.mode]
                    timestamp_in_log_to_utc = self.read_obj.local_to_utc(timestamp_in_log.strip())
                    
                    #Compare File log time and File actual time. Both time are in UTC
                    formatted_timestamp_in_log = datetime.strptime(timestamp_in_log_to_utc, "%Y-%m-%d %H:%M:%S.%f")
                    formatted_timestamp = datetime.strptime(timestamp, '%Y%m%d%H%M%S.%f')
                    if str(formatted_timestamp) <= str(formatted_timestamp_in_log):                    
                        logger.DEBUG("The file <%s> has not been modified since it was last read <%s>"%(filename_with_dirpath, timestamp_in_log.strip("r\n")))
                        already_read_flag = True
                    #Compare File log time and File actual time.

        return already_read_flag, file_details_dict

    def check_if_file_exists_on_ftp(self, file_filter, destination_dir):
        """ Checks if file is available on ftp server """
        ftp_dir_set = 0
        file_list = []
        if self.read_obj.ftp:
            if destination_dir:
                try:
                    ftp_dir_set  = self.read_obj.change_ftp_dir(destination_dir)
                    for file_name in file_filter:
                        file_list = self.read_obj.poll_for_file(file_name)
                    if ftp_dir_set:
                        self.read_obj.change_ftp_dir('/')
                except Exception as ex:
                    logger.ERROR("Error while checking file exist on FTP path {0} : {1}".format(destination_dir, str(ex)))
        return file_list


    def retrieve_timestamp(self, filename, destination_dir):
        """ Retrieves timestamp for given file """
        ftp_dir_set = 0
        ftp_obj = self.read_obj.ftp
        if ftp_obj:
            if destination_dir:
                ftp_dir_set = self.read_obj.change_ftp_dir(destination_dir)
                timestamp = self.read_obj.get_file_modified_timestamp(filename)
                timestamp = str(self.read_obj.utc_to_local(timestamp))
                if ftp_dir_set:
                    self.read_obj.change_ftp_dir('/')
        return timestamp


    def create_transactiondict(self, simplified_list):
        """ Creates a nested dict with filename, mode, timestamp retrieved from list after reading file """
        transaction_log_dict = {}         
        for each in simplified_list:
            split_list = each.split(self.transaction_log_delimiter)
            date_time = split_list[2] 
            list_element = {split_list[0]:{split_list[1]:date_time}}
            if transaction_log_dict:
                if split_list[0] in list(transaction_log_dict.keys()):
                    transaction_log_dict[split_list[0]][split_list[1]] = date_time
                else:
                    transaction_log_dict[split_list[0]] = {split_list[1]:date_time}
            else:
                transaction_log_dict.update(list_element)
        return transaction_log_dict


    def create_list_from_transactiondict(self, transactiondict):
        """ Creates a list from the nested transaction dict : {Filename:{Mode:Timestamp}}"""
        transactionlist = []
        for key in list(transactiondict.keys()):
            for innerdict_key in list(transactiondict[key].keys()):
                transactionlist.append((self.transaction_log_delimiter).join((key, innerdict_key, transactiondict[key][innerdict_key])))
        return transactionlist


    def write_to_transactiondict(self, filename, mode, current_timestamp):
        """ Perform operations like search, update and append to nested transaction dict """

        timestamp_in_list = self.search_in_transactiondict(filename, mode)
        if timestamp_in_list:
            transactiondict = self.compare_and_update_in_transactiondict(filename, mode, current_timestamp)
        else:
            transactiondict = self.append_to_transactiondict(filename, mode, current_timestamp)
        return transactiondict


    def search_in_transactiondict(self, filename, mode):
        """ Search in transaction dict file with a given mode and return timestamp """
        if self.transactiondict:
            if filename in list(self.transactiondict.keys()):
                if mode in list(self.transactiondict[filename].keys()):
                    return self.transactiondict[filename][mode]


    def compare_and_update_in_transactiondict(self, filename, mode, file_timestamp):
        """ Update dict if given file_timestamp is greater than filestamp for given filename and mode in transaction dict"""
        if self.transactiondict:
            timestamp_in_dict = self.transactiondict[filename][mode]
            if file_timestamp > timestamp_in_dict:
                self.transactiondict[filename][mode] = file_timestamp
            return self.transactiondict


    def append_to_transactiondict(self, filename, mode, timestamp):
        """ Append to existing transaction dict given filename, mode, timestamp"""

        file_entry_exists = False
        if self.transactiondict:
            if filename in list(self.transactiondict.keys()):
                file_entry_exists = True
                self.transactiondict[filename][mode] = timestamp
            if not file_entry_exists:

                self.transactiondict[filename] = {mode:timestamp}
        else:

            self.transactiondict = {filename:{mode:timestamp}}
        return self.transactiondict

    def read_transaction_log(self, dir_path, destination, filter):
        """ Read from transaction log , check if file was read, read process"""
        success = 0
        file_path_list = []        
        file_list = self.check_if_file_exists_on_ftp([filter], dir_path)
        self.file_details_dict = {} # file_details_dict = {filename: [self.mode, timestamp]}
        filename_and_modified_timestamp = {} #will use for update file_details_dict
        if len(file_list) > 0:
            ftp_dir_set = self.read_obj.change_ftp_dir(dir_path) #Change directory before get modified time of file.
            for file in file_list[:]: #Loop over a copy
                already_read_flag, file_details = self.check_if_file_already_read(file, dir_path)
                if already_read_flag:
                    file_list.remove(file)
                else:                        
                    filename_and_modified_timestamp[file] = file_details
            if ftp_dir_set: #Change directory as a root
                self.read_obj.change_ftp_dir('/')
            
            if len(file_list) == 0:
                success = 1
        if file_list:
            file_path_list = self.read_obj.read(dir_path, destination, file_list)

            #After successfully execute read operation updating dictionary.             
            for file in file_list:
                #While checking file already read or not we stored it last modified time in filename_and_modified_timestamp dictionary
                if file in filename_and_modified_timestamp:
                    self.file_details_dict.update(filename_and_modified_timestamp[file])
                else:
                    #below code should not hit but added for safety in case filename_and_modified_timestamp don't have data.
                    logger.DEBUG("File modified time not exists in dictionary for File : {0} and Path : {1}".format(file, dir_path))
                    ftp_dir_set = self.read_obj.change_ftp_dir(dir_path) #Change directory before get modified time of file.
                    already_read_flag, file_details_dict = self.check_if_file_already_read(file, dir_path)
                    if ftp_dir_set: #Change directory as a root
                        self.read_obj.change_ftp_dir('/')
                    self.file_details_dict.update(file_details_dict)  

            if file_path_list:
                success = 1
        return success, file_path_list



...

  FFTPDIROperations
"""--------------------------------------------------------------------
MODULE
    FFTPDIROperations -  Operations like reading and writing to directory

DESCRIPTION
    This script handles the DIR operations.

VERSION: 2.0.7

--------------------------------------------------------------------"""
import os
import acm
import ael
import shutil
import fnmatch
import subprocess

import FFTPConfig
import FFTPLibHooks
import FFTPNotification
file_read_result = 1
file_write_result = 1
logger = FFTPNotification.FFTPLogger('FFTPLibrary')


class DIROperations(object):
    def __init__(self, donot_timestamp_archive_files=False, config_variables_obj=None):
        self.donot_timestamp_archive_files = donot_timestamp_archive_files
        self.config_data = config_variables_obj.config_data if config_variables_obj else {}
        self.read_mode = self.config_data.get('FROM_MODE', 'DIR')
        self.write_mode = self.config_data.get('TO_MODE', '')

    @classmethod
    def initialize(cls, mode, reader, task_parameters, config_variables_obj=None):
        # logger.INFO("Subscribed to Directory")

        system_config_param = FFTPConfig.Parameters('FFTPSystemSettings')
        donot_timestamp_archive_files = getattr(system_config_param, 'DONOT_TIMESTAMP_ARCHIVE_FILES', '')
        obj = cls(donot_timestamp_archive_files=donot_timestamp_archive_files,
                  config_variables_obj=config_variables_obj)
        return obj

    def read(self, read_dir, dest_dir, filename_list):
        """
        Read files from the directory
        """

        logger.INFO("Looking for files in the directory : '%s'" % read_dir)
        file_path_list = []
        # read files from dir
        file_list = self.get_files_from_dir(read_dir, filename_list)
        for each_file in file_list:

            file_ref, destination_path = FFTPLibHooks.fftplibrary_export_entry(self.read_mode, self.write_mode,
                                                                               each_file)
            if file_ref and type(file_ref) == str:
                each_file = file_ref
                file_path = os.path.join(read_dir, each_file)
                file_path, destination_path = FFTPLibHooks.fftplibrary_export_exit(self.read_mode, self.write_mode,
                                                                                   file_path)
            if file_path and type(file_path) == str:
                file_path_list.append(file_path)
                if destination_path:
                    self.config_data['TEMP_{}-{}'.format(self.read_mode, self.write_mode)][file_path] = destination_path

        return file_path_list

    def write(self, file_path_list, write_dir, temp_dest_dict={}):
        """ Writes file(s) to a directory"""
        read_file_path = None
        global file_write_result
        files_written_to_dest = []
        if file_path_list:
            read_file_path = os.path.dirname(file_path_list[0])
            read_file_path = self.get_mapped_network_path(read_file_path)
        if read_file_path != write_dir:
            for file_path in file_path_list:
                if temp_dest_dict:
                    temp_dest = temp_dest_dict.get(file_path)
                    if temp_dest:
                        write_dir = temp_dest
                file_path = FFTPLibHooks.fftplibrary_import_entry(self.read_mode, self.write_mode, file_path)
                if file_path and type(file_path) == str:
                    file_path = FFTPLibHooks.fftplibrary_import_exit(self.read_mode, self.write_mode, file_path)

                if file_path and type(file_path) == str:
                    try:
                        shutil.copy(file_path, write_dir)
                        files_written_to_dest.append(file_path)

                    except Exception as ex:
                        logger.ERROR("Error while copying file :%s " % ex)
                        file_write_result = 0
        else:
            files_written_to_dest = file_path_list
        return files_written_to_dest

    def get_files_from_dir(self, file_path, file_search_exp=None):
        """Get the list of files forom the input directory"""
        logger.DEBUG("Get files from directory")
        file_lst = []
        dir_path = self.get_mapped_network_path(file_path)
        global file_read_result
        if os.path.isdir(dir_path):
            dir_file_lst = [eachfile for eachfile in os.listdir(dir_path) if \
                            os.path.isfile(os.path.join(dir_path, eachfile))]
            if file_search_exp:
                logger.DEBUG("Searching for file/s with filter %s in directory '%s'" % (file_search_exp, dir_path))
                for file_exp in file_search_exp:
                    filter_file_lst = fnmatch.filter(dir_file_lst, file_exp)
                    if filter_file_lst:
                        file_lst.extend(filter_file_lst)
                    else:
                        if os.path.isfile((os.path.join(dir_path, file_exp))):
                            file_lst.extend(file_exp)
            else:
                file_lst = dir_file_lst
            if file_lst:
                logger.DEBUG("Found file/s %s" % file_lst)
            else:
                logger.ERROR("No matching files with filter %s found in '%s' directory" % (file_search_exp, dir_path))
                file_read_result = 0
        else:
            logger.ERROR("No directory named '%s' found" % dir_path)
            file_read_result = 0
        return set(file_lst)

    def get_mapped_network_path(self, dir_path):
        """Get the remote path for the mapped directory"""
        '''
        logger.DEBUG("Checking for Mapped network path")
        network_file_path = dir_path
        mapped_drive = dir_path[:2]
        network_drives = subprocess.check_output(['net', 'use'], shell=True).decode()  # get shared drives
        for row in network_drives.split("\n")[4:]:  # check each row after formatting
            split = row.split(':')
            if len(split) == 2:  # only check non-default shared drives
                if split[0].strip() == mapped_drive[0]:
                    mapped_netword_path = split[1].strip()
                    network_file_path = network_file_path.replace(mapped_drive, mapped_netword_path)
                    logger.INFO("Mapped directory for {} is {}.".format(mapped_drive[0], mapped_netword_path))
        '''
        return dir_path

    def copy_files_to_dir(self, file_list, source_dir, dest_dir):
        """Copy files to a directory"""
        logger.DEBUG("Copy files to a directory")
        try:
            for file_name in file_list:
                src_file = os.path.join(source_dir, file_name)
                dest_file = os.path.join(dest_dir, file_name)
                shutil.copy(src_file, dest_dir)
        except Exception as ex:
            logger.ERROR("Error while copying file : %s" % ex)

    def move_files_to_dir(self, file_list, source_dir, dest_dir):
        """Move files to a directory"""
        logger.DEBUG("Move files to a directory")
        dest_dir_path_list = []
        moved_files_count = 0
        try:
            for file_name in file_list:
                afile_name = self.get_archive_file_name(file_name)
                src_file = os.path.join(source_dir, file_name)
                dest_file = os.path.join(dest_dir, afile_name)
                dest_dir_path = shutil.move(src_file, dest_file)
                if dest_dir_path and os.path.isfile(dest_dir_path):
                    dest_dir_path_list.append(dest_dir_path)
        except Exception as ex:
            logger.ERROR("Error while moving files to directory : %s" % ex)
        
        moved_files_count = len(dest_dir_path_list) 
        return moved_files_count
    
    def get_archive_file_name(self, file_name):
        """Get archive file name by adding the current timestamp"""
        archive_file_name = file_name
        utc_time = acm.Time.LocalToUtc(acm.Time.TimeNow())

        if not self.donot_timestamp_archive_files:
            split_file_name, file_extn = os.path.splitext(archive_file_name)
            if file_extn:
                file_name_time_stamp = split_file_name + '_' + str(utc_time) + file_extn
            else:
                file_name_time_stamp = split_file_name + '_' + str(utc_time)

            archive_file_name = self.validate_file_name(file_name_time_stamp)
        return archive_file_name

    def validate_file_name(self, file_name):
        valid_file_name = ''
        for char_i in file_name:
            if char_i in [' ', '/', '\\']:
                char_i = '_'
            elif char_i in ['<', '>', ':', '"', '|', '?', '*', '-']:
                char_i = ''
            valid_file_name += char_i
        return valid_file_name

    def get_archive_dir(self, read_dir, archive_dir):
        """Creates the archive directory if does not exist"""
        if not os.path.dirname(archive_dir):
            archive_rel_path = os.path.relpath(archive_dir)
            archive_dir = os.path.join(read_dir, archive_rel_path)
            if not os.path.exists(archive_dir):
                try:
                    os.makedirs(archive_dir)
                except Exception as ex:
                    logger.ERROR("Error while creating archive directory %s" % ex)
        return archive_dir

    def archive_files(self, file_path_list, archive_dir):
        """Copy files to archive directory"""
        moved_files_count = 0
        source_dir = None
        if file_path_list:
            source_dir = os.path.dirname(file_path_list[0])
        if source_dir and archive_dir:
            file_list = [os.path.split(each_file)[1] for each_file in file_path_list]
            archive_dir = self.get_archive_dir(source_dir, archive_dir)
            if os.path.exists(archive_dir):
                moved_files_count = self.move_files_to_dir(file_list, source_dir, archive_dir)
            else:
                logger.ERROR("Archive path %s does not exist" % archive_dir)
        
        return moved_files_count 
    
    def remove_files(self, file_path_list):
        """Removes files from the provided directory"""
        for file_path in file_path_list:
            try:
                os.remove(file_path)
            except Exception as ex:
                logger.ERROR("%s" % ex)

    def close_connection(self):
        pass


def read_files_names_from_dir(source_dir, filename_list):
    """ API to get file names list 
    Input:
    read_dir : File directory 
    filename_list : Filter or file name list

    Output:
    filenamelist : File name list
    result : 1 on success, 0 on failure
    """
    if source_dir == '' :
        logger.ERROR('Source directory is empty. Please provide source directory')
        return [], 0
    if filename_list == '':
        logger.ERROR('File name or file filter is empty. Please provide source file name or file filter')
        return [], 0
    result = 1
    output_list = []
    dest_dir = ''
    global file_read_result
    try:
        dir_obj = DIROperations()
        output_list = dir_obj.read(source_dir, dest_dir, [filename_list])
        result = file_read_result
        file_read_result = 1
    except Exception as exp:
        logger.ERROR("Error in read_files_names_from_dir %s"%exp)
        result = 0
    return output_list, result
    

def write_files_to_dir(source_dir, filename_list, dest_dir, archive_files = False , archive_dir = ''):
    """ API to get file names list 
    Input:
    source_dir :Source  file directory 
    filename_list : Filter or file name list
    dest_dir: Destination file directory 
    archive_files : optional paramater, if user want to archieve files (True/False)
    archive_dir : optional paramater, archive file directory 
    Output:
    filenamelist : File name list
    result : 1 on success, 0 on failure
    """

    result = 0
    file_list = []
    written_file_list = []
    global file_write_result
    try:
        file_list , result = read_files_names_from_dir(source_dir, filename_list)
        dir_obj = DIROperations()
        
        if result and file_list :
            written_file_list = dir_obj.write(file_list, dest_dir)
            result = file_write_result
            file_write_result = 1
  
        if archive_files:
            if result == 0:
                logger.ERROR("Error while copying file to destination directory %s . Hence files will not be archived"%dest_dir)
                return written_file_list, result   
            moved_files_count = 0
            try:
                if not os.path.exists(archive_dir):
                    logger.INFO("Given archive directory is not exist, hence creating  archive directory %s"%archive_dir)
                    os.makedirs(archive_dir)
            
            except Exception as ex:
                log_archive_dir = ael.get_config_var('logdir')
                if log_archive_dir == None:
                    logger.INFO("Parameter logdir is not set in configuration. Please set logdir to create archive directory")
                    result = 0
                    return written_file_list, result
                else:
                    logger.INFO("Unable to create archive directory at  %s, creating archive directory at %s "%(archive_dir,log_archive_dir))
                    archive_files_folder = "ARCHIVE_FILES"
                    archive_dir = os.path.join(log_archive_dir, archive_files_folder)   
                    if not os.path.exists(archive_dir):
                        os.makedirs(archive_dir)

            if os.path.exists(archive_dir):
                logger.DEBUG("Archiving files to directory %s "%archive_dir)
                moved_files_count = dir_obj.archive_files(file_list, archive_dir)
                logger.DEBUG("%s files archived to archive directory %s"%(str(moved_files_count),archive_dir))
            else:
                 logger.ERROR("Files will not be archived")   
            if moved_files_count != len(file_list):
                result = 0 
                logger.ERROR("All files are not archived")       
    except Exception as exp:
        logger.ERROR("Error in write_files_to_dir %s"%exp)
        result = 0
    
    return written_file_list, result





...

  FFTPLibHooks
"""--------------------------------------------------------------------
MODULE
    FFTPLibHooks -  FFTPLibrary custom hook

DESCRIPTION
    This script defines extension point to extend the FFTPLibrary functionality.
    User should 

VERSION: 2.0.7

--------------------------------------------------------------------"""

import FFTPConfig
import FFTPNotification
logger = FFTPNotification.FFTPLogger('FFTPLibrary')

def amb_message_file_name(file_name, mb_message_str, org_mb_message_obj, file_path=''):
    """ Extension point to customize the name of file to export mb messages
    file_name = file_name as used by FFTPLibrary
    file_path = destination file path to export the amb message
    mb_message_str = message as string to export
    org_mb_message_obj = Original amb message object

    return
    file_path : customized file path
    file_name : customized file name
    """
    """
    #Example: For AMB-FTP mode , get the destination directory of FTP server from Fparameter: WRITE_SOURCE 
    #and add subdirectory to the path and return from the function
    import os
    ftp_mode_settings = FFTPConfig.Parameters('FFTPModeSettings_AMB-FTP')
    write_source = getattr(ftp_mode_settings, 'WRITE_SOURCE', None)
    file_path = os.path.join(write_source, 'SUB DIRECTORY')
    """
    return file_path, file_name


def amb_message_content(file_name, mb_message_str, org_mb_message_obj):
    """ Extension point to customize the name of file to export mb messages
    Input: file_name = file_name as used by FFTPLibrary
    mb_message_str = message as string to export
    org_mb_message_obj = Original amb message object

    """
    return mb_message_str


def fftplibrary_import_entry(from_mode, to_mode,  content_ref, content_handler=None, **kwargs):
    """
    Import entry hook to import data to modes : DIR, AMB, FTP, SFTP, before processing that data.
    :param from_mode: The mode from which the data is importing, value can be either of FTP, SFTP, AMB, DIR
    :param to_mode: The mode to which the data is importing,values can be either of FTP, SFTP, AMB, DIR
    :param content_ref: This is the data reference like amb message, FTP/SFTP file or dir file with path
    :param content_handler: This is object of the content reference like file handler, amb message obj.
    :return: Customized value of content_ref or content_handler
    """
    return content_handler if content_handler else content_ref

def fftplibrary_import_exit(from_mode, to_mode,  content_ref, content_handler=None, **kwargs):
    """
    Import exit hook to import data to modes : DIR, AMB, FTP, SFTP, after processing that data.
    :param from_mode: The mode from which the data is importing, value can be either of FTP, SFTP, AMB, DIR
    :param to_mode: The mode to which the data is importing, values can be either of FTP, SFTP, AMB, DIR
    :param content_ref: This is the data reference like amb message, FTP/SFTP file or dir file with path
    :param content_handler: This is object of the content reference like file handler, amb message obj.
    :return: Customized value of content_ref or content_handler
    """
    return content_handler if content_handler else content_ref


def fftplibrary_export_entry(from_mode, to_mode, content_ref, content_handler=None, **kwargs):
    """
    Export entry hook to export data from modes : DIR, AMB, FTP, SFTP, before processing that data.
    :param from_mode: The mode from which the data is exporting, value can be either of FTP, SFTP, AMB, DIR
    :param to_mode: The mode to which the data is exporting, values can be either of FTP, SFTP, AMB, DIR
    :param content_ref: This is the data reference like amb message, FTP/SFTP file or dir file with path
    :param content_handler: This is object of the content reference like file handler, amb message obj.
    :return: Customized value of content_ref or content_handler and
            destination path to which data need to export like FTP/SFTP dir path, local dir path and amb subject
    kwargs :  if from_mode == 'AMB' then {'msg_subject': <amb message subject>}
    """
    destination_path = ''
    """
    Example to change the destination path 
    if from_mode == 'FTP':
        if to_mode == 'DIR':
            destination_path = "C:\Projects\Destination_FTP\Temp"
    """

    """
    Example to stop reading file from FTP
    if from_mode == 'FTP':
        file_name = content_ref 
        if file_name == 'Provider_Data_Bloomberg.txt':
            content_ref = None
    """
    return content_handler if content_handler else content_ref, destination_path


def fftplibrary_export_exit(from_mode, to_mode, content_ref, content_handler=None, **kwargs):
    """
    Import entry hook to import data to modes : DIR, AMB, FTP, SFTP, after processing that data.
    :param from_mode: The mode from which the data is importing, value can be either of FTP, SFTP, AMB, DIR
    :param to_mode: The mode to which the data is importing,values can be either of FTP, SFTP, AMB, DIR
    :param content_ref: This is the data reference like amb message, FTP/SFTP file or dir file with path
    :param content_handler: This is object of the content reference like file handler, amb message obj.
    :return: Customized value of content_ref or content_handler and
            destination path to which data need to export like FTP/SFTP dir path, local dir path and amb subject
    kwargs :  if from_mode == 'AMB' then {'msg_subject': <amb message subject>}
    """
    destination_path = ''
    return content_handler if content_handler else content_ref, destination_path

def fftplibrary_get_external_password(application_name, user_name, host_name, certificate_file_path=None):
    """
    Using this hook we can set password for 2 or more users
    :param application_name: application name
    :param user_name: user name which we use in connection
    :param host_name: host name which we use in connection
    :param certificate_file_path: FTP TLS server certificate file name with path.
    :return: server password
    """
    """
    Example to get password
    if certificate_file_path:
        import os
        file_name = os.path.split(certificate_file_path)[-1]

    if application_name == 'FFTPLib-FTP' and user_name == 'FTP' and host_name == '127.0.0.1' and file_name == 'ServerCertificate.p12':
        pwd = 'Mp7ATqF1' # (example)
    elif application_name == 'FFTPLib-FTP' and user_name == 'FTP' and host_name == '127.0.0.1':
        pwd = 'Mp7ATqF1' # (example)
    elif application_name == 'FFTPLib-SFTP' and user_name == 'SFTP' and host_name == 'dlsftp.bbg.com':
        pwd = 'Mp7ATqF1' # (example)
    """
    
    """
    Example to get password using FPassword      
    new_application_name = application_name + "-" + user_name + "-" + host_name
    if certificate_file_path:
        import os
        file_name = os.path.split(certificate_file_path)[-1]
        new_application_name += "-" + file_name
    try:
        import FPassword
        pwd = FPassword.get_external_password(new_application_name)
        logger.DEBUG("imported FPassword module for application %s" % new_application_name)
    except:
        logger.INFO("Could not import FPassword module")
    """    
    pwd = None
    return pwd



...

  FFTPLibraryInstalledComponent
'''---------------------------------------------------------------------------------
 MODULE
    InstalledComponentFFTPLibrary

DESCRIPTION
    This module runs the TestMe, ConfigMe and LogMe for installed FFTPLibrary

VERSION: 2.0.7

---------------------------------------------------------------------------------'''
import InstalledComponentBase
import FFTPConfig

config_variables_obj = FFTPConfig.FTPConfigSingleton('FFTPLibrary')
config_data = config_variables_obj.config_data

class Diagnostics(InstalledComponentBase.InstalledComponentDiagnostics):
    def __init__(self):
        super(Diagnostics, self).__init__()
        self._name = 'FFTPLibrary'
        self._version = config_data.get('FFTPLIBRARY_VERSION', '').split('-')[0]
        self._moduleList = self.Get_Module_list()
        self._moduleVersions = {}
        self._description = "FFTPLibrary transfers files/amb messages between local directory, AMB, FTP and SFTP"
        self._releaseDate = config_data.get('FFTPLIBRARY_BUILD_DATE', '')
        self._isBuiltInModule = 'No'
        
    def Get_Module_list(self):
        dependent_module_supported_version_list = {'FANotification':'1.0.1', 'Chilkat':'9.5.0.93'}
        module_list = []
        for module, supported_version in dependent_module_supported_version_list.items():        
            installed_version = ''
            if module == 'FANotification':
                try:
                    import FANotificationInstalledComponent
                    obj=FANotificationInstalledComponent.Diagnostics()
                    installed_version = obj._version                
                except:
                    pass
            elif module == 'Chilkat':
                try:
                    from chilkat import chilkat
                    ftp = chilkat.CkFtp2()
                    installed_version = ftp.version()
                except:
                    pass            
            display_string =  module +  ' supported version:' + supported_version + '(current version:' + installed_version + ')'
            module_list.append(display_string)
        return module_list

...

  FFTPNotification
"""--------------------------------------------------------------------
MODULE
    FFTPNotification -  Creates FANotification class object for logging

VERSION: 2.0.7

--------------------------------------------------------------------"""
import acm
import FFTPConfig
import FANotification

config_obj = FFTPConfig.FTPConfigSingleton('FFTPLibrary')
config = config_obj.config_data

source = 'FFTPLibrary'
user = config.get('NOTIFY_USER')
if not user:
    user = acm.UserName()
    
amb_address = config.get('MESSAGE_BROKER')
notification_media = config.get('NOTIFICATION_MEDIA')
notify_level = config.get('NOTIFY_LEVEL')
log_level = config.get('LOGGING_LEVEL')
smtp_server = config.get('SMTP_SERVER')
user_email_list = config.get('USER_EMAIL')
application_name = config.get('FFTP_APPLICATION_NAME')

def FFTPLogger(source):
    logger = FANotification.FANotification(name=source, 
                    notification_media=notification_media, 
                    notify_level=notify_level,
                    logging_level=log_level, 
                    message_broker=amb_address, 
                    user=user, 
                    user_emails=user_email_list, 
                    smtp_server=smtp_server)
    return logger





...

  FFTPOperations
"""--------------------------------------------------------------------
MODULE
    FFTPOperations -  Operations like reading and writing to FTP server

DESCRIPTION
    This script handles the FTP operations.

VERSION: 2.0.7

--------------------------------------------------------------------"""
import os
import io
import time
import fnmatch
import ntpath

import FFTPConfig
import FFTPLibHooks
import FFTPNotification
import acm
import ael
from datetime import datetime
from FFTPDIROperations import DIROperations
logger = FFTPNotification.FFTPLogger('FFTPLibrary')
FTP_ERROR_codes = {'10052': 'Network dropped connection on reset',
                   '10053': 'Connection abort',
                   '10054': 'Connection reset by peer',
                   '10060': 'Connection timed out',
                   '10061': 'Connection refused'
                   }

file_download_result = 1
class FTPOperations(object):
    def __init__(self, application_name, host=None, port=None, user=None, pwd=None, timeout=0, interval=0, retry=0,
                 config_variables_obj=None, *args):
        self.application_name = application_name
        self.host = host
        self.port = port
        self.user = user
        self.pwd = pwd
        self.interval = interval
        self.timeout = timeout
        self.retry = retry
        if not self.pwd:
            self.pwd = self.get_password_from_hook(self.application_name, self.user, self.host)
        self.ftp = self.connect()
        config_variables_obj = config_variables_obj
        self.config_data = config_variables_obj.config_data if config_variables_obj else {}
        self.read_mode = self.config_data.get('FROM_MODE', 'FTP')
        self.write_mode = self.config_data.get('TO_MODE', '')
        self.check_empty_parameters()
    
    def check_empty_parameters(self):
        """checks empty parameter for FTP connection"""
        config = 'FFTPModeSettings_' + self.read_mode + "-" + self.write_mode        
        reader = True if self.read_mode == "FTP" else False

        if not self.host:
            if reader:
                logger.ERROR("Configuration parameters 'READ_HOST' is missing. Please check %s" % config)
            else:
                logger.ERROR("Configuration parameters 'WRITE_HOST' is missing. Please check %s" % config)
        if not self.port:
            if reader:
                logger.ERROR("Configuration parameters 'READ_PORT' is missing. Please check %s" % config)
            else:
                logger.ERROR("Configuration parameters 'WRITE_PORT' is missing. Please check %s" % config)

        if not self.user:
            if reader:
                logger.ERROR("Configuration parameters 'READ_USER' is missing. Please check %s" % config)
            else:
                logger.ERROR("Configuration parameters 'WRITE_USER' is missing. Please check %s" % config)

        if not self.pwd:
            if reader:
                logger.ERROR("Configuration parameters 'READ_PASSWORD' is missing. Please check %s" % config)
            else:
                logger.ERROR("Configuration parameters 'WRITE_PASSWORD' is missing. Please check %s" % config)
                    
    @classmethod
    def initialize(cls, mode, reader, task_parameters, config_variables_obj=None):
        ftp_config_param = FFTPConfig.Parameters('FFTPSettings')
        interval = getattr(ftp_config_param, 'POLL_INTERVAL', '')
        timeout = getattr(ftp_config_param, 'POLL_TIMEOUT', '')
        retry = getattr(ftp_config_param, 'POLL_RETRY', '')        
        pwd = None
        user = None
        host = None
        port = None
        if mode.split('-')[0] == 'FTP' and reader:
            if task_parameters:
                host = task_parameters.get('READ_HOST', '')
                port = task_parameters.get('READ_PORT', '')
                user = task_parameters.get('READ_USER', '')
                pwd = task_parameters.get('READ_PASSWORD', '')
            else:
                mode_config_param = FFTPConfig.Parameters('FFTPModeSettings_' + mode)
                host = getattr(mode_config_param, 'READ_HOST', '')
                port = getattr(mode_config_param, 'READ_PORT', '')
                user = getattr(mode_config_param, 'READ_USER', '')
                pwd = getattr(mode_config_param, 'READ_PASSWORD', '')                

                if not (host and port and user ):
                    host = getattr(ftp_config_param, 'READ_HOST', '')
                    port = getattr(ftp_config_param, 'READ_PORT', '')
                    user = getattr(ftp_config_param, 'READ_USER', '')
                if not pwd:    
                    pwd = getattr(ftp_config_param, 'READ_PASSWORD', '')
                    
        elif mode.split('-')[1] == 'FTP':
            if task_parameters:
                host = task_parameters.get('WRITE_HOST', '')
                port = task_parameters.get('WRITE_PORT', '')
                user = task_parameters.get('WRITE_USER', '')
                pwd = task_parameters.get('WRITE_PASSWORD', '')
            else:
                mode_config_param = FFTPConfig.Parameters('FFTPModeSettings_' + mode)
                host = getattr(mode_config_param, 'WRITE_HOST', '')
                port = getattr(mode_config_param, 'WRITE_PORT', '')
                user = getattr(mode_config_param, 'WRITE_USER', '')
                pwd = getattr(mode_config_param, 'WRITE_PASSWORD', '')

                if not (host and port and user ):
                    host = getattr(ftp_config_param, 'WRITE_HOST', '')
                    port = getattr(ftp_config_param, 'WRITE_PORT', '')
                    user = getattr(ftp_config_param, 'WRITE_USER', '')
                if not pwd:
                    pwd = getattr(ftp_config_param, 'WRITE_PASSWORD', '')                    
        
        ftp_config_param = FFTPConfig.Parameters('FFTPSettings')
        application_name = getattr(ftp_config_param, 'FFTPLib_APPLICATION_NAME', '')
        if mode.split('-')[1] == mode.split('-')[0]:
            application_name = application_name + "-" + user 
                        
        obj = cls(application_name, host, port, user, pwd, timeout, interval, retry, config_variables_obj=config_variables_obj)        

        if not obj.ftp:
            return None
        return obj

    def connect(self):
        """Connection to FTP server"""
        ftp = None
        try:
            from chilkat import chilkat
            glob = chilkat.CkGlobal()
            glob.UnlockBundle("FSLTNS.CB4032023_xPv5yNngkRpl")

            ftp = chilkat.CkFtp2()
            ftp.put_Passive(False)  
            ftp.put_Hostname(self.host)
            ftp.put_Port(int(self.port))
            if self.user and self.pwd:
                ftp.put_Username(self.user)
                ftp.put_Password(self.pwd)
            else:    
                ftp.put_Username('anonymous')
                ftp.put_Password('')
                
            success = ftp.Connect()
            if (success != True):
                logger.ERROR("Unable to connect to FTP server %s using chilkat. Error code  %s" %(self.host, str(ftp.get_ConnectFailReason())))
                logger.ERROR(ftp.lastErrorText())
                ftp = None
            else:
                logger.DEBUG('Connected to FTP server <%s> using chilkat' % (self.host))
                
        except Exception as e:
            logger.ERROR("Connection to FTP server <%s> failed ." % str(self.host))
            logger.ERROR(str(e))
            ftp = None
        return ftp

    def retry_ftp_connection(self):
        """Retry FTP connection"""
        ftp_connected = False
        poll_retry = int(self.retry)
        logger.INFO("Re-connecting FTP server")
        for i in range(0, poll_retry ):
            if self.interval:
                retry_interval = self.interval
            else:
                retry_interval = 10
                logger.DEBUG("Default retry interval is {}".format(retry_interval))
            logger.INFO("~ %s in %s retry" % (str(retry_interval), str(i + 1)))
            time.sleep(int(retry_interval))
            # logger.DEBUG("Reconnecting to server")
            self.ftp = self.connect()
            if self.ftp:
                ftp_connected = True
                break
        return ftp_connected
                 
    def retry_ftp_connection_if_disconnected(self): 
        """Check connection to ftp server. If not connected then again try to re-connect"""
        ftp_connected = False
        try:
            if self.ftp:
                ftp_connected = self.ftp.CheckConnection() 
            if not ftp_connected:
                ftp_connected = self.retry_ftp_connection()
        except Exception as e:
            logger.ERROR("Error while connecting to FTP server :- {}".format(str(e)))
                        
        return ftp_connected
                
    def poll_until_timeout(self, file_name, timeout, interval):
        """This method polls to FTP for a given time period at given
        interval of time If the reply file is
        present before the timeout then the result is returned.

        """
        file_list = []
        self.time_seconds = 0
        poll_start_time = time.time()
        if int(timeout):
            logger.INFO("Waiting for a file <{}> to download".format(file_name))
            while self.time_seconds < int(timeout):

                time.sleep(float(interval))
                seconds = str(self.time_seconds + \
                              int(interval)) + 's'
                msg = '~' + str(seconds) + ' ...'
                logger.INFO(msg)
                file_list = self.poll_for_file(file_name)
                if file_list:
                    return file_list

                self.time_seconds = self.time_seconds + \
                                    int(interval)
        else:
            file_list = self.poll_for_file(file_name)
        return file_list

    def poll_for_file(self, file_name):
        """This method polls for the reply file at ftp.
        True - if file exists at ftp server.
        false - if no file exists at ftp server.

        """
        ftp_connection = True
        filter_file_lst = []
        remote_file_count= 0
        try:
            file_lst = []
            remote_file_count = self.ftp.GetDirCount()
            if remote_file_count and remote_file_count > 0:
                for remote_file in range(0, remote_file_count):
                    file_lst.append(self.ftp.getFilename(remote_file))
            
            filter_file_lst = fnmatch.filter(file_lst, file_name)    

        except Exception as e:
            logger.ERROR("Error while fetching reply file from FTP server : %s" % str(e))
            for error_code in FTP_ERROR_codes.keys():
                if error_code in str(e):
                    ftp_connection = False

        if not ftp_connection:
            logger.WARN("FTP is down, Trying to connect again")
            connected = self.retry_ftp_connection()
            if connected:
                self.poll_for_file(file_name)

        return filter_file_lst

    def upload_file(self, file_path, ftp_dir=None):
        """Uploads a file to the FTP server.
        Input - request file name to upload, request file path.

        """
        ftp_dir_set = 0
        ftp_connection = 1
        result = 1
        if self.ftp:
            if ftp_dir:
                result = self.change_ftp_dir(ftp_dir)
                if result == 0:
                    return result
                ftp_dir_set = 1

            try:
                file_name = os.path.split(file_path)[-1]
                file_handler = open(file_path, 'rb')

                file_ref = FFTPLibHooks.fftplibrary_import_exit(self.read_mode, self.write_mode, file_path,
                                                                file_handler)

                if file_ref and isinstance(file_ref, io.BufferedReader):
                    file_handler = file_ref
                    file_path = file_ref.name
                else:
                    file_path = file_ref

                if file_handler:
                    file_handler.close()

                
                success = self.ftp.PutFile(file_path, file_name)
                
                if success:
                    logger.INFO("File uploaded to FTP server %s at path %s" % (file_name, ftp_dir))
                    result = 1
                else:
                    result = 0
                    logger.ERROR(self.ftp.lastErrorText())
                
                if ftp_dir_set == 1:
                    self.change_ftp_dir('/')

            except Exception as e:
                logger.ERROR("Error while uploading file to FTP server : %s" % str(e))
                result = 0
                for error_code in FTP_ERROR_codes.keys():
                    if error_code in str(e):
                        ftp_connection = 0

            if not ftp_connection:
                logger.WARN("FTP is not connected while uploading file, Trying to re-connect")
                connected = self.retry_ftp_connection()
                if connected:
                    self.upload_file(file_path, ftp_dir)
                else:
                    result = 0
        else:
            result = 0

        return result

    def download_file(self, filename_lst, download_dir, ftp_dir=None):
        """Downloads a file from the FTP.
        retrbinary is used to download binary files.
        Input - reply file name, reply file path to download.
        Output - List of downloaded files from FTP server.

        """
        downloaded_file_list = []
        global file_download_result
        ftp_dir_set = 0
        if not filename_lst:
            logger.WARN("Download file name is not provided, Check file name or the READ_SOURCE FParameter")
            return downloaded_file_list

        if ftp_dir:
            ftp_dir_set = self.change_ftp_dir(ftp_dir)
            if ftp_dir_set == 0:
                return downloaded_file_list
                
        try:            
            logger.DEBUG("Downloading files to dir <%s>" % download_dir)

            for file_name in filename_lst:
                file_list = self.poll_until_timeout(file_name, self.timeout, self.interval)

                if file_list:
                    for file_name in file_list:
                        tmp_file_name = file_name
                        file_name, destination_path = FFTPLibHooks.fftplibrary_export_entry(self.read_mode,
                                                                                            self.write_mode, file_name)
                        if file_name and type(file_name) == str:
                            if destination_path:
                                if self.write_mode == 'DIR':
                                    download_dir = destination_path
                                else:
                                    file_path = os.path.join(download_dir, file_name)
                                    self.config_data['TEMP_{}-{}'.format(self.read_mode, self.write_mode)][
                                        file_path] = destination_path

                            result = self._download_from_file(file_name, download_dir)
                            if result == 0:
                                file_download_result = 0
                            if result:
                                downloaded_file_list.append(file_name)
                        else:
                            logger.ERROR(
                                "File {} is filtered in fftplibrary_export_entry, returns: {}".format(tmp_file_name,
                                                                                                      str(file_name)))
                            file_download_result = 0

                else:
                    logger.WARN("No File match with the filter provided to download from FTP Server.")
                    file_download_result = 0

        except IOError as e:
            logger.ERROR('FTP Error: %s' % str(e))
            file_download_result = 0
        except Exception as e:
            logger.ERROR('FTP Error: %s' % str(e))
            file_download_result = 0
        finally:
            if ftp_dir_set: 
                ftp_dir_set = self.change_ftp_dir('/')
                
        return downloaded_file_list
        
    def _download_from_file(self, file_name, download_dir):
        """Download file from FTP"""  

        ftp_connection = 1
        result = 0
        try:
            file_path = os.path.join(download_dir, file_name)
            success = self.ftp.GetFile(file_name, file_path) 
            if success:
                logger.INFO("Downloaded file <%s> from FTP server. Applying hook" % file_name)
                result = 1
            else:
                logger.ERROR(self.ftp.lastErrorText())
                
            
            file_handler = open(file_path, 'ab')
            if file_handler:
                # export exit hook for amb message
                file_ref, destination_path = FFTPLibHooks.fftplibrary_export_exit(self.read_mode, self.write_mode,
                                                                                      file_path, file_handler)
    
                    # Check the return valaue is file handler or file path
                if isinstance(file_ref, io.BufferedWriter):
                    file_handler = file_ref
                    file_path = file_ref.name
                else:
                    file_path = file_ref
    
                    # close tthe file handler
                if file_handler:
                    file_handler.close()
    
                    # Set the return destination path from extension point
                if file_path:
                    if destination_path:
                        self.config_data['TEMP_{}-{}'.format(self.read_mode, self.write_mode)][
                            file_path] = destination_path
    

        except Exception as e:
            logger.ERROR("Error while downloading file %s from FTP : %s" % (file_name, str(e)))
            for error_code in FTP_ERROR_codes.keys():
                if error_code in str(e):
                    ftp_connection = 0

        if not ftp_connection:
            logger.WARN("FTP is down, Trying to connect again")
            connected = self.retry_ftp_connection()
            if connected:
                result = self._download_from_file(download_dir, file_name)
        return result

    def change_ftp_dir(self, ftp_dir):
        """
        Change the ftp directory path to copy the file in provided directory
        :param ftp_dir: ftp directory path
        :return: result as boolean
        """
        result = 0
        is_connected = True
        global file_download_result
        try:
            success = self.ftp.ChangeRemoteDir(ftp_dir)
            if (success != True):
                logger.ERROR(self.ftp.lastErrorText())
                file_download_result = 0
            else:
                result = 1
        except Exception as e:
            file_download_result = 0
            logger.ERROR("Error while changing FTP directory %s : %s" % (ftp_dir,str(e)))
            for error_code in FTP_ERROR_codes.keys():
                if error_code in str(e):
                    is_connected = False
                    
        if not is_connected:
            connected = self.retry_ftp_connection()
            if connected:
                self.change_ftp_dir(ftp_dir)
            else:
                logger.WARN("Cannot connect to FTP after retry, FTP directory path cannot be changed")
        return result

    def get_file_modified_timestamp(self, file_name, dir_path=None):
        """
        Get the modified timestamp of the file on FTP server.
        :param file_name: file name on FTP server
        :return: return the timestamp of file
        """
        is_connected = True
        timestamp = ''
        try:
            timestamp = self.ftp.getLastModifiedTimeByNameStr(file_name)
            if timestamp:
                timestamp = timestamp[5:25].strip()
                obj_datetime = datetime.strptime(str(timestamp), '%d %b %Y %H:%M:%S')
                timestamp = obj_datetime.strftime("%Y%m%d%H%M%S.000000")
            else:
                logger.DEBUG("Unable to get modified time of file %s from FTP" % file_name)
                is_connected = self.ftp.CheckConnection()
        except Exception as e:
            logger.ERROR("Error while fetching modified time of file %s from FTP : %s" % (file_name,str(e)))
            for error_code in FTP_ERROR_codes.keys():
                if error_code in str(e):
                    is_connected = False

        if not is_connected:
            connected = self.retry_ftp_connection()
            if connected:
                self.change_ftp_dir(dir_path) 
                timestamp = self.get_file_modified_timestamp(file_name, dir_path)
        return timestamp

    def utc_to_local(self, utc_date_string):
        """
        Covert date string from UTC date string to local date string
        :param utc_date_string: date string
        :return: date string in local time
        """
        import calendar
        from datetime import datetime, timedelta
        try:            
            if len(utc_date_string) >= 18:
                ael_date = ael.date_from_string(utc_date_string[0:8])
                year_month_date = ael_date.to_string(ael.DATE_ISO)
            
                hour_min_sec_milisec_list = utc_date_string.split(utc_date_string[0:8])[1].split(".")
                hour_min_sec = hour_min_sec_milisec_list[0]
                milisec = hour_min_sec_milisec_list[1]
                str_hour_min_sec_in_format = ':'.join(hour_min_sec[i:i+2] for i in range(0, len(hour_min_sec), 2))            
                
                str_utc_to_local = year_month_date + " " + str_hour_min_sec_in_format + "." + milisec
                utc_local_time = acm.Time().UtcToLocal(str_utc_to_local) #str '2023-03-19 04:23:25.554000'
                
                #above acm.Time API don't return milliseconds if it zero, so adding it manually. ex '2023-02-28 09:43:21'
                if len(utc_local_time) == 19:
                    utc_local_time = utc_local_time + ".000000"

                return utc_local_time
            else:
                return str(timedelta(microseconds=1))
        except Exception as e:
            logger.ERROR("Error while converting UTC time to local time %s " % str(e) )
            return str(timedelta(microseconds=1))
        
    def local_to_utc(self, local_date_string):
        """Covert date string from local date string to utc date string"""
        utc_time = acm.Time().LocalToUtc(local_date_string) #str '2023-03-19 04:23:25.554000'
        
        #above acm.Time API don't return milliseconds if it zero, so adding it manually. ex '2023-02-28 09:43:21'
        if len(utc_time) == 19:
            utc_time = utc_time + ".000000"
                    
        return utc_time

    def read(self, ftp_dir, dest_dir, filename_lst):
        """
        download files from the FTP directory
        :param ftp_dir: directory on FTP server
        :param dest_dir: local directory to copy files
        :param filename_lst: list of files to download from FTP
        :return:
        """
        file_path_list = []
        if not self.ftp:
            self.ftp = self.connect()

        download_file_list = self.download_file(filename_lst, dest_dir, ftp_dir)
        if download_file_list:
            for each_file in download_file_list:
                file_path_list = [os.path.join(dest_dir, each_file) for each_file in download_file_list]
        return file_path_list

    def write(self, file_path_list, ftp_dir, temp_dest_dict={}):
        """Upload files to FTP """
        files_written_to_dest = []

        if not self.ftp:
            self.ftp = self.connect()

        for file_path in file_path_list:
            tmp_file_path = file_path
            if temp_dest_dict:
                temp_dest = temp_dest_dict.get(file_path)
                if temp_dest:
                    ftp_dir = temp_dest
            file_ref = FFTPLibHooks.fftplibrary_import_entry(self.read_mode, self.write_mode, file_path)

            if file_ref and type(file_ref) == str:
                file_path = file_ref
                result = self.upload_file(file_path, ftp_dir)
                if result:
                    files_written_to_dest.append(file_path)
            else:
                logger.WARN(
                    "File {} is filtered in fftplibrary_import_entry which returned value: {}".format(tmp_file_path,
                                                                                                      str(file_ref)))

        return files_written_to_dest
    
    def get_password_from_hook(self, application_name, user_name, host_name, certificate_file_path=None):
        """ get psw from FTPLibPassword or FPassword hook """        
        pwd = FFTPLibHooks.fftplibrary_get_external_password(application_name, user_name, host_name, certificate_file_path)
        if not pwd:
            try:
                import FPassword
                pwd = FPassword.get_external_password(application_name)
                logger.DEBUG("Imported FPassword module for application %s" % application_name)
            except:
                logger.INFO("Could not import FPassword module")
        return pwd

    def close_connection(self):
        """Close the FTP connection"""
        if self.ftp:
            try:
                success = self.ftp.Disconnect()
                if (success == True):
                    logger.INFO("FTP Connection closed successfully")
                else:
                    logger.ERROR("FTP Connection not closed successfully. %s" % self.ftp.lastErrorText())
            except Exception as ex:
                logger.ERROR("Error while closing FTP connection %s" % str(ex))


def split_connection_str(connstr):
    conn_param_lst = connstr.split(':')
    host, port, user, pwd = '', '', '', ''
    connection_param_dict = {'host': '', 'port': '', 'user': '', 'password':''}
    if len(conn_param_lst) > 2:
        host = conn_param_lst[0]
        port = conn_param_lst[1] 
        connection_param_dict["host"] = conn_param_lst[0]
        connection_param_dict["port"] = conn_param_lst[1] 
    if len(conn_param_lst) >= 3:
        user = conn_param_lst[2]
        connection_param_dict["user"] = conn_param_lst[2]
    if len(conn_param_lst) == 4: 
        pwd = conn_param_lst[3] 
        connection_param_dict["password"] = conn_param_lst[3]    
    
    for connection_key, connection_val in connection_param_dict.items():
        if connection_val == "" and connection_key != 'password' :
            logger.ERROR("%s is empty, Please give value to %s"%(connection_key,connection_key) )
        
    return host, port, user, pwd

def check_ftp_object(ftp_obj):
    """Check ftp object  """
    ftp_object_initialized = True
    if not ftp_obj.ftp:
        ftp_object_initialized = False
        try:
            poll_retry = int(ftp_obj.retry)
            if poll_retry:
                ftp_object_initialized = ftp_obj.retry_ftp_connection()
        except Exception as exp:
            logger.ERROR(str(exp))
        
        if not ftp_object_initialized:
            logger.INFO("Login to FTP server is unsuccessful. Please check host, port, username (check if password is provided or check in FPassword hook against application name )")
    return ftp_object_initialized

def read_from_ftp(download_dir, connstr, \
                  ftp_dir, timeout=0, interval=0, retry=0, app_name= ''):
    """ Download file from FTP server to local directory
    Input:
    download_dir: Local directory on which files are downloaded
    connstr: Connection string Format localhost:port:username:password
    ftp_dir: FTP server directory
    timeout: Time in seconds to time-out the polling operation for files on the Provider FTP server
    interval: Interval between two successive polls on the FTP server.
    retry: The ATS resends the request to the FTP server
    app_name: Apllication name
    Output:
    result : 1 on success, 0 on failure
    """

    global file_download_result
    result = 0
    download_dir_lst = FFTPConfig.string_as_list(download_dir)
    ftp_dir_lst = FFTPConfig.string_as_list(ftp_dir)
    source_dict = {}
    destination = download_dir_lst[0]
    if len(download_dir_lst) > 1 and len(download_dir_lst) == len(ftp_dir_lst):
        source_dict = dict(list(zip(ftp_dir_lst, download_dir_lst)))
    elif len(download_dir_lst) > 1:
        logger.ERROR("Invalid download_dir / ftp_dir provided as input to API")
        return result

    if connstr:
        host, port, user, pwd = split_connection_str(connstr)   
        ftp_obj = FTPOperations(app_name, host, port, user, pwd, timeout, interval, retry)
        if not check_ftp_object(ftp_obj):
            return result
        for each_source in ftp_dir_lst:
            if source_dict:
                destination = source_dict[each_source]
            ftp_dir, filter = ntpath.split(os.path.expandvars(each_source))

            file_list = ftp_obj.download_file(filename_lst=[filter], \
                                           download_dir=destination, ftp_dir=ftp_dir)
            
            logger.DEBUG("%s files downloaded to %s"%(str(len(file_list)), destination))
            
                
        result = file_download_result
        file_download_result =  1
        ftp_obj.close_connection()
    else:
        logger.ERROR("Please give host, port, username, password(optional) in format HOST:PORT:USERNAME:PASSWORD  to run api read_from_ftp")
        result = 0

    return result
  
def write_to_ftp(file_path, connstr, ftp_dir='',
                 timeout=0, interval=0, retry=0, app_name= ''):
    """ Writes an file to FTP server at specified directory 
    Input:
    file_path: File path  
    connstr: Connection string Format localhost:port:username:password
    ftp_dir: FTP server directory
    timeout: Time in seconds to time-out the polling operation for files on the Provider FTP server
    interval: Interval between two successive polls on the FTP server.
    retry:The ATS resends the request to the FTP server
    app_name: Apllication name
    Output:
    result : 1 on success, 0 on failure
    """
    try:

        result = 0
        file_path_lst = FFTPConfig.string_as_list(file_path)
        ftp_dir_lst = FFTPConfig.string_as_list(ftp_dir)
        source_dict = {}
        destination = ftp_dir_lst[0]
        dir_obj = DIROperations()
        temp_file_str = ''
        
        if len(ftp_dir_lst) > 1 and len(ftp_dir_lst) == len(file_path_lst):
            source_dict = dict(list(zip(file_path_lst, ftp_dir_lst)))
        elif len(ftp_dir_lst) > 1:
            logger.ERROR("Invalid file_path / ftp_dir provided as input to API")
            return result

        if connstr:
            host, port, user, pwd = split_connection_str(connstr)
            if host:
                file_upload_flag = True
                ftp_obj = FTPOperations(app_name, host, port, user, pwd, timeout, interval, retry)
                if not check_ftp_object(ftp_obj) :
                    return result
                for file_path in file_path_lst:
                    if source_dict:
                        destination = source_dict[file_path]
                    if os.path.isfile(file_path):
                        result = ftp_obj.upload_file(file_path, destination)
                    else:
                        dir_path, filter = ntpath.split(os.path.expandvars(file_path))
                        file_path_list = dir_obj.read(dir_path, temp_file_str, [filter])
                        for files in file_path_list:                            
                            result = ftp_obj.upload_file(files, destination)
                            if result == 0:
                                file_upload_flag = False
                        if len(file_path_list) == 0:
                            result = 0
                    if result == 0:
                        file_upload_flag = False
                if not file_upload_flag:
                    result = 0
                ftp_obj.close_connection()
            else:
                logger.ERROR("FTP host name not provided by user")
        else:
            logger.ERROR("Please give host, port, username, password (optional) in format HOST:PORT:USERNAME:PASSWORD to run api write_to_ftp")
                   
    except Exception as e:
        logger.ERROR("Error in write_to_ftp %s "%(e))
        result = 0
            
    return result



...

  FFTPTasks
"""-------------------------------------------------------------------
MODULE
    FTPTasks - Module to create FTP ATS Tasks

DESCRIPTION
    This is a file which is saved as a python module for created
    FTP Library Tasks. The file executes when the ATS runs the
    scheduled job.

VERSION: 2.0.7

-------------------------------------------------------------------"""

import os
import acm

import FFTPConfig
import FFTPNotification
from FFTPController import FTPController

logger = FFTPNotification.FFTPLogger('FFTPLibrary')

#config_obj = FFTPConfig.FTPConfigSingleton('FFTPLibrary')
#config = config_obj.config_data

mode_config_param = FFTPConfig.Parameters('FFTPModeSettings')


#Below are the tool tip variables.
tt_read_mode = '''
Select read mode
'''

tt_write_mode = '''
Select write mode
'''

tt_read_source = '''
Enter read source
'''

tt_write_source = '''
Enter write source
'''

tt_read_ftp_details = '''
Enter the read FTP credential in format Host:Port:User:Password
'''

tt_write_ftp_details  = '''
Enter the write FTP credential in format Host:Port:User:Password
'''

tt_file_name_exp = '''
Enter the file search expression which needs to be sent to destination
'''

tt_amb_msg_file_name = '''
Enter AMB message file name
'''

tt_ftp_tls = '''
FTP with TLS
'''

tt_ftp_tls_certificate = '''
FTP TLS Server Certificate Path
'''

tt_ftp_tls_psw = '''
FTP TLS Server Certificate Password
'''

def get_read_mode():
    return ['FTP','SFTP','DIR','AMB']

def get_write_mode():
    return ['FTP','SFTP','DIR','AMB']

Index_read_mode                  = 0
Index_read_ftptls                = 1
Index_read_ftptls_certificate    = 2
Index_read_ftptls_psw            = 3
Index_write_mode                 = 4
Index_write_ftptls               = 5
Index_write_ftptls_certificate   = 6
Index_write_ftptls_psw           = 7
Index_read_source                = 8
Index_write_source               = 9
Index_archive_source             = 10
Index_read_file_filter           = 11
Index_amb_msg_file_name          = 12
Index_read_ftp_details           = 13
Index_write_ftp_details          = 14
Index_temp_file_path             = 15

#[5]=Mandatory or not. [9]=Enable/Disable
def disable_read_mode_fields(index, fieldValues):
    if fieldValues[index] in ['FTP', 'SFTP']:
        ael_variables[Index_read_ftp_details][9] = 1
    else:
        ael_variables[Index_read_ftp_details][9] = 0

    if fieldValues[index] == 'AMB':
        ael_variables[Index_amb_msg_file_name][9] = 1
        ael_variables[Index_read_file_filter][9] = 0
        ael_variables[Index_read_file_filter][5] = 0
        fieldValues[Index_read_file_filter] = ''
    else:
        ael_variables[Index_amb_msg_file_name][9] = 0
        ael_variables[Index_read_file_filter][9] = 1
        ael_variables[Index_read_file_filter][5] = 1

    if fieldValues[index] in ['DIR']:
        ael_variables[Index_archive_source][9] = 1
    else:
        ael_variables[Index_archive_source][9] = 0
        ael_variables[Index_archive_source][5] = 0
        ael_variables[Index_temp_file_path][9] = 1
        ael_variables[Index_temp_file_path][5] = 1

    if fieldValues[index] in ['DIR'] or fieldValues[index+2] in ['DIR'] :
        ael_variables[Index_temp_file_path][9] = 0
        ael_variables[Index_temp_file_path][5] = 0
    else:
        ael_variables[Index_temp_file_path][9] = 1
        ael_variables[Index_temp_file_path][5] = 1

    if fieldValues[index] == 'FTP':
        ael_variables[Index_read_ftptls][9] = 1
    else:
        ael_variables[Index_read_ftptls][9] = 0        
        ael_variables[Index_read_ftptls_certificate][9] = 0
        ael_variables[Index_read_ftptls_psw][9] = 0
        fieldValues[Index_read_ftptls] = 0
        fieldValues[Index_read_ftptls_certificate] = None
        fieldValues[Index_read_ftptls_psw] = None
    
    return fieldValues

#[5]=Mandatory or not. [9]=Enable/Disable
def disable_write_mode_fields(index, fieldValues):
    if fieldValues[index] in ['FTP', 'SFTP']:
        ael_variables[Index_write_ftp_details][9] = 1
    else:
        ael_variables[Index_write_ftp_details][9] = 0

    if fieldValues[index] in ['DIR'] or fieldValues[index-2] in ['DIR'] :
        ael_variables[Index_temp_file_path][9] = 0
        ael_variables[Index_temp_file_path][5] = 0
    else:
        ael_variables[Index_temp_file_path][9] = 1
        ael_variables[Index_temp_file_path][5] = 1

    if fieldValues[index] == 'FTP':
        ael_variables[Index_write_ftptls][9] = 1
    else:
        ael_variables[Index_write_ftptls][9] = 0        
        ael_variables[Index_write_ftptls_certificate][9] = 0
        ael_variables[Index_write_ftptls_psw][9] = 0
        fieldValues[Index_write_ftptls] = 0
        fieldValues[Index_write_ftptls_certificate] = None
        fieldValues[Index_write_ftptls_psw] = None

    return fieldValues
 
def enable_disable_ftptls_fields(index, fieldValues):
    """ Enable/Disable FTPTLS read/write GUI. [5]=Mandatory or not. [9]=Enable/Disable. """
    if index == Index_read_ftptls:
        bChekedOrUnChecked = int(fieldValues[Index_read_ftptls])
        if bChekedOrUnChecked == 1:
            ael_variables[Index_read_ftptls_certificate][9] = 1
            ael_variables[Index_read_ftptls_psw][9] = 1
        else:
            ael_variables[Index_read_ftptls_certificate][9] = 0
            ael_variables[Index_read_ftptls_psw][9] = 0
            fieldValues[Index_read_ftptls_certificate] = None
            fieldValues[Index_read_ftptls_psw] = None
    elif index == Index_write_ftptls:
        bChekedOrUnChecked = int(fieldValues[Index_write_ftptls])
        if bChekedOrUnChecked == 1:
            ael_variables[Index_write_ftptls_certificate][9] = 1
            ael_variables[Index_write_ftptls_psw][9] = 1
        else:
            ael_variables[Index_write_ftptls_certificate][9] = 0
            ael_variables[Index_write_ftptls_psw][9] = 0
            fieldValues[Index_write_ftptls_certificate] = None
            fieldValues[Index_write_ftptls_psw] = None
        
    return fieldValues

ael_gui_parameters = {
                        'runButtonLabel': '&&OK',
                        'hideExtraControls': False
                     }


mode = getattr(mode_config_param, 'MODE', '')
read_mode = ''
write_mode = ''
if mode:
    first_mode = mode.split(',')[0]    
    read_mode = first_mode.split('-')[0]    
    write_mode = first_mode.split('-')[1]    

ael_variables = [\

#FTP Library is a tab name.
# 0-name, 1-field name_tabname, 2-data_type, 3-values, 4-default value, 5-Mandatory, 6-'Multiple selection', 7-tooltip, 8-callback method, 9-enable/disable

# List box to select a Read Mode
['read_mode', 'Read Mode_FTP Library', 'string', get_read_mode(), read_mode, 1, 0, tt_read_mode, disable_read_mode_fields, 1],

#check box for select FTP TLS
['read_ftptls', 'Read FTP TLS_FTP Library', 'int', [0, 1], 0, 1, 0, tt_ftp_tls, enable_disable_ftptls_fields, 1],

#FTP TLS Certificate path
['read_ftptls_certificate', 'Certificate Path_FTP Library', 'string', None, '', 0, 0, tt_ftp_tls_certificate, 0, 1],

#FTP TLS Password
['read_ftptls_psw', 'Certificate Password_FTP Library', 'string', None, '', 0, 0, tt_ftp_tls_psw, 0, 1],

# List box to select a Write Mode
['write_mode', 'Write Mode_FTP Library', 'string', get_write_mode(), write_mode, 1, 0, tt_write_mode, disable_write_mode_fields, 1],

#check box for select FTP TLS
['write_ftptls', 'Write FTP TLS_FTP Library', 'int', [0, 1], 0, 1, 0, tt_ftp_tls, enable_disable_ftptls_fields, 1],

#FTP TLS Certificate path
['write_ftptls_certificate', 'Certificate Path_FTP Library', 'string', None, '', 0, 0, tt_ftp_tls_certificate, 0, 1],

#FTP TLS Password
['write_ftptls_psw', 'Certificate Password_FTP Library', 'string', None, '', 0, 0, tt_ftp_tls_psw, 0, 1],

# Input field for read source
['read_source', 'Read Path/Subject_FTP Library', 'string', None, '', 0, 0, tt_read_source, 0, 1],

# Input field for write source
['write_source', 'Write Path/Subject_FTP Library', 'string', None, '', 0, 0, tt_write_source, 0, 1],

# Input field for archive source
['archive_source', 'Archive Path_FTP Library', 'string', None, '', 0, 0, tt_write_source, 0, 1],

['read_file_filter', 'Read File Filter_FTP Library', 'string', None, '', 1, 0, tt_file_name_exp, 0, 1],

['amb_msg_file_name', 'AMB Message File Name_FTP Library', 'string', None, '', 0, 0, tt_amb_msg_file_name, 0, 1],

# Enter the read FTP credential in format Host:Port:User:Password
['read_ftp_details', 'Read FTP_FTP Library', 'string', None, '', 0, 0, tt_read_ftp_details, 0, 1],

# Enter the write FTP credential in format Host:Port:User:Password
['write_ftp_details', 'Write FTP_FTP Library', 'string', None, '', 0, 0, tt_write_ftp_details, 0, 1],

# Input field for temporary file path
['temp_file_path', 'Temporary File path_FTP Library', 'string', None, '', 0, 0, '', 0, 1],

]

def override_config_with_gui_input(ael_params):
    #config['READ_MODE'] = ael_params['read_mode']
    #config['WRITE_MODE'] = ael_params['write_mode']
    config_ael_params = {}
    read_source_lst = [] 
    read_mode = ael_params['read_mode']
    write_mode = ael_params['write_mode']
    fftp_mode = read_mode + '-' + write_mode
    config_ael_params['MODE'] = fftp_mode

    if ael_params['read_source']:
        read_source = ael_params['read_source']
        read_source_lst = FFTPConfig.string_as_list(read_source)
        config_ael_params['READ_SOURCE'] = read_source_lst

    if ael_params['write_source']:
        write_source = ael_params['write_source']
        write_source_lst = FFTPConfig.string_as_list(write_source)
        config_ael_params['WRITE_SOURCE'] = write_source_lst

    if ael_params['archive_source']:
        archive_source = ael_params['archive_source']
        config_ael_params['ARCHIVE_PATH'] = archive_source

    #config['READ_WRITE_SOURCE'] = [(read_source, archive_source, write_source)]

    if ael_params['read_file_filter']:
        lst = []
        str_val = ael_params['read_file_filter']

        filter_lst = FFTPConfig.string_as_list(str_val)

        read_sources = []
        if read_mode in ['DIR', 'FTP', 'SFTP', 'FTPTLS']:
            for filter in filter_lst:
                for read_source in read_source_lst:
                    read_source = os.path.join(read_source, filter)
                    read_sources.append(read_source)
        config_ael_params['READ_SOURCE'] = read_sources

    if ael_params['amb_msg_file_name']:
        config_ael_params['MESSAGE_FILE_NAME'] = ael_params['amb_msg_file_name']

    if ael_params['read_ftp_details']:
        ftp_read_cred = ael_params['read_ftp_details']
        try:
            if ftp_read_cred:
                cred_list = ftp_read_cred.split(':')
                if 2 <= len(cred_list) <= 4:
                    config_ael_params['READ_HOST'] = cred_list[0]
                    config_ael_params['READ_PORT'] = cred_list[1]
                if len(cred_list) >= 3:
                    config_ael_params['READ_USER'] = cred_list[2]
                if len(cred_list) == 4:
                    config_ael_params['READ_PASSWORD'] = cred_list[3]
        except Exception as ex:
            logger.ERROR("Enter the read FTP credential in format host:port:user:password")
            return 0

    if ael_params['write_ftp_details']:
        ftp_write_cred = ael_params['write_ftp_details']
        try:
            if ftp_write_cred:
                cred_list = ftp_write_cred.split(':')
                if 2 <= len(cred_list) <= 4:
                    config_ael_params['WRITE_HOST'] = cred_list[0]
                    config_ael_params['WRITE_PORT'] = cred_list[1]
                if len(cred_list) >= 3:
                    config_ael_params['WRITE_USER'] = cred_list[2]
                if len(cred_list) == 4:
                    config_ael_params['WRITE_PASSWORD'] = cred_list[3]
        except Exception as ex:
            logger.ERROR("Enter the write FTP credential in format host:port:user:password")
            return 0

    if ael_params['temp_file_path']:
        config_ael_params['TEMP_FILE_PATH']  = ael_params['temp_file_path']

    if ael_params['read_ftptls']:
        config_ael_params['READ_FTPTLS']  = ael_params['read_ftptls']
        config_ael_params['READ_FTPTLS_CERT']  = ael_params['read_ftptls_certificate']
        config_ael_params['READ_FTPTLS_PSW']  = ael_params['read_ftptls_psw']
    if ael_params['write_ftptls']:
        config_ael_params['WRITE_FTPTLS']  = ael_params['write_ftptls']
        config_ael_params['WRITE_FTPTLS_CERT']  = ael_params['write_ftptls_certificate']
        config_ael_params['WRITE_FTPTLS_PSW']  = ael_params['write_ftptls_psw']

    return config_ael_params


#import ATSOperationsWork
def ael_main(ael_params):
    logger.INFO("============================== Start of Processing ==============================")    
    config_ael_params = override_config_with_gui_input(ael_params)
    mode = config_ael_params.get('MODE', '')
    controller_obj = FTPController(mode, config_ael_params)
    success = controller_obj.main()
    if success:
        logger.INFO("Task completed Successfully")
    elif not success:
        logger.ERROR("Task Failed!")
    controller_obj.close_connection()
    logger.INFO("=============================== End of Processing ===============================")


...

  FFTPTLSOperations
"""--------------------------------------------------------------------
MODULE
    FFTPTLSOperations -  Operations like reading and writing to FTP TLS server

DESCRIPTION
    This script handles the FTP TLS operations.

VERSION: 2.0.7

--------------------------------------------------------------------"""
import os
import io
import time
import fnmatch
import ntpath

import FFTPConfig
import FFTPLibHooks
import FFTPNotification
import acm
import ael

from FFTPDIROperations import DIROperations
from FFTPOperations import logger, FTP_ERROR_codes, FTPOperations

file_download_result = 1
class FTPTLSOperations(FTPOperations):
    def __init__(self, application_name, host=None, port=None, user=None, pwd=None, certFile=None, certPassword=None, timeout=0, interval=0, retry=0,
                 config_variables_obj=None, *args):
        self.application_name = application_name
        self.host = host
        self.port = port
        self.user = user
        self.pwd = pwd
        self.Cert_P12_OR_PFX_file = certFile
        self.Cert_P12_OR_PFX_password = certPassword
        self.interval = interval
        self.timeout = timeout
        self.retry = retry        
        config_variables_obj = config_variables_obj
        self.config_data = config_variables_obj.config_data if config_variables_obj else {}
        self.read_mode = self.config_data.get('FROM_MODE', 'FTP')
        self.write_mode = self.config_data.get('TO_MODE', '')
        self.check_empty_parameters()
        if not self.pwd:
            self.pwd = self.get_password_from_hook(self.application_name, self.user, self.host)
        if not self.Cert_P12_OR_PFX_password:
            self.Cert_P12_OR_PFX_password = self.get_password_from_hook(self.application_name, self.user, self.host, self.Cert_P12_OR_PFX_file)
        self.ftp = self.connect()

    @classmethod
    def initialize(cls, mode, reader, task_parameters, config_variables_obj=None):
        ftp_config_param = FFTPConfig.Parameters('FFTPSettings')
        interval = getattr(ftp_config_param, 'POLL_INTERVAL', '')
        timeout = getattr(ftp_config_param, 'POLL_TIMEOUT', '')
        retry = getattr(ftp_config_param, 'POLL_RETRY', '')
        mode_config_param = FFTPConfig.Parameters('FFTPModeSettings_' + mode) #For task also we required this. For set certificate path etc

        host, port, user, pwd, certFile, certPassword = None, None, None, None, None, None

        if mode.split('-')[0] == 'FTP' and reader:
            if task_parameters:
                host = task_parameters.get('READ_HOST', '')
                port = task_parameters.get('READ_PORT', '')
                user = task_parameters.get('READ_USER', '')
                pwd = task_parameters.get('READ_PASSWORD', '')
                certFile = task_parameters.get('READ_FTPTLS_CERT', None)
                certPassword = task_parameters.get('READ_FTPTLS_PSW', None)
                if not certFile:
                    certFile = getattr(mode_config_param, 'CERT_P12_OR_PFX_FILE_READ', None)
                if not certPassword:
                    certPassword = getattr(mode_config_param, 'CERT_P12_OR_PFX_PASSWORD_READ', None)
            else:               
                host = getattr(mode_config_param, 'READ_HOST', '')
                port = getattr(mode_config_param, 'READ_PORT', '')
                user = getattr(mode_config_param, 'READ_USER', '')
                pwd = getattr(mode_config_param, 'READ_PASSWORD', '')
                certFile = getattr(mode_config_param, 'CERT_P12_OR_PFX_FILE_READ', None)
                certPassword = getattr(mode_config_param, 'CERT_P12_OR_PFX_PASSWORD_READ', None) 
                
                if not (host and port and user ):
                    host = getattr(ftp_config_param, 'READ_HOST', '')
                    port = getattr(ftp_config_param, 'READ_PORT', '')
                    user = getattr(ftp_config_param, 'READ_USER', '')
                if not pwd:    
                    pwd = getattr(ftp_config_param, 'READ_PASSWORD', '')
            
            #GUI and Task mode took value from FParameter or GUI. if not present then take from FFTPSettings
            if not certFile:
                certFile = getattr(ftp_config_param, 'CERT_P12_OR_PFX_FILE_READ', None)
            if not certPassword:
                certPassword = getattr(ftp_config_param, 'CERT_P12_OR_PFX_PASSWORD_READ', None)
                    
        elif mode.split('-')[1] == 'FTP':
            if task_parameters:
                host = task_parameters.get('WRITE_HOST', '')
                port = task_parameters.get('WRITE_PORT', '')
                user = task_parameters.get('WRITE_USER', '')
                pwd = task_parameters.get('WRITE_PASSWORD', '')
                certFile = task_parameters.get('WRITE_FTPTLS_CERT', None)
                certPassword = task_parameters.get('WRITE_FTPTLS_PSW', None)
                if not certFile:
                    certFile = getattr(mode_config_param, 'CERT_P12_OR_PFX_FILE_WRITE', None)
                if not certPassword:
                    certPassword = getattr(mode_config_param, 'CERT_P12_OR_PFX_PASSWORD_WRITE', None)
            else:
                host = getattr(mode_config_param, 'WRITE_HOST', '')
                port = getattr(mode_config_param, 'WRITE_PORT', '')
                user = getattr(mode_config_param, 'WRITE_USER', '')
                pwd = getattr(mode_config_param, 'WRITE_PASSWORD', '')
                certFile = getattr(mode_config_param, 'CERT_P12_OR_PFX_FILE_WRITE', None)
                certPassword = getattr(mode_config_param, 'CERT_P12_OR_PFX_PASSWORD_WRITE', None)

                if not (host and port and user ):
                    host = getattr(ftp_config_param, 'WRITE_HOST', '')
                    port = getattr(ftp_config_param, 'WRITE_PORT', '')
                    user = getattr(ftp_config_param, 'WRITE_USER', '')
                if not pwd:
                    pwd = getattr(ftp_config_param, 'WRITE_PASSWORD', '')                    
        
            #GUI and Task mode took value from FParameter or GUI. if not present then take from FFTPSettings
            if not certFile:
                certFile = getattr(ftp_config_param, 'CERT_P12_OR_PFX_FILE_WRITE', None)
            if not certPassword:
                certPassword = getattr(ftp_config_param, 'CERT_P12_OR_PFX_PASSWORD_WRITE', None)

        ftp_config_param = FFTPConfig.Parameters('FFTPSettings')
        application_name = getattr(ftp_config_param, 'FFTPLib_APPLICATION_NAME', '')
        if mode.split('-')[1] == mode.split('-')[0]:
            application_name = application_name + "-" + user 
                        
        obj = cls(application_name, host, port, user, pwd, certFile, certPassword, timeout, interval, retry, config_variables_obj=config_variables_obj)        

        if not obj.ftp:
            return None
        return obj

    def connect(self):
        """Connect to FTP server.
        :return: FTP object
        """
        ftp = None
        try:
            from chilkat import chilkat
            glob = chilkat.CkGlobal()
            success = glob.UnlockBundle("FSLTNS.CB4032023_xPv5yNngkRpl")
            ftp = chilkat.CkFtp2()

            #False for non-passive/active mode and True for passive/port mode.
            #In non-passive mode client provide port no & in passive mode server provide port no then client use that port no.            
            ftp.put_Passive(False)    
            ftp.put_Hostname(self.host)
            ftp.put_Port(int(self.port))
            
            # Establish an AUTH TLS/SSL secure channel after connection. # on the standard FTP port 21.
            ftp.put_AuthTls(True)       
            #ftp.put_AuthSsl(False)
                 
            # The Ssl property is for establishing an implicit SSL connection. # on port 990.  Do not set it.
            ftp.put_Ssl(False)

            if self.user and self.pwd:
                ftp.put_Username(self.user)
                ftp.put_Password(self.pwd)
            else:    
                ftp.put_Username('anonymous')
                ftp.put_Password('')
            
            if self.Cert_P12_OR_PFX_file and self.Cert_P12_OR_PFX_password:
                logger.INFO("Certificate {} will be used in connection.".format(self.Cert_P12_OR_PFX_file))
                cert = chilkat.CkCert()
                success = cert.LoadPfxFile(self.Cert_P12_OR_PFX_file, self.Cert_P12_OR_PFX_password)
                if (success != True):
                    logger.ERROR(cert.lastErrorText())
                    return None                

                # Use this certificate for our secure (SSL/TLS) connection:
                success = ftp.SetSslClientCert(cert)
                if (success != True):
                    logger.ERROR(cert.lastErrorText())
                    return None
            else:
                logger.INFO("Self Sign Certificate will be used in connection.")

            # Connect and convert the connection to TLS automatically. 
            success = ftp.Connect() #ConnectOnly & LoginAfterConnectOnly methods under Connect method
            if (success != True):
                logger.ERROR(str(ftp.get_ConnectFailReason()))
                logger.ERROR(ftp.lastErrorText())
                return None
            logger.INFO("TLS connection established and successfully authenticated to FTP Server :- {0}. Connected :- {1}".format(self.host, ftp.get_IsConnected()))
            
            #Optional code. Check FTP server certificates.          
            cert = ftp.GetSslServerCert() # cert is a CkCert
            if (ftp.get_LastMethodSuccess() != True):
                logger.INFO("No server certificate!")
            else:
                # Display the distinguished name of the SSL cert.
                logger.INFO("TLS cert name is :- {}".format(cert.subjectDN()))

        except Exception as e:
            logger.ERROR("Login to FTP server <%s> failed. : %s" % (str(self.host), str(e)))
            return None

        return ftp

    def retry_ftp_connection_if_disconnected(self):
        ftp_connected = self.ftp.CheckConnection() if self.ftp else False        
        if not ftp_connected:
            ftp_connected = self.retry_ftp_connection()
            if ftp_connected:
                logger.DEBUG("Connected :- {}".format(self.ftp.CheckConnection()))
        
        return ftp_connected

    def poll_for_file(self, file_name):
        """This method polls for the reply file at ftp.
        True - if file exists at ftp server.
        false - if no file exists at ftp server.

        """
        ftp_connection = True
        filter_file_lst = []
        try:
            file_lst = []
            n = self.ftp.GetDirCount()
            if (n > 0):
              for i in range(0,n):
                file_lst.append(self.ftp.getFilename(i))
            filter_file_lst = fnmatch.filter(file_lst, file_name)
        except Exception as e:
            logger.ERROR("Error while fetching reply file from FTP server : %s" % str(e))
            for error_code in FTP_ERROR_codes.keys():
                if error_code in str(e):
                    ftp_connection = False

        if not ftp_connection:
            logger.WARN("FTP is down, Trying to connect again")
            connected = self.retry_ftp_connection()
            if connected:
                self.poll_for_file(file_name)

        return filter_file_lst

    def upload_file(self, file_path, ftp_dir=None):
        """Uploads a file to the FTP server.
        Input - request file name to upload, request file path.
        
        """
        ftp_dir_set = 0
        ftp_connection = 1
        result = 1
        if self.ftp:
            if ftp_dir:
                result = self.change_ftp_dir(ftp_dir)
                if result == 0:
                    return result
                ftp_dir_set = 1

            try:
                file_name = os.path.split(file_path)[-1] #take the file name
                file_handler = open(file_path, 'rb')

                file_ref = FFTPLibHooks.fftplibrary_import_exit(self.read_mode, self.write_mode, file_path,
                                                                file_handler)
                if file_ref and isinstance(file_ref, io.BufferedReader):
                    file_handler = file_ref
                    file_path = file_ref.name
                else:
                    file_path = file_ref

                if file_handler:
                    file_handler.close()
                
                self.ftp.PutFile(file_path, file_name) #We can give any file_name for upload on FTP
            
                if file_path:
                    if ftp_dir:
                        logger.INFO("File %s uploaded to FTP server at path %s" % (file_name, ftp_dir))
                    else:
                        logger.INFO("File %s uploaded to FTP server" % (file_name))
                else:                    
                    result = 0

                if ftp_dir_set == 1:
                    self.change_ftp_dir('/')
            except Exception as e:
                logger.ERROR("Error while uploading file to FTP server : %s" % str(e))
                result = 0
                for error_code in FTP_ERROR_codes.keys():
                    if error_code in str(e):
                        ftp_connection = 0

            if not ftp_connection:
                logger.WARN("FTP is not connected while uploading file, Trying to re-connect")
                connected = self.retry_ftp_connection()
                if connected:
                    self.upload_file(file_path, ftp_dir)
                else:
                    result = 0
        else:
            result = 0

        return result

    def _download_from_file(self, file_name, download_dir):
        """Download file from FTP"""
        file_path = os.path.join(download_dir, file_name)
 
        ftp_connection = 1
        result = 0
        
        try:
            self.ftp.GetFile(file_name, file_path) #File downloaded successfully
            logger.INFO("Downloaded file <%s> from FTP server. Applying hook" % file_name)
            
            #apply hook
            file_handler = open(file_path, 'ab')
            if file_handler:
                # export exit hook for amb message
                file_ref, destination_path = FFTPLibHooks.fftplibrary_export_exit(self.read_mode, self.write_mode,
                                                                                  file_path, file_handler)
    
                # Check the return valaue is file handler or file path
                if isinstance(file_ref, io.BufferedWriter):
                    file_handler = file_ref
                    file_path = file_ref.name
                else:
                    file_path = file_ref
    
                # close the file handler
                if file_handler:
                    file_handler.close()
                
                # Set the return destination path from extension point
                if file_path:
                    if destination_path:
                        self.config_data['TEMP_{}-{}'.format(self.read_mode, self.write_mode)][
                            file_path] = destination_path
                    result = 1

        except Exception as e:
            logger.ERROR("Error while downloading file %s from FTP : %s" % (file_name, str(e)))			
            for error_code in FTP_ERROR_codes.keys():
                if error_code in str(e):
                    ftp_connection = 0

        if not ftp_connection:
            logger.WARN("FTP is down, Trying to connect again")
            connected = self.retry_ftp_connection()
            if connected:
                result = self._download_from_file(download_dir, file_name)
        return result

    def change_ftp_dir(self, ftp_dir):
        """
        Change the ftp directory path to copy the file in provided directory
        :param ftp_dir: ftp directory path
        :return: result as boolean
        """
        result = 0
        is_connected = True
        global file_download_result
        try:
            result = self.ftp.ChangeRemoteDir(ftp_dir)
            if (result != True):                
                logger.ERROR("Unable to change FTP directory {} : {}".format(ftp_dir,self.ftp.lastErrorText()))
                result = 0
                return result
            result = 1
            #logger.DEBUG("Directory <%s> changed : Result <%s>" % (ftp_dir,str(result)))            
        except Exception as e:
            file_download_result = 0
            logger.ERROR("Error while changing FTP directory %s : %s" % (ftp_dir,str(e)))
            for error_code in FTP_ERROR_codes.keys():
                if error_code in str(e):
                    is_connected = False

        if not is_connected:
            connected = self.retry_ftp_connection()
            if connected:
                self.change_ftp_dir(ftp_dir)
            else:
                logger.WARN("Cannot connect to FTP after retry, FTP directory path cannot be changed")
        return result

    def get_file_modified_timestamp(self, file_name, dir_path=None):
        """
        Get the modified timestamp of the file on FTP server.
        :param file_name: file name on FTP server
        :return: return the timestamp of file
        """
        is_connected = True
        timestamp = ''
        from datetime import datetime
        try:
            #Below line return none if file does not exist on server or if FTP Server do not support MDTM.
            #timestamp = self.ftp.sendCommand("MDTM " + file_name) # returns datetime in UTC and YYYYMMDDHHMMSS format ex 213 20230227091742.528
            timestamp = self.ftp.getLastModifiedTimeByNameStr(file_name) # return Mon, 27 Mar 2023 11:44:13 +0530
            if timestamp:
                timestamp = timestamp[5:25].strip()
                obj_datetime = datetime.strptime(str(timestamp), '%d %b %Y %H:%M:%S')
                timestamp = obj_datetime.strftime("%Y%m%d%H%M%S.000000")
            else:
                logger.DEBUG("Unable to get modified time of file {} from FTP.".format(file_name))
                is_connected = self.ftp.CheckConnection()
            
        except Exception as e:
            logger.ERROR("Error while fetching modified time of file %s from FTP : %s" % (file_name,str(e)))
            for error_code in FTP_ERROR_codes.keys():
                if error_code in str(e):
                    is_connected = False

        if not is_connected:
            connected = self.retry_ftp_connection()
            if connected:
                self.change_ftp_dir(dir_path) #Change directory before get modified time of file.
                timestamp = self.get_file_modified_timestamp(file_name, dir_path)
        return timestamp

    def close_connection(self):
        """Close the FTP connection"""
        if self.ftp:
            try:
                success = self.ftp.Disconnect()
                if (success == True):
                    logger.INFO("FTP Connection closed successfully")
                else:
                    logger.ERROR("FTP Connection not closed successfully. %s" % self.ftp.lastErrorText())
            except Exception as ex:
                logger.ERROR("Error while closing FTP connection %s" % str(ex))
        
def split_connection_str(connstr):
    """ Separate/split the string
    :Input String with ':' separator 
    :Return host, port, user, pwd, certFile, certPassword
    """
    conn_param_lst = connstr.split('|')
    host, port, user, pwd, certFile, certPassword = '', '', '', '', None, None
    connection_param_dict = {'host': '', 'port': '', 'user': '', 'password':'', 'certFile':'', 'certPassword':''}
    if len(conn_param_lst) > 2:
        host = conn_param_lst[0]
        port = conn_param_lst[1] 
        connection_param_dict["host"] = conn_param_lst[0]
        connection_param_dict["port"] = conn_param_lst[1] 
    if len(conn_param_lst) >= 3:
        user = conn_param_lst[2]
        connection_param_dict["user"] = conn_param_lst[2]
    if len(conn_param_lst) >= 4:
        pwd = conn_param_lst[3]
        connection_param_dict["password"] = conn_param_lst[3]
    if len(conn_param_lst) == 6:
        certFile = conn_param_lst[4]
        certPassword = conn_param_lst[5]
        connection_param_dict["certFile"] = conn_param_lst[4]
        connection_param_dict["certPassword"] = conn_param_lst[5]
    
    for connection_key, connection_val in connection_param_dict.items():
        if connection_val == "" and connection_key not in ['password','certFile','certPassword'] :
            logger.ERROR("%s is empty, Please give value to %s"%(connection_key,connection_key) )
        
    return host, port, user, pwd, certFile, certPassword

def check_ftp_object(ftp_obj):
    """Check ftp object  """
    ftp_object_initialized = True
    if not ftp_obj.ftp:
        ftp_object_initialized = False
        try:
            poll_retry = int(ftp_obj.retry)
            if poll_retry:
                ftp_object_initialized = ftp_obj.retry_ftp_connection()
        except Exception as exp:
            logger.ERROR(str(exp))
        
        if not ftp_object_initialized:
            logger.INFO("Login to FTP server is unsuccessful. Please check host, port, username (check if password is provided or check in FPassword hook against application name )")
    return ftp_object_initialized

def read_from_ftp(download_dir, connstr, \
                  ftp_dir, timeout=0, interval=0, retry=0, app_name= ''):
    """ Download file from FTP server to local directory
    Input:
    download_dir: Local directory on which files are downloaded
    connstr: Connection string Format localhost|port|username|password|certFile|certPassword
    ftp_dir: FTP server directory
    timeout: Time in seconds to time-out the polling operation for files on the Provider FTP server
    interval: Interval between two successive polls on the FTP server.
    retry: The ATS resends the request to the FTP server
    app_name: Apllication name
    Output:
    result : 1 on success, 0 on failure
    """
    global file_download_result
    result = 0
    download_dir_lst = FFTPConfig.string_as_list(download_dir)
    ftp_dir_lst = FFTPConfig.string_as_list(ftp_dir)
    source_dict = {}
    destination = download_dir_lst[0]
    if len(download_dir_lst) > 1 and len(download_dir_lst) == len(ftp_dir_lst):
        source_dict = dict(list(zip(ftp_dir_lst, download_dir_lst)))
    elif len(download_dir_lst) > 1:
        logger.ERROR("Invalid download_dir / ftp_dir provided as input to API")
        return result

    if connstr:
        host, port, user, pwd, certFile, certPassword = split_connection_str(connstr)   
        ftp_obj = FTPTLSOperations(app_name, host, port, user, pwd, certFile, certPassword, timeout, interval, retry)
        if not check_ftp_object(ftp_obj):
            return result
        for each_source in ftp_dir_lst:
            if source_dict:
                destination = source_dict[each_source]
            ftp_dir, filter = ntpath.split(os.path.expandvars(each_source))

            file_list = ftp_obj.download_file(filename_lst=[filter], \
                                           download_dir=destination, ftp_dir=ftp_dir)
            
            logger.DEBUG("%s files downloaded to %s"%(str(len(file_list)), destination))
            
                
        result = file_download_result
        file_download_result =  1
        ftp_obj.close_connection()
    else:
        logger.ERROR("Please give host, port, username, password(optional), certFile(optional), certPassword(optional) in format HOST:PORT:USERNAME:PASSWORD:CERTFILE:CERTPASSWORD  to run api read_from_ftp")
        result = 0

    return result
  
def write_to_ftp(file_path, connstr, ftp_dir='',
                 timeout=0, interval=0, retry=0, app_name= ''):
    """ Writes an file to FTP server at specified directory 
    Input:
    file_path: File path  
    connstr: Connection string Format localhost|port|username|password|certFile|certPassword                                      
    ftp_dir: FTP server directory
    timeout: Time in seconds to time-out the polling operation for files on the Provider FTP server
    interval: Interval between two successive polls on the FTP server.
    retry:The ATS resends the request to the FTP server
    app_name: Apllication name
    Output:
    result : 1 on success, 0 on failure
    """
    try:
        result = 0
        file_path_lst = FFTPConfig.string_as_list(file_path)
        ftp_dir_lst = FFTPConfig.string_as_list(ftp_dir)
        source_dict = {}
        destination = ftp_dir_lst[0]
        dir_obj = DIROperations()
        temp_file_str = ''
        
        if len(ftp_dir_lst) > 1 and len(ftp_dir_lst) == len(file_path_lst):
            source_dict = dict(list(zip(file_path_lst, ftp_dir_lst)))
        elif len(ftp_dir_lst) > 1:
            logger.ERROR("Invalid file_path / ftp_dir provided as input to API")
            return result

        if connstr:
            host, port, user, pwd, certFile, certPassword = split_connection_str(connstr)
            if host:
                file_upload_flag = True
                ftp_obj = FTPTLSOperations(app_name, host, port, user, pwd, certFile, certPassword, timeout, interval, retry)
                if not check_ftp_object(ftp_obj) :
                    return result
                for file_path in file_path_lst:
                    if source_dict:
                        destination = source_dict[file_path]
                    if os.path.isfile(file_path):
                        result = ftp_obj.upload_file(file_path, destination)
                    else:
                        dir_path, filter = ntpath.split(os.path.expandvars(file_path))
                        file_path_list = dir_obj.read(dir_path, temp_file_str, [filter])
                        for files in file_path_list:                            
                            result = ftp_obj.upload_file(files, destination)
                            if result == 0:
                                file_upload_flag = False
                        if len(file_path_list) == 0:
                            result = 0
                    if result == 0:
                        file_upload_flag = False
                if not file_upload_flag:
                    result = 0
                ftp_obj.close_connection()
            else:
                logger.ERROR("FTP host name not provided by user")
        else:
            logger.ERROR("Please give host, port, username, password(optional), certFile(optional), certPassword(optional) in format HOST:PORT:USERNAME:PASSWORD:CERTFILE:CERTPASSWORD to run api write_to_ftp")
                   
    except Exception as e:
        logger.ERROR("Error in write_to_ftp %s "%(e))
        result = 0
            
    return result



...

  FSFTPOperations
"""--------------------------------------------------------------------
MODULE
    FSFTPOperations -  Operations like reading and writing to SFTP server

DESCRIPTION
    This script handles the SFTP operations.

VERSION: 2.0.7

--------------------------------------------------------------------"""
import os
import fnmatch
import sys
import time
import ntpath
import FFTPConfig
import FFTPLibHooks
import FFTPNotification 
import FIntegrationUtils
import FSFTPOperationsOverride
from FFTPDIROperations import DIROperations

logger = FFTPNotification.FFTPLogger('FFTPLibrary')


class SFTPOperations(object):
    def __init__(self, app_name, host=None, port=None, user=None, pwd=None, timeout=0, interval=0, retry=0, proxy_hostname=None, proxy_portnumber=None, config_variables_obj=None, *args):
        self.sftp = None
        self.host = host
        self.port = port
        self.user = user
        self.application_name = app_name
        self.proxy_host = proxy_hostname
        self.proxy_port = proxy_portnumber
        self.pwd = pwd
        if not self.pwd:
            self.pwd = FFTPLibHooks.fftplibrary_get_external_password(self.application_name, self.user, self.host)
        if not self.pwd:
            try:
                import FPassword
                self.pwd = FPassword.get_external_password(self.application_name)
                logger.DEBUG("Imported FPassword module for application %s" % self.application_name)
            except:
                logger.INFO("Could not import FPassword module")

        self.timeout = timeout
        self.interval = interval
        self.retry = retry
        self.transport = None
        self.utilsobj = FIntegrationUtils.FParamsEncode()
        self.config_data = config_variables_obj.config_data if config_variables_obj else {}

        self.read_mode = self.config_data.get('FROM_MODE', 'SFTP')
        self.write_mode = self.config_data.get('TO_MODE', '')
        self.sftp = self.connect()

    @classmethod
    def initialize(cls, mode, reader, task_parameters, config_variables_obj=None):
        """Read the config parameters and initialize the SFTP connection"""
        conn = False
        ftp_config_param = FFTPConfig.Parameters('FFTPSettings')
        interval = getattr(ftp_config_param, 'POLL_INTERVAL', '')
        timeout = getattr(ftp_config_param, 'POLL_TIMEOUT', '')
        retry = getattr(ftp_config_param, 'POLL_RETRY', '')
        mode_config_param = FFTPConfig.Parameters('FFTPModeSettings_' + mode)
        user = None
        pwd = None
        host = None
        port = None
        if mode.split('-')[0] == 'SFTP' and reader:
            if task_parameters:
                host = task_parameters.get('READ_HOST', '')
                port = task_parameters.get('READ_PORT', '')
                user = task_parameters.get('READ_USER', '')
                pwd = task_parameters.get('READ_PASSWORD', '')
            else:
                host = getattr(mode_config_param, 'READ_HOST', '')
                port = getattr(mode_config_param, 'READ_PORT', '')
                user = getattr(mode_config_param, 'READ_USER', '')
                pwd = getattr(mode_config_param, 'READ_PASSWORD', '')
                if not (host and port and user):
                    host = getattr(ftp_config_param, 'READ_HOST', '')
                    port = getattr(ftp_config_param, 'READ_PORT', '')
                    user = getattr(ftp_config_param, 'READ_USER', '')
                if not pwd:
                    pwd = getattr(ftp_config_param, 'READ_PASSWORD', '')
        elif mode.split('-')[1] == 'SFTP':
            if task_parameters:
                host = task_parameters.get('WRITE_HOST', '')
                port = task_parameters.get('WRITE_PORT', '')
                user = task_parameters.get('WRITE_USER', '')
                pwd = task_parameters.get('WRITE_PASSWORD', '')
            else:
                host = getattr(mode_config_param, 'WRITE_HOST', '')
                port = getattr(mode_config_param, 'WRITE_PORT', '')
                user = getattr(mode_config_param, 'WRITE_USER', '')
                pwd = getattr(mode_config_param, 'WRITE_PASSWORD', '')
                if not (host and port and user ):
                    host = getattr(ftp_config_param, 'WRITE_HOST', '')
                    port = getattr(ftp_config_param, 'WRITE_PORT', '')
                    user = getattr(ftp_config_param, 'WRITE_USER', '')
                if not pwd:
                    pwd = getattr(ftp_config_param, 'WRITE_PASSWORD', '')
        application_name = getattr(ftp_config_param, 'FFTP_APPLICATION_NAME', '') 
        if mode.split('-')[1] == mode.split('-')[0]:
            application_name = application_name + "-" + user
                       
        obj = cls(application_name, host, port, user, pwd, timeout, interval, retry)
        if not obj.sftp:
            return None
        return obj

    def connect(self):
        """Connect to SFTP server via Chilkat"""
        self.sftp = None
        proxyPort = ''
        Port = ''
        proxyHost=self.proxy_host
        if self.proxy_port:
            proxyPort=int(self.proxy_port)
        HostName=self.host
        if self.port:
            Port=int(self.port)
        username=self.user
        password=self.pwd
        self.sftp=FSFTPOperationsOverride.connect_override(proxyHost, proxyPort, HostName, Port, username, password)

        if not self.sftp or self.sftp == None:

            self.sftp = self.connect_chilkat()
        return self.sftp


    def connect_chilkat(self):

        sftp = None
        proxyPort = ''
        try:
            from chilkat import chilkat

            try:
                glob = chilkat.CkGlobal()
                success = glob.UnlockBundle("FSLTNS.CB4032023_xPv5yNngkRpl")
                sftp = chilkat.CkSFtp()
                proxyHost=self.proxy_host
                if self.proxy_port:
                    proxyPort=int(self.proxy_port)
                HostName=self.host
                if self.port:
                    Port=int(self.port)
                username=self.user
                password=self.pwd

                if proxyPort and proxyHost:
                    sftp.put_HttpProxyHostname(proxyHost)
                    sftp.put_HttpProxyPort(proxyPort)
                    logger.INFO("Connecting to %s server using chilkat with proxy host %s and port %s" % (self.host, proxyHost, proxyPort ))

                success = sftp.Connect(HostName,Port)
                if (success != True):
                    print(sftp.lastErrorText())


                ret_task = sftp.AuthenticatePw(username,password)
                if (ret_task != True):
                    print(sftp.lastErrorText())
                status = sftp.InitializeSftp()

                if status:
                    logger.DEBUG("Connected to {} server using chilkat".format(self.host))
                else:
                    logger.ERROR("Unable to Connect to {} server using chilkat.Please refer chilkat logs for reference".format(self.host))
                    sftp = None
            except Exception as e:
                logger.ERROR("Exception in connecting to {} server using chilkat".format(self.host))
                logger.DEBUG(str(e), exc_info=1)
                sftp = None
        except Exception as e:
            logger.WARN("%s" % e)
            sftp = None
        return sftp

    def checkIfFileExists(self, filename, sftpdir=None, sftp=None):
        """Check if filename exists on sftp server"""
        reportExists = False
        if sftp:
            self.sftp = sftp
        fullFileName = os.path.join(sftpdir, filename)
        try:
            status = self.sftp.FileExists(fullFileName, True)
            if status < 0:
                logger.ERROR("Error while checking file on SFTP server : {}".format(sftp.lastErrorText()))
            elif status:
                logger.DEBUG("File: <{0}> exists on SFTP server".format(filename))
                reportExists = True

        except Exception as e:
            logger.ERROR("Exception while checking file at SFTP server using chilkat")
            logger.ERROR(str(e), exc_info=1)

        return reportExists

    def retry_sftp_connection(self):
        """Retry the SFTP connection if connections fails in between"""
        sftp_connected = False
        poll_retry = int(self.retry)
        logger.INFO("Re-conneting SFTP server")
        for i in range(0, poll_retry):
            if self.interval:
                retry_interval = self.interval
            else:
                retry_interval = 10
                logger.DEBUG("Default retry interval is {}".format(retry_interval))
            logger.INFO("~ %s in %s retry" % (str(retry_interval), str(i + 1)))
            time.sleep(int(retry_interval))
            # logger.DEBUG("Reconnecting to server")
            connected = self.connect()
            if connected:
                sftp_connected = True
                break
        return sftp_connected

    def poll_until_timeout(self, file_name, timeout, interval):

        """This method polls to FTP for a given time period at given
        interval of time If the reply file is
        present before the timeout then the result is returned.

        """
        self.time_seconds = 0
        poll_start_time = time.time()
        if int(timeout):
            logger.INFO("Waiting for a file to download")
            while self.time_seconds < int(timeout):

                time.sleep(float(interval))
                seconds = str(self.time_seconds + \
                              int(interval)) + 's'
                msg = '~' + str(seconds) + ' ...'
                logger.INFO(msg)
                file_list = self.__poll_for_file(file_name)
                if file_list:
                    return file_list

                self.time_seconds = self.time_seconds + \
                                    int(interval)
        else:
            file_list = self.__poll_for_file(file_name)
        return file_list

    def __poll_for_file(self, file_name):
        """This method polls for the reply file at ftp.
        True - if file exists at ftp server.
        false - if no file exists at ftp server.

        """
        sftp_connection = True
        filter_file_lst = []
        try:
            file_lst = self.sftp.listdir()
            filter_file_lst = fnmatch.filter(file_lst, file_name)
        except Exception as e:
            error_message = "Error while fetching reply file from FTP server"
            logger.ERROR(error_message)
            logger.ERROR(str(e))
            if 'Server connection dropped' in str(e):
                sftp_connection = False

        if not sftp_connection:
            logger.WARN("SFTP is down, Trying to connect again")
            connected = self.retry_sftp_connection()
            if connected:
                self.__poll_for_file(file_name)

        return filter_file_lst





    def upload_file(self, file_path, upload_dir=None):
        """Uploads a file to the FTP server.
        storbinary is used to store the file in the binary format.
        Input - request file name to upload, request file path.

        """
        result = 0
        sftp = self.sftp

        result = FSFTPOperationsOverride.upload_file_override(sftp, file_path, upload_dir=None)

        if result == 0:
            result = self.upload_file_using_chilkat(file_path, upload_dir)
        return result



    def upload_file_using_chilkat(self, file_path, upload_dir):
        """ Upload file at SFTP server using putty """
        logger.DEBUG("Uploading file using Chilkat")
        file_name = os.path.split(file_path)[-1]
        file_path = FFTPLibHooks.fftplibrary_import_exit(self.read_mode, self.write_mode, file_path)
        proxyPort = ''
        Port = ''
        result = 0
        if not file_path or not type(file_path) == str:
            logger.WARN("Value returned from fftplibrary_import_exit is {} not supported".format(str(file_path)))
            return 0
        if os.path.isfile(file_path):
            try:
                from chilkat import chilkat

                try:
                    glob = chilkat.CkGlobal()
                    success = glob.UnlockBundle("FSLTNS.CB4032023_xPv5yNngkRpl")
                    sftp = chilkat.CkSFtp()
                    proxyHost=self.proxy_host
                    if self.proxy_port:
                        proxyPort=int(self.proxy_port)
                    HostName=self.host
                    if self.port:
                        Port=int(self.port)
                    username=self.user
                    password=self.pwd

                    if proxyPort and proxyHost:
                        sftp.put_HttpProxyHostname(proxyHost)
                        sftp.put_HttpProxyPort(proxyPort)

                    success = sftp.Connect(HostName,Port)
                    if (success != True):
                        print(sftp.lastErrorText())

                    ret_task = sftp.AuthenticatePw(username,password)
                    status = sftp.InitializeSftp()
                    if upload_dir:
                        remoteFilePath = upload_dir + '/' + file_name
                    else:
                        remoteFilePath = file_name

                    localFilePath =file_path
                    success = sftp.UploadFileByName(remoteFilePath, localFilePath)

                    if status and success :
                        logger.INFO("File uploaded to SFTP server %s at directory %s" % (file_name, upload_dir))
                        result = 1
                    else:
                        result = 0
                        logger.INFO("Failed to uploaded to SFTP server %s at directory %s" % (file_name, upload_dir))
                        logger.ERROR("possible error {}  using chilkat".format(sftp.lastErrorText()))

                except Exception as e:
                    logger.ERROR("Exception in connecting to {} server using chilkat".format(self.host))
                    logger.DEBUG(str(e), exc_info=1)
            except Exception as e:
                logger.WARN("%s" % e)

        else:
            logger.ERROR("File %s does not exist" % file_path)

        return result


    def download_file(self, filename_lst, download_dir, sftp_dir):
        """Download file from SFTP server"""
        result = 0
        sftp = self.sftp
        timeout = self.timeout
        interval = self.interval
        result = FSFTPOperationsOverride.polling_for_override(sftp, timeout, interval, filename_lst, download_dir, sftp_dir)
        if result == 0:
            result = self.polling_for_chilkat(filename_lst, download_dir, sftp_dir)
        return result



    def polling_for_chilkat(self, filename_lst, download_dir, sftp_dir=None):
        """Downloads a file from the FTP.
        retrbinary is used to download binary files.
        Input - reply file name, reply file path to download.
        Output - reply file from FTP server.

        """
        result = 0
        try:
            logger.DEBUG("Downloading files to dir <%s>" % download_dir)
            for file_name in filename_lst:
                file_path = os.path.join(download_dir, file_name)
                file_path, destination_path = FFTPLibHooks.fftplibrary_export_entry(self.read_mode,
                                                                                    self.write_mode, file_path)
                if file_path and type(file_path) == str:
                    if destination_path:
                        if self.write_mode == 'DIR':
                            download_dir = destination_path
                        else:
                            self.config_data['TEMP_{}-{}'.format(self.read_mode, self.write_mode)][
                                file_path] = destination_path

                    result = self.chilkat_poll_until_timeout(self.timeout, self.interval, file_name,
                                                           download_dir, sftp_dir)
                else:
                    result = 0

        except Exception as ex:
            logger.ERROR("Error while downloading file from SFTP")
            logger.ERROR(str(ex))
            result = 0

        return result




    def chilkat_poll_until_timeout(self, timeout, interval, filename, download_dir, sftp_dir):
        """This method polls to FTP for a given time period at given
        interval of time If the reply file is
        present before the timeout then the result is returned.
        """
        result = 0
        self.time_seconds = 0
        poll_start_time = time.time()
        if int(timeout):
            logger.INFO("Waiting for a file to download")
            while self.time_seconds < int(timeout):

                time.sleep(float(interval))
                seconds = str(self.time_seconds + \
                              int(interval)) + 's'
                msg = '~' + str(seconds) + ' ...'
                logger.INFO(msg)
                result, err_log = self.download_file_using_chilkat(filename, download_dir, sftp_dir)
                if result:
                    return result
                elif err_log:
                    logger.DEBUG('%s' % err_log)

                self.time_seconds = self.time_seconds + \
                                    int(interval)
        else:
            result, err_log = self.download_file_using_chilkat(filename, download_dir, sftp_dir)
            if err_log:
                logger.DEBUG('%s' % err_log)
        return result


    def download_file_using_chilkat(self, file_name, download_dir, sftp_dir):
        """ Download file using Putty """
        result = 0
        error_log = ''
        output = ''
        destination_path = ''
        proxyPort = ''
        Port = ''
        recursion = True
        sftpfilePath = ""
        logger.DEBUG("Downloading file using Chilkat")
        try:
            from chilkat import chilkat

            try:
                glob = chilkat.CkGlobal()
                success = glob.UnlockBundle("FSLTNS.CB4032023_xPv5yNngkRpl")
                sftp = chilkat.CkSFtp()
                proxyHost=self.proxy_host
                if self.proxy_port:
                    proxyPort=int(self.proxy_port)
                HostName=self.host
                if self.port:
                    Port=int(self.port)
                username=self.user
                password=self.pwd

                if proxyPort and proxyHost:
                    sftp.put_HttpProxyHostname(proxyHost)
                    sftp.put_HttpProxyPort(proxyPort)

                success = sftp.Connect(HostName,Port)
                if (success != True):
                    logger.ERROR(sftp.lastErrorText())


                ret_task = sftp.AuthenticatePw(username,password)
                status = sftp.InitializeSftp() 
                handle = sftp.openDir(sftp_dir)
                if not handle:
                    logger.ERROR("Directory %s does not exist. Read source is invalid, please check FParameter READ_SOURCE" %(sftp_dir))                      
                    return result, error_log
                if "*" not in file_name:
                    recursion = False               
                    sftpfilePath = os.path.join(sftp_dir, file_name)                    
                        
                sftp.put_SyncCreateAllLocalDirs(False)
                sftp.put_SyncMustMatch(file_name)
                mode = 0                
                success = sftp.SyncTreeDownload(sftp_dir, download_dir, mode, recursion)
                if success :                    
                    downloaded_files_list = sftp.syncedFiles().splitlines()
                    for downloaded_file_name in downloaded_files_list :
                        localpath = os.path.join(download_dir, downloaded_file_name)                       
                        if success and os.path.isfile(localpath):
                            localpath, destination_path = FFTPLibHooks.fftplibrary_export_exit(self.read_mode, self.write_mode,
                                                                                   localpath)
                        if localpath and os.path.isfile(localpath):
                            if type(localpath) == str:
                                if destination_path:
                                    self.config_data['TEMP_{}-{}'.format(self.read_mode, self.write_mode)][
                                            localpath] = destination_path
                                logger.DEBUG("Downloaded file <%s> from SFTP server" % downloaded_file_name)
                                result = 1
                        else:
                            if localpath and os.path.exists(localpath):
                                logger.DEBUG("Directory %s is created " %(localpath))
                            else:
                                logger.WARN("Value returned from fftplibrary_export_exit is {} not supported".format(
                                                                                                                     str(localpath)))
                            
                else:
                    if sftp.FileExists(sftpfilePath, True) == 0 :                        
                        logger.ERROR("File %s does not exist on sftp server" %(file_name))
                    result = 0
            except Exception as e:
                logger.ERROR("Exception in connecting to {} server using chilkat".format(self.host))
                logger.DEBUG(str(e), exc_info=1)
        except Exception as e:
            logger.WARN("%s" % e)

        return result, error_log


    def read(self, sftp_dir, dest_dir, file_list):
        if not self.sftp:
            self.sftp = self.connect()
        file_path_list = []

        result = self.download_file(file_list, dest_dir, sftp_dir)
        if result:
            file_list = os.listdir(dest_dir)
            # file_path_list = [os.path.join(dest_dir, filename)]
            file_path_list = [os.path.join(dest_dir, each_file) for each_file in file_list]
            # file_path_list = [ filename]

        return file_path_list

    def write(self, file_path_list, sftp_dir, temp_dest_dict={}):
        """Upload files to the SFTP server"""
        files_written_to_dest = []

        if not self.sftp:
            self.sftp = self.connect()

        for file_path in file_path_list:
            temp_file_path = file_path
            if temp_dest_dict:
                temp_dest = temp_dest_dict.get(file_path)
                if temp_dest:
                    sftp_dir = temp_dest
            file_ref = FFTPLibHooks.fftplibrary_import_entry(self.read_mode, self.write_mode, file_path)
            if file_ref and type(file_ref) == str:
                file_path = file_ref
                result = self.upload_file(file_path, sftp_dir)
                if result:
                    files_written_to_dest.append(file_path)
            else:
                logger.WARN(
                    "File {} is filtered in fftplibrary_import_entry which returned value : {}".format(temp_file_path,
                                                                                                       str(file_ref)))

        return files_written_to_dest

    def close_connection(self):
        """Close the SFTP connection"""
        '''
        
        '''


    def list_from_sftp( self, sftp_dir):
        """ gives list of file from SFTP server """
        try:
            from chilkat import chilkat
            proxyPort = ''
            file_List = []
            try:
                glob = chilkat.CkGlobal()
                success = glob.UnlockBundle("FSLTNS.CB4032023_xPv5yNngkRpl")
                sftp = chilkat.CkSFtp()
                proxyHost = self.proxy_host
                if self.proxy_port:
                    proxyPort = int(self.proxy_port)
                HostName = self.host
                if self.port:
                    Port = int(self.port)
                username = self.user
                password = self.pwd
                if proxyPort and proxyHost:
                    sftp.put_HttpProxyHostname(proxyHost)
                    sftp.put_HttpProxyPort(proxyPort)
                success = sftp.Connect(HostName,Port)
                if (success != True):
                    logger.ERROR(sftp.lastErrorText())
                ret_task = sftp.AuthenticatePw(username,password)
                if (ret_task != True):
                    logger.ERROR(sftp.lastErrorText())
                status = sftp.InitializeSftp()
                handle = sftp.openDir(sftp_dir)
                if (sftp.get_LastMethodSuccess() != True):
                    logger.ERROR(sftp.lastErrorText())# dirListing is a CkSFtpDir
                dirListing = sftp.ReadDir(handle)
                if (sftp.get_LastMethodSuccess() != True):
                    logger.ERROR(sftp.lastErrorText())# Iterate over the files.
                i = 0
                n = dirListing.get_NumFilesAndDirs()
                while i < n :# fileObj is a CkSFtpFile
                    fileObj = dirListing.GetFileObject(i)
                    file = fileObj.filename()
                    i = i + 1
                    file_List.append(str(file))
                return  file_List

            except Exception as e:
                logger.ERROR("Exception in connecting to {} server using chilkat".format(self.host))
                logger.DEBUG(str(e), exc_info=1)
        except Exception as e:
            logger.WARN("%s" % e)

def validate_params(app_name, connstr, source_dir_list, dest_dir_list):
    """Check and validates parameters for read from sftp"""

    validation_param = True
    res_source_dir_list = '' in source_dir_list
    res_dest_dir_list = '' in dest_dir_list


    if app_name == '':
        logger.ERROR("Application name is empty, please provide application name")
        validation_param = False
    if connstr == '':
        logger.ERROR("Please give host, port, username, password (optional) in format HOST:PORT:USERNAME:PASSWORD")
        validation_param = False
    if res_source_dir_list :
        logger.ERROR("Source directory is empty, please provide source directory")
        validation_param = False
    if res_dest_dir_list :
        logger.ERROR("Destination directory is empty, please provide destination  directory")
        validation_param = False
        
        
    return validation_param

def check_sftp_object(sftp_obj):
    """check sftp object"""
    sftp_object_initialized = True
    if not sftp_obj.sftp:
        sftp_object_initialized = False
        try:
            poll_retry = int(sftp_obj.retry)
            if poll_retry:
                sftp_object_initialized = sftp_obj.retry_sftp_connection()
        except Exception as exp:
            logger.ERROR(str(exp))
        
        if not sftp_object_initialized:
            logger.INFO("Login to SFTP server is unsuccessful. Please check host, port, username (check if password is provided or check in FPassword hook against application name )")
    return sftp_object_initialized

def validate_params_for_write(app_name, connstr, source_dir_list):
    """Check and validates parameters for write to sftp"""
    validation_param = True


    res_source_dir_list = '' in source_dir_list
    
    if app_name == '':
        logger.ERROR("Application name is empty, please provide application name")
        validation_param = False
    if connstr == '':
        logger.ERROR("Please give host, port, username, password (optional) in format HOST:PORT:USERNAME:PASSWORD")
        validation_param = False
    if res_source_dir_list :
        logger.ERROR("Source directory is empty, please provide source directory")
        validation_param = False

        
        
    return validation_param
    
def read_from_sftp(download_dir, app_name, connstr, \
                   sftp_dir='', timeout=0, interval=0, retry=0, proxy_hostname='', proxy_portnumber=''):
    """ Copies file from SFTP server to local directory """
    try:
        download_dir_lst = FFTPConfig.string_as_list(download_dir)
        sftp_dir_lst = FFTPConfig.string_as_list(sftp_dir)
        if not validate_params(app_name, connstr, download_dir_lst, sftp_dir_lst):
            return 0
        source_dict = {}
        destination = download_dir_lst[0]
        if len(download_dir_lst) > 1 and len(download_dir_lst) == len(sftp_dir_lst):
            source_dict = dict(list(zip(sftp_dir_lst, download_dir_lst)))
        elif len(download_dir_lst) > 1:
            logger.ERROR("Invalid download_dir / sftp_dir provided as input to API")
            return

        result = 0
        if connstr:
            host, port, user, pwd = '', '', '', ''
            conn_param_lst = connstr.split(':')
            if len(conn_param_lst) > 2:
                host = conn_param_lst[0]
                port = conn_param_lst[1]
            if len(conn_param_lst) >= 3:
                user = conn_param_lst[2]
            if len(conn_param_lst) == 4:                
                pwd = conn_param_lst[3]
            sftp_obj = SFTPOperations(app_name, host, port, user, pwd, timeout, interval, retry, proxy_hostname, proxy_portnumber)
            
            if not check_sftp_object(sftp_obj):
                return result
            
            if sftp_obj.sftp:
                for each_source in sftp_dir_lst:
                    if source_dict:
                        destination = source_dict[each_source]
                    sftp_dir, filter = ntpath.split(os.path.expandvars(each_source))
                    result = sftp_obj.download_file(filename_lst=[filter], download_dir=destination, sftp_dir=sftp_dir)
                sftp_obj.close_connection()
        else:
            result = 0
        return result
    except Exception as e:
        logger.ERROR(str(e))


def write_to_sftp(app_name, file_path='',  connstr='', ftp_dir='',
                  timeout=0, interval=0, retry=0, proxy_hostname='', proxy_portnumber=''):
    """ Writes an file to SFTP server at specified directory """
    try:
        file_path_lst = FFTPConfig.string_as_list(file_path)
        ftp_dir_lst = FFTPConfig.string_as_list(ftp_dir)
        if not validate_params_for_write(app_name, connstr, file_path_lst):
            return 0
        source_dict = {}
        destination = ftp_dir_lst[0]
        if len(ftp_dir_lst) > 1 and len(ftp_dir_lst) == len(file_path_lst):
            source_dict = dict(list(zip(file_path_lst, ftp_dir_lst)))
        elif len(ftp_dir_lst) > 1:
            logger.ERROR("Invalid file_path / ftp_dir provided as input to API")
            return

        result = 0
        if connstr:
            host, port, user, pwd = '', '', '', ''
            conn_param_lst = connstr.split(':')
            if len(conn_param_lst) > 2:
                host = conn_param_lst[0]
                port = conn_param_lst[1]
            if len(conn_param_lst) >= 3:
                user = conn_param_lst[2]
            if len(conn_param_lst) == 4:
                pwd = conn_param_lst[3]
                                
            sftp_obj = SFTPOperations(app_name, host, port, user, pwd, timeout, interval, retry, proxy_hostname, proxy_portnumber)
            if not check_sftp_object(sftp_obj):
                return result
            if sftp_obj.sftp:

                for file_path in file_path_lst:
                    if source_dict:
                        destination = source_dict[file_path]
                    if "*" in file_path:
                        systemsettings_param = FFTPConfig.Parameters('FFTPSystemSettings')
                        timestamp = getattr(systemsettings_param, 'DONOT_TIMESTAMP_ARCHIVE_FILES', '')
                        dir_obj = DIROperations(timestamp)
                        dir_path, filter = ntpath.split(os.path.expandvars(file_path))
                        if os.path.exists(dir_path):
                            file_list = dir_obj.get_files_from_dir(dir_path, [filter])
                            for files in file_list:
                                file_to_upload = dir_path + os.sep + files
                                result = sftp_obj.upload_file(file_to_upload, destination)

                if os.path.isfile(file_path):
                    result = sftp_obj.upload_file(file_path, destination)
                elif "*" not in file_path :
                    for files in os.listdir(file_path):
                        file_to_open = file_path + '/' + files
                        result = sftp_obj.upload_file(file_to_open, destination)
            sftp_obj.close_connection()
        else:
            result = 0
        return result

    except Exception as e:
        logger.ERROR(str(e))
        result = 0
        
    return result



...

  FSFTPOperationsOverride
"""--------------------------------------------------------------------
MODULE
    FSFTPOperationsOverride -  This module provide override API's for Operations like reading and writing to SFTP server

DESCRIPTION
    This script handles the SFTP operations.

VERSION: 2.0.7
--------------------------------------------------------------------"""
import os
import fnmatch
import sys
import time
import ntpath

def connect_override(proxyHost, proxyPort, HostName, Port, username, password):
        """ Override API for SFTP Connect  """
        sftp = None
        '''
        Customized code for sftp connection      
        
        '''
        return sftp
    
def upload_file_override(sftp, file_path, upload_dir=None):
        """ Override API for SFTP file upload  """
        result = 0
        '''
        Customized code for sftp file upload    
        
        '''
        return result    
    
    
def polling_for_override(sftp, timeout, interval, filename_lst, download_dir, sftp_dir):
        """ Override API for SFTP polling  """
        result = 0
        '''
        Customized code for sftp file polling    
        result = self.override_poll_until_timeout(timeout, interval, file_name, download_dir, sftp_dir)
        
        '''
        
        return result   
    
    
def override_poll_until_timeout():
        """ Override API for SFTP polling timeout """
        result = 0
        '''
        Customized code for sftp file polling  timeout   
        
        '''
        result = download_file_using_override()
        return result      
    
    
def download_file_using_override():
        """ Override API for SFTP polling timeout """
        result = 0
        '''
        Customized code for sftp file polling  timeout   
        
        '''
        return result    

...

}

