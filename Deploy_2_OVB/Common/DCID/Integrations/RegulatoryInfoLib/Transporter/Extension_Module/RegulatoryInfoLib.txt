#
# FIS exported extension module.
# source          ""
# timestamp (utc) "2016-08-25 07:18:27"
# ***** DO NOT EDIT! *****
#
name        "RegulatoryInfoLib"
description ""

groups {
}
decls[FParameters] {
}

decls[FParameters] {
}

clx FObject [FParameters] {
  FRegulatoryAPIConfig=
FREGULATORY_ADDINFO =
FREGULATORY_API =

  FRegulatoryLogConfig=
FREGULATORY_LOGGER_NAME='RegulatoryInfo'
FREGULATORY_MESSAGE_VERBOSE='WARNING'
FREGULATORY_VERSION='1.0.29'
FREGULATORY_DEFAULT_MARKET='ECBFIX'
FREGULATORY_FXSWAP_TRADES='Both'#'Single'
FREGULATORY_TRANSACTION_LIMIT=10
FREGULATORY_MODULAR_FLAG=False

  FRegulatoryNotificationConfig=
FREGULATORY_NOTIFICATION_MEDIA=OFF
FREGULATORY_NOTIFICATION_MESSAGE_BROKER=''
FREGULATORY_NOTIFY_LEVEL=WARNING
FREGULATORY_NOTIFY_USERS=''
FREGULATORY_SMTP_SERVER=''
FREGULATORY_USER_EMAILS=''



}

decls[FPythonCode] {
}

clx FObject [FPythonCode] {
  FInstrumentClassification
import acm, ael
import FRegulatoryLogger
logger = 'FInstrumentClassification'

class FInstrumentClassification(object):
    def __init__(self, instrument, current_date=None):
        self.__instrument = instrument
        self.current_date = current_date

    def CD(self):
        rts2_instype = 'Bonds'
        rts2_subtype = None
        fpml_code = None
        return rts2_instype, rts2_subtype, fpml_code

    def Bill(self):
        rts2_instype = 'Bonds'
        rts2_subtype = None
        fpml_code = None
        return rts2_instype, rts2_subtype, fpml_code

    def Bond(self):
        rts2_instype = 'Bonds'
        rts2_subtype = None
        fpml_code = None
        return rts2_instype, rts2_subtype, fpml_code

    def DualCurrBond(self):
        rts2_instype = 'Bonds'
        rts2_subtype = None
        fpml_code = None
        return rts2_instype, rts2_subtype, fpml_code

    def Flexi_Bond(self):
        rts2_instype = 'Bonds'
        rts2_subtype = None
        fpml_code = None
        return rts2_instype, rts2_subtype, fpml_code

    def Convertible(self):
        rts2_instype = 'Bonds'
        rts2_subtype = None
        fpml_code = None
        return rts2_instype, rts2_subtype, fpml_code

    def Zero(self):
        rts2_instype = 'Bonds'
        rts2_subtype = None
        fpml_code = None
        return rts2_instype, rts2_subtype, fpml_code

    def FRN(self):
        rts2_instype = 'Bonds'
        rts2_subtype = None
        fpml_code = None
        return rts2_instype, rts2_subtype, fpml_code

    def IndexLinkedBond(self):
        rts2_instype = 'Bonds'
        rts2_subtype = None
        fpml_code = None
        return rts2_instype, rts2_subtype, fpml_code

    def PromisLoan(self):
        rts2_instype = 'Bonds'
        rts2_subtype = None
        fpml_code = None
        return rts2_instype, rts2_subtype, fpml_code

    def CreditDefaultSwap(self):
        rts2_instype = ''
        rts2_subtype = ''
        fpml_code = ''
        if self.__instrument.Underlying() and self.__instrument.Underlying().InsType() == 'Credit Index':
            rts2_instype = 'Credit Derivatives'
            rts2_subtype = 'Index credit default swap (CDS)'
            fpml_code = 'IndexCreditDefaultSwap'
        elif self.__instrument.Underlying() and self.__instrument.Underlying().InsType() in ['Bill', 'Bond',
                                                                                             'Convertible', 'Zero',
                                                                                             'FRN', 'IndexLinkedBond',
                                                                                             'PromisLoan']:
            rts2_instype = 'Credit Derivatives'
            rts2_subtype = 'Single name credit default swap (CDS)'
            fpml_code = 'SingleNameCreditDefaultSwap'
        elif self.__instrument.Underlying() and self.__instrument.Underlying().InsType() == 'Combination':
            rts2_instype = 'Credit Derivatives'
            rts2_subtype = 'Bespoke basket credit default swap (CDS)'
            fpml_code = 'BespokeCreditDefaultSwap'

        else:
            rts2_instype = 'Credit Derivatives'
            rts2_subtype = 'Other credit derivatives'
            fpml_code = 'Other'
        return rts2_instype, rts2_subtype, fpml_code

    def CFD(self):
        rts2_instype = ''
        rts2_subtype = ''
        fpml_code = ''
        if self.__instrument.Underlying() and self.__instrument.Underlying().InsType() in ['Stock',
                                                                                           'Depository Receipt']:
            rts2_instype = 'Financial contracts for differences'
            rts2_subtype = 'Equity CFDs'
            fpml_code = None
        if self.__instrument.Underlying() and self.__instrument.Underlying().InsType() == 'Bond':
            rts2_instype = 'Financial contracts for differences'
            rts2_subtype = 'Bond CFDs'
            fpml_code = None
        if self.__instrument.Underlying() and self.__instrument.Underlying().InsType() == 'EquityIndex':
            rts2_instype = 'Financial contracts for differences'
            rts2_subtype = 'Other CFDs'
            fpml_code = None
        return rts2_instype, rts2_subtype, fpml_code

    def CurrSwap(self):
        rts2_instype = ''
        rts2_subtype = ''
        fpml_code = ''
        legs = self.__instrument.Legs()
        if all([leg.LegType() == 'Fixed' for leg in legs]):
            rts2_instype = 'Interest Rate Derivatives'
            rts2_subtype = "Fixed-to-Fixed 'multi-currency swaps' or 'cross-currency swaps' and futures/forwards on Fixed-to-Fixed 'multi-currency swaps' or 'cross-currency swaps'"
            fpml_code = 'FixedFixed:CrossCurrency'
        elif any([leg.LegType() == 'Fixed' for leg in legs]) and any(
                [leg.LegType() == 'Float' for leg in legs]):
            rts2_instype = 'Interest Rate Derivatives'
            rts2_subtype = "Fixed-to-Float 'multi-currency swaps' or 'cross-currency swaps' and futures/forwards on Fixed-to-Float 'multi-currency swaps' or 'cross-currency swaps'"
            fpml_code = 'FixedFloat:CrossCurrency'
        elif all([leg.LegType() == 'Float' for leg in legs]):
            rts2_instype = 'Interest Rate Derivatives'
            rts2_subtype = "Float-to-Float 'multi-currency swaps' or 'cross-currency swaps' and futures/forwards on Float-to-Float 'multi-currency swaps' or 'cross-currency swaps'"
            fpml_code = 'FloatFloat:CrossCurrency'
        for leg in self.__instrument.Legs():
            if leg.LegType() == 'Float':
                if leg.RollingPeriodCount() == 1 and leg.RollingPeriodUnit() == "Days":
                    rts2_instype = 'Interest Rate Derivatives'
                    rts2_subtype = "Overnight Index Swap (OIS) 'multi-currency swaps' or 'cross-currency swaps' and futures/forwards on Overnight Index Swap (OIS) 'multi-currency swaps' or 'cross-currency swaps'"
                    fpml_code = 'OIS:CrossCurrency'
        return rts2_instype, rts2_subtype, fpml_code

    def Future_Forward(self):
        rts2_instype = ''
        rts2_subtype = ''
        fpml_code = ''

        if self.__instrument.Underlying() and self.__instrument.Underlying().InsType() == 'CurrSwap':
            legs = self.__instrument.Legs()
            if all([leg.LegType() == 'Fixed' for leg in legs]):
                rts2_instype = 'Interest Rate Derivatives'
                rts2_subtype = "Fixed-to-Fixed 'multi-currency swaps' or 'cross-currency swaps' and futures/forwards on Fixed-to-Fixed 'multi-currency swaps' or 'cross-currency swaps'"
                fpml_code = 'FixedFixed:CrossCurrency'
            elif any([leg.LegType() == 'Fixed' for leg in legs]) and any(
                    [leg.LegType() == 'Float' for leg in legs]):
                rts2_instype = 'Interest Rate Derivatives'
                rts2_subtype = "Float-to-Float 'multi-currency swaps' or 'cross-currency swaps' and futures/forwards on Float-to-Float 'multi-currency swaps' or 'cross-currency swaps'"
                fpml_code = 'FixedFloat:CrossCurrency'
            elif all([leg.LegType() == 'Float' for leg in legs]):
                rts2_instype = 'Interest Rate Derivatives'
                rts2_subtype = "Float-to-Float 'multi-currency swaps' or 'cross-currency swaps' and futures/forwards on Float-to-Float 'multi-currency swaps' or 'cross-currency swaps'"
                fpml_code = 'FloatFloat:CrossCurrency'
            for leg in self.__instrument.Legs():
                if leg.LegType() == 'Float':
                    if leg.RollingPeriodCount() == 1 and leg.RollingPeriodUnit() == "Days":
                        rts2_instype = 'Interest Rate Derivatives'
                        rts2_subtype = "Overnight Index Swap (OIS) 'multi-currency swaps' or 'cross-currency swaps' and futures/forwards on Overnight Index Swap (OIS) 'multi-currency swaps' or 'cross-currency swaps'"
                        fpml_code = 'OIS:CrossCurrency'
        elif self.__instrument.Underlying() and self.__instrument.Underlying().InsType() == 'Dividend Point Index':
            rts2_instype = 'Equity Derivatives'
            rts2_subtype = 'Dividend index futures/ forwards'
            fpml_code = 'DividendIndexFutureForward'
        elif self.__instrument.Underlying() and self.__instrument.Underlying().InsType() == 'ETF':
            rts2_instype = 'Equity Derivatives'
            rts2_subtype = 'ETF futures/ forwards'
            fpml_code = 'ETFFutureForward'
        elif self.__instrument.Underlying() and self.__instrument.Underlying().InsType() in ['Stock',
                                                                                             'Depository Receipt']:
            rts2_instype = 'Equity Derivatives'
            rts2_subtype = 'Stock futures/ forwards'
            fpml_code = 'StockFutureForward'
        elif self.__instrument.Underlying() and self.__instrument.Underlying().InsType() == 'EquityIndex':
            rts2_instype = 'Equity Derivatives'
            rts2_subtype = 'Stock index futures/ forwards'
            fpml_code = 'StockIndexFutureForward'
        elif self.__instrument.Underlying() and self.__instrument.Underlying().InsType() == 'Curr' and not self.__instrument.Otc():
            rts2_instype = 'Foreign Exchange Derivatives'
            rts2_subtype = 'FX futures'
            fpml_code = 'Future'
        elif self.__instrument.Underlying() and self.__instrument.Underlying().InsType() in ['Bill', 'Bond',
                                                                                             'Convertible', 'Zero',
                                                                                             'CLN', 'FRN',
                                                                                             'IndexLinkedBond',
                                                                                             'PromisLoan']:
            rts2_instype = 'Interest Rate Derivatives'
            rts2_subtype = 'Bond futures/forwards'
            fpml_code = 'BondFutureForward'
        elif self.__instrument.Underlying().InsType() == 'Combination':
            for leg in self.__instrument.Legs():
                instrument_map = leg.FloatRateReference().InstrumentMaps()
                if all([ins.Instrument().InsType() in ['Stock', 'EquityIndex', 'ETF', 'Depositary Receipt',
                                                                   'Dividend Point Index'] for ins in instrument_map]):
                    rts2_instype = 'Equity Derivatives'
                    rts2_subtype = 'Other equity derivatives'
                    fpml_code = 'Other'
        elif self.__instrument.Underlying() and self.__instrument.Underlying().InsType() == 'Curr':
            settlement_type = self.__instrument.SettlementType()
            if settlement_type == 'Physical Delivery' and self.__instrument.Otc():
                rts2_instype = 'Foreign Exchange Derivatives'
                rts2_subtype = 'Deliverable forward(DF)'
                fpml_code = 'DeliverableForward'
            elif settlement_type == 'Cash' and self.__instrument.Otc():
                rts2_instype = 'Foreign Exchange Derivatives'
                rts2_subtype = 'Non-deliverable forward (NDF)'
                fpml_code = 'NonDeliverableForward'
        elif self.__instrument.Underlying() and self.__instrument.Underlying().InsType() == 'Swap':
            legs = self.__instrument.Underlying().Legs()
            if all([leg.LegType() == 'Fixed' for leg in legs]):
                rts2_instype = 'Interest Rate Derivatives'
                rts2_subtype = "Fixed-to-Fixed 'single currency swaps' and futures/forwards on Fixed-to-Fixed 'single currency swaps'"
                fpml_code = 'FixedFixed:SingleCurrency'
            elif any([leg.LegType() == 'Fixed' for leg in legs]) and any(
                    [leg.LegType() == 'Float' for leg in legs]):
                rts2_instype = 'Interest Rate Derivatives'
                rts2_subtype = "Fixed-to-Float 'single currency swaps' and futures/forwards on Fixed-to-Float 'single currency swaps'"
                fpml_code = 'FixedFloat:SingleCurrency'
            elif all([leg.LegType() == 'Float' for leg in legs]):
                rts2_instype = 'Interest Rate Derivatives'
                rts2_subtype = "Float-to-Float 'single currency swaps' and futures/forwards on Float-to-Float 'single currency swaps'"
                fpml_code = 'FloatFloat:SingleCurrency'
            for leg in self.__instrument.Legs():
                if leg.LegType() == 'Float':
                    if leg.RollingPeriodCount() == 1 and leg.RollingPeriodUnit() == 'Days':
                        rts2_instype = 'Interest Rate Derivatives'
                        rts2_subtype = "Overnight Index Swap (OIS) 'single currency swaps' and futures/forwards on Overnight Index Swap (OIS) 'single currency swaps'"
                        fpml_code = 'OIS:SingleCurrency'

        for leg in self.__instrument.Legs():
            if leg.FloatRateReference().InsType() == 'PriceIndex':
                curr = set([l.Currency().Name() for l in self.__instrument.Legs()])
                if len(curr) > 1:
                    rts2_instype = 'Interest Rate Derivatives'
                    rts2_subtype = "Inflation 'multi-currency swaps' or 'cross-currency swaps' and futures/forwards on Inflation 'multi-currency swaps' or 'cross-currency swaps'"
                    fpml_code = 'Inflation:CrossCurrency'
                else:
                    rts2_instype = 'Interest Rate Derivatives'
                    rts2_subtype = "Inflation 'single currency swaps' and futures/forwards on Inflation 'single currency swaps'"
                    fpml_code = 'Inflation:SingleCurrency'

        underlying = self.__instrument.Underlying()
        if underlying and underlying.InsType() in ['Commodity', 'Commodity Variant', 'Commodity Index']:
            try:
                if underlying.RegulatoryInfo() and underlying.RegulatoryInfo().CommodityBaseProduct():
                    if underlying.RegulatoryInfo().CommodityBaseProduct().Name() == 'AGRI':
                        rts2_instype = 'Commodity Derivatives'
                        rts2_subtype = 'Agricultural commodity futures/forwards'
                        fpml_code = 'AgriculturalCommodityFutureForward'
                    elif underlying.RegulatoryInfo().CommodityBaseProduct().Name() == 'METL':
                        rts2_instype = 'Commodity Derivatives'
                        rts2_subtype = 'Metal commodity futures/forwards'
                        fpml_code = None
                    elif underlying.RegulatoryInfo().CommodityBaseProduct().Name() == 'NRGY':
                        rts2_instype = 'Commodity Derivatives'
                        rts2_subtype = 'Energy commodity futures/forwards'
                        fpml_code = None
                    elif underlying.RegulatoryInfo().CommodityBaseProduct().Name() not in ['AGRI', 'METL', 'NRGY']:
                        rts2_instype = 'Commodity Derivatives'
                        rts2_subtype = 'Other commodity derivatives'
                        fpml_code = 'Other'
                else:
                    rts2_instype = 'Commodity Derivatives'
                    rts2_subtype = 'Other commodity derivatives'
                    fpml_code = 'Other'
            except Exception as e:
                FRegulatoryLogger.ERROR(logger, "RegulatorySupport package needs to be installed to use this functionality")
        return rts2_instype, rts2_subtype, fpml_code

    def Certificate(self):
        rts2_instype = ''
        rts2_subtype = ''
        fpml_code = ''
        if self.__instrument.Underlying() and self.__instrument.Underlying().InsType() == 'EquityIndex':
            rts2_instype = 'Equity Derivatives'
            rts2_subtype = 'Stock index futures/ forwards'
            fpml_code = 'StockIndexFutureForward'
        return rts2_instype, rts2_subtype, fpml_code

    def Deposit_Loan(self):
        rts2_instype = 'Interest Rate Derivatives'
        rts2_subtype = 'Other Interest Rate Derivatives'
        fpml_code = 'Other'
        return rts2_instype, rts2_subtype, fpml_code

    def FRA(self):
        rts2_instype = 'Interest Rate Derivatives'
        rts2_subtype = 'IR futures and FRA'
        fpml_code = 'FutureFra'
        return rts2_instype, rts2_subtype, fpml_code

    def Average_Future_Forward(self):
        rts2_instype = ''
        rts2_subtype = ''
        fpml_code = ''

        for leg in self.__instrument.Legs():
            if leg.LegType() == 'Float' and leg.FloatRateReference():
                if leg.FloatRateReference().InsType() in ['Commodity', 'Commodity Variant', 'Commodity Index']:
                    try:
                        if leg.FloatRateReference().RegulatoryInfo() and leg.FloatRateReference().RegulatoryInfo().CommodityBaseProduct():
                            if leg.FloatRateReference().RegulatoryInfo().CommodityBaseProduct().Name() == 'AGRI':
                                rts2_instype = 'Commodity Derivatives'
                                rts2_subtype = 'Agricultural commodity futures/forwards'
                                fpml_code = 'AgriculturalCommodityFutureForward'
                            elif leg.FloatRateReference().RegulatoryInfo().CommodityBaseProduct().Name() == 'METL':
                                rts2_instype = 'Commodity Derivatives'
                                rts2_subtype = 'Metal commodity futures/forwards'
                                fpml_code = None
                            elif leg.FloatRateReference().RegulatoryInfo().CommodityBaseProduct().Name() == 'NRGY':
                                rts2_instype = 'Commodity Derivatives'
                                rts2_subtype = 'Energy commodity futures/forwards'
                                fpml_code = None
                            elif leg.FloatRateReference().RegulatoryInfo().CommodityBaseProduct().Name() not in ['AGRI',
                                                                                                                 'METL',
                                                                                                                 'NRGY']:
                                rts2_instype = 'Commodity Derivatives'
                                rts2_subtype = 'Other commodity derivatives'
                                fpml_code = 'Other'
                        else:
                            rts2_instype = 'Commodity Derivatives'
                            rts2_subtype = 'Other commodity derivatives'
                            fpml_code = 'Other'
                    except Exception as e:
                        FRegulatoryLogger.ERROR(logger, "RegulatorySupport package needs to be installed to use this functionality")
        return rts2_instype, rts2_subtype, fpml_code

    def Option(self):
        rts2_instype = ''
        rts2_subtype = ''
        fpml_code = ''
        if self.__instrument.Underlying():

            if self.__instrument.Underlying().InsType() in ['Commodity', 'Commodity Variant', 'Commodity Index']:
                try:
                    if self.__instrument.Underlying().RegulatoryInfo() and self.__instrument.Underlying().RegulatoryInfo().CommodityBaseProduct():
                        if self.__instrument.Underlying().RegulatoryInfo().CommodityBaseProduct().Name() == "AGRI":
                            rts2_instype = 'Commodity Derivatives'
                            rts2_subtype = 'Agricultural commodity options'
                            fpml_code = 'AgriculturalCommodityOption'
                        elif self.__instrument.Underlying().RegulatoryInfo().CommodityBaseProduct().Name() == 'METL':
                            rts2_instype = 'Commodity Derivatives'
                            rts2_subtype = 'Metal commodity options'
                            fpml_code = None
                        elif self.__instrument.Underlying().RegulatoryInfo().CommodityBaseProduct().Name() == 'NRGY':
                            rts2_instype = 'Commodity Derivatives'
                            rts2_subtype = 'Energy commodity options'
                            fpml_code = None
                        elif self.__instrument.Underlying().RegulatoryInfo().CommodityBaseProduct().Name() not in [
                            'AGRI', 'METL', 'NRGY']:
                            rts2_instype = 'Commodity Derivatives'
                            rts2_subtype = 'Other commodity derivatives'
                            fpml_code = 'Other'
                    else:
                        rts2_instype = 'Commodity Derivatives'
                        rts2_subtype = 'Other commodity derivatives'
                        fpml_code = 'Other'
                except Exception as e:
                    FRegulatoryLogger.ERROR(logger, "RegulatorySupport package needs to be installed to use this functionality")

            elif self.__instrument.Underlying().InsType() == 'ETF':
                rts2_instype = 'Equity Derivatives'
                rts2_subtype = 'ETF options'
                fpml_code = 'ETFOption'
            elif self.__instrument.Underlying().InsType() == 'EquityIndex':
                rts2_instype = 'Equity Derivatives'
                rts2_subtype = 'Stock index options'
                fpml_code = 'StockIndexOption'
            elif self.__instrument.Underlying().InsType() in ['Stock', 'Depositary Receipt']:
                rts2_instype = 'Equity Derivatives'
                rts2_subtype = 'Stock options'
                fpml_code = 'StockOption'
            elif self.__instrument.Underlying().InsType() == 'RateIndex':
                rts2_instype = 'Interest Rate Derivatives'
                rts2_subtype = 'IR options'
                fpml_code = 'Option'
            elif self.__instrument.Underlying().InsType() in ['Swap', 'CurrSwap']:
                rts2_instype = 'Interest Rate Derivatives'
                rts2_subtype = 'Swaptions'
                fpml_code = 'Swaption'
            elif self.__instrument.Underlying().InsType() == 'Curr':
                settlement_type = self.__instrument.SettlementType()
                if settlement_type == 'Physical Delivery':
                    rts2_instype = 'Foreign Exchange Derivatives'
                    rts2_subtype = 'Deliverable FX options (DO)'
                    fpml_code = 'DeliverableOption'
                elif settlement_type == 'Cash':
                    rts2_instype = 'Foreign Exchange Derivatives'
                    rts2_subtype = 'Non-Deliverable FX options (NDO)'
                    fpml_code = 'NonDeliverableOption'

            elif self.__instrument.Underlying().InsType() == 'CreditDefaultSwap':
                if self.__instrument.Underlying().Underlying() and self.__instrument.Underlying().Underlying().InsType() == 'CreditIndex':
                    rts2_instype = 'Credit Derivatives'
                    rts2_subtype = 'CDS index options'
                    fpml_code = 'IndexOption'
                elif self.__instrument.Underlying().Underlying() and self.__instrument.Underlying().Underlying().InsType() in [
                    'Bill', 'Bond', 'Convertible',
                    'Zero', 'FRN', 'IndexLinkedBond', 'PromisLoan']:
                    rts2_instype = 'Credit Derivatives'
                    rts2_subtype = 'Single name CDS options'
                    fpml_code = 'SingleNameOption'
            elif self.__instrument.Underlying().InsType() in ['Bill', 'Bond', 'Convertible', 'Zero', 'CLN', 'FRN',
                                                              'IndexLinkedBond', 'PromisLoan']:
                rts2_instype = 'Interest Rate Derivatives'
                rts2_subtype = 'Bond options'
                fpml_code = 'BondOption'

            elif self.__instrument.Underlying() and self.__instrument.Underlying().InsType() == 'Combination':
                if all([ins.Instrument().InsType() in ['Stock', 'EquityIndex', 'ETF', 'Depositary Receipt',
                                                                   'Dividend Point Index'] for ins in self.__instrument.Underlying().InstrumentMaps()]):
                    rts2_instype = 'Equity Derivatives'
                    rts2_subtype = 'Other equity derivatives'
                    fpml_code = 'Other'
        return rts2_instype, rts2_subtype, fpml_code

    def FX_Option(self):
        rts2_instype = ''
        rts2_subtype = ''
        fpml_code = ''
        settlement_type = self.__instrument.SettlementType()
        if settlement_type == 'Physical Delivery':
            rts2_instype = 'Foreign Exchange Derivatives'
            rts2_subtype = 'Deliverable FX options (DO)'
            fpml_code = 'DeliverableOption'
        elif settlement_type == 'Cash':
            rts2_instype = 'Foreign Exchange Derivatives'
            rts2_subtype = 'Non-Deliverable FX options (NDO)'
            fpml_code = 'NonDeliverableOption'
        return rts2_instype, rts2_subtype, fpml_code

    def Swap(self):
        rts2_instype = ''
        rts2_subtype = ''
        fpml_code = ''
        legs = self.__instrument.Legs()
        if all([leg.LegType() == 'Fixed' for leg in legs]):
            rts2_instype = 'Interest Rate Derivatives'
            rts2_subtype = "Fixed-to-Fixed 'single currency swaps' and futures/forwards on Fixed-to-Fixed 'single currency swaps'"
            fpml_code = 'FixedFixed:SingleCurrency'
        elif any([leg.LegType() == 'Fixed' for leg in legs]) and any(
                [leg.LegType() == 'Float' for leg in legs]):
            rts2_instype = 'Interest Rate Derivatives'
            rts2_subtype = "Fixed-to-Float 'single currency swaps' and futures/forwards on Fixed-to-Float 'single currency swaps'"
            fpml_code = 'FixedFloat:SingleCurrency'
        elif all([leg.LegType() == 'Float' for leg in legs]):
            rts2_instype = 'Interest Rate Derivatives'
            rts2_subtype = "Float-to-Float 'single currency swaps' and futures/forwards on Float-to-Float 'single currency swaps'"
            fpml_code = 'FloatFloat:SingleCurrency'

        elif self.__instrument.Underlying().InsType() in ['Commodity', 'Commodity Variant', 'Commodity Index']:
            rts2_instype = 'Commodity Derivatives'
            rts2_subtype = 'Other commodity derivatives'
            fpml_code = 'Other'

        for leg in self.__instrument.Legs():
            if leg.LegType() == 'Float':
                if leg.RollingPeriodCount() == 1 and leg.RollingPeriodUnit() == 'Days':
                    rts2_instype = 'Interest Rate Derivatives'
                    rts2_subtype = "Overnight Index Swap (OIS) 'single currency swaps' and futures/forwards on Overnight Index Swap (OIS) 'single currency swaps'"
                    fpml_code = 'OIS:SingleCurrency'
        return rts2_instype, rts2_subtype, fpml_code

    def FXOptionDatedFwd(self):
        rts2_instype = 'Foreign Exchange Derivatives'
        rts2_subtype = 'Deliverable forward (DF)'
        fpml_code = 'DeliverableForward'
        return rts2_instype, rts2_subtype, fpml_code

    def FXNDF(self):
        rts2_instype = 'Foreign Exchange Derivatives'
        rts2_subtype = 'Non-deliverable forward (NDF)'
        fpml_code = 'NonDeliverableForward'
        return rts2_instype, rts2_subtype, fpml_code

    def MBS_ABS(self):
        rts2_instype = 'Structured Finance Products (SFPs)'
        rts2_subtype = None
        fpml_code = None
        return rts2_instype, rts2_subtype, fpml_code

    def CLN(self):
        rts2_instype = 'Structured Finance Products (SFPs)'
        rts2_subtype = None
        fpml_code = None
        return rts2_instype, rts2_subtype, fpml_code

    def BasketRepo_Reverse(self):
        rts2_instype = 'Structured Finance Products (SFPs)'
        rts2_subtype = None
        fpml_code = None
        return rts2_instype, rts2_subtype, fpml_code

    def BasketSecurityLoan(self):
        rts2_instype = 'Structured Finance Products (SFPs)'
        rts2_subtype = None
        fpml_code = None
        return rts2_instype, rts2_subtype, fpml_code

    def BuySellback(self):
        rts2_instype = 'Structured Finance Products (SFPs)'
        rts2_subtype = None
        fpml_code = None
        return rts2_instype, rts2_subtype, fpml_code

    def Cap(self):
        rts2_instype = 'Interest Rate Derivatives'
        rts2_subtype = 'IR options'
        fpml_code = 'Option'
        return rts2_instype, rts2_subtype, fpml_code

    def Floor(self):
        rts2_instype = 'Interest Rate Derivatives'
        rts2_subtype = 'IR options'
        fpml_code = 'Option'
        return rts2_instype, rts2_subtype, fpml_code

    def IndexLinkedSwap(self):
        rts2_instype = ''
        rts2_subtype = ''
        fpml_code = ''
        for leg in self.__instrument.Legs():
            if leg.LegType() == 'Float':
                if leg.RollingPeriodCount() == 1 and leg.RollingPeriodUnit() == 'Days':
                    rts2_instype = 'Interest Rate Derivatives'
                    rts2_subtype = "Overnight Index Swap (OIS) 'single currency swaps' and futures/forwards on Overnight Index Swap (OIS) 'single currency swaps'"
                    fpml_code = 'OIS:SingleCurrency'
        return rts2_instype, rts2_subtype, fpml_code

    def Repo_Reverse(self):
        rts2_instype = 'Structured Finance Products (SFPs)'
        rts2_subtype = None
        fpml_code = None
        return rts2_instype, rts2_subtype, fpml_code

    def PriceSwap(self):
        rts2_instype = ''
        rts2_subtype = ''
        fpml_code = ''
        for leg in self.__instrument.Legs():
            if leg.LegType() == 'Float' and leg.FloatRateReference():
                if leg.FloatRateReference().InsType() in ['Commodity', 'Commodity Variant', 'Commodity Index']:
                    rts2_instype = 'Commodity Derivatives'
                    rts2_subtype = 'Other commodity derivatives'
                    fpml_code = 'Other'
        return rts2_instype, rts2_subtype, fpml_code

    def TotalReturnSwap(self):
        rts2_instype = ''
        rts2_subtype = ''
        fpml_code = ''
        for leg in self.__instrument.Legs():
            if leg.LegType() == 'Total Return' and leg.FloatRateReference():
                if leg.FloatRateReference().InsType() in ['Commodity', 'Commodity Variant', 'Commodity Index']:

                    try:
                        if leg.FloatRateReference().RegulatoryInfo() and leg.FloatRateReference().RegulatoryInfo().CommodityBaseProduct():
                            if leg.FloatRateReference().RegulatoryInfo().CommodityBaseProduct().Name() == "AGRI":
                                rts2_instype = 'Commodity Derivatives'
                                rts2_subtype = 'Agricultural commodity swaps'
                                fpml_code = 'AgriculturalCommoditySwap'
                            elif leg.FloatRateReference().RegulatoryInfo().CommodityBaseProduct().Name() == "NRGY":
                                rts2_instype = 'Commodity Derivatives'
                                rts2_subtype = 'Energy commodity swaps'
                                fpml_code = 'EnergyCommoditySwap'
                            elif leg.FloatRateReference().RegulatoryInfo().CommodityBaseProduct().Name() == "METL":
                                rts2_instype = 'Commodity Derivatives'
                                rts2_subtype = 'Metal commodity swaps'
                                fpml_code = None
                            elif leg.FloatRateReference().RegulatoryInfo().CommodityBaseProduct().Name() not in ['AGRI',
                                                                                                                 'METL',
                                                                                                                 'NRGY']:
                                rts2_instype = 'Commodity Derivatives'
                                rts2_subtype = 'Other commodity derivatives'
                                fpml_code = 'Other'
                        else:
                            rts2_instype = 'Commodity Derivatives'
                            rts2_subtype = 'Other commodity derivatives'
                            fpml_code = 'Other'
                    except Exception as e:
                        FRegulatoryLogger.ERROR(logger, "RegulatorySupport package needs to be installed to use this functionality")

                elif leg.FloatRateReference().InsType() in ['Stock', 'EquityIndex', 'Dividend Point Index', 'ETF',
                                                            'Depository Receipt']:
                    rts2_instype = 'Equity Derivatives'
                    rts2_subtype = 'Swaps'
                    fpml_code = 'Swap'
                elif leg.FloatRateReference().InsType() == 'Combination' and all([ins.Instrument().InsType() in ['Stock', 'EquityIndex', 'ETF', 'Depositary Receipt',
                                                                   'Dividend Point Index'] for ins in leg.FloatRateReference().InstrumentMaps()]):
                    rts2_instype = 'Equity Derivatives'
                    rts2_subtype = 'Portfolio Swaps'
                    fpml_code = 'PortfolioSwap'
                elif leg.FloatRateReference().InsType() == 'PriceIndex':
                    curr = set([l.Currency().Name() for l in self.__instrument.Legs()])
                    if len(curr) > 1:
                        rts2_instype = 'Interest Rate Derivatives'
                        rts2_subtype = "Inflation 'multi-currency swaps' or 'cross-currency swaps' and futures/forwards on Inflation 'multi-currency swaps' or 'cross-currency swaps'"
                        fpml_code = 'Inflation:CrossCurrency'
                    else:
                        rts2_instype = 'Interest Rate Derivatives'
                        rts2_subtype = "Inflation 'single currency swaps' and futures/forwards on Inflation 'single currency swaps'"
                        fpml_code = 'Inflation:SingleCurrency'
        return rts2_instype, rts2_subtype, fpml_code

    def Warrant(self):
        rts2_instype = 'Securitised Derivatives'
        rts2_subtype = None
        fpml_code = None
        return rts2_instype, rts2_subtype, fpml_code

    def __instrument_classification(self):
        instrument_type = self.__instrument.InsType()
        if instrument_type.find('/') != -1:
            instrument_type = instrument_type.replace('/', '_')
        if instrument_type.find(' ') != -1:
            instrument_type = instrument_type.replace(' ', '_')
        ins_type = None
        sub_type = None
        fpml_code = None
        try:
            ins_type, sub_type, fpml_code = eval('self.' + instrument_type + '()')
        except Exception as e:
            if instrument_type in ['Combination', 'Commodity', 'Curr', 'Commodity_Index', 'Commodity_Variant',
                                   'Credit_Balance', 'CreditIndex', 'Depositary_Receipt', 'Deposit',
                                   'Dividend_Point_Index', 'ETF', 'EquityIndex', 'FreeDefCF', 'FxSwap', 'PriceIndex',
                                   'PriceSwap', 'RateIndex', 'Rolling_Schedule', 'SecurityLoan', 'Stock',
                                   'VarianceSwap', 'VolatilitySwap']:
                pass
            else:
                FRegulatoryLogger.ERROR(logger, "Could not infer the instrument classification. Error: <%s>"%str(e))

        return ins_type, sub_type, fpml_code

    def fpml_code(self):
        ins_type, subtype, fpml_code = self.__instrument_classification()
        return fpml_code

    def mifid2_rts2_instype(self):
        ins_type, subtype, fpml_code = self.__instrument_classification()
        return ins_type

    def mifid2_rts2_inssubtype(self):
        ins_type, subtype, fpml_code = self.__instrument_classification()
        return subtype




...

  FRegulatoryAPIConfigureGUI
"""------------------------------------------------------------------------
MODULE
    FRegulatoryAPIConfigureGUI -
DESCRIPTION:
    This file consists of the task GUI that lists down all Regulatory APIs that can be made available on different objects
VERSION: 1.0.29(0.1.1278)
RESTRICTIONS/ LIMITATIONS:
    1. Any modifications to the scripts/ encrypted modules/ clear text code within the core is not supported.
    2. This module is not customizable
    3. The component may not work as expected with any modifications done to this module at user end
--------------------------------------------------------------------------"""
import FRegulatoryAPIs
import FRegulatoryConfigParam
import ast
import FRunScriptGUI
import FRegulatoryLibUtils
import FRegulatorySupportAPIs
import FRegulatoryLogger

logger = 'FRegulatoryAPIConfigureGUI'

reg_api_obj = FRegulatoryAPIs.RegulatoryMethods()
std_ratings_obj = FRegulatoryAPIs.StandardRatings()
config_param = FRegulatoryConfigParam.FRegulatoryConfigParam()


def get_apis():
    """returns the list of Regulatory API(s)"""
    return ['Collateral', 'SFTR', 'Standard', 'Ratings']


def get_standard_apis():
    """returns standard api(s)"""
    return reg_api_obj._standardMethods


def get_collateral_methods():
    """returns list of collateral api(s)"""
    return reg_api_obj._collateralMethods


def get_sftr_methods():
    """returns list of sftr api(s)"""
    return reg_api_obj._SFTRMethods


def get_ratings():
    """returns list of rating api(s)"""
    return std_ratings_obj._ratings


api_method_dict = {'Collateral': get_collateral_methods(), 'SFTR': get_sftr_methods(), 'Ratings': get_ratings(),
                   'Standard': get_standard_apis()}


class RegulatoryLibAelVariables(FRunScriptGUI.AelVariablesHandler):

    def enable_disable_override_value(self, index, field_values):
        """enables or disables api"""
        the_api = field_values[index]
        api_list = []
        if config_param:
            if len(config_param.get_paramvalue('FREGULATORY_API')) != 0:
                api_dict = ast.literal_eval(config_param.get_paramvalue('FREGULATORY_API'))
                if api_dict.values():
                    api_list = [inner for outer in api_dict.values() for inner in outer]
                    field_values[index + 1] = ','.join(api_list)
        if the_api:
            api_list.extend((api_method_dict.get(the_api)))
            ael_variables[1][3] = list(set(api_list))
        return field_values

    def enable_disable_add_info(self, index, field_values):
        """enables or disables add-info"""
        add_info_list = []
        add_info_apis = None
        if config_param:
            if len(config_param.get_paramvalue('FREGULATORY_ADDINFO')) != 0:
                add_info_list = config_param.get_paramvalue('FREGULATORY_ADDINFO').strip('][').split(', ')
                field_values[index + 1] = ','.join(add_info_list)

        add_info_apis = field_values[index]
        add_info_list.extend(add_info_apis.split(','))
        ael_variables[2][3] = add_info_list
        return field_values

    def __init__(self):
        """initialises ConservatoryAELVariables"""
        # 0-name, 1-field name_tab, 2-data_type, 3-values, 4-default value, 5-Mandatory, 6-'', 7-tooltip, 8-enable/disable method, 9-enable/disable
        vars = [

            ['apis', 'Select Classification_Create API', 'string', get_apis(), '', 0, 0,
             "Select Classification.", self.enable_disable_override_value,
             None],

            ['apis_selected', 'Select API(s)_Create API', 'string', '', '', 0, 1,
             "Select Regulatory API to be created", self.enable_disable_add_info, None],

            ['add_info_selected', 'Select API(s)_Create AddInfo', 'string', '', '', 0, 1,
             "Select API on which AddInfo needs to be created", None, None]

        ]
        FRunScriptGUI.AelVariablesHandler.__init__(self, vars)


ael_variables = RegulatoryLibAelVariables()


def ael_main(ael_params):
    """
    Main function
    """
    selected_apis_dict = {}
    selected_add_info_list = []
    add_infos_to_create = []
    api_keys = ael_params.get('apis')
    api_values = ael_params.get('apis_selected')
    add_infos = ael_params.get('add_info_selected')

    FRegulatoryLogger.INFO(logger, "Create Ternary API(s):<%s>" % (str(api_values)))
    FRegulatoryLogger.INFO(logger, "Create AddInfo(s) <%s>" % (str(add_infos)))
    for api_key, api_val in api_method_dict.items():
        for api in api_values:
            if api in api_val:
                selected_apis_dict.setdefault(api_key, []).append(api)
        if api_key not in selected_apis_dict.keys():
            selected_apis_dict.setdefault(api_key, [])

    FRegulatoryLibUtils.save_apis_in_fparameters(selected_apis_dict, add_infos)

    # AddInfo functions
    for add_info_api in add_infos:

        if reg_api_obj._addInfoStandardDict.get(add_info_api):
            selected_add_info_list.append(reg_api_obj._addInfoStandardDict.get(add_info_api)[0])
            FRegulatoryLogger.DEBUG(logger, "Create AddInfo on Standard API(s) <%s>" % (add_info_api))
        if std_ratings_obj._ratingMethodsAddInfoDictIns.get(add_info_api):
            selected_add_info_list.append(std_ratings_obj._ratingMethodsAddInfoDictIns.get(add_info_api)[0])
            FRegulatoryLogger.DEBUG(logger, "Create AddInfo on Rating API(s) <%s> on Instrument" % (add_info_api))
        if std_ratings_obj._ratingMethodsAddInfoDictParty.get(add_info_api):
            selected_add_info_list.append(std_ratings_obj._ratingMethodsAddInfoDictParty.get(add_info_api)[0])
            FRegulatoryLogger.DEBUG(logger, "Create AddInfo on Rating API(s) <%s> on Party" % (add_info_api))

    for addinfos in FRegulatorySupportAPIs.addInfoSpecs:
        for selected_add_info in selected_add_info_list:
            if addinfos.get('FieldName') == selected_add_info:
                FRegulatoryLogger.DEBUG(logger, "Creating AddInfo <%s>" % (selected_add_info))
                FRegulatorySupportAPIs.create_additional_info_spec(addinfos)
                FRegulatoryLogger.INFO(logger, "Created AddInfo <%s>" % (selected_add_info))

    # Creation of API(s)
    for api in get_apis():
        if selected_apis_dict.get(api):
            FRegulatoryLogger.DEBUG(logger,
                                    "Setting up <%s> Regulatory API<%s>" % (api, selected_apis_dict.get('SFTR')))
            if api == 'SFTR':
                reg_api_obj.setupSFTRMethods(selected_apis_dict.get('SFTR'))
            if api == 'Collateral':
                reg_api_obj.setupCollateralMethods(selected_apis_dict.get('Collateral'))
            if api == 'Standard':
                reg_api_obj.setupStandardMethods(selected_apis_dict.get('Standard'))
            if api == 'Ratings':
                reg_api_obj.setupRatingMethod(selected_apis_dict.get('Ratings'))
            FRegulatoryLogger.INFO(logger, "Created <%s> Regulatory API <%s>" % (api, selected_apis_dict.get('SFTR')))

...

  FRegulatoryAPIs
"""------------------------------------------------------------------------
MODULE
    FRegulatoryAPIs -
DESCRIPTION:
    This file consists of the Regulatory APIs that can be made available on different objects
VERSION: 1.0.29(0.1.1278)
RESTRICTIONS/ LIMITATIONS:
    1. Any modifications to the scripts/ encrypted modules/ clear text code within the core is not supported. 
    2. This module is not customizable
    3. The component may not work as expected with any modifications done to this module at user end
--------------------------------------------------------------------------"""


import FRegulatoryLibWrapper
import FRegulatoryLogger
import acm
import FRegulatoryConfigParam
logger = 'FRegulatoryAPIs'
class RegulatoryMethods(object):
    def __init__(self):
        
        self.apiOnClassDict = {'IsCleared' : 'acm.FTrade',
                               'HiQualityLiquidAsset' : 'acm.FInstrument',
                               'CountryOfIssue' : 'acm.FInstrument',
                               'BondType' : 'acm.FInstrument',
                               'BbgCollateralType' : 'acm.FInstrument',
                               'IsGovernmentGuaranteed' : 'acm.FInstrument',
                               'IsCovered' : 'acm.FInstrument',
                               'FundType' : 'acm.FInstrument',
                               'MainTradingPlace' : 'acm.FInstrument',
                               'SFTRSecurityType' : 'acm.FInstrument',
                               'IsEquity' : 'acm.FInstrument',
                               'SFTRIsCollateralProvider' : 'acm.FTrade',
                               'IsAllocated' : 'acm.FAccount',
                               'TradeDepository' : 'acm.FAccount',
                               'OutstandingShares' : 'acm.FInstrument',
                               'IssuerType' : 'acm.FInstrument',
                               'SFTRType' : 'acm.FTrade',
                               'DayCountMethod' : 'acm.FInstrument',
                               'SFTRAsset' : 'acm.FTrade',
                               'SFTRSecurityQuality' : 'acm.FTrade',
                               'ISDAMMSProductSubGroup' : 'acm.FTrade',
                               'ISDAMMSAssetClass' : 'acm.FTrade',
                               'FloatingRateIndex' : 'acm.FInstrument',
                               'IsJurisdiction' : ('acm.FInstrument', 'acm.FParty'),
                               'IsRegulatoryAuthority' : ('acm.FInstrument', 'acm.FParty'),
                               'IsGovernmentGuaranteedT' : 'acm.FInstrument',
                               'IsGovernmentGuaranteedB' : 'acm.FInstrument',
                               'IsCoveredT' : 'acm.FInstrument',
                               'IsCoveredB' : 'acm.FInstrument',
                               'SFTRIsCollateralProviderT' : 'acm.FTrade',
                               'SFTRIsCollateralProviderB' : 'acm.FTrade',
                               'HasStandardTerm' : 'acm.FInstrument',
                               'HasStandardTermT' : 'acm.FInstrument',
                               'HasStandardTermB' : 'acm.FInstrument',
                               'IsByTenor' : 'acm.FInstrument',
                               'EMIRCategory' : 'acm.FParty',
                               'LEIName' : 'acm.FParty',
                               'UltimateParent' : 'acm.FParty',
                               'NotionalAmount' : 'acm.FTrade',
                               'ImpliedVolatility' : 'acm.FInstrument',
                               'MasterAgreementType' : 'acm.FTrade',
                               'Delta' : 'acm.FInstrument',
                               'CurrentSpread' : 'acm.FInstrument',
                               'SFTRDayCountMethod' : 'acm.FInstrument',
                               'ExecutionVenueType' : 'acm.FParty',
                               'IsShortSell' : 'acm.FTrade',
                               'MIC' : 'acm.FParty',
                               'IsSubsidiary' : 'acm.FParty',
                               }
        self.apiGetterSetterFunction = {'IsCleared' : ('is_cleared_getter', 'bool const',\
                                                       'is_cleared_setter', '(bool setval)',\
                                                       'FRegulatoryLibWrapper.tradeWrapper'),\
                                        'HiQualityLiquidAsset' : ('hi_qlty_liquid_asset_getter', 'string const',\
                                                                  'hi_qlty_liquid_asset_setter', '(string setval)',\
                                                                  'FRegulatoryLibWrapper.instrumentWrapper'),\
                                        'CountryOfIssue' : ('country_of_issue_getter', 'string const',\
                                                            'country_of_issue_setter', '(string setval)',\
                                                            'FRegulatoryLibWrapper.instrumentWrapper'),\
                                        'BondType' : ('bond_type_getter', 'string const',\
                                                      'bond_type_setter', '(string setval)', 'FRegulatoryLibWrapper.instrumentWrapper'),\
                                        'BbgCollateralType' : ('bbg_collateral_type_getter', 'string const',\
                                                            'bbg_collateral_type_setter', '(string setval)',\
                                                            'FRegulatoryLibWrapper.instrumentWrapper'),\
                                        'IsGovernmentGuaranteed' : ('is_government_guaranteed_getter', 'FChoiceList const',\
                                                                    'is_government_guaranteed_setter', '(FChoiceList setval)',\
                                                                    'FRegulatoryLibWrapper.instrumentWrapper'),\
                                        'IsCovered' : ('is_covered_getter', 'FChoiceList const',\
                                                       'is_covered_setter', '(FChoiceList setval)',\
                                                       'FRegulatoryLibWrapper.instrumentWrapper'),\
                                        'IsEquity' : ('is_equity_getter', 'bool const',\
                                                        'is_equity_setter', '(bool setval)',\
                                                        'FRegulatoryLibWrapper.instrumentWrapper'),\
                                        'FundType' : ('fund_type_getter', 'string const',\
                                                      'fund_type_setter', '(string setval)',\
                                                      'FRegulatoryLibWrapper.instrumentWrapper'),\
                                        'MainTradingPlace' : ('main_trading_place_getter', 'string const',\
                                                              'main_trading_place_setter', '(string setval)',\
                                                              'FRegulatoryLibWrapper.instrumentWrapper'),\
                                        'SFTRSecurityType' : ('sftr_security_type_getter', 'string const',\
                                                              'sftr_security_type_setter', '(string setval)',\
                                                              'FRegulatoryLibWrapper.instrumentWrapper'),\
                                        'IsAllocated' : ('is_allocated_getter', 'bool const',\
                                                       'is_allocated_setter', '(bool setval)',
                                                       'FRegulatoryLibWrapper.accountWrapper'),\
                                        'TradeDepository' : ('trade_depository_getter', 'FParty const',\
                                                       'trade_depository_setter', '(FParty setval)',
                                                       'FRegulatoryLibWrapper.accountWrapper'),\
                                        'OutstandingShares' : ('outstanding_shares_getter', 'string const',\
                                                              'outstanding_shares_setter', '(string setval)',\
                                                              'FRegulatoryLibWrapper.instrumentWrapper'),\
                                        'SFTRIsCollateralProvider' : ('sftr_is_collateral_provider_getter', 'FChoiceList const',\
                                                              'sftr_is_collateral_provider_setter', '(FChoiceList setval)',\
                                                              'FRegulatoryLibWrapper.tradeWrapper'),\
                                        'IssuerType' : ('issuer_type_getter', 'string const',\
                                                              'issuer_type_setter', '(string setval)',\
                                                              'FRegulatoryLibWrapper.instrumentWrapper'),\
                                        'SFTRType' : ('sftr_type_getter', 'string const',\
                                                              'sftr_type_setter', '(string setval)',\
                                                              'FRegulatoryLibWrapper.tradeWrapper'),\
                                        'SFTRAsset' : ('sftr_asset_getter', 'string const',\
                                                              'sftr_asset_setter', '(string setval)',\
                                                              'FRegulatoryLibWrapper.tradeWrapper'),\
                                        'SFTRSecurityQuality' : ('sftr_security_quality_getter', 'string const',\
                                                              'sftr_security_quality_setter', '(string setval)',\
                                                              'FRegulatoryLibWrapper.tradeWrapper'),\
                                        'ISDAMMSProductSubGroup' : ('product_sub_group_getter', 'string const',\
                                                              'product_sub_group_setter', '(string setval)',\
                                                              'FRegulatoryLibWrapper.tradeWrapper'),\
                                        'ISDAMMSAssetClass' : ('asset_class_getter', 'string const',\
                                                              'asset_class_setter', '(string setval)',\
                                                              'FRegulatoryLibWrapper.tradeWrapper'),\
                                        'HasStandardTerm' : ('has_standard_term_getter', 'FChoiceList const',\
                                                       'has_standard_term_setter', '(FChoiceList setval)',\
                                                       'FRegulatoryLibWrapper.instrumentWrapper'),\
                                        'HasStandardTermT' : ('has_standard_term_t_getter', 'string const',\
                                                       'has_standard_term_t_setter', '(string setval)',\
                                                       'FRegulatoryLibWrapper.instrumentWrapper'),\
                                        'HasStandardTermB' : ('has_standard_term_b_getter', 'bool const',\
                                                       'has_standard_term_b_setter', '(bool setval)',\
                                                       'FRegulatoryLibWrapper.instrumentWrapper'),\
                                        'IsGovernmentGuaranteedT' : ('is_government_guaranteed_t_getter', 'string const',\
                                                       'is_government_guaranteed_t_setter', '(string setval)',\
                                                       'FRegulatoryLibWrapper.instrumentWrapper'),\
                                        'IsGovernmentGuaranteedB' : ('is_government_guaranteed_b_getter', 'bool const',\
                                                       'is_government_guaranteed_b_setter', '(bool setval)',\
                                                       'FRegulatoryLibWrapper.instrumentWrapper'),\
                                        'IsCoveredT' : ('is_covered_t_getter', 'string const',\
                                                       'is_covered_t_setter', '(string setval)',\
                                                       'FRegulatoryLibWrapper.instrumentWrapper'),\
                                        'IsCoveredB' : ('is_covered_b_getter', 'bool const',\
                                                       'is_covered_b_setter', '(bool setval)',\
                                                       'FRegulatoryLibWrapper.instrumentWrapper'),\
                                        'SFTRIsCollateralProviderT' : ('sftr_is_collateral_provider_t_getter', 'string const',\
                                                              'sftr_is_collateral_provider_t_setter', '(string setval)',\
                                                              'FRegulatoryLibWrapper.tradeWrapper'),\
                                        'SFTRIsCollateralProviderB' : ('sftr_is_collateral_provider_b_getter', 'bool const',\
                                                              'sftr_is_collateral_provider_b_setter', '(bool setval)',\
                                                              'FRegulatoryLibWrapper.tradeWrapper'),\
                                        'EMIRCategory' : ('emir_category_getter', 'string const',\
                                                              'emir_category_setter', '(string setval)',\
                                                              'FRegulatoryLibWrapper.partyWrapper'),\
                                        'LEIName' : ('lei_name_getter', 'string const',\
                                                              'lei_name_setter', '(string setval)',\
                                                              'FRegulatoryLibWrapper.partyWrapper'),\
                                        'UltimateParent' : ('ultimate_parent_getter', 'string const',\
                                                              'ultimate_parent_setter', '(string setval)',\
                                                              'FRegulatoryLibWrapper.partyWrapper'),\
                                        'ExecutionVenueType' : ('exceution_venue_type_getter', 'FChoiceList const',\
                                                              'exceution_venue_type_setter', '(FChoiceList setval)',\
                                                              'FRegulatoryLibWrapper.partyWrapper'),\
                                        }
        self.trade_wrapper_obj = FRegulatoryLibWrapper.tradeWrapper()
        self.ins_wrapper_obj = FRegulatoryLibWrapper.instrumentWrapper()
        self.account_wrapper_obj = FRegulatoryLibWrapper.accountWrapper()
        self.party_wrapper_obj = FRegulatoryLibWrapper.partyWrapper()
        self.addInfoDataType = {'regIsCleared' : 'Boolean', 'regHiQltyLqdAsset' : 'String',\
                                'regCountryOfIssue' : 'String', 'regBondType' : 'String',\
                                'regCollateralType' : 'String', 'regIsGovtGuaranteed' : 'FChoiceList',\
                                'regIsCovered' : 'FChoiceList', 'regIsCollatrlPrvdr' : 'FChoiceList',\
                                'regFundType' : 'String', 'regMainTradingPlace' : 'String',\
                                'regIsEquity' : 'Boolean', \
                                'regIsCmdtyAllocated' : 'Boolean', 'regSFTRSecurityType' : 'String',\
                                'regOutStndingShares' : 'String', 'regIssuerType' : 'String',\
                                'regSFTRType' : 'String', 'regSFTRAsset' : 'String',\
                                'regSFTRSecurityQlty' : 'String', 'regProductSubGroup' : 'String',\
                                'regAssetClass' : 'String', 'regHasStandardTerm' : 'FChoiceList',\
                                'regEMIRCategory' : 'String', 'regLEIName' : 'String',\
                                'regTradeDepository' : 'FParty', 'regExecVenueType' : 'FChoiceList'}
        self.addInfoChoiceListType = {'regIsGovtGuaranteed' : 'Tristate',\
                                      'regIsCovered' : 'Tristate',\
                                      'regIsCollatrlPrvdr' : 'Tristate',\
                                      'regHasStandardTerm' : 'Tristate',\
                                      'regExecVenueType' : 'ExecutionVenueType'}
        self._addInfoStandardDict = {
        'IsCleared' : ('regIsCleared', None, self.trade_wrapper_obj.is_cleared, 'bool', 'Is the trade cleared', None),
        'HiQualityLiquidAsset' : ('regHiQltyLqdAsset',  None, None, 'String',\
                                  'Categorization of a collateral to judge how willingly one would want to use as collateral. Values like 1, 2A, 2B, 3, NA.', None),
        'CountryOfIssue': ('regCountryOfIssue', None, self.ins_wrapper_obj.country_of_issue, 'string', 'country of issye of the instrument', None),
        'BondType': ('regBondType', None, self.ins_wrapper_obj.bond_type, 'string', 'bond type of the instrument', None),
        'BbgCollateralType': ('regCollateralType', None, self.ins_wrapper_obj.bbg_collateral_type, 'string', 'collateral type of the instrument', None),
        'IsEquity': ('regIsEquity', None, self.ins_wrapper_obj.is_equity, 'bool', 'equity type of the instrument', None),
        'FundType': ('regFundType', None, self.ins_wrapper_obj.fund_type, 'string', 'fund type of the instrument', None),
        'MainTradingPlace': ('regMainTradingPlace', None, self.ins_wrapper_obj.main_trading_place, 'string', 'main trading place of the instrument', None),
        'SFTRSecurityType': ('regSFTRSecurityType', None, self.ins_wrapper_obj.sftr_security_type, 'string', 'SFTR secutiry type of the instrument', None),
        'OutstandingShares': ('regOutStndingShares', None, self.ins_wrapper_obj.outstanding_shares, 'string', 'Market Cap of the instrument', None),
        'IsGovernmentGuaranteed' : ('regIsGovtGuaranteed', None, self.ins_wrapper_obj.is_government_guaranteed, 'FChoiceList', 'Is the instrument a government guaranteed instrument', None),
        'IsCovered' : ('regIsCovered', None, self.ins_wrapper_obj.is_covered, 'FChoiceList', 'Is the Bond covered or not', None),
        'SFTRIsCollateralProvider' : ('regIsCollatrlPrvdr', None, self.trade_wrapper_obj.sftr_is_collateral_provider, 'FChoiceList', 'Is it is collateral provider or not', None),
        'IsAllocated' : ('regIsCmdtyAllocated', None, None, 'bool', 'Is allocated or not', None),
        'TradeDepository' : ('regTradeDepository', None, self.account_wrapper_obj.trade_depository, 'FParty', 'location of a commodity or security', None),
        'IssuerType' : ('regIssuerType', None, self.ins_wrapper_obj.issuer_type, 'string', 'type of issuer of the instrument', None),
        'SFTRType' : ('regSFTRType', None, self.trade_wrapper_obj.sftr_type, 'string', 'sftrType of the instrument on which the trade is booked', None),
        'SFTRAsset' : ('regSFTRAsset', None, self.trade_wrapper_obj.sftr_asset, 'string', 'sftr asset type of the instrument on which the trade is booked', None),
        'SFTRSecurityQuality' : ('regSFTRSecurityQlty', None, self.trade_wrapper_obj.sftr_security_quality, 'string', 'sftr asset type of the instrument on which the trade is booked', None),
        'ISDAMMSAssetClass' : ('regAssetClass', None, self.trade_wrapper_obj.asset_class, 'string', 'asset class of the instrument', None),
        'ISDAMMSProductSubGroup' : ('regProductSubGroup', None, self.trade_wrapper_obj.product_sub_group, 'string', 'product sub group of the instrument', None),
        'FloatingRateIndex' : (None, None, self.ins_wrapper_obj.floating_rate_index, 'string', 'get the ESMA name for the RateIndex', None),
        'IsGovernmentGuaranteedT' : ('regIsGovtGuaranteed', None, self.ins_wrapper_obj.is_government_guaranteed_tristate, 'string', 'Is the instrument a government guaranteed instrument', None),
        'IsGovernmentGuaranteedB' : ('regIsGovtGuaranteed', None, self.ins_wrapper_obj.is_government_guaranteed_boolean, 'bool', 'Is the instrument a government guaranteed instrument', None),
        'IsCoveredT' : ('regIsCovered', None, self.ins_wrapper_obj.is_covered_tristate, 'string', 'Is the Bond covered or not', None),
        'IsCoveredB' : ('regIsCovered', None, self.ins_wrapper_obj.is_covered_boolean, 'bool', 'Is the Bond covered or not', None),
        'SFTRIsCollateralProviderT' : ('regIsCollatrlPrvdr', None, self.trade_wrapper_obj.sftr_is_collateral_provider_tristate, 'string', 'Is it is collateral provider or not', None),
        'SFTRIsCollateralProviderB' : ('regIsCollatrlPrvdr', None, self.trade_wrapper_obj.sftr_is_collateral_provider_boolean, 'bool', 'Is it is collateral provider or not', None),
        'HasStandardTerm' : ('regHasStandardTerm', None, self.ins_wrapper_obj.has_standard_term, 'FChoiceList', 'Ability to judge if a Swap has standard terms, and can be used for requesting an ISIN from ANNA', None),
        'HasStandardTermT' : ('regHasStandardTerm', None, self.ins_wrapper_obj.has_standard_term_tristate, 'string', 'Ability to judge if a Swap has standard terms, and can be used for requesting an ISIN from ANNA', None),
        'HasStandardTermB' : ('regHasStandardTerm', None, self.ins_wrapper_obj.has_standard_term_boolean, 'bool', 'Ability to judge if a Swap has standard terms, and can be used for requesting an ISIN from ANNA', None),       
        'IsByTenor' : (None, None, self.ins_wrapper_obj.is_by_tenor, 'bool', 'Ability to decide if the instrument is to be considered by Tenor or not', None),
        'EMIRCategory' : ('regEMIRCategory', None, None, 'string', 'the EMIR category classification of a party', None),
        'LEIName' :  ('regLEIName', None, None, 'string', 'the LEI Name of the party', None),
        'UltimateParent' :  (None, None, None, 'string', 'the ultimate parent of the party', None),
        'NotionalAmount' : (None, None, self.trade_wrapper_obj.notional_amount, 'float', 'Notional Amount of the trade', None),
        'ImpliedVolatility' : (None, None, self.ins_wrapper_obj.implied_volatility, 'float', 'Implied volatility of the trade', None),
        'MasterAgreementType' : (None, None, self.trade_wrapper_obj.master_agreement_type, 'string', 'Master agreement type on the trade', None),
        'Delta' : (None, None, self.ins_wrapper_obj.delta, 'string', 'Delta on the trade', None),
        'CurrentSpread' : (None, None, self.ins_wrapper_obj.current_spread, 'string', 'Current Spread on the trade', None),
        'SFTRDayCountMethod' : (None, None, self.ins_wrapper_obj.sftr_day_count_method, 'string', 'DayCountMethod on the leg', None),
        'ExecutionVenueType' : ('regExecVenueType', None, None, 'FChoiceList', 'the type of the Execution Venue (OTF/MTF/SEF)', None),
        'IsShortSell' : (None, None, self.trade_wrapper_obj.is_short_sell, 'FChoiceList', 'returns True/False/None on the basis of whether the trade isShortSell or not'),
        'MIC' : (None, None, self.party_wrapper_obj.mic, 'string', 'returns the value of the MIC alias on the Party'),
        'IsSubsidiary' : (None, None, self.party_wrapper_obj.is_subsidiary, 'bool', 'Is the given party subsidiary of the party', None),
}
        self._standardMethods = ['IsCleared', 'CountryOfIssue',\
                                 'BondType', 'IsCovered',\
                                 'FundType', 'MainTradingPlace',\
                                 'IsEquity', 'IsAllocated',\
                                 'OutstandingShares', 'IssuerType',\
                                 'FloatingRateIndex', 'IsJurisdiction',\
                                 'IsRegulatoryAuthority', 'IsByTenor',\
                                 'HasStandardTerm', 'EMIRCategory',\
                                 'LEIName', 'UltimateParent',\
                                 'TradeDepository', 'ExecutionVenueType',\
                                 'IsShortSell', 'MIC', 'IsSubsidiary']
        self._collateralMethods = ['HiQualityLiquidAsset', 'BbgCollateralType',\
                                   'IsGovernmentGuaranteed', 'ISDAMMSAssetClass',\
                                   'ISDAMMSProductSubGroup', 'NotionalAmount',\
                                   'ImpliedVolatility', 'Delta', 'CurrentSpread']
        self._SFTRMethods = ['SFTRSecurityType', 'SFTRIsCollateralProvider',\
                            'SFTRType', 'SFTRAsset', 'SFTRSecurityQuality',\
                            'MasterAgreementType', 'SFTRDayCountMethod']
        self._alreadyAddedAPIs = {}
        self.additionalAPIsToAdd = ['IsGovernmentGuaranteed', 'IsCovered', 'SFTRIsCollateralProvider', 'IsJurisdiction', 'IsRegulatoryAuthority', 'HasStandardTerm']

    def __createAPI(self, meth):
        """create the API for the method name being passed into the function"""
        retLog = ''
        if meth not in self._addInfoStandardDict:
            if meth.rfind('.') != -1:
                meth = meth[meth.rfind('.') + 1 :]
        details = self._addInfoStandardDict[meth]
        aiName = details[0]
        provName = details[1]
        provFunc = details[2]
        rettyp = details[3]
        if provName:# Return single value of a provider attribute COLLATERL_TYP
            FRegulatoryLogger.INFO(logger, "Currently not supported")
        elif provFunc:
            am = "%s:%s" % (meth, rettyp)
            if isinstance(self.apiOnClassDict[meth], tuple):
                for each_class in self.apiOnClassDict[meth]:
                    eval(each_class + '.AddMethod(am, provFunc)')
                    eval(each_class + '.AddMethod(am, provFunc)')
            else:
                eval(self.apiOnClassDict[meth] + '.AddMethod(am, provFunc)')
            retLog += '%s: Added for "%s"\n' % (meth, str(provFunc))
            self.addToAPIexistsDict(meth, self.apiOnClassDict[meth])
        else:
            if meth not in ['UltimateParent']:
                retLog += '%s: Missing provider data info (%s)\n' % (meth, str((meth, provName, provFunc, rettyp)))
        return retLog

    def addToAPIexistsDict(self, methodName, methodOnclass):
        """once the API is already added, the API will not be created again"""
        if methodOnclass in self._alreadyAddedAPIs:
            apiList = self._alreadyAddedAPIs[methodOnclass]
            if methodName in apiList:
                FRegulatoryLogger.DEBUG(logger, '<%s> already exists on class <%s>'%(methodName, methodOnclass))
            else:
                self._alreadyAddedAPIs[methodOnclass] = apiList.append(methodName)

    def setupMethods(self, apiList = None):
        """create all the methods that are present in the list being passed as input argument"""
        retLog = ''
        if not apiList:
            apiList = self._addInfoStandardDict.keys()
        for meth in apiList:
            if meth in self.apiOnClassDict:
                if meth in ['IsJurisdiction', 'IsRegulatoryAuthority', 'IsSubsidiary']:
                    getterWithArguments().setupMethods()
                elif meth in ['UltimateParent']:
                    acm.FParty.AddMethod('UltimateParent: FParty const', FRegulatoryLibWrapper.partyWrapper().ultimate_parent_getter)
                    acm.FParty.AddMethod('UltimateParent(string partyVal)', FRegulatoryLibWrapper.partyWrapper().ultimate_parent_setter)
                elif isinstance(self.apiOnClassDict[meth], tuple):
                    function_present = False
                    for each_class in self.apiOnClassDict[meth]:
                        if eval(each_class + '.GetMethod(meth, 0)'):
                            retLog += '%s: Already defined\n' % meth
                            function_present = True
                            continue
                        else:
                            function_present = False
                    if function_present:
                        continue
                else:
                    if eval(self.apiOnClassDict[meth] + '.GetMethod(meth, 0)'):
                        retLog += '%s: Already defined\n' % meth
                        continue
            if meth in self.apiOnClassDict.keys():
                apiOnAddInfo = self.addAPIOnAddInfo(meth, self.apiOnClassDict[meth], self._addInfoStandardDict)
                if not apiOnAddInfo:
                    if meth not in ['IsJurisdiction', 'IsRegulatoryAuthority', 'IsSubsidiary']:
                        retLog += self.__createAPI(meth)
        acm.UpdatePythonWrappers()
        return retLog

    def addAPIOnAddInfo(self, meth, methodOnclass, dictForLookUp):
        """if the AddInfo exists, then the method will be created on the AdditionalInfo"""
        apisAdded = False
        if self.ifAddInfoSpecExists(meth, methodOnclass, dictForLookUp):
            if meth in self.apiGetterSetterFunction:
                methodDetails = self.apiGetterSetterFunction[meth]
                getterMethod = methodDetails[4] + '().' + methodDetails[0]
                setterMethod = methodDetails[4] + '().' + methodDetails[2]
                if meth.rfind('.') != -1:#this is to ensure that acm.FInstrument.MoodysShortRating is changed to MoodysShortRating
                    meth = meth[meth.rfind('.') + 1 : ]
                if isinstance(self.apiOnClassDict[meth], tuple):
                    classes = self.apiOnClassDict[meth]
                    for each_class in classes:
                        eval(each_class + ".AddMethod('" + meth + ':' + methodDetails[1] + "', " + getterMethod + ')')
                        eval(each_class + ".AddMethod('" + meth + methodDetails[3] + "', " + setterMethod + ')')
                        self.addToAPIexistsDict(meth, each_class)
                else:
                    eval(self.apiOnClassDict[meth] + ".AddMethod('" + meth + ':' + methodDetails[1] + "', " + getterMethod + ')')
                    eval(self.apiOnClassDict[meth] + ".AddMethod('" + meth + methodDetails[3] + "', " + setterMethod + ')')
                    self.addToAPIexistsDict(meth, self.apiOnClassDict[meth])
                apisAdded = True
            else:
                FRegulatoryLogger.INFO(logger, "The AdditionalInfo details are not present for API <%s>"%meth)
        return apisAdded

    def ifAddInfoSpecExists(self, meth, methodOnclass, dictForLookUp):
        """returns True of the AdditionalInfoSpec exists and is of the specification type that is expected to be in"""
        addInfoSpecExists = False
        if meth in dictForLookUp:
            details = dictForLookUp[meth]
            addInfoName = details[0]
            if addInfoName:
                addInfoSpec = acm.FAdditionalInfoSpec[addInfoName]
                if addInfoSpec:
                    addInfoSpecExists = True
                    if addInfoName in self.addInfoDataType:
                        excType = self.addInfoDataType[addInfoName]
                        if excType in ['FChoiceList']:
                            if addInfoSpec.Description() != self.addInfoChoiceListType[addInfoName]:
                                FRegulatoryLogger.WARN(logger, "AddInfoSpec <%s> exists in ADS. However, it is not of type <%s> for expected functionality"%(addInfoName, self.addInfoChoiceListType[addInfoName]))
                        elif excType in ['FParty', 'FCounterparty', 'FVenue',\
                            'FClearingHouse', 'FBroker', 'FClient',\
                            'FInternalDepartment', 'FIssuer', 'FMarketPlace',\
                            'FMiddleware', 'FRepository', 'FDepot', 'FMTMMarket']:
                            if addInfoSpec.DataTypeGroup() != 'RecordRef' or addInfoSpec.DataTypeType() != 27:
                                    FRegulatoryLogger.WARN(logger, "AddInfoSpec <%s> exists in ADS. However, it is not of type <%s> for expected functionality"%(addInfoName, excType))
                        else:
                            if addInfoSpec.DataTypeType() != acm.FEnumeration['enum(B92StandardType)'].Enumeration(excType.capitalize()):
                                FRegulatoryLogger.WARN(logger, "AddInfoSpec <%s> exists in ADS. However, it is not of type <%s> for expected functionality"%(addInfoName, excType))
                    else:
                        FRegulatoryLogger.WARN(logger, "Details not entered in lookup dict to validate the dataType of AddInfoSpec <%s>"%addInfoName)
        return addInfoSpecExists

    def setupRatingMethod(self, providerMethodList=None):
        """create methods related to Ratings"""
        obj = StandardRatings()
        methLog = obj.setupMethods(providerMethodList)
        #FRegulatoryLogger.DEBUG(logger, methLog)

    def __appendAdditionalAPIs(self, providerMethodList):
        """For APIs that return the ChoiceList Trisate value, add additional APIs
         with T and B at the end to return the choicelist value in the form
          of string or boolean"""
        for each_api in self.additionalAPIsToAdd:
            if each_api in providerMethodList:
                providerMethodList.append(each_api + 'T')
                providerMethodList.append(each_api + 'B')
        return providerMethodList

    def setupStandardMethods(self, providerMethodList=None):
        """create the standard methods"""
        if not providerMethodList:
            providerMethodList = self._standardMethods
        providerMethodList = self.__appendAdditionalAPIs(providerMethodList)
        methLog = self.setupMethods(providerMethodList)
        FRegulatoryLogger.DEBUG(logger, methLog)
    
    def setupCollateralMethods(self, providerMethodList=None):
        """create the collateral related methods"""
        if not providerMethodList:
            providerMethodList = self._collateralMethods
        providerMethodList = self.__appendAdditionalAPIs(providerMethodList)
        methLog = self.setupMethods(providerMethodList)
        FRegulatoryLogger.DEBUG(logger, methLog)

    def setupSFTRMethods(self, providerMethodList=None):
        """create the SFTR methods"""
        if not providerMethodList:
            providerMethodList = self._SFTRMethods
        providerMethodList = self.__appendAdditionalAPIs(providerMethodList)
        methLog = self.setupMethods(providerMethodList)
        FRegulatoryLogger.DEBUG(logger, methLog)

class getterWithArguments():
    def __init__(self, jurisdiction_lookup = None, regulatory_authority_lookup = None):
        self.jurisdiction_lookup = jurisdiction_lookup
        self.regulatory_authority_lookup = regulatory_authority_lookup
        self.method_lookup = {'IsJurisdiction' : ["(string jurisdiction):FChoiceList const", 'isJurisdiction'],
                              'IsJurisdictionT' : ["(string jurisdiction):string const", 'isJurisdictionT'],
                              'IsJurisdictionB' : ["(string jurisdiction):bool const", 'isJurisdictionB'],
                              'IsRegulatoryAuthority' : ["(string regulatory_authority):FChoiceList const", 'isRegulatoryAuthority'],
                              'IsRegulatoryAuthorityT' : ["(string regulatory_authority):string const", 'isRegulatoryAuthorityT'],
                              'IsRegulatoryAuthorityB' : ["(string regulatory_authority):bool const", 'isRegulatoryAuthorityB'],
                              'IsSubsidiary' : ["(FParty party_obj):bool const", 'is_subsidiary'],
                              }
    def setupMethods(self):
        """create IsJurisdiction and IsRegulatoryAuthority related APIs"""
        self.__create_methods()

    def __create_methods(self):
        """create IsJurisdiction and IsRegulatoryAuthority related APIs"""
        for each_method in self.method_lookup:
            am = each_method + self.method_lookup[each_method][0]
            if each_method.startswith('IsJurisdiction'):
                acm.FInstrument.AddMethod(am, eval("FRegulatoryLibWrapper.JurisdictionNRegulatoryAuthority(jurisdiction_lookup=self.jurisdiction_lookup)." + self.method_lookup[each_method][1]))
                acm.FParty.AddMethod(am, eval("FRegulatoryLibWrapper.JurisdictionNRegulatoryAuthority(jurisdiction_lookup=self.jurisdiction_lookup)." + self.method_lookup[each_method][1]))
            elif each_method.startswith('IsRegulatoryAuthority'):
                acm.FInstrument.AddMethod(am, eval("FRegulatoryLibWrapper.JurisdictionNRegulatoryAuthority(regulatory_authority_lookup=self.regulatory_authority_lookup)." + self.method_lookup[each_method][1]))
                acm.FParty.AddMethod(am, eval("FRegulatoryLibWrapper.JurisdictionNRegulatoryAuthority(jurisdiction_lookup=self.jurisdiction_lookup)." + self.method_lookup[each_method][1]))
            else:
                acm.FParty.AddMethod(am, eval("FRegulatoryLibWrapper.partyWrapper()." + self.method_lookup[each_method][1]))

class ratingAlias():
    def __init__(self, sortOrder):
        self.sortOrder = sortOrder + 1 # Sort order is 0,1,2 but attr are rating1_chlnbr, rating2_chlnbr and rating3_chlnbr

    def getter(self, acm_object):
        """getter of the rating related APIs"""
        rating_val = None
        if self.sortOrder > 3:
            sortOrder = self.sortOrder - 1
            cl = acm.FChoiceList.Select01("list = 'Ratings' and sortOrder=%d"%sortOrder, None)
            if cl:
                sr = StandardRatings()
                meth = sr.getMethod(cl.Name())
                addinfo_val = sr.getAddInfo(meth, acm_object)
                rating_val = addInfoLookup(addinfo_val).getter(acm_object)

        else:
            if acm_object.IsKindOf(acm.FParty):
                rating_val = eval('acm_object.Rating' + str(self.sortOrder) + '()')
            elif acm_object.IsKindOf(acm.FInstrument):
                rating_val = eval('acm_object.Rating' + str(self.sortOrder) + 'ChlItem()')
        return rating_val

    def setter(self, acm_object, setval):
        """getter of the rating related APIs"""
        if self.sortOrder > 3:
            sortOrder = self.sortOrder - 1
            cl = acm.FChoiceList.Select01("list = 'Ratings' and sortOrder=%d"%sortOrder, None)
            if cl:
                sr = StandardRatings()
                meth = sr.getMethod(cl.Name())
                addinfo_val = sr.getAddInfo(meth, acm_object)
                addInfoLookup(addinfo_val).setter(acm_object, setval)
        
        else:
            if acm_object.IsKindOf(acm.FParty):
                eval('acm_object.Rating' + str(self.sortOrder) + '(acm.FChoiceList[' + str(setval.Oid()) + '])')
            elif acm_object.IsKindOf(acm.FInstrument):
                try:
                    eval('acm_object.Rating' + str(self.sortOrder) + 'ChlItem(acm.FChoiceList[' + str(setval.Oid()) + '])')
                except Exception as e:
                    FRegulatoryLogger.ERROR(logger, str(e))
        
class addInfoLookup():
    def __init__(self, addInfoName):
        self.addInfoName = addInfoName[0].upper() + addInfoName[1:]

    def getter(self, insOrParty):
        """return the value of the AdditionalInfo on the acm object
         (FInstrument/FParty) which is the input argument"""
        val = eval('insOrParty.AdditionalInfo().' + self.addInfoName + '()')
        clObj = None
        if val:
            cl = acm.FAdditionalInfoSpec[self.addInfoName].Description()
            clObj = acm.FChoiceList.Select01("list = '%s' and name = '%s'"%(cl, val), None)
        return clObj

    def setter(self, insOrParty, setVal):
        """sets the value of the AdditionalInfo on the acm object
         (FInstrument/FParty) which is the input argument"""
        eval('insOrParty.AdditionalInfo().' + self.addInfoName + '(acm.FChoiceList[' + str(setVal.Oid()) + '])')

class StandardRatings(object):
    def __init__(self): 
        self._ratingsChlNameDict = { 'Moodys' : 'MoodysRating', 'MoodysShort' : 'MoodysShortRating',\
                                     'S&P' : 'SnPRating', 'SnP' : 'SnPRating',\
                                     'S&PShort' : "SnPShortRating", "SnPShort" : "SnPShortRating",\
                                     'Fitch' : 'FitchRating', 'FitchShort' : 'FitchShortRating',
                                     'DBRS' : 'DBRSRating', 'DBRSShort' : 'DBRSShortRating',}
        
        self._ratingMethodsAddInfoDictIns = {'MoodysRating' : 'MoodysRating',
                                             'MoodysShortRating' : 'MoodysShortRating',
                                             'SnPRating' : 'SnPRating',\
                                             'SnPShortRating' : 'SnPShortRating',\
                                             'FitchRating' : 'FitchRating', 
                                             'FitchShortRating' : 'FitchShortRating',
                                             'DBRSRating' : 'DBRSRating',
                                             'DBRSShortRating' : 'DBRSShortRating'}
        self._ratingMethodsAddInfoDictParty = {'MoodysRating' : 'MoodysRtg',\
                                               'MoodysShortRating' : 'MoodysShortRtg',\
                                               'SnPRating' : 'SnPRtg',\
                                               'SnPShortRating' : 'SnPShortRtg',\
                                               'FitchRating' : 'FitchRtg',\
                                               'FitchShortRating' : 'FitchShortRtg',\
                                               'DBRSRating' : 'DBRSRtg',\
                                               'DBRSShortRating' : 'DBRSShortRtg'}
        self._ratings = ['MoodysRating', 'SnPRating', 'FitchRating', 'DBRSRating',\
                         'MoodysShortRating', 'SnPShortRating', 'FitchShortRating']

    def getMethod(self, choiceListName):
        """get the name of the method that needs to be created on the class"""
        methodName = None
        if choiceListName in self._ratingsChlNameDict.keys():
            methodName = self._ratingsChlNameDict[choiceListName]
        return methodName

    def getAddInfo(self, methodName, acm_object):
        """get the AddInfo for the corresponding function on the class"""
        addInfoName = None
        if acm_object.IsKindOf(acm.FParty):
            if methodName in self._ratingMethodsAddInfoDictParty.keys():
                addInfoName = self._ratingMethodsAddInfoDictParty[methodName]
        else:
            if methodName in self._ratingMethodsAddInfoDictIns.keys():
                addInfoName = self._ratingMethodsAddInfoDictIns[methodName]
        return addInfoName

    def __createMethod(self, meth, chlR):
        """create the method being passed as an argument"""
        am = meth + ":FChoiceList const"
        acm.FInstrument.AddMethod(am, ratingAlias(chlR.SortOrder()).getter)
        acm.FParty.AddMethod(am, ratingAlias(chlR.SortOrder()).getter)
        FRegulatoryLogger.DEBUG(logger, "Adding method <%s> on Instrument and Party."%am)
        am = meth + "(FChoiceList const)"
        acm.FInstrument.AddMethod(am, ratingAlias(chlR.SortOrder()).setter)  
        acm.FParty.AddMethod(am, ratingAlias(chlR.SortOrder()).setter)
        FRegulatoryLogger.DEBUG(logger, "Adding method <%s> on Instrument and Party."%am)

    def setupMethods(self, nameList=[]):
        """set up methods"""
        if not nameList: 
            nameList = self._ratings
        alreadyAdded=[]
        cl_dict = {}
        choicelists = acm.FChoiceList.Select('list=Ratings')
        cl_names = []
        for choicelist in choicelists:
            cl_names.append(choicelist.Name())
            cl_dict[choicelist.Name()] = choicelist
        for chlr in self._ratingsChlNameDict.keys():
            if chlr in cl_names:
                meth = self._ratingsChlNameDict[chlr]
                self.__createMethod(meth, cl_dict[chlr])
                alreadyAdded.append(meth)
            else:
                FRegulatoryLogger.DEBUG(logger, "ChoiceList <%s> does not exist in ADS. "
                "Hence cannot create APIS <%s>"%(chlr, str(self._ratingsChlNameDict[chlr])))
        for meth in nameList:
            if meth not in alreadyAdded:
                FRegulatoryLogger.DEBUG(logger, "Creating API <%s> on AddInfo"%meth)
                if meth in self._ratingMethodsAddInfoDictIns.keys():
                    aiName = self._ratingMethodsAddInfoDictIns[meth]
                    if acm.FAdditionalInfoSpec[aiName]: # Is it defined?
                        am = meth + ":FChoiceList const"
                        FRegulatoryLogger.DEBUG(logger, "Adding method <%s> on Instrument."%am)
                        acm.FInstrument.AddMethod(am, addInfoLookup(aiName).getter)  
                        am = meth + "(FChoiceList const)"
                        acm.FInstrument.AddMethod(am, addInfoLookup(aiName).setter)  
                        alreadyAdded.append(meth)
                        FRegulatoryLogger.DEBUG(logger, "Adding method <%s> on Instrument."%am)
                    else:
                        FRegulatoryLogger.INFO(logger, meth + "was not defined. Missing AdditionalInfoSpec (%s)" % aiName)
                if meth in self._ratingMethodsAddInfoDictParty.keys():
                    aiName = self._ratingMethodsAddInfoDictParty[meth]
                    if acm.FAdditionalInfoSpec[aiName]: # Is it defined?
                        am = meth + ":FChoiceList const"
                        FRegulatoryLogger.DEBUG(logger, "Adding method <%s> on Party."%am)
                        acm.FParty.AddMethod(am, addInfoLookup(aiName).getter)
                        am = meth + "(FChoiceList const)"
                        acm.FParty.AddMethod(am, addInfoLookup(aiName).setter)
                        FRegulatoryLogger.DEBUG(logger, "Adding method <%s> on Party."%am)
                        alreadyAdded.append(meth)
                    else:
                        FRegulatoryLogger.DEBUG(logger,\
                                meth + "was not defined. Missing AdditionalInfoSpec (%s)" % aiName)
        acm.UpdatePythonWrappers()
        return alreadyAdded

    def addChoiceListRating(self, instrOrParty, methodname, choiceListName):
        """Add/update RatingAPI on class based on the ChoiceList"""
        if choiceListName in self._ratingsChlNameDict.keys():
            if self._ratingsChlNameDict[choiceListName] != methodname:
                FRegulatoryLogger.DEBUG(logger, "API <%s> currently refers to ChoiceList <%s>\
                 instead of <%s>. This will be overridden with <%s>"%(\
                methodname, self._ratingsChlNameDict[choiceListName],\
                choiceListName, choiceListName))
        self._ratingsChlNameDict[choiceListName] = methodname

    def addAddInfoRating(self, instrOrParty, methodname, addInfSpecName):
        """Add/update RatingAPI on class based on the AddInfoSpec being passed"""
        if 'Instrument' in instrOrParty:
            if methodname in self._ratingMethodsAddInfoDictIns.keys():
                if self._ratingMethodsAddInfoDictIns[methodname] != addInfSpecName:
                    FRegulatoryLogger.DEBUG(logger, "API <%s> on Instrument currently refers to AddInfoSpec <%s>\
                 instead of <%s>. This will be overridden with <%s>"%(methodname,\
                    self._ratingMethodsAddInfoDictIns[methodname], addInfSpecName, addInfSpecName))
                    self._ratingMethodsAddInfoDictIns[methodname] = addInfSpecName
                 
        elif 'Party' in instrOrParty:
            if methodname in self._ratingMethodsAddInfoDictParty.keys():
                if self._ratingMethodsAddInfoDictParty[methodname] != addInfSpecName:
                    FRegulatoryLogger.DEBUG(logger, "API <%s> on Party currently refers to AddInfoSpec <%s>\
                 instead of <%s>. This will be overridden with <%s>"%(methodname,\
                    self._ratingMethodsAddInfoDictParty[methodname], addInfSpecName, addInfSpecName))
                    self._ratingMethodsAddInfoDictParty[methodname] = addInfSpecName
        else:
            FRegulatoryLogger.DEBUG(logger, "Adding of an AddInfoRating is supported for Party and Instrument only")


...

  FRegulatoryCfiCodeGeneration
"""------------------------------------------------------------------------
MODULE
    FRegulatoryCfiCodeGeneration -
DESCRIPTION:
    This file consists of the functions to generate the CfiCode for instruments that do not have CfiCode present on them
VERSION: 1.0.29(0.1.1278)
RESTRICTIONS/ LIMITATIONS:
    1. Any modifications to the scripts/ encrypted modules/ clear text code within the core is not supported. 
    2. This module is not customizable
    3. The component may not work as expected with any modifications done to this module at user end
--------------------------------------------------------------------------"""
import acm
import ael
option_style_type_lookup = {
    'European-Call' : 'A',
    'American-Call' : 'B',
    'Bermudan-Call' : 'C',
    'European-Put' : 'D',
    'American-Put' : 'E',
    'Bermudan-Put' : 'F',
}
exotic_lookup = {
    'Digital European Vanilla' : 'D',
    'Vanilla'   : 'V',
    'Asian'     : 'A',
    'Barrier'   : 'B',
    'Digital European Barrier'  : 'G',
    'Digital American'  : 'D',
    'KIKO'      : 'G',
    'Lookback' : 'L',
    'Range Accrual' : 'P',
    'Misc' : 'M',
}
#COMMODITY SUB PRODUCT CLASSIFICATION NOT IN REGSUPPORT: 'CSHP', 'DLVR', 'NDLV', 
seniority_lookup = {'SNRFOR' : 'N', 'SUBLT2' : 'Q', 'JRSUBUT2' : 'J'}
exercise_type_lookup = {'European' : 'E', 'American' : 'A', 'Amer GA' : 'A', 'Bermudan' : 'B'}
commodity_classification = {'A': ["AGRI",'DIRY', 'FRST', 'LSTK', 'GROS',  'SEAF', 'GRIN', 'POTA', \
                                'OOLI', 'SOFT','MHWT', 'CORN', 'RICE','SOYB', 'RPSD','LAMP','CCOA',\
                                'ROBU', 'BRWN', 'WHSG','FWHT'],
                            'E': ["NRGY", 'COAL', 'DIST', 'INRG', 'LGHT', 'NGAS', 'OILP', 'BAKK', \
                                'BDSL', 'BRNT', 'BRNX', 'CNDA', 'COND', 'DSEL', 'DUBA', 'ESPO', \
                                'ETHA', 'FUEL', 'FOIL', 'GOIL', 'GSLN', 'HEAT', 'JTFL', 'KERO', \
                                'LLSO', 'MARS', 'NAPH', 'NGLO', 'TAPI', 'WTIO', 'URAL','ALUM', \
                                'ALUA', 'CBLT', 'COPR', 'IRON', 'LEAD', 'MOLY', 'NASC', 'NICK', \
                                'STEL', 'TINN', 'ZINC', 'GASP', 'LNGG','NBPG', 'NCGG', 'TTFG', \
                                'NPRM', 'PRME', 'GOLD', 'PLDM', 'PTNM', 'SLVR', 'METL',],
                            'I': ["PAPR", 'CBRD', 'NSPT', 'PULP', 'RCVP', "INDP", 'CSTR', 'MFTG',],
                            'P': ["POLY", 'PLST',],
                            'H': ['ELEC','RNNG','BSLD', 'FITR', 'PKLD', 'OFFP',],
                            'N': ["ENVR",  'EMIS', 'CERE', 'ERUE', 'EUAE', 'EUAA','CRBR',  'WTHR',],
                            'M': ["FRTL", 'AMMO', 'DAPH', 'PTSH', 'SLPH', 'UREA', 'UAAN', 'INFL','MCEX', 'OEST', 'OTHR'],
                            'S': ["FRGT", 'DRYF', 'WETF','DBCR', 'TNKR']}

swap_classification = {
'Float-Float' : 'A',
'Fixed-Floating' : 'C',
'Fixed-Fixed' : 'D',
'Inflation rate index' : 'G',
'Overnight Index Swap' : 'H',
'Zero coupon' : 'Z',
}

commodity_classification_for_swaps = {
'A': ["AGRI",'DIRY', 'FRST', 'LSTK', 'GROS',  'SEAF', 'GRIN', 'POTA', \
     'OOLI', 'SOFT','MHWT', 'CORN', 'RICE','SOYB', 'RPSD','LAMP','CCOA',\
     'ROBU', 'BRWN', 'WHSG','FWHT'],
'S': ["FRTL", 'AMMO', 'DAPH', 'PTSH', 'SLPH', 'UREA', 'UAAN',],
'G': ["FRGT", 'DRYF', 'WETF','DBCR', 'TNKR'],
'P': ["POLY", 'PLST',],
'T': ["PAPR", 'CBRD', 'NSPT', 'PULP', 'RCVP',],
'N': ["ENVR",  'EMIS', 'CERE', 'ERUE', 'EUAE', 'EUAA','CRBR',  'WTHR',],
'K': ['ALUM', 'ALUA', 'CBLT', 'COPR', 'IRON', 'LEAD', 'MOLY', 'NASC', 'NICK', \
     'STEL', 'TINN', 'ZINC', 'GASP', 'LNGG','NBPG', 'NCGG', 'TTFG', \
     'NPRM', 'PRME', 'GOLD', 'PLDM', 'PTNM', 'SLVR', 'METL',], 
'J': ["NRGY", 'COAL', 'DIST', 'INRG', 'LGHT', 'NGAS', 'OILP', 'BAKK', \
     'BDSL', 'BRNT', 'BRNX', 'CNDA', 'COND', 'DSEL', 'DUBA', 'ESPO', \
     'ETHA', 'FUEL', 'FOIL', 'GOIL', 'GSLN', 'HEAT', 'JTFL', 'KERO', \
     'LLSO', 'MARS', 'NAPH', 'NGLO', 'TAPI', 'WTIO', 'URAL',]}


def is_non_deliverable_swap(instrument):
    settlement_char = 'X'
    if instrument.NonDeliverable():
        settlement_char = 'C'
    else:
        settlement_char = 'P'
    return settlement_char

def is_underlyer_curr_different(instrument):
    """checks for the currency of the reference index being used and returns True if it is different from that of the instrument's currency"""
    ins_currency = instrument.Currency().Name()
    diff_currency = False
    if instrument.InsType() in ['Swap', 'IndexLinkedSwap', 'TotalReturnSwap', 'CreditDefaultSwap']:
        for leg in instrument.Legs():
            try:
                if (leg.InflationScalingRef() and leg.InflationScalingRef().Currency().Name() != ins_currency) or \
                    (leg.IndexRef() and leg.IndexRef().Currency().Name() != ins_currency) or \
                    (leg.FloatRateReference() and leg.FloatRateReference().Currency().Name() != ins_currency) or \
                    (leg.FloatRateReference2() and leg.FloatRateReference2().Currency().Name() != ins_currency) or \
                    (leg.CreditRef() and leg.CreditRef().Currency().Name() != ins_currency):
                    diff_currency = True
                    break
            except:
                if (leg.IndexRef() and leg.IndexRef().Currency().Name() != ins_currency) or \
                    (leg.FloatRateReference() and leg.FloatRateReference().Currency().Name() != ins_currency) or \
                    (leg.FloatRateReference2() and leg.FloatRateReference2().Currency().Name() != ins_currency) or \
                    (leg.CreditRef() and leg.CreditRef().Currency().Name() != ins_currency):
                    diff_currency = True
                    break    
    if instrument.InsType() in ['VolatilitySwap', 'VarianceSwap']:
        if instrument.Underlying() and instrument.Underlying().Currency().Name() != ins_currency:
            diff_currency = True
    if instrument.InsType() in ['CurrSwap']:
        curr1 = instrument.Legs()[0].Currency().Name()
        curr2 = instrument.Legs()[1].Currency().Name()
        if curr1 != curr2:
            diff_currency = True
    return diff_currency

def get_credit_category(instrument):
    category_char = 'C'
    ins = instrument
    if instrument and instrument.Underlying():
        ins = instrument.Underlying()
    if ins and ins.Issuer() and ins.Issuer().BusinessStatus():
        business_status = ins.Issuer().BusinessStatus().Name()
        if 'GOVERNMENT' in business_status.upper():
            category_char = 'S'
        elif 'MUNICIPAL' in business_status.upper():
            category_char = 'L'
        else:
            category_char = 'C'
    return category_char

def commodity_classify(instrument):
    cmdty_classify = None
    cmdty_swap_classify = 'M'
    cmdty_classify = get_commodity_details(instrument)
    if cmdty_classify:       
        for each_commodity_classify in commodity_classification_for_swaps:
            commodity_key = each_commodity_classify
            if cmdty_classify in commodity_classification_for_swaps[commodity_key]:
                cmdty_swap_classify = commodity_key
                break
    '''
    if instrument.RegulatoryInfo().CommodityProduct():
        if instrument.RegulatoryInfo().CommodityProduct().Name() == 'OTHR':
            if instrument.RegulatoryInfo().CommoditySubProduct().Name() == 'OTHR':
                cmdty_classify = instrument.RegulatoryInfo().CommodityBaseProduct().Name()
            else:
                cmdty_classify = instrument.RegulatoryInfo().CommoditySubProduct().Name()
        else:
            cmdty_classify = instrument.RegulatoryInfo().CommodityProduct().Name()
        for each_commodity_classify in commodity_classification_for_swaps:
            commodity_key = each_commodity_classify
            if cmdty_classify in commodity_classification_for_swaps[commodity_key]:
                cmdty_swap_classify = commodity_key
                break
    '''
    return cmdty_swap_classify

def get_commodity_classification_for_swaps(instrument):
    cmdty_swap_classify = None
    cmdty_swap_classify = 'M'
    if instrument.InsType() in ['PriceSwap']:
        for leg in instrument.Legs():
            if leg.FloatRateReference():
                float_rate_ref = leg.FloatRateReference()
                if float_rate_ref.RegulatoryInfo().CommodityBaseProduct() or \
                    float_rate_ref.RegulatoryInfo().CommoditySubProduct() or \
                    float_rate_ref.RegulatoryInfo().CommodityFurtherSubProduct():
                #if float_rate_ref.RegulatoryInfo().CommodityProduct():
                    cmdty_swap_classify = commodity_classify(float_rate_ref)
                    
                else:
                    if float_rate_ref.InsType() == 'Commodity Index':
                        cmdty_swap_classify = 'I'
                    elif float_rate_ref.InsType() == 'Commodity Variant':
                        cmdty_swap_classify = commodity_classify(float_rate_ref.Underlying())
                    elif float_rate_ref.InsType() == 'Combination' and get_combination_classification(float_rate_ref)[1]:
                        cmdty_swap_classify = 'Q'
    if instrument.InsType() in ['Future/Forward']:
        underlyer = instrument.Underlying()
        if underlyer.RegulatoryInfo().CommodityBaseProduct() or \
            underlyer.RegulatoryInfo().CommoditySubProduct() or \
            underlyer.RegulatoryInfo().CommodityFurtherSubProduct():
            cmdty_swap_classify = commodity_classify(underlyer)
        else:
            if underlyer.InsType() == 'Commodity Index':
                cmdty_swap_classify = 'I'
    return cmdty_swap_classify

def get_swap_classification(instrument):
    float_leg_count = 0
    fixed_leg_count = 0
    zc_fixed_leg_count = 0
    ois = False
    swap_classify = None
    swap_classify_char = 'M'
    if instrument.InsType() == 'IndexLinkedSwap':
        swap_classify = 'Inflation rate index'
    elif instrument.InsType() == 'TotalReturnSwap':
        leg_counter = 0
        for leg in instrument.Legs():
            leg_counter = leg_counter + 1
            if leg_counter > 2:
                break
            if leg.LegType() in ['Fixed', 'Fixed Accretive']:
                fixed_leg_count = fixed_leg_count + 1
            elif leg.LegType() in ['Zero Coupon Fixed']:
                zc_fixed_leg_count = zc_fixed_leg_count + 1
            elif leg.LegType() in ['Float', 'Total Return']:
                float_leg_count = float_leg_count + 1               
                if leg.FloatRateReference() and leg.FloatRateReference().Legs() and leg.FloatRateReference().Legs()[0].EndPeriod() == '1d':
                    ois = True
            elif leg.LegType() in ['Capped Float', 'Floored Float', 'Collared Float', \
                'Reverse Float', 'Target Redemption', 'Range Accrual', 'Snowball', \
                'Collared LPI', 'Floored LPI', 'Capped LPI']:
                pass
    else:
        for leg in instrument.Legs():
            if leg.LegType() in ['Fixed', 'Fixed Accretive']:
                fixed_leg_count = fixed_leg_count + 1
            elif leg.LegType() in ['Zero Coupon Fixed']:
                zc_fixed_leg_count = zc_fixed_leg_count + 1
            elif leg.LegType() in ['Float', 'Total Return']:
                float_leg_count = float_leg_count + 1
                if leg.FloatRateReference() and leg.FloatRateReference().Legs()[0].EndPeriod() == '1d':
                    ois = True
            elif leg.LegType() in ['Capped Float', 'Floored Float', 'Collared Float', \
                'Reverse Float', 'Target Redemption', 'Range Accrual', 'Snowball', \
                'Collared LPI', 'Floored LPI', 'Capped LPI']:
                pass
    if not swap_classify:
        if ois:
            swap_classify = 'Overnight Index Swap'
        elif float_leg_count == 2:
            swap_classify = 'Float-Float'
        elif fixed_leg_count == 2:
            swap_classify = 'Fixed-Fixed'
        elif float_leg_count == fixed_leg_count:
            swap_classify = 'Fixed-Floating'
        elif zc_fixed_leg_count > 0:
            swap_classify = 'Zero coupon'
    if swap_classify and swap_classify in swap_classification:
        swap_classify_char = swap_classification[swap_classify]
    if not swap_classify_char:
        swap_classify_char = 'M'
    return swap_classify_char

def get_commodity_details(instrument):
    cmdty_classify = None
    if instrument.RegulatoryInfo().CommodityBaseProduct():
        if instrument.RegulatoryInfo().CommodityFurtherSubProduct():
            if instrument.RegulatoryInfo().CommodityFurtherSubProduct().Name() == 'OTHR':
                if instrument.RegulatoryInfo().CommoditySubProduct().Name() == 'OTHR':
                    cmdty_classify = instrument.RegulatoryInfo().CommodityBaseProduct().Name()
                else:
                    cmdty_classify = instrument.RegulatoryInfo().CommoditySubProduct().Name()
            else:
                cmdty_classify = instrument.RegulatoryInfo().CommodityFurtherSubProduct().Name()
        elif instrument.RegulatoryInfo().CommoditySubProduct():
            if instrument.RegulatoryInfo().CommoditySubProduct().Name() == 'OTHR':
                cmdty_classify = instrument.RegulatoryInfo().CommodityBaseProduct().Name()
            else:
                cmdty_classify = instrument.RegulatoryInfo().CommoditySubProduct().Name()
        else:
            cmdty_classify = instrument.RegulatoryInfo().CommodityBaseProduct().Name()
    return cmdty_classify

def get_commodity_classification(instrument):
    commodity_classify_val = 'M'
    commodity_classify = get_commodity_details(instrument)
    if commodity_classify:
        for each_commodity_classify in commodity_classification:
            commodity_key = each_commodity_classify
            if commodity_classify in commodity_classification[commodity_key]:
                commodity_classify_val = commodity_key
                break
    return commodity_classify_val

def get_delivery_char(instrument):
    delivery_char = 'X'
    if instrument.SettlementType () == 'Physical Delivery':
        delivery_char = 'P'
    else:
        delivery_char = 'C'
    return delivery_char

def get_tenure(instrument):
    start_date = ael.date_from_string(instrument.StartDate())
    end_date = ael.date_from_string(instrument.EndDate())
    tenure = start_date.days_between(end_date)
    return tenure

def get_exercise_type_char(instrument):
    exercise_type_char = 'X'
    if instrument.ExerciseType() in exercise_type_lookup:
        exercise_type_char = exercise_type_lookup[instrument.ExerciseType()]
    return exercise_type_char

def get_option_callable_char(instrument):
    callable_char = 'X'
    try:
        if instrument.OptionType() in ['Receiver', 'Put', 'Lender']:
            callable_char = 'P'
        elif instrument.OptionType() in ['Payer', 'Call', 'Borrower']:
            callable_char = 'C'
    except:
        if instrument.IsCallOption():
            callable_char = 'C'
        else:
            callable_char = 'P'
    return callable_char

def get_seniority_char(instrument):
    seniority_char = 'X'
    if instrument.Seniority() and instrument.Seniority().Name() in seniority_lookup:
        seniority_char = seniority_lookup[instrument.Seniority().Name()]
    return seniority_char

def get_instrument_type(instrument):
    return instrument.InsType()
        
def get_first_char_in_cfi_code(instrument, ins_type):
    first_char = 'X'
    if instrument.InsType() in ['Rolling Schedule', 'FRA', 'FXOptionDatedFwd']:
        first_char = 'J'
    elif instrument.InsType() in ['Certificate', 'Combination']:
        first_char = 'M'
    elif instrument.InsType() in ['Commodity Index', 'Dividend Point Index', 'Curr', 'EquityIndex', 'RateIndex', 'CreditIndex', 'PriceIndex']:
        first_char = 'T'
    elif instrument.InsType() in ['Stock', 'Depositary Receipt']:# and (not instrument.Otc()) :
        first_char = 'E'
    elif instrument.InsType() in ['ETF', 'Fund']:# and (not instrument.Otc()) :
        first_char = 'C'
    elif instrument.InsType() in ['Bond', 'Convertible', 'FRN', 'MBS/ABS', 'PromisLoan', 'Zero', \
        'Bill', 'DualCurrBond', 'CLN', 'IndexLinkedBond', 'CD', 'Deposit', 'Flexi Bond']:# and (not instrument.Otc()):
        first_char = 'D'
    elif instrument.InsType() in ['Warrant']:
        first_char = 'R'
    elif instrument.InsType() in ['Option']:
        if is_otc_option(instrument):
            first_char = 'H'
        else:
            first_char = 'O'
    elif instrument.InsType() in ['Future/Forward', 'Average Future/Forward', 'CFD']:
        if (not instrument.Otc()):
            first_char = 'F'
        else:
            first_char = 'J'
    elif instrument.InsType() in ['Swap', 'CurrSwap' , 'TotalReturnSwap', 'VarianceSwap', 'CreditDefaultSwap', 'IndexLinkedSwap', 'PriceSwap', 'VolatilitySwap']:
        first_char = 'S'
    elif instrument.InsType() in ['Cap', 'Floor']:
        first_char = 'H'
    elif instrument.InsType() in ['SecurityLoan', 'Repo/Reverse', 'BasketSecurityLoan', 'BasketRepo/Reverse', 'BuySellback']:
        first_char = 'L'
    elif instrument.InsType() in ['Commodity', 'Commodity Variant']:
        first_char = 'I'
    return first_char

def get_combination_classification(instrument):
    is_equity = False
    is_commodity = False
    is_credit = False
    is_rate = False
    is_curr = False
    equity_counter = 0
    cmdty_counter = 0
    credit_counter = 0
    rate_counter = 0
    curr_counter = 0
    misc_counter = 0
    for ins_map in instrument.InstrumentMaps():
        if ins_map.Instrument().InsType() in ['EquityIndex', 'Stock', 'Dividend Point Index']:
            equity_counter = equity_counter + 1
        elif ins_map.Instrument().InsType() in ['Average Future/Forward', 'Commodity', 'Commodity Index', 'Commodity Variant', \
    'Precious Metal Rate', 'Rolling Schedule']:
            cmdty_counter = cmdty_counter + 1
        elif ins_map.Instrument().InsType() in ['CreditIndex']:
            credit_counter = credit_counter + 1
        elif ins_map.Instrument().InsType() in ['Bill', 'Bond', 'Convertible', 'Deposit', 'FRA', 'FRN', 'RateIndex', 'Zero', 'IndexLinkedBond', 'Swap']:
            rate_counter = rate_counter + 1
        elif ins_map.Instrument().InsType() in ['Curr']:
            curr_counter = curr_counter + 1
        else:
            misc_counter = misc_counter + 1
    if equity_counter > 0 and cmdty_counter == 0 and credit_counter == 0 and misc_counter == 0 and rate_counter == 0 and curr_counter == 0:
        is_equity = True
    elif cmdty_counter > 0 and equity_counter == 0 and credit_counter == 0 and misc_counter == 0 and rate_counter == 0 and curr_counter == 0:
        is_commodity = True
    elif credit_counter > 0 and equity_counter == 0 and cmdty_counter == 0 and misc_counter == 0 and rate_counter == 0 and curr_counter == 0:
        is_credit = True
    elif rate_counter > 0 and equity_counter == 0 and cmdty_counter == 0 and misc_counter == 0 and credit_counter == 0 and curr_counter == 0:
        is_rate = True
    elif curr_counter > 0 and equity_counter == 0 and cmdty_counter == 0 and misc_counter == 0 and credit_counter == 0 and rate_counter == 0:
        is_curr = True
    return is_equity, is_commodity, is_credit, is_rate, is_curr

def get_TRS_float_rate_ref_classification(instrument):
    classification_char = 'M'
    if instrument:
        if instrument.InsType() in ['Combination']:
            classification_char = get_combination_classification_char(instrument)
        if (instrument.InsType() in ['CFD'] and instrument.Underlying().InsType() in ['EquityIndex', 'Stock']) or \
           (instrument.InsType() in ['EquityIndex', 'Stock', 'Dividend Point Index', 'Depositary Receipt']) :
            classification_char = 'E'
        if instrument.InsType() in ['Average Future/Forward', 'Commodity', 'Commodity Index', 'Commodity Variant', \
            'Precious Metal Rate', 'Rolling Schedule', 'PriceSwap', 'PriceIndex']:
            classification_char = 'T'
        if instrument.InsType() in ['BasketRepo/Reverse', 'BasketSecurityLoan', 'Bill', 'Bond', 'BondIndex', 'BuySellback', \
            'CallAccount', 'CD', 'Certificate', 'CLN', 'Convertible', 'Deposit', 'Flexi Bond', \
            'FRA', 'FRN', 'IndexLinkedBond', 'PromisLoan', 'RateIndex', 'Repo/Reverse', 'SecurityLoan', 'Zero', 'DualCurrBond']:
            classification_char = 'R'
        if instrument.InsType() in ['CreditIndex']:
            classification_char = 'C'
        #if instrument.InsType() in ['Curr']:
        #    classification_char = 'F'
    return classification_char

def get_combination_classification_char(instrument):
    cmdty_classify_char = 'M'
    is_equity, is_commodity, is_credit, is_rate, is_curr = get_combination_classification(instrument)
    if is_equity:
        cmdty_classify_char = 'E'
    if is_commodity:
        cmdty_classify_char = 'T'
    if is_credit:
        cmdty_classify_char = 'C'
    if is_rate:
        cmdty_classify_char = 'R'
    if is_curr:
        cmdty_classify_char = 'F'
    return cmdty_classify_char

def get_second_char_in_cfi_code(instrument, ins_type):
    second_char = 'X'
    if instrument.InsType() in ['Rolling Schedule', 'Commodity', 'Commodity Variant']:
        second_char = 'T'
    elif instrument.InsType() in ['Certificate', 'CD', 'Deposit', 'Flexi Bond']:
        second_char = 'M'
    elif instrument.InsType() in ['Commodity Index', 'CreditIndex']:
        second_char = 'I'
    elif instrument.InsType() in ['Stock', 'SecurityLoan', 'BasketSecurityLoan', 'CLN']:# and (not instrument.Otc()) :
        second_char = 'S'
    elif instrument.InsType() in ['Depositary Receipt', ]:# and (not instrument.Otc()) :
        second_char = 'D'
    elif instrument.InsType() in ['Dividend Point Index']:
        second_char = 'D'
    elif instrument.InsType() in ['ETF']:
        second_char = 'E'
    elif instrument.InsType() in ['Bill']:
        second_char = 'Y'
    elif instrument.InsType() in ['Bond', 'FRN', 'PromisLoan', 'Zero']:# and (not instrument.Otc()) :
        if instrument.Issuer() and instrument.Issuer().BusinessStatus() and 'MUNICIPAL' in instrument.Issuer().BusinessStatus().Name().upper():
            second_char = 'N'
        else:
            tenure = get_tenure(instrument)
            if tenure > 366:
                second_char = 'B'
            else:
                second_char = 'Y'
    elif instrument.InsType() in ['Convertible', 'Curr', 'Combination']:# and (not instrument.Otc()) :
        second_char = 'C'
    elif instrument.InsType() in ['MBS/ABS']:# and (not instrument.Otc()) :
        second_char = 'A'
    elif instrument.InsType() in ['Warrant']:
        second_char = 'W'
    elif instrument.InsType() in ['Option']:
        if is_otc_option(instrument):
            second_char = 'M'
            if instrument.Underlying().InsType() in ['VarianceSwap']:
                if instrument.Underlying().Underlying().InsType() in ['Stock', 'EquityIndex', 'Depositary Receipt',]:
                    second_char = 'E'
                elif instrument.Underlying().Underlying().InsType() in ['Curr']:
                    second_char = 'F'
            elif instrument.Underlying().InsType() in ['Bill', 'Bond', 'FRN', 'Convertible', 'Deposit',  'Zero', 'PromisLoan', 'Swap', \
                'IndexLinkedSwap', 'Cap', 'Floor', 'FRA', 'CurrSwap', 'RateIndex']:
                second_char = 'R'
            elif instrument.Underlying().InsType() in ['Commodity', 'Commodity Variant', 'Commodity Index', 'Average Future/Forward']:
                second_char = 'T'
            elif instrument.Underlying().InsType() in ['TotalReturnSwap']:
                for leg in instrument.Underlying().Legs():
                    if leg.LegType() == 'Total Return':
                        second_char = get_TRS_float_rate_ref_classification(leg.FloatRateReference())
            elif instrument.Underlying().InsType() in ['Stock', 'EquityIndex', 'Depositary Receipt', 'Dividend Point Index'] or \
                (instrument.InsType() in ['CFD'] and instrument.Underlying().InsType() in ['Stock', 'EquityIndex']):
                second_char = 'E'
            elif instrument.Underlying().InsType() in ['Combination']:
                second_char = get_combination_classification_char(instrument.Underlying())
            elif instrument.Underlying().InsType() in ['CreditDefaultSwap', 'CLN']:
                second_char = 'C'
            elif instrument.Underlying().InsType() in ['Curr']:
                second_char = 'F'
            elif instrument.Underlying().InsType() in ['Option', 'Warrant', 'CFD']:
                underlyer = instrument.Underlying().Underlying()
                if underlyer.InsType() in ['Bill', 'Bond', 'FRN', 'Convertible', 'Deposit',  'Zero', 'PromisLoan', 'Swap', \
                    'IndexLinkedSwap', 'VarianceSwap', 'Cap', 'Floor', 'FRA', 'CurrSwap', 'RateIndex']:
                    second_char = 'R'
                elif underlyer.InsType() in ['Commodity', 'Commodity Variant', 'Commodity Index', 'Average Future/Forward']:
                    second_char = 'T'
                elif underlyer.InsType() in ['Curr']:
                    second_char = 'F'
                elif underlyer.InsType() in ['Stock', 'EquityIndex', 'Depositary Receipt', 'Dividend Point Index'] or \
                (underlyer.InsType() in ['CFD'] and underlyer.Underlying().InsType() in ['Stock', 'EquityIndex']):
                    second_char = 'E'
            elif instrument.Underlying().InsType() in ['Future/Forward']:
                underlyer = instrument.Underlying().Underlying()
                if underlyer.InsType() in ['Average Future/Forward', 'Commodity', 'Commodity Variant', 'Commodity Index']:
                    second_char = 'T'
                elif underlyer.InsType() in ['Bill', 'Bond', 'Convertible', 'Deposit', 'FRA', 'FRN', 'RateIndex', 'Zero', 'IndexLinkedBond', 'Swap', 'PromisLoan']:
                    second_char = 'R'
                elif underlyer.InsType() in ['Combination']:
                    second_char = get_combination_classification_char(underlyer)
                elif underlyer.InsType() in ['CreditDefaultSwap', 'CLN', ]:
                    second_char = 'C'
                elif underlyer.InsType() in ['Curr']:
                    second_char = 'F'
                elif underlyer.InsType() in ['Dividend Point Index', 'EquityIndex', 'Stock', 'Depositary Receipt']:
                    second_char = 'E'
        else:
            second_char = get_option_callable_char(instrument)

    elif instrument.InsType() in ['Future/Forward', 'Average Future/Forward', 'CFD']:
        if not instrument.Otc():
            second_char = 'C'
            if instrument.InsType() in ['Future/Forward'] and instrument.Underlying().InsType() not in ['Average Future/Forward', 'Commodity', 'Commodity Variant',]:
                second_char = 'F'
            elif instrument.InsType() in ['Future/Forward'] and instrument.Underlying().InsType() in ['Combination']:
                if get_combination_classification(instrument.Underlying())[1]:
                    second_char = 'C'
                else:
                    second_char = 'F'
            elif instrument.InsType() in ['CFD']:
                second_char = 'F'
        else:
            underlyer = None
            if instrument.InsType() == 'Average Future/Forward':
                underlyer = instrument.Legs()[0].FloatRateReference()
            else:
                underlyer = instrument.Underlying()
            if (underlyer.InsType() in ['Stock', 'EquityIndex', 'Dividend Point Index', 'Depositary Receipt']) or \
                (instrument.InsType() in ['CFD'] and underlyer.InsType() in ['Stock', 'EquityIndex']):
                second_char = 'E'
            elif underlyer.InsType() in ['Curr']:
                second_char = 'F'
            elif underlyer.InsType() in ['CreditDefaultSwap', 'CLN']:
                second_char = 'C'
            elif underlyer.InsType() in ['RateIndex', 'Bill', 'Bond', 'FRN', 'Deposit', 'Zero', 'PromisLoan', 'FRA', 'IndexLinkedBond', 'Convertible', 'Swap']:
                second_char = 'R'
            elif underlyer.InsType() in ['Commodity', 'Commodity Variant', 'Commodity Index', \
                                    'Average Future/Forward', 'Precious Metal Rate', 'Rolling Schedule']:
                second_char = 'T'
            elif underlyer.InsType() in ['Combination']:
                second_char = get_combination_classification_char(underlyer)
    elif instrument.InsType() in ['Swap', 'CurrSwap', 'IndexLinkedSwap', 'FRA', 'Cap', 'Floor', 'RateIndex', 'Repo/Reverse', 'BasketRepo/Reverse', 'BuySellback', 'PriceIndex']:
        second_char = 'R'
    elif instrument.InsType() in ['CreditDefaultSwap']:
        second_char = 'C'
    elif instrument.InsType() in ['VarianceSwap', 'VolatilitySwap', ]:
        second_char = 'M'
        if instrument.Underlying().InsType() in ['Stock', 'EquityIndex', 'Depositary Receipt'] or \
            (instrument.Underlying().InsType() in ['Combination'] and get_combination_classification(instrument.Underlying())[0]):
            second_char = 'E'
    elif instrument.InsType() in ['PriceSwap']:
        second_char = 'T'
    elif instrument.InsType() in ['TotalReturnSwap']:
        second_char = 'M'
        for leg in instrument.Legs():
            if leg.LegType() == 'Total Return':
                second_char = get_TRS_float_rate_ref_classification(leg.FloatRateReference())
    elif instrument.InsType() in ['EquityIndex']:
        second_char = 'I'
    elif instrument.InsType() in ['DualCurrBond', 'IndexLinkedBond']:
        second_char = 'B'
    elif instrument.InsType() in ['FXOptionDatedFwd']:
        second_char = 'F'
    return second_char

def get_third_char_in_cfi_code(instrument, ins_type):
    third_char = 'X'
    if instrument.InsType() in ['Rolling Schedule', 'Cap', 'Floor', 'BasketSecurityLoan', 'Flexi Bond', 'CreditIndex']:
        third_char = 'M'
    elif instrument.InsType() in ['Commodity Index']:
        third_char = 'T'
    elif instrument.InsType() in ['Depositary Receipt', 'Certificate', 'Dividend Point Index', 'Repo/Reverse', 'BuySellback']:# and (not instrument.Otc()) :
        third_char = 'S'
    elif instrument.InsType() in ['Bill']:
        third_char = 'Z'
    elif instrument.InsType() in ['Bond', 'Convertible', 'FRN', 'MBS/ABS', 'PromisLoan', 'Zero']:#and (not instrument.Otc()) :
        if instrument.Legs()[0].LegType() in ['Fixed', 'Fixed Accretive']:
            third_char = 'F'
        elif instrument.Legs()[0].LegType() == 'Zero Coupon Fixed':
            third_char = 'Z'
        elif instrument.Legs()[0].LegType() in ['Float', 'Capped Float', 'Floored Float', 'Collared Float', 'Reverse Float']:
            third_char = 'V'
    elif instrument.InsType() in ['Warrant'] and instrument.Underlying() and (not instrument.Otc()) :
        if instrument.Underlying().InsType() in ['Combination', 'ETF', 'Fund']:
            third_char = 'B'
        elif instrument.Underlying().InsType() in ['Stock', 'Depositary Receipt']:
            third_char = 'S'
        elif instrument.Underlying().InsType() in ['Bill', 'Bond', 'FRN', 'Convertible', 'Deposit', 'Zero', 'PromisLoan']:
            third_char = 'D'
        elif instrument.Underlying().InsType() in ['Commodity', 'Commodity Variant', 'Average Future/Forward']:
            third_char = 'T'
        elif instrument.Underlying().InsType() in ['Curr',]:
            third_char = 'C'
        elif instrument.Underlying().InsType() in ['EquityIndex', 'RateIndex', 'Commodity Index']:
            third_char = 'I'
        elif instrument.Underlying().InsType() in ['Cap', 'CFD', 'CLN', \
                        'CreditDefaultSwap', 'CurrSwap', 'Floor', 'FreeDefCF', 'FRA', \
                        'Future/Forward', 'IndexLinkedSwap', 'Option', 'Swap', \
                        'TotalReturnSwap', 'VarianceSwap', 'Warrant', ]:
            third_char = 'M'
    elif instrument.InsType() in ['Option']:
        if is_otc_option(instrument):
            third_char = 'M'
            underlying = instrument.Underlying()
            if underlying.InsType() in ['Swap', 'IndexLinkedSwap', 'CurrSwap']:
                third_char = get_swap_classification(underlying)
            elif underlying.InsType() in ['TotalReturnSwap']:
                second_char = get_second_char_in_cfi_code(instrument, instrument.InsType()) 
                if second_char in ['T', 'C']:
                    third_char = 'W'
                elif second_char in ['R']:
                    third_char = get_swap_classification(underlying)
            elif underlying.InsType() == 'FRA':
                third_char = 'R'
            elif underlying.InsType() in ['Cap', 'Floor']:
                third_char = 'O'
            elif underlying.InsType() in ['Option', 'Warrant']:
                third_char = 'O'
                if underlying.Underlying().InsType() in ['Curr']:
                    third_char = 'M'
                elif underlying.Underlying().InsType() in ['Combination'] :
                    if get_second_char_in_cfi_code(instrument, instrument.InsType()) == 'M':
                        third_char = 'M'
            elif underlying.InsType() in ['Future/Forward']:
                underlyer = underlying.Underlying()
                if underlyer.InsType() in ['Bill', 'Bond', 'Convertible', 'Deposit', 'FRA', 'FRN', 'RateIndex', 'Zero', \
                    'Average Future/Forward', 'Commodity', 'Commodity Variant', 'Commodity Index', 'Curr', 'Stock', 'EquityIndex']:
                    if underlying.Otc():
                        third_char = 'R'
                    else:
                        third_char = 'F'
            elif underlying.InsType() in ['Combination'] :
                combination_classification = get_combination_classification_char(underlying)
                if combination_classification == 'T':
                    third_char = 'Q'
                elif combination_classification == 'E':
                    third_char = 'B'
                elif combination_classification =='C':#, 'R', 'F']:#TODO: Should this be M? if yes, there is no need to call it. comment the code
                    third_char = get_credit_default_swap_classification(underlying)
            elif underlying.InsType() in ['Commodity', 'Commodity Variant']:
                und_ins = underlying
                if underlying.InsType() != 'Commodity':
                    und_ins = underlying.Underlying()
                third_char = commodity_classify(und_ins)
            elif underlying.InsType() in ['Commodity Index', 'Dividend Point Index', 'EquityIndex'] or \
                (instrument.InsType() in ['CFD'] and instrument.Underlying().InsType() in ['EquityIndex']):
                third_char = 'I'
            elif underlying.InsType() in ['Stock', 'Depositary Receipt'] or \
                (instrument.InsType() in ['CFD'] and instrument.Underlying().InsType() in ['Stock']):
                third_char = 'S'
            elif underlying.InsType() in ['CreditDefaultSwap']:
                if underlying.Legs()[0].CreditRef().InsType() in ['EquityIndex', 'CreditIndex']:
                    third_char = 'I'
                elif underlying.Legs()[0].CreditRef().InsType() in ['Bill', 'Bond', 'Convertible', 'Deposit', 'FRN', 'Zero']:
                    third_char = 'U'
            elif underlying.InsType() in ['Average Future/Forward']:
                third_char = 'R'
            elif underlying.InsType() in ['Curr']:
                if instrument.Otc():
                    third_char = 'R'
                else:
                    third_char = 'F'
        else:
            third_char = get_exercise_type_char(instrument)
    elif instrument.InsType() in ['Future/Forward'] and (not instrument.Otc()) :
        if instrument.Underlying().InsType() in ['Combination', 'ETF']:
            third_char = 'B'
        elif instrument.Underlying().InsType() in ['Stock', 'Depositary Receipt']:
            third_char = 'S'
        elif instrument.Underlying().InsType() in ['Bill', 'Bond', 'FRN', 'Convertible', 'Deposit', 'Zero', 'PromisLoan', 'IndexLinkedBond']:
            third_char = 'D'
        elif instrument.Underlying().InsType() in ['Curr',]:
            third_char = 'C'
        elif instrument.Underlying().InsType() in ['EquityIndex', 'Commodity Index', 'Dividend Point Index']:
            third_char = 'I'
        elif instrument.Underlying().InsType() in [ 'RateIndex']:
            third_char = 'N'
        elif instrument.Underlying().InsType() in ['Swap']:
            third_char = 'W'
        elif instrument.Underlying().InsType() in ['FRA']:
            third_char = 'N'
        elif instrument.Underlying().InsType() in ['FreeDefCF', 'CLN', 'CreditDefaultSwap']:
            third_char = 'M'
        elif instrument.Underlying().InsType() in ['Average Future/Forward', 'Commodity', 'Commodity Variant',]:
            third_char = 'M'
            underlyer = instrument.Underlying()
            final_underlyer = None
            while underlyer:
                final_underlyer = underlyer
                underlyer = underlyer.Underlying()
            third_char = get_commodity_classification(final_underlyer)
    elif instrument.InsType() in ['Average Future/Forward'] and (not instrument.Otc()) :
        third_char = 'M'
        underlyer = instrument.Legs()[0].FloatRateReference()
        final_underlyer = None
        while underlyer:
            final_underlyer = underlyer
            try:
                underlyer = underlyer.Legs()[0].FloatRateReference()
            except:
                underlyer = None
                pass
        third_char = get_commodity_classification(final_underlyer)

    elif instrument.InsType() in ['Future/Forward', 'Average Future/Forward', 'CFD'] and (instrument.Otc()):
        underlyer = None
        if instrument.InsType() == 'Average Future/Forward':#Average Future/Forward
            underlyer = instrument.Legs()[0].FloatRateReference()
        else:
            underlyer = instrument.Underlying()
        if underlyer.InsType() in ['Stock', 'Depositary Receipt']:
            third_char = 'S'
        elif underlyer.InsType() in ['EquityIndex', 'Dividend Point Index', 'RateIndex']:
            third_char = 'I'
        elif underlyer.InsType() in ['Combination']:
            if get_combination_classification(underlyer)[0] or get_combination_classification(underlyer)[1] or get_combination_classification(underlyer)[2]:
                third_char = 'B'
            elif get_combination_classification(underlyer)[4]:
                third_char = 'R'
        elif underlyer.InsType() in ['CreditDefaultSwap']:
            third_char = get_credit_default_swap_classification_FutureForward(underlyer)
        elif underlyer.InsType() in ['Bill', 'Bond', 'FRN', 'Deposit', 'Zero', 'PromisLoan', 'FRA', 'IndexLinkedBond', 'Convertible', 'Swap', 'BasketSecurityLoan']:
            third_char = 'M'
        elif underlyer.InsType() in ['Commodity', 'Commodity Variant', 'Commodity Index', 'Average Future/Forward', 'Precious Metal Rate', 'Rolling Schedule']:
            third_char = get_commodity_classification_for_swaps(instrument)#.Underlying())
        elif underlyer.InsType() in ['Curr']:
            third_char = 'R'
    elif instrument.InsType() in ['Swap', 'CurrSwap', 'IndexLinkedSwap']:
        third_char = get_swap_classification(instrument)
    elif instrument.InsType() in ['PriceSwap']:
        third_char = get_commodity_classification_for_swaps(instrument)
    elif instrument.InsType() in ['TotalReturnSwap']:
        third_char = 'M'
        for leg in instrument.Legs():
            if leg.LegType() == 'Total Return':
                reference = leg.FloatRateReference()
                if not reference:
                    reference = leg.IndexRef()
                if reference.InsType() in ['EquityIndex']:
                    third_char = 'I'
                elif reference.InsType() in ['Stock']:
                    third_char = 'S'
                elif reference.InsType() in ['CFD']:
                    if reference.Underlying().InsType() in ['EquityIndex']:
                        third_char = 'I'
                    elif reference.Underlying().InsType() in ['Stock']:
                        third_char = 'S'
                elif reference.InsType() in ['Average Future/Forward', 'Commodity', 'Commodity Variant', \
                        'Precious Metal Rate', 'Rolling Schedule']:
                    third_char = get_commodity_classification_for_swaps(reference)
                elif reference.InsType() in ['CreditIndex', 'Commodity Index']:
                    third_char = 'I'
                elif reference.InsType() in ['Combination']:
                    is_equity, is_commodity, is_credit, is_rate, is_curr = get_combination_classification(reference)
                    third_char = 'M'
                    if is_commodity:
                        third_char = 'Q'
                    elif is_equity:
                        third_char = 'B'
                    elif is_credit:
                        third_char = 'B'
                elif reference.InsType() in ['Bond', 'Convertible', 'DualCurrBond', \
                    'Flexi Bond', 'FRN', 'PromisLoan', 'BasketRepo/Reverse', 'BasketSecurityLoan', \
                    'Bill', 'BuySellback', 'CD', 'CLN', 'Deposit', 'IndexLinkedBond', 'RateIndex', \
                    'Repo/Reverse', 'SecurityLoan', 'Zero']:
                    third_char = get_swap_classification(instrument)
    elif instrument.InsType() in ['VarianceSwap', 'VolatilitySwap', ]:
        third_char = 'M'
        if instrument.Underlying().InsType() in ['EquityIndex']:
            third_char = 'I'
        elif instrument.Underlying().InsType() in ['Stock', 'Depositary Receipt']:
            third_char = 'S'
        elif instrument.Underlying().InsType() in ['Combination'] and get_combination_classification(instrument.Underlying())[0]:
            third_char = 'B'
    elif instrument.InsType() in ['CreditDefaultSwap']:
        third_char = 'M'
        credit_ref = None
        for leg in instrument.Legs():
            if leg.CreditRef():
                credit_ref = leg.CreditRef()
                break
        if credit_ref:
            if credit_ref.InsType() in ['Bill', 'Bond', 'Deposit', 'Flexi Bond', 'Zero', 'PromisLoan', 'Certificate', 'FRN']:
                third_char = 'U'
            elif credit_ref.InsType() in ['CreditIndex']:
                third_char = 'I'
            elif credit_ref.InsType() in ['Combination']:
                third_char = 'B'
    elif instrument.InsType() in ['Warrant']:
        if instrument.Underlying().InsType() in ['VarianceSwap', 'Warrant', 'TotalReturnSwap', \
            'Future/Forward', 'Option', 'FreeDefCF', 'Floor', 'Bond', 'CreditDefaultSwap', \
            'CFD', 'Cap', 'Bill', 'ETF']:
            third_char = 'M'
        elif instrument.Underlying().InsType() in ['Zero', 'Swap', 'PromisLoan', 'IndexLinkedSwap', \
            'FRN', 'FRA', 'Deposit', 'CurrSwap', 'Convertible', 'CLN']:
            third_char = 'D'
        elif instrument.Underlying().InsType() in ['Stock', 'Depositary Receipt']:
            third_char = 'S'
        elif instrument.Underlying().InsType() in ['RateIndex', 'EquityIndex', 'Commodity Index']:
            third_char = 'I'
        elif instrument.Underlying().InsType() in ['Curr']:
            third_char = 'C'
        elif instrument.Underlying().InsType() in ['Commodity', 'Commodity Variant', 'Average Future/Forward']:
            third_char = 'T'
        elif instrument.Underlying().InsType() in ['Combination']:
            third_char = 'B'
    elif instrument.InsType() in ['FRA']:
        third_char = 'I'
    elif instrument.InsType() in ['EquityIndex']:
        third_char = 'E'
    elif instrument.InsType() in ['RateIndex']:
        third_char = 'V'
    elif instrument.InsType() in ['SecurityLoan']:
        if instrument.Underlying():
            if instrument.Underlying().InsType() in ['Deposit']:
                third_char = 'C'
            elif instrument.Underlying().InsType() in ['Bill']:
                third_char = 'K'
            elif instrument.Underlying().InsType() in ['CD']:
                third_char = 'D'
            elif instrument.Underlying().InsType() in ['CLN', 'Combination', 'Commodity', 'Commodity Variant', \
                    'Dividend Point Index', 'ETF', 'FreeDefCF', 'IndexLinkedBond', 'MBS/ABS', 'Swap']:
                third_char = 'M'
            elif instrument.Underlying().InsType() in ['Convertible']:
                third_char = 'T'
            elif instrument.Underlying().InsType() in ['Depositary Receipt', 'EquityIndex', 'Stock', ]:
                third_char = 'E'
            elif instrument.Underlying().InsType() in ['Bond', 'DualCurrBond', 'Flexi Bond', 'FRN', 'PromisLoan', 'Zero']:
                third_char = 'X'
                if instrument.Underlying().Issuer() and instrument.Underlying().Issuer().BusinessStatus():
                    business_status = instrument.Underlying().Issuer().BusinessStatus().Name()
                    if 'GOVERNMENT' in business_status.upper():
                        third_char = 'G'
                    elif 'MUNICIPAL' in business_status.upper():
                        third_char = 'P'
    elif instrument.InsType() in ['CLN']:
        third_char = 'A'
    elif instrument.InsType() in ['BasketRepo/Reverse']:
        third_char = 'G'
    elif instrument.InsType() in ['IndexLinkedBond', 'DualCurrBond']:
        third_char = 'V'
    elif instrument.InsType() in ['CD']:
        third_char = 'P'
    elif instrument.InsType() in ['Deposit']:
        third_char = 'B'
    elif instrument.InsType() in ['CFD'] and (not instrument.Otc()):
        if instrument.Underlying().InsType() in ['Stock', 'Depositary Receipt']:
            third_char = 'S'
        elif instrument.Underlying().InsType() in ['EquityIndex']:
            third_char = 'I'
        elif instrument.Underlying().InsType() in ['Bond']:
            third_char = 'B'
        elif instrument.Underlying().InsType() in ['ETF', 'Warrant']:
            third_char = 'M'
    elif instrument.InsType() in ['Commodity', 'Commodity Variant']:
        third_char = commodity_classify(instrument)
    elif instrument.InsType() in ['FXOptionDatedFwd']:
        third_char = 'R'
    elif instrument.InsType() in ['Combination']:
        b_shares = False
        b_bonds = False
        b_warrants = False
        b_funds = False
        b_others = False
        for ins_map in instrument.InstrumentMaps():
            if ins_map.Instrument().InsType() in ['Bill', 'Bond', 'DualCurrBond', \
                'Flexi Bond', 'FRN', 'PromisLoan', 'Zero', 'IndexLinkedBond', \
                'Convertible']:
                b_bonds = True
            elif ins_map.Instrument().InsType() in ['Depositary Receipt', 'Stock']:
                b_shares = True
            elif ins_map.Instrument().InsType() in ['CLN', 'Combination', 'Commodity', 'Commodity Variant', \
                    'Dividend Point Index', 'FreeDefCF', 'MBS/ABS', 'Swap', \
                    'VarianceSwap', 'TotalReturnSwap', 'Future/Forward', 'Option', 'Floor', \
                    'CreditDefaultSwap', 'CFD', 'Cap', 'IndexLinkedSwap', 'FRA', 'Deposit', 'CurrSwap', \
                    'CLN', 'RateIndex', 'Commodity Index', 'Curr', 'Average Future/Forward', \
                    'Combination', 'EquityIndex', ]:
                b_others = True
            elif ins_map.Instrument().InsType() in ['Warrant']:
                b_warrants = True
            elif ins_map.Instrument().InsType() in ['ETF']:
                b_funds = True
        if b_others:
            third_char = 'M'
        else:
            if b_funds:
                if b_shares or b_bonds or b_warrants:
                    third_char = 'M'
                else:
                    third_char = 'U'
            else:
                if b_bonds and b_warrants:
                    third_char = 'M'
                elif b_shares and b_bonds:
                    third_char = 'H'
                elif b_shares and b_warrants:
                    third_char = 'A'
                elif b_shares:
                    third_char = 'S'
                elif b_bonds:
                    third_char = 'B'
                elif b_warrants:
                    third_char = 'W'
        
    return third_char

def get_credit_default_swap_classification_FutureForward(instrument):
    leg_ref = None
    if instrument.InsType() == 'CreditDefaultSwap':
        for leg in instrument.Legs():
            if leg.LegType() == 'Credit Default':
                leg_ref = leg
                break
    elif instrument.InsType() == 'CLN':
        leg_ref = instrument.Legs()[0]
    if leg_ref:
        instrument = leg_ref.CreditRef()        
    cds_classify = 'X'
    if instrument.InsType() in ['Bill', 'Bond', 'Deposit', 'Flexi Bond', 'Zero', 'PromisLoan']:
        cds_classify = 'C'
    if instrument.InsType() in ['CreditIndex']:
        cds_classify = 'D'
    if instrument.InsType() in ['Combination'] and get_combination_classification(instrument)[2]:
        cds_classify = 'I'
    return cds_classify
    
def get_credit_default_swap_classification(instrument):
    leg_ref = None
    if instrument.InsType() == 'CreditDefaultSwap':
        for leg in instrument.Legs():
            if leg.LegType() == 'Credit Default':
                leg_ref = leg
                break
    elif instrument.InsType() == 'CLN':
        leg_ref = instrument.Legs()[0]
    if leg_ref:
        instrument = leg_ref.CreditRef()        
    cds_classify = 'M'
    if instrument.InsType() in ['Bill', 'Bond', 'Deposit', 'Flexi Bond', 'Zero', 'PromisLoan']:
        cds_classify = 'C'
    if instrument.InsType() in ['CreditIndex']:
        cds_classify = 'D'
    if instrument.InsType() in ['Combination'] and get_combination_classification(instrument)[2]:
        cds_classify = 'I'
    return cds_classify

def get_otc_option_style_type(instrument):
    option_type = None
    option_style = ''
    option_style_type_classification = 'X'
    if instrument.IsCallOption():
        option_type = 'Call'
    else:
        option_type = 'Put'
    if instrument.ExerciseType():
        if instrument.ExerciseType() in ['American', 'Amer GA']:
            option_style = 'American'
        if instrument.ExerciseType() == 'Bermudan':
            option_style = 'Bermudan'
        if instrument.ExerciseType() == 'European':
            option_style = 'European'
    if option_style + '-' + option_type in option_style_type_lookup:
        option_style_type_classification = option_style_type_lookup[option_style + '-' + option_type]
    return option_style_type_classification
        
def is_otc_option(instrument):
    otc_option = False
    exotic_char = get_exotic_char(instrument)
    if instrument.Otc() or instrument.Underlying().InsType() in ['CLN', 'CreditDefaultSwap', 'CFD'] or (instrument.Underlying().InsType() == 'Curr' and exotic_char != 'V'):
        otc_option = True
    return otc_option
    
def get_fourth_char_in_cfi_code(instrument, ins_type):
    fourth_char = 'X'
    if instrument.InsType() in ['Bond', 'Convertible', 'FRN', 'MBS/ABS', 'PromisLoan', 'Zero', 'Bill', 'IndexLinkedBond']: #and (not instrument.Otc()) :
        fourth_char = get_seniority_char(instrument)
    elif instrument.InsType() in ['Warrant'] and (not instrument.Otc()):
        fourth_char = 'T'
    elif instrument.InsType() in ['Option']:
        if is_otc_option(instrument):
            fourth_char = get_otc_option_style_type(instrument)
        else:
            if instrument.Underlying().InsType() in ['Combination', 'ETF', 'Fund', ]:
                fourth_char = 'B'
            if instrument.Underlying().InsType() in ['Stock', 'Depositary Receipt']:
                fourth_char = 'S'
            if instrument.Underlying().InsType() in ['Bill', 'Bond', 'FRN', 'Convertible', 'Deposit',  'Zero', 'PromisLoan']:
                fourth_char = 'D'
            if instrument.Underlying().InsType() in ['Commodity', 'Commodity Variant', 'Average Future/Forward', ]:
                fourth_char = 'T'
            if instrument.Underlying().InsType() in ['Curr',]:
                fourth_char = 'C'
            if instrument.Underlying().InsType() in ['EquityIndex', 'RateIndex', 'Commodity Index', ]:
                fourth_char = 'I'
            if instrument.Underlying().InsType() in ['Option', 'Warrant']:
                fourth_char = 'O'
            if instrument.Underlying().InsType() in ['Future/Forward']:
                fourth_char = 'F'
            if instrument.Underlying().InsType() in ['CurrSwap', 'Swap', 'IndexLinkedSwap', 'TotalReturnSwap', 'VarianceSwap', 'CreditDefaultSwap']:
                fourth_char = 'W'
            if instrument.Underlying().InsType() in ['Cap', 'Floor', 'FRA']:
                fourth_char = 'N'
            if instrument.Underlying().InsType() in ['CFD', 'CLN', 'FreeDefCF', 'PromisLoan', ]:#TODO: Discuss with Ishan for CLN
                fourth_char = 'M'
    elif instrument.InsType() in ['Future/Forward', 'Average Future/Forward'] and (not instrument.Otc()):
        fourth_char = get_delivery_char(instrument)
    elif instrument.InsType() in ['Swap', 'CurrSwap' 'IndexLinkedSwap']:
        fourth_char = 'X'
    elif instrument.InsType() in ['VarianceSwap']:
        fourth_char = 'X'
        if instrument.Underlying().InsType() in ['EquityIndex', 'Stock', 'Depositary Receipt'] or (instrument.Underlying().InsType() in ['Combination'] and get_combination_classification(instrument.Underlying())[0]):
            fourth_char = 'V'
    elif instrument.InsType() in ['VolatilitySwap', ]:
        fourth_char = 'X'
        if instrument.Underlying().InsType() in ['EquityIndex', 'Stock', 'Depositary Receipt'] or (instrument.Underlying().InsType() in ['Combination'] and get_combination_classification(instrument.Underlying())[0]):
            fourth_char = 'L'
    elif instrument.InsType() in ['CreditDefaultSwap']:
        fourth_char = 'C'
    elif instrument.InsType() in ['PriceSwap']:
        fourth_char = 'X'#TODO: discuss with Thomas
    elif instrument.InsType() in ['TotalReturnSwap']:
        fourth_char = 'X'
        for leg in instrument.Legs():
            if leg.LegType() == 'Total Return' and leg.FloatRateReference():#Tell Thomas
                if leg.FloatRateReference().InsType() in ['EquityIndex', 'Stock'] or \
                    (leg.FloatRateReference().InsType() in ['CFD'] and leg.FloatRateReference().Underlying().InsType() in ['EquityIndex', 'Stock']):
                    #if leg.PassingType() != 'None':
                    fourth_char = 'T'
                    #else:
                    #    fourth_char = 'P'
                if leg.FloatRateReference().InsType() in ['Dividend Point Index']:
                    fourth_char = 'D'
                if leg.FloatRateReference().InsType() in ['Depositary Receipt']:
                    fourth_char = 'T'
                if leg.FloatRateReference().InsType() in ['Average Future/Forward', 'Commodity', 'Commodity Index', 'Commodity Variant', \
                        'Precious Metal Rate', 'Rolling Schedule']:
                    fourth_char = 'X'#TODO: discuss with Thomas
                if leg.FloatRateReference().InsType() in ['CreditIndex']:
                    fourth_char = 'C'
                if leg.FloatRateReference().InsType() in ['Combination']:
                    is_equity, is_commodity, is_credit, is_rate, is_curr = get_combination_classification(leg.FloatRateReference())
                    if is_equity:
                        if leg.PassingType() != 'None':
                            fourth_char = 'T'
                        else:
                            fourth_char = 'P'
                    if is_commodity:
                        fourth_char = 'X'#TODO: discuss with Thomas
                    if is_credit:
                        fourth_char = 'T'
                break
    elif instrument.InsType() in ['Cap']:
        fourth_char = 'A'
    elif instrument.InsType() in ['Floor']:
        fourth_char = 'D'
    elif instrument.InsType() in ['CLN']:
        if instrument.Legs()[0].LegType() == 'Fixed':
            fourth_char = 'F'
        else:
            fourth_char = 'V'
    elif instrument.InsType() in ['SecurityLoan', 'Repo/Reverse', 'BasketSecurityLoan', 'BasketRepo/Reverse']:
        if instrument.OpenEnd():
            fourth_char = 'X'
            if instrument.OpenEnd() == 'Open End':
                fourth_char = 'O'
        else:
            end_date = ael.date_from_string(instrument.EndDate())
            start_date = ael.date_from_string(instrument.StartDate())
            date_diff = start_date.days_between(end_date)
            if abs(date_diff) == 1:
                fourth_char = 'N'
            else:
                fourth_char = 'T'
    elif instrument.InsType() in ['BuySellback']:
        fourth_char = 'T'
        end_date = ael.date_from_string(instrument.ExpiryDateOnly())
        start_date = ael.date_from_string(instrument.StartDate())
        date_diff = start_date.days_between(end_date)
        if abs(date_diff) == 1:
            fourth_char = 'N'
    elif instrument.InsType() in ['Depositary Receipt']:
        fourth_char = 'N'
    elif instrument.InsType() in ['CFD'] and (not instrument.Otc()):
        fourth_char = 'C'
    return fourth_char

def get_exotic_char(instrument):
    valuation_method = 'M'
    exotic_type = None
    if instrument.Exotics() and instrument.Exotics()[0].Oid() > 0:
        if instrument.Exotics()[0].AverageMethodType() != 'None':
            exotic_type = 'Asian'
        elif instrument.Exotics()[0].LookbackOptionType() != 'None':
            exotic_type = 'Lookback'
        elif instrument.Exotics()[0].RangeAccrualAmount():
            exotic_type = 'Range Accrual'
        elif instrument.Exotics()[0].BarrierOptionType():
            if 'KIKO' in instrument.Exotics()[0].BarrierOptionType():
                exotic_type = 'KIKO'
            else:
                exotic_type = 'Barrier'
        if instrument.Exotics()[0].DigitalBarrierType():
            if instrument.Exotics()[0].DigitalBarrierType() == 'Barrier & Strike':
                exotic_type = 'Digital European Barrier'
            elif instrument.Exotics()[0].DigitalBarrierType() == 'Barrier':
                exotic_type = 'Digital American'
    else:
        if instrument.Digital():
            exotic_type = 'Digital European Vanilla'
        else:
            if instrument.ExerciseType().upper() == 'NONE':
                exotic_type = 'Custom'
            else:
                exotic_type = 'Vanilla'
    if exotic_type and exotic_type in exotic_lookup:
        valuation_method = exotic_lookup[exotic_type]
    return valuation_method
            
def get_fifth_char_in_cfi_code(instrument, ins_type):
    fifth_char = 'X'
    if instrument.InsType() in ['Rolling Schedule', 'FRA', 'FXOptionDatedFwd']:
        fifth_char = 'F'
    elif instrument.InsType() in ['ETF']:
        if instrument.Underlying().InsType() == 'Stock':
            fifth_char = 'E'
        elif instrument.Underlying().InsType() == 'Bond':
            fifth_char = 'B'
        elif instrument.Underlying().InsType() == 'Combination':
            fifth_char = 'L'
        elif instrument.Underlying().InsType() == 'Commodity':
            fifth_char = 'C'
        elif instrument.Underlying().InsType() in ['EquityIndex', 'RateIndex']:
            fifth_char = 'F'
        elif instrument.Underlying().InsType() == 'Future/Forward':
            fifth_char = 'D'
    elif instrument.InsType() in ['Future/Forward', 'Average Future/Forward'] and (instrument.Otc()):
        fifth_char = 'F'
    elif instrument.InsType() in ['CFD'] and instrument.Underlying().InsType() in ['Stock', 'EquityIndex'] and (instrument.Otc()):
        fifth_char = 'C'

    elif instrument.InsType() in ['ETF'] and (not instrument.Otc()) :
        if instrument.Underlying().InsType() in ['Stock', 'EquityIndex']:
            fifth_char = 'E'
        if instrument.Underlying().InsType() in ['Bond']:
            fifth_char = 'B'
        if instrument.Underlying().InsType() in ['Combination']:
            fifth_char = 'M'
        if instrument.Underlying().InsType() in ['Commodity']:
            fifth_char = 'C'
        if instrument.Underlying().InsType() in ['RateIndex', 'Future/Forward']:
            fifth_char = 'D'

    elif instrument.InsType() in ['Bond', 'Convertible', 'FRN', 'MBS/ABS', 'PromisLoan', 'Zero', 'DualCurrBond', 'IndexLinkedBond']:# and (not instrument.Otc()):
        if instrument.Callable() and instrument.Putable():
            fifth_char = 'D'
        elif instrument.Callable():
            fifth_char = 'G'
        elif instrument.Putable():
            fifth_char = 'C'
        else:
            fifth_char = 'F'
    elif instrument.InsType() in ['Warrant']:
        fifth_char = get_option_callable_char(instrument)
    elif instrument.InsType() in ['Option']:
        if is_otc_option(instrument):
        #if instrument.Otc() or instrument.Underlying().InsType() in ['CLN', 'CreditDefaultSwap']:
            fifth_char = 'V'
            if instrument.Underlying().InsType() in ['Curr'] or \
                (instrument.Underlying().InsType() in ['Future/Forward'] and instrument.Underlying().Underlying().InsType() == 'Curr') or \
                (instrument.Underlying().InsType() in ['Combination'] and get_combination_classification_char(instrument.Underlying()) == 'F'):
                    fifth_char = get_exotic_char(instrument)

        else:
            fifth_char = get_delivery_char(instrument)
    elif instrument.InsType() in ['Future/Forward', 'Average Future/Forward'] and (not instrument.Otc()):
        fifth_char = 'S'
    elif instrument.InsType() in ['Swap', 'CurrSwap', 'IndexLinkedSwap']:
        fifth_char = 'S'
        if is_underlyer_curr_different(instrument):
            fifth_char = 'C'
    elif instrument.InsType() in ['PriceSwap']:
        fifth_char = 'X'
    elif instrument.InsType() in ['CreditDefaultSwap']:
        credit_ref = None
        for leg in instrument.Legs():
            if leg.CreditRef():
                credit_ref = leg.CreditRef()
                break
        fifth_char = get_credit_category(credit_ref)
    elif instrument.InsType() in ['CurrSwap', ]:
        fifth_char = 'C'
    elif instrument.InsType() in ['VolatilitySwap', 'VarianceSwap',]: 
        fifth_char = 'X'
    elif instrument.InsType() in ['TotalReturnSwap']:
        if get_second_char_in_cfi_code(instrument, instrument.InsType()) == 'R':
            fifth_char = 'S'
            if is_underlyer_curr_different(instrument):
                fifth_char = 'C'
        else:
            float_rate_ref = None
            for leg in instrument.Legs():
                if leg.FloatRateReference():
                    float_rate_ref = leg.FloatRateReference()
                    break
            if not float_rate_ref:
                for leg in instrument.Legs():
                    if leg.IndexRef():
                        float_rate_ref = leg.IndexRef()
                        break
            if float_rate_ref.InsType() in ['Combination']:
                is_equity, is_commodity, is_credit, is_rate, is_curr = get_combination_classification(float_rate_ref)
                if is_credit:
                    fifth_char = get_credit_category(float_rate_ref)
            if float_rate_ref.InsType() in ['CreditIndex']:
                fifth_char = get_credit_category(float_rate_ref)
    elif instrument.InsType() in ['Cap', 'Floor']:
        fifth_char = 'V'
    elif instrument.InsType() in ['Depositary Receipt']:
        fifth_char = 'D'
    elif instrument.InsType() in ['CLN']:
        fifth_char = 'M'  
    elif instrument.InsType() in ['CFD'] and (not instrument.Otc()):
        fifth_char = 'S'     
            
    return fifth_char

def get_sixth_char_in_cfi_code(instrument, ins_type):
    sixth_char = 'X'
    if instrument.InsType() in ['Rolling Schedule', 'FRA']:
        sixth_char = 'C'
    elif instrument.InsType() in ['FXOptionDatedFwd']:
        sixth_char = 'P'
    elif instrument.InsType() in ['ETF']:
        sixth_char = 'U'
        if instrument.Underlying().InsType() == 'Stock':
            sixth_char = 'S'
    elif instrument.InsType() in ['Warrant']:
        sixth_char = get_exercise_type_char(instrument)
    elif instrument.InsType() in ['IndexLinkedSwap', 'PriceSwap', 'VolatilitySwap', 'VarianceSwap']:
        sixth_char = 'C'
    elif instrument.InsType() in ['TotalReturnSwap', 'CreditDefaultSwap']:
        sixth_char = get_delivery_char(instrument)
    elif instrument.InsType() in ['Future/Forward', 'Average Future/Forward'] and instrument.Otc():
        sixth_char = get_delivery_char(instrument)
    elif instrument.InsType() in ['CFD'] and instrument.Underlying().InsType() in ['Stock', 'EquityIndex'] and instrument.Otc():
        sixth_char = get_delivery_char(instrument)
    elif instrument.InsType() in ['CurrSwap', 'Swap']:
        sixth_char = is_non_deliverable_swap(instrument)
    #elif (instrument.InsType() in ['Option'] and (instrument.Otc() or instrument.Underlying().InsType() in ['CLN', 'CreditDefaultSwap'])):
    elif instrument.InsType() in ['Option'] and is_otc_option(instrument):
        sixth_char = get_delivery_char(instrument)
    elif instrument.InsType() in ['Cap', 'Floor']:
        sixth_char = 'C'
    elif instrument.InsType() in ['CLN']:
        if instrument.Legs()[0].CreditRef().InsType() in ['Average Future/Forward', 'Commodity', 'Commodity Variant', 'Rolling Schedule']:
            sixth_char = 'T'
        elif instrument.Legs()[0].CreditRef().InsType() in ['BasketRepo/Reverse', 'Repo/Reverse', 'FxSwap', 'Swap', \
            'CurrSwap', 'IndexLinkedSwap', 'SecurityLoan', 'BasketSecurityLoan', 'BuySellback', ]:
            sixth_char = 'N'
        elif instrument.Legs()[0].CreditRef().InsType() in ['Combination', 'ETF', 'Fund', ]:
            sixth_char = 'B'
        elif instrument.Legs()[0].CreditRef().InsType() in ['Bill', 'Bond', 'Convertible', 'Deposit', \
            'FRA', 'FRN', 'IndexLinkedBond', 'PromisLoan', 'CLN', \
            'DualCurrBond', 'CD', 'Flexi Bond', 'MBS/ABS']:
            sixth_char = 'D'
        elif instrument.Legs()[0].CreditRef().InsType() in ['Commodity Index', 'RateIndex', 'CreditIndex', \
            'Dividend Point Index', 'EquityIndex', 'PriceIndex', 'BondIndex']:
            sixth_char = 'I'
        
        elif instrument.Legs()[0].CreditRef().InsType() in ['Stock', 'Depositary Receipt']:
            sixth_char = 'S'
        elif instrument.Legs()[0].CreditRef().InsType() in ['Curr', ]:
            sixth_char = 'C'
        else:
            sixth_char = 'M'
    return sixth_char

def get_first_char_in_cfi_code_trade(trade):
    first_char = 'X'
    if trade.Instrument().InsType() == 'Curr':
        if trade.IsFxSwap():
            first_char = 'S'
        elif trade.IsFxSpot():
            first_char = 'I'
        elif trade.IsFxForward():
            first_char = 'J'
        else:
            first_char = 'F'
    elif (trade.Instrument().InsType() == 'Option' and trade.Instrument().Underlying().InsType() == 'Curr'):
        first_char = 'H'
    elif trade.Instrument().InsType() == 'Future/Forward' and trade.Instrument().Underlying().InsType() == 'Curr':
        if trade.Instrument().Otc():
            first_char = 'J'
        else:
            first_char = 'F'
    return first_char

def get_second_char_in_cfi_code_trade(trade):
    second_char = 'X'
    if (trade.Instrument().InsType() == 'Curr') or \
        (trade.Instrument().InsType() in ['Option', 'Future/Forward'] and trade.Instrument().Underlying().InsType() == 'Curr'):
        second_char = 'F'
    return second_char

def get_third_char_in_cfi_code_trade(trade):
    third_char = 'X'
    if trade.Instrument().InsType() == 'Curr' and trade.IsFxSwap():
        value_day = ael.date_from_string(trade.ValueDay())
        calendar = ael.Calendar[trade.Currency().Legs()[0].PayCalendar().Name()]
        trade_date = ael.date_from_string(str(trade.TradeTime()).split(' ')[0])
        spot_day = trade_date.add_banking_day(calendar, trade.Instrument().SpotBankingDaysOffset())
        if value_day == spot_day:
            third_char = 'A'
        elif value_day > spot_day:
            third_char = 'C'
        else:
            third_char = 'M'
    elif trade.Instrument().InsType() == 'Curr' and trade.IsFxForward():
        third_char = 'R'
    elif trade.Instrument().InsType() == 'Option' and trade.Instrument().Underlying().InsType() == 'Curr':
        expiry_date = ael.date_from_string(trade.Instrument().ExpiryDateOnly())
        calendar = ael.Calendar[trade.Currency().Legs()[0].PayCalendar().Name()]
        delivery_date = expiry_date.add_banking_day(calendar, trade.Instrument().PayDayOffset())
        trade_date = ael.date_from_string(str(trade.TradeTime()).split(' ')[0])
        spot_day = ael.date_from_string(trade_date.add_banking_day(calendar, trade.Instrument().SpotBankingDaysOffset()))
        if delivery_date == spot_day:
            third_char = 'T'
        else:
            if trade.Instrument().PayType() == 'Future':
                third_char = 'F'
            else:
                third_char = 'R'
        
    elif trade.Instrument().InsType() == 'Future/Forward' and trade.Instrument().Underlying().InsType() == 'Curr':
        if trade.Instrument().Otc():
            expiry_date = ael.date_from_string(trade.Instrument().ExpiryDateOnly())
            calendar = ael.Calendar[trade.Currency().Legs()[0].PayCalendar().Name()]
            delivery_date = ael.date_from_string(trade.Instrument().LastPayDay())
            trade_date = ael.date_from_string(str(trade.TradeTime()).split(' ')[0])
            spot_day = ael.date_from_string(trade_date.add_banking_day(calendar, trade.Instrument().SpotBankingDaysOffset()))
            if delivery_date == spot_day:
                third_char = 'T'
            else:
                if trade.Instrument().PayType() in ['Forward', 'Contingent']:
                    third_char = 'R'
                else:
                    third_char = 'F'
        else:
            third_char = 'C'        
    return third_char

def get_fourth_char_in_cfi_code_trade(trade):
    fourth_char = 'X'
    if trade.Instrument().InsType() == 'Option' and trade.Instrument().Underlying().InsType() == 'Curr':
        fourth_char = get_otc_option_style_type(trade.Instrument())
    elif trade.Instrument().InsType() == 'Future/Forward' and trade.Instrument().Underlying().InsType() == 'Curr':
        if not trade.Instrument().Otc():
            fourth_char = get_delivery_char(trade.Instrument())
    return fourth_char

def get_fifth_char_in_cfi_code_trade(trade):
    fifth_char = 'X'
    if trade.Instrument().InsType() == 'Option' and trade.Instrument().Underlying().InsType() == 'Curr':
        fifth_char = get_exotic_char(trade.Instrument())
    elif trade.Instrument().InsType() == 'Future/Forward' and trade.Instrument().Underlying().InsType() == 'Curr':
        if trade.Instrument().Otc():
            fifth_char = 'F'
        else:
            fifth_char = 'S'
    return fifth_char

def get_sixth_char_in_cfi_code_trade(trade):
    sixth_char = 'X'
    if trade.Instrument().InsType() == 'Curr':
        sixth_char = 'P'
        if trade.IsFxForward():
            sixth_char = 'C'
    elif trade.Instrument().InsType() == 'Option' and trade.Instrument().Underlying().InsType() == 'Curr':
        sixth_char = get_delivery_char(trade.Instrument())
    elif trade.Instrument().InsType() == 'Future/Forward' and trade.Instrument().Underlying().InsType() == 'Curr':
        if trade.Instrument().Otc():
            sixth_char = get_delivery_char(trade.Instrument())
    return sixth_char

def compute_cfi_code(acm_object):
    if acm_object.IsKindOf(acm.FInstrument):
        ins_type = get_instrument_type(acm_object)
        cfi_code = get_first_char_in_cfi_code(acm_object, ins_type) + 'XXXXX'
        cfi_code = cfi_code[0] + get_second_char_in_cfi_code(acm_object, ins_type) + 'XXXX'
        cfi_code = cfi_code[0:2] + get_third_char_in_cfi_code(acm_object, ins_type) + 'XXX'
        cfi_code = cfi_code[0:3] + get_fourth_char_in_cfi_code(acm_object, ins_type) + 'XX'
        cfi_code = cfi_code[0:4] + get_fifth_char_in_cfi_code(acm_object, ins_type) + 'X'
        cfi_code = cfi_code[0:5] + get_sixth_char_in_cfi_code(acm_object, ins_type)
    elif acm_object.IsKindOf(acm.FTrade):
        if (acm_object.Instrument().InsType() == 'Curr') or \
            (acm_object.Instrument().InsType() in ['Option', 'Future/Forward'] and acm_object.Instrument().Underlying().InsType() == 'Curr'):
            cfi_code = get_first_char_in_cfi_code_trade(acm_object) + 'XXXXX'
            cfi_code = cfi_code[0] + get_second_char_in_cfi_code_trade(acm_object) + 'XXXX'
            cfi_code = cfi_code[0:2] + get_third_char_in_cfi_code_trade(acm_object) + 'XXX'
            cfi_code = cfi_code[0:3] + get_fourth_char_in_cfi_code_trade(acm_object) + 'XX'
            cfi_code = cfi_code[0:4] + get_fifth_char_in_cfi_code_trade(acm_object) + 'X'
            cfi_code = cfi_code[0:5] + get_sixth_char_in_cfi_code_trade(acm_object)
        else:
            cfi_code = None
    return cfi_code


...

  FRegulatoryConfigParam
"""------------------------------------------------------------------------
MODULE
    FRegulatoryConfigParam -
DESCRIPTION:
    This file is used to read all the FParameters that are required by the component to function as expected
VERSION: 1.0.29(0.1.1278)
RESTRICTIONS/ LIMITATIONS:
    1. Any modifications to the scripts/ encrypted modules/ clear text code within the core is not supported. 
    2. This module is not customizable
    3. The component may not work as expected with any modifications done to this module at user end 
--------------------------------------------------------------------------"""
import acm
class Enumeration_Dict:

    def __init__(self, enumList):
        lookup = { }
        i = 1
        for x in enumList:
            lookup[x] = i
            i = i + 1
        self.lookup = lookup

    def getAttributeValue(self, attr):
        attr = attr.strip()
        return self.lookup[attr]
        
class FRegulatoryConfigParam(object):
    _instance = None    
    def __new__(cls, *args, **kwargs):
        if not cls._instance:
            cls._instance = super(FRegulatoryConfigParam, cls).__new__(cls)
            cls._instance.config_parameters = cls._instance.read_config_parameters()
        else:
            cls._instance.set_parameters(cls._instance.config_parameters)
        return cls._instance
    
    def set_paramvalue(self, key, value):
        """sets the value of the given config parameter"""
        self.config_parameters[key] = value        

    def get_paramvalue(self, key):
        """gets the value of the given config parameter"""
        retval = ''
        try:
            retval = self.config_parameters[key]
            if isinstance(retval, str):
                retval = retval.strip()
        except:
            pass
        return retval
    
    def read_config_parameters(self):
        """reads the config parameters from FParameters within extension manager """
        key_list = []
        val_list = []
        context = acm.GetDefaultContext()
        extension_lst = {}
        extension_lst['RegulatoryInfoApp'] = ['FRegulatoryLogConfig', 'FRegulatoryNotificationConfig', 'FRegulatoryDefaultConfig', 'FRegulatoryRepLogConfig', 'FRegulatoryAPIConfig']
        for extn in  extension_lst['RegulatoryInfoApp']:
            config_extension = context.GetExtension("FParameters", "FObject", extn)                 
            if config_extension:
                for key in config_extension.Value().Keys():
                    key_list.append(str(key))
                for vals in config_extension.Value().Values():
                    vals = str(vals).split('#')[0]
                    if 0 == vals.count('{'):
                        vals = vals.replace("'", "")
                    val_list.append(str(vals))                      
        params_dict = dict(list(zip(key_list, val_list)))
        self.set_parameters(params_dict)
        return params_dict
        
    def set_parameters(self, params_dict):
        """set the RegulatoryInfo component specific FParameteres to common parameters to be used in code"""
        enumNames = ["INFO", "DEBUG", "WARNING", "ERROR"]
        enum = Enumeration_Dict(enumNames)
        if 'FREGULATORY_MESSAGE_VERBOSE' in params_dict:
            FParameterVerbosityLevel = params_dict['FREGULATORY_MESSAGE_VERBOSE'].strip()
        else:
            FParameterVerbosityLevel = 'WARNING'
        params_dict['FREGULATORY_VERBOSITY_LEVEL'] = enum.getAttributeValue(FParameterVerbosityLevel)

...

  FRegulatoryISITCode
"""------------------------------------------------------------------------
MODULE
    FRegulatoryISITICCode -
DESCRIPTION:
    This file consists the approach to infer the ISITIC classification code for the given instrument
VERSION: 1.0.29(0.1.1278)
--------------------------------------------------------------------------"""
import FRegulatoryLogger
logger = 'FRegulatoryISITICCode'
ins_type_isitc_code = {        'Option'                 :   'OPT',
                               'Warrant'                :   'WAR',
                               'FRN'                    :   'FRN',
                               'CD'                     :   'CD',
                               'Deposit'                :   'TD',
                               'FRA'                    :   'FRA',
                               'Swap'                   :   'NULL',
                               'CurrSwap'               :   'NULL',
                               'Cap'                    :   'NULL',
                               'Floor'                  :   'NULL',
                               'Curr'                   :   'NULL',
                               'EquityIndex'            :   'NULL',
                               'RateIndex'              :   'NULL',
                               'SecurityLoan'           :   'NULL',
                               'BuySellback'            :   'NULL',
                               'PriceIndex'             :   'NULL',
                               'TotalReturnSwap'        :   'NULL',
                               'CreditDefaultSwap'      :   'NULL',
                               'Commodity'              :   'NULL',
                               'UnKnown'                :   'NULL',
                               'CLN'                    :   'NULL',
                               'BasketRepo/Reverse'     :   'NULL',
                               'CreditIndex'            :   'NULL',
                               'IndexLinkedSwap'        :   'NULL',
                               'BasketSecurityLoan'     :   'NULL',
                               'CFD'                    :   'NULL',
                               'VarianceSwap'           :   'NULL',
                               'Depositary Receipt'     :   'NULL',
                               'FXOptionDatedFwd'       :   'NULL',
                               'Portfolio Swap'         :   'NULL',
                               'ETF'                    :   'ETF',
                               'Stock'                  :   'FUNCTION', 
                               'Bond'                   :   'FUNCTION',
                               'Future/Forward'         :   'FUNCTION',
                               'Zero'                   :   'FUNCTION',
                               'Bill'                   :   'FUNCTION',
                               'Convertible'            :   'FUNCTION',
                               'Repo/Reverse'           :   'FUNCTION',
                               'IndexLinkedBond'        :   'FUNCTION',
                               'DualCurrBond'           :   'FUNCTION',
                               'Fund'                   :   'MF',
                               'Depositary Receipt'     :   'CS',
                               'Flexi Bond'             :   'FUNCTION',
                               'Average Future/Forward' :   'FUNCTION',
                               'Curr'                   :   'FUNCTION',
                               'MBS/ABS'                   :   'FUNCTION',
                               }
class ISITCodeType(object):
    def __init__(self, acm_object):
        self.__trade = None
        self.__instrument = None
        try:
            if acm_object and acm_object.IsKindOf('FTrade'):
                self.__trade = acm_object
                self.__instrument = acm_object.Instrument()
            elif acm_object and acm_object.IsKindOf('FInstrument'):
                self.__instrument = acm_object.Instrument()
            else:
                FRegulatoryLogger.WARN(logger, "Please provide the valid acm object either of FTrade or FInstrument type")
        except Exception as e:
            FRegulatoryLogger.ERROR(logger, "Please provide the valid acm object either of FTrade or FInstrument type")

    def get_isitic_classification(self):
        """get the isitic classification for a given instrument"""
        ins_type = None
        if self.__instrument:
            ins_type = self.__instrument.InsType()
        elif self.__trade:
            ins_type = self.__trade.Instrument().InsType()
        isitc_classification_code = None
        if ins_type in ins_type_isitc_code:
            isitc_classification_code = ins_type_isitc_code[ins_type]
        if isitc_classification_code == 'FUNCTION':
            function_call = ins_type.replace('/', '_')
            function_call = function_call.replace(' ', '_')
            isitc_classification_code = eval('self.' + function_call + '()')
        if isitc_classification_code and isitc_classification_code == 'NULL':
            isitc_classification_code = None
        return isitc_classification_code

    def __get_provider_data(self, field_name):
        """get the provider data if available for the given field name"""
        field_value = None
        try:
            field_value = self.__instrument.GetProviderDataFieldValue('Bloomberg', field_name)
        except:
            FRegulatoryLogger.DEBUG(logger, "DataLoader Bloomberg needs to be installed to get the %s."%field_name)
        return field_value

    def MUTUAL_FUND(self):
        """infer the isitc code for mutual fund based on the SECURITY_TYP field in Provider data"""
        isitic_code = None
        security_type = self.__get_provider_data('SECURITY_TYP')
        if security_type:
            if security_type == 'ETP':
                isitic_code = 'ETF'
        else:
            isitic_code = 'MF'
        return isitic_code

    def Stock(self):
        """infer the isitc code for Stock instrument type"""
        Stock_dict =  { 'PFD'       :       'PS', 
                        'EQUITY'    :       {'PREFERENCE'           : 'PS',
                                             'PREFERRED STOCK'      : 'PS', 
                                             'RIGHT'                : 'RTS',
                                             'COMMON STOCK'         : 'CS', 
                                             'MUTUAL FUND'          : 'FUNCTION',
                                             'WARRANT'              : 'WAR'}
              }
        isitic_code = 'CS'
        market_sec = self.__get_provider_data('MARKET_SECTOR_DES')
        if market_sec:
            if market_sec.upper() in Stock_dict:
                sec_type2 = Stock_dict[market_sec.upper()]
                if isinstance(sec_type2, dict):
                    sec_type = self.__get_provider_data('SECURITY_TYP2')
                    if sec_type and sec_type.upper() in sec_type2:
                        isitic_code = sec_type2[sec_type.upper()]
                        if isitic_code == 'FUNCTION':
                            function_name = sec_type.replace(' ', '_')
                            isitic_code = eval('self.' + function_name.upper() + '()')
                else:
                    isitic_code =  sec_type2
        return isitic_code

    def Future_Forward(self):
        """infer the isitc code for Futute/Forward instrument type"""
        isitic_code = None
        if self.__instrument:
            if self.__instrument.PayType() == 'Future':
                isitic_code = 'FUT'
            elif self.__instrument.PayType() == 'Forward':
                if self.__instrument.Underlying().InsType() == 'Bond':
                    isitic_code = 'BFW'
        elif self.__trade:
            if self.__trade.Instrument().Underlying().InsType() == 'Curr':
                isitic_code = 'FXF'
        return isitic_code

    def Bond(self):
        """infer the isitc code for Bond instrument type"""
        isitic_code = None
        floater = self.__get_provider_data('FLOATER')
        if floater and floater != 'Y':
            isitic_code = self.__isitic_from_market_sector()
        if not isitic_code:
            security_type2 = self.__get_provider_data('SECURITY_TYP2')
            security_type = self.__get_provider_data('SECURITY_TYP')
            if security_type2 and security_type2.upper() == 'NOTE' and security_type and security_type.upper() == 'US GOVERNMENT':
                isitic_code = 'TN'
        if not isitic_code:
            isitic_code = self.__get_isitic_from_issuer_bis()
        return isitic_code

    def __get_isitic_from_mkt_sector_issuer_bis(self):
        """infer the isitc code on the basis of market sector or issuer on the instrument"""
        isitic_code = self.__isitic_from_market_sector()
        if not isitic_code:
            isitic_code = self.__get_isitic_from_issuer_bis()
        return isitic_code

    def __get_isitic_from_issuer_bis(self):
        """infer the isitc code on the basis of the issuer on the instrument"""
        isitic_code = None
        if self.__instrument.Issuer():
            if self.__instrument.Issuer().BisStatus() in ['OECD Government',  'Non-OECD Government']:
                isitic_code = 'GOVT'
            else:
                isitic_code = 'CORP'
        return isitic_code

    def Zero(self):
        """infer the isitc code for Zero instrument type"""
        isitic_code = None
        zero_coupon = self.__get_provider_data('ZERO_CPN')
        if zero_coupon and zero_coupon == 'Y':
            isitic_code = self.__isitic_from_market_sector()
        if not isitic_code:
            isitic_code = self.__get_isitic_from_issuer_bis()
        return isitic_code

    def Bill(self):
        """infer the isitc code for Bill instrument type"""
        isitic_code = None
        security_type = self.__get_provider_data('SECURITY_TYP')
        security_type2 = self.__get_provider_data('SECURITY_TYP2')
        if security_type and security_type.upper() == 'US GOVERNMENT' and security_type2 and security_type2.upper() == 'BILL':
            isitic_code = 'USTB'
        if (not isitic_code) and self.__instrument.Currency().Name() == 'USD' and \
            self.__instrument.Issuer() and \
            self.__instrument.Issuer().BisStatus() in ['OECD Government',  'Non-OECD Government']:
            isitic_code = 'USTB'
        return isitic_code

    def Convertible(self):
        """infer the isitc code for Convertible instrument type"""
        isitic_code = None
        convertible = self.__get_provider_data('CONVERTIBLE')
        if convertible and convertible == 'Y':
            isitic_code = self.__isitic_from_market_sector()
        if not isitic_code:
            isitic_code = self.__get_isitic_from_issuer_bis()
        return isitic_code

    def __isitic_from_market_sector(self):
        """infer the isitc code on the basis of the market sector des available in provider data"""
        isitic_code = None
        market_sec = self.__get_provider_data('MARKET_SECTOR_DES')
        isitic_lookup = {'CORP' : 'CORP', 'MUNI' : 'MUNI', 'GOVT' : 'GOVT'}
        if market_sec and market_sec.upper() in isitic_lookup:
            isitic_code = isitic_lookup[market_sec.upper()]
        return isitic_code

    def IndexLinkedBond(self):
        """infer the isitc code for IndexLinkedBond instrument type"""
        isitic_code = None
        inflation_lined_indicator = self.__get_provider_data('INFLATION_LINKED_INDICATOR')
        if inflation_lined_indicator and inflation_lined_indicator == 'Y':
            isitic_code = self.__isitic_from_market_sector()
        if not isitic_code:
            isitic_code = self.__get_isitic_from_issuer_bis()
        return isitic_code

    def DualCurrBond(self):
        """infer the isitc code for DualCurrBond instrument type"""
        return self.__get_isitic_from_mkt_sector_issuer_bis()

    def MBS_ABS(self):
        """infer the isitc code for MBS/ABS instrument type"""
        isitic_code = None
        security_type2 = self.__get_provider_data('SECURITY_TYP2')
        secutiry_type2_dict = { 'RMBS CDO'              :      'CDO',
                                'MEZZ DEBT CDO'         :      'CDO',
                                'IG DEBT CDO'           :      'CDO',
                                'HY DEBT CDO'           :      'CDO',
                                'EM DEBT CDO'           :      'CDO',
                                'CDS-CRP CDO'           :      'CDO',
                                'CDS-ABS CDO'           :      'CDO',
                                'CDS CDO'               :      'CDO',
                                'CDO SQUARE'            :      'CDO',
                                'MEZZ ABS CDO'          :      'CDO',
                                'HIGH GRADE ABS CDO'    :      'CDO',
                                'ABS CDO'               :      'CDO',
                                'CLO'                   :      'CLO',
                                'SME MEZZANINE CLO'     :      'CLO',
                                'SME CLO'               :      'CLO',
                                'MIDDLE MARKET CLO'     :      'CLO',
                                'LEVERAGED LOAN CLO'    :      'CLO',
                                'CMO'                   :      'CMO',
                                'WHOLE LOAN'            :      'CMO'}
        if security_type2 and security_type2.upper() in secutiry_type2_dict:
            isitic_code = secutiry_type2_dict[security_type2.upper()]
        if not isitic_code:
            issuer = self.__get_provider_data('ISSUER')
            issuer_dict =  {'GOVERNMENT NATIONAL MORTGAGE A'            : 'GN',
                            'GOVERNMENT NATIONAL MORTGAGE ASSOCIATION'  : 'GN',
                            'FEDERAL HOME LOAN BANKS'                   : 'FHL',
                            'FANNIE MAE'                                : 'FN'}
            if issuer and issuer.upper() in issuer_dict:
                isitic_code = issuer_dict[issuer.upper()]
        if not isitic_code:
            isitic_code = 'FHA'
        return isitic_code

    def Repo_Reverse(self):
        """infer the isitc code for Repo/Reverse instrument type"""
        isitic_code = None
        if self.__trade:
            if self.__trade.Nominal() > 0:
                isitic_code = 'RVRP'
            else:
                isitic_code = 'RP'
        return isitic_code

    def Flexi_Bond(self):
        """infer the isitc code for FlexiBond instrument type"""
        isitic_code = self.__isitic_from_market_sector()
        if not isitic_code:
            isitic_code = self.__get_isitic_from_issuer_bis()
        return isitic_code

    def Average_Future_Forward(self):
        """infer the isitc code for Average Future/Forward instrument type"""
        isitic_code = None
        if self.__instrument:
            if self.__instrument.PayType() == 'Future':
                isitic_code = 'FUT'
            elif self.__instrument.PayType() == 'Forward':
                if self.__instrument.Legs()[0].FloatRateReference().InsType()== 'Bond':
                    isitic_code = 'BFW'
        return isitic_code

    def Curr(self):
        """infer the isitc code for all FX trades and Curr instrument type"""
        isitic_code = None
        if self.__trade:
            if self.__trade.IsFxForward():
                isitic_code = 'FXF'
            elif self.__trade.IsFxSpot():
                isitic_code = 'FXS'
            #elif self.__trade.IsFxSwap():
        return isitic_code


...

  FRegulatoryLibUtils
"""------------------------------------------------------------------------
MODULE
    FRegulatoryLibUtils -
DESCRIPTION:
    This file consists of the actual implementation of the API open to customizations to users in the FRegulatoryLib
VERSION: 1.0.29(0.1.1278)
--------------------------------------------------------------------------"""
import acm
import ael
import FRegulatoryLogger
import FRegulatoryLookup
import FRegulatoryCfiCodeGeneration
import operator
import re,sys
import FRegulatoryConfigParam
config_param = FRegulatoryConfigParam.FRegulatoryConfigParam()
logger = "FRegulatoryLibUtils"

party_lookup = {'Counterparty' : 'FCounterParty',
'Client' : 'FClient',
'Intern Dept' : 'FInternalDepartment',
'Broker' : 'FBroker',
'Market' : 'FMarketPlace', 
'MtM Market' : 'FMTMMarket', 
'Issuer' : 'FIssuer',
'Depot' : 'FDepot',
'Clearing House' : 'FClearingHouse',
'Middleware' : 'FMiddleware',
'Repository' : 'FRepository',
'Venue' : 'FVenue'}

day_count_convention_lookup = {
'1/1'    :   '1/1',
'30/360'    :   '30/360', 
'30/360GERMAN'    :   '30/360GERMAN', 
'30/360SIA'    :   '30/360SIA', 
'30/365'    :   '30/365', 
'30E/360'    :   '30E/360', 
'30E/365'    :   '30E/365', 
'30U/360'    :   '30U/360', 
'Act/360'    :   'A004',
'Act/364'    :   'Act/364', 
'Act/365'    :   'Act/365', 
'Act/365L'    :   'Act/365L', 
'Act/ActAFB'    :   'A010',
'Act/ActISDA'    :   'A008',
'Act/ActISMA (Act/ActICMA)'    :   'A006',
'Bus/252'    :   'Bus/252', 
'NL/360'    :   'NL/360', 
'NL/365'    :   'NL/365', 
'NL/ActISDA'    :   'NL/ActISDA', 
}

def get_party_handle(party_val):
    """get the actual party object from the given input - either string or party obj"""
    party_handle = None
    try:
        if isinstance(party_val, str):
            party_handle = acm.FParty[party_val]
        elif party_val.IsKindOf(acm.FParty):
            party_handle = party_val
    except Exception as e:
        # this exception is hit when the IsKindOf is called on a None party object that is being sent
        pass
    return party_handle

def day_count_method(day_count_method_val):
    """returns the corresponding DayCountMethod for that in PRIME"""
    daycount_method = None
    if day_count_method_val in day_count_convention_lookup.keys():
        day_count_convention_lookup[day_count_method_val]
    else:
        FRegulatoryLogger.ERROR(logger, "DayCountMethod <%s> is not supported in SFTR Codes"%day_count_method_val)
    return daycount_method

def get_provider_data_exists_on_party():
    """returns True if the DataLoader's GetProviderDataFieldValue
     API is available in the ADS on the party, else False"""
    get_provider_data_api_exists = False
    try:
        if acm.FParty.GetMethod('GetProviderDataFieldValue', 1):
            get_provider_data_api_exists = True
    except:
        pass
    return get_provider_data_api_exists

def get_provider_data_exists():
    """returns True if the DataLoader's GetProviderDataFieldValue
     API is available in the ADS on the instrument, else False"""
    get_provider_data_api_exists = False
    try:
        if acm.FInstrument.GetMethod('GetProviderDataFieldValue', 1):
            get_provider_data_api_exists = True
    except:
        pass
    return get_provider_data_api_exists

def get_country(party):
    """gets the list of countries on a given party
     - Country of Risk and Country set on it"""
    countries = []
    if party:
        if party.RiskCountry():
            countries.append(party.RiskCountry().Name())
        if party.Country():
            countries.append(party.Country())
        if not countries:
            FRegulatoryLogger.WARN(logger,\
                "CountryOfRisk/Country is not set on %s"%(party.Name()))
    return countries

def is_currency_code_valid_for_iso_4217(currency_code, currency_code_lookup=None):
    """returns True is the given currency code is a valid ISO4217 currency code else False"""
    is_valid_currency_code = False
    currency_codes = FRegulatoryLookup.currency_codes
    if currency_code_lookup:
        currency_codes = currency_code_lookup
    if currency_code:
        if currency_code in currency_codes:
            is_valid_currency_code = True
    return is_valid_currency_code

def is_country_code_valid_for_iso_3166(country_code, country_code_lookup_dict=None):
    """returns True is the given country code is a valid ISO3166 country code else False"""
    is_valid_country_code = False
    country_code_dict = FRegulatoryLookup.country_code_dict
    if country_code_lookup_dict:
        country_code_dict = country_code_lookup_dict
    if country_code:
        if country_code in country_code_dict.values():
            is_valid_country_code = True
    return is_valid_country_code

def get_countrycode(country):
    """gets the country code for the given country"""
    country_code = None
    country_vals = []
    for each_country in FRegulatoryLookup.country_code_dict.keys():
        country_vals.append(each_country)
    for country_val in country_vals:
        FRegulatoryLookup.country_code_dict[country_val.upper()] = FRegulatoryLookup.country_code_dict[country_val]
    if country.upper() in FRegulatoryLookup.country_code_dict.keys():
        country_code = FRegulatoryLookup.country_code_dict[country.upper()]
    return country_code

def __get_modified_jurisdiction_lookup(jurisdiction_lookup=None):
    if not jurisdiction_lookup:
        jurisdiction_lookup = FRegulatoryLookup.jurisdiction_codes
    else:#complement your dict with the incoming dict values
        for each_key in jurisdiction_lookup:
            if each_key in FRegulatoryLookup.jurisdiction_codes:
                country_codes = FRegulatoryLookup.jurisdiction_codes[each_key]
                override_country_codes = jurisdiction_lookup[each_key]
                for each_country_code in override_country_codes:
                    if each_country_code.find('-') == 0:#it means it needs to be removed from the list
                        country_code_val = each_country_code.replace('-', '')
                        if country_code_val in country_codes:
                            country_codes.remove(country_code_val)
                    else:
                        country_codes.append(each_country_code)
                FRegulatoryLookup.jurisdiction_codes[each_key] = country_codes
                jurisdiction_lookup = FRegulatoryLookup.jurisdiction_codes
    return jurisdiction_lookup

def get_jurisdiction(country_code, jurisdiction_lookup=None):
    """returns the jurisdiction for the given country code"""
    jurisdiction_val = None
    jurisdiction_lookup = __get_modified_jurisdiction_lookup(jurisdiction_lookup)
    for jurisdiction in jurisdiction_lookup:
        country_codes = jurisdiction_lookup[jurisdiction]
        if jurisdiction == 'EEA':
            country_codes.extend(jurisdiction_lookup['EU'])
        if country_code in country_codes:
            jurisdiction_val = jurisdiction
    return jurisdiction_val

def is_jurisdiction(jurisdiction, country_code, jurisdiction_lookup=None):
    """returns True if the given country code is applicable for
     the given jurisdiction, else False. If it cannot be inferred
     returns False """
    is_jurisdiction_val = None
    jurisdiction_lookup = __get_modified_jurisdiction_lookup(jurisdiction_lookup)
    if jurisdiction in jurisdiction_lookup.keys():
        country_codes = jurisdiction_lookup[jurisdiction]
        if jurisdiction == 'EEA':
            country_codes.extend(jurisdiction_lookup['EU'])
        if country_code in country_codes:
            is_jurisdiction_val = True
        else:
            is_jurisdiction_val = False
    else:
        FRegulatoryLogger.WARN(logger,\
            "Jurisdiction <%s> is currently not supported in the library."%jurisdiction)
    return is_jurisdiction_val

def is_party_in_regulatory_authority(party, regulatory_authority, regulatory_authority_lookup=None, jurisdiction_lookup=None):
    """returns True if the given party is applicable for the
     given Regulatory Authority, else False. Returns None
      if it cannot be inferred"""
    is_regulatory_authority = None
    country_code = None
    countries = get_country(party)
    for country in countries:
        country_code = get_countrycode(country)
        if country_code:
            if not regulatory_authority_lookup:
                regulatory_authority_lookup = FRegulatoryLookup.regulatory_authority
            jurisdiction_val = get_jurisdiction(country_code, jurisdiction_lookup)
            if jurisdiction_val:
                if jurisdiction_val in regulatory_authority_lookup.keys():
                    if regulatory_authority_lookup[jurisdiction_val] == regulatory_authority:
                        is_regulatory_authority = True
                    else:
                        is_regulatory_authority = False
                else:
                    if country_code in regulatory_authority_lookup.keys():
                        if regulatory_authority_lookup[country_code] == regulatory_authority:
                            is_regulatory_authority = True
                        else:
                            is_regulatory_authority = False
                    else:
                        FRegulatoryLogger.WARN(logger,\
                        "The regulatory authority cannot be inferred for Country <%s>/jurisdiction <%s> "%(country, jurisdiction_val))
            else:
                if country_code in regulatory_authority_lookup.keys():
                    if regulatory_authority_lookup[country_code] == regulatory_authority:
                        is_regulatory_authority = True
                    else:
                        is_regulatory_authority = False
                else:
                    FRegulatoryLogger.WARN(logger,\
                    "The regulatory authority cannot be inferred for country <%s>"%country)
        else:
            FRegulatoryLogger.WARN(logger,\
            "Unable to infer the country code for country <%s> set on party <%s>"\
            %(country, party.Name()))
    if not country:
        FRegulatoryLogger.WARN(logger,\
            "IsJurisdiction cannot be inferred for Party <%s> as it does not have the CountryOfRisk/Country set on it"%(party.Name()))
    return is_regulatory_authority

def is_party_in_jurisdiction(party, jurisdiction, jurisdiction_lookup=None):
    """returns True if the given party is applicable for the
     given jurisdiction, else False. Returns None
      if it cannot be inferred"""
    is_jurisdiction_val = None
    countries = get_country(party)
    if countries:
        for country in countries:
            country_code = get_countrycode(country)
            if country_code:
                is_jurisdiction_val = is_jurisdiction(jurisdiction, country_code, jurisdiction_lookup)
                if is_jurisdiction_val != None:
                    break
            else:
                FRegulatoryLogger.WARN(logger,\
                "Unable to infer the country code for Country <%s> set on Party <%s>"\
                %(country, party.Name()))
    else:
        FRegulatoryLogger.WARN(logger,\
            "IsJurisdiction cannot be inferred for Party <%s> as it does not have the CountryOfRisk/Country set on it"%(party.Name()))
    return is_jurisdiction_val
      
def get_jurisdiction(country_code, jurisdiction_lookup=None):
    """returns the juridiction for the given country code"""
    jurisdiction_val = None
    jurisdiction_lookup = __get_modified_jurisdiction_lookup(jurisdiction_lookup)
    for jurisdiction in jurisdiction_lookup.keys():
        country_codes = jurisdiction_lookup[jurisdiction]
        if country_code in country_codes:
            jurisdiction_val = jurisdiction
            break
    return jurisdiction_val

class BondTypeEnum():
    enumeration =   (
                     'ABS',    # 0. 
                     'MBS',    # 1.
                     'CDO',    # 2.
                     'CBO',    # 3.
                     'CLO',    # 4.
                     'CMO',    # 5.
                     'TIPS',    # 6.
                     'Covered Bond',    # 7.
                     'Jumbo Pfandbrief',    # 8.
                     'Pfandbrief',    # 9.
                     'Bill',    # 10.
                     'Bullet',    # 11.
                     'TBill',    # 12.
                     'TBond',    # 13.
                     'TNote',    # 14.
                     'Commercial Paper',    # 15.
                     'Pool',    # 16.
                     'Whole Loan',    # 17.
                     'Non Bullet',    # 18.
                     'Other Bond',    # 19.
                     'LoC',    # 20.
                     'CAT',    # 21.
                     'Interest Only (PO) Strips',    # 22.
                     'Principal Only (IO) Strips',    # 23.
                     'ABS Senior',    # 24.
                     'ABS Mezzanine',    # 25.
                     'ABS First Loss'    # 26.
                    )
    def name(self, val):
        try:

            name = self.enumeration[val]
        except IndexError:
            name = self.enumeration[len(self.enumeration) - 1]
        return name

    def number(self, val):
        try:
            index = self.enumeration.index(val)
        except (TypeError, ValueError):
            index = (len(self.enumeration) - 1)
        return index

def get_tristate_choiceList(cl_val):
    """get the Tristate choicelist object for the value being passed"""
    if isinstance(cl_val, str):
        if cl_val == '':
            cl_val = 'None'
        cl_val = cl_val.title()
    elif isinstance(cl_val, bool):
        cl_val = str(cl_val)
    try:
        if cl_val.IsKindOf(acm.FChoiceList):
            cl_obj = cl_val
    except:
        cl_obj = acm.FChoiceList.Select01("list = 'Tristate' and name = '%s'"%str(cl_val), None)
    if not cl_obj:
        FRegulatoryLogger.ERROR(logger, "ChoiseList of name Tristate with values True, False and None should to be present in ADS for expected behaviour")
    return cl_obj

def get_isin_from_alias(instrument):
    """check if there is an alias of the name ISIN in DB and return the value if present on the instrument"""
    isin = None
    try:
        isin = instrument.Alias('Isin')
    except:
        pass
    return isin

def get_isin_from_addinfo(instrument):
    """check if there is an AddInfo on the name ISIN on the instrument. If present, then return this value"""
    isin = None
    try:
        isin = instrument.AdditionalInfo().Isin()
    except:
        pass
    return isin

def get_isin_from_similar_isin(instrument):
    """check if there is an AddInfo on the name ISIN on the instrument. If present, then return this value"""
    isin = None
    try:
        isin = instrument.RegulatoryInfo().SimilarIsin()
    except:
        pass
    return isin

def get_ins_category(instrument):
    ins_type_category = {
                    'CREDIT'    : ('CreditDefaultSwap', 'CLN', 'Bill', 'Bond', 'Credit Balance', 'CreditIndex', \
                                    'DualCurrBond', 'Flexi Bond', 'FRN', 'MBS/ABS', 'PromisLoan', 'Zero',),
                    'IR'        : ('Portfolio Swap', 'BasketSecurityLoan', 'Repo/Reverse', 'BasketRepo/Reverse', \
                                    'Swap', 'RateIndex', 'PriceIndex', 'IndexLinkedBond', \
                                    'IndexLinkedSwap', 'Floor', 'FRA', 'CurrSwap', 'FreeDefCF', 'Collateral', \
                                    'Cap', 'BuySellback',),
                    'COMMODITY' : ('Average Future/Forward', 'Commodity Index', 'Commodity Variant', 'Commodity', \
                                    'PriceSwap', 'Rolling Schedule',),
                    'EQUITY'    : ('Certificate', 'Depositary Receipt', 'Dividend Point Index', 'EquityIndex', \
                                    'ETF', 'SecurityLoan', 'Stock', 'VarianceSwap', 'VolatilitySwap', 'Warrant', 'Fund',),
                    'FX'        : ('Curr','FXOptionDatedFwd','FxSwap','CD','Fx Rate',),
                    }
    ins_category = None
    ins_type = instrument.InsType()
    ins_categroy_rev_dict = dict(list(zip(list(ins_type_category.values()), list(ins_type_category.keys()))))
    for each_val in ins_categroy_rev_dict:
        if ins_type in each_val:
            ins_category = ins_categroy_rev_dict[each_val]
            break
    ins_with_underlyers = ['Combination', 'Convertible', 'Future/Forward', 'Option', 'CFD', 'TotalReturnSwap',]
    if not ins_category and instrument.InsType() == 'Deposit':
        if instrument.Legs()[0].LegType() not in ['Call Fixed', 'Call Float', 'Call Fixed Adjustable']:
            ins_category = 'IR'
        else:
            ins_category = 'FX'
    if (not ins_category) and instrument.InsType() in ins_with_underlyers:
        ins = instrument.Underlying()
        if not ins:
            if instrument.InsType() == 'Combination':
                ins = instrument.InstrumentMaps()[0].Instrument()
            elif instrument.InsType() == 'TotalReturnSwap':
                for leg in instrument.Legs():
                    if leg.LegType() == 'Total Return':
                        ins = leg.IndexRef()
        if ins:
            ins_category = get_ins_category(ins)
    return ins_category

def reverse_dict(dictionary):
    reverse_dict = {}
    for key, value in dictionary.items():
        if not isinstance(value, (list, tuple)):
            value = [value]
        for val in value:
            reverse_dict[val] = reverse_dict.get(val, [])
            reverse_dict[val].append(key)
    for key, value in reverse_dict.items():
        if len(value) == 1:
            reverse_dict[key] = value[0]
    return reverse_dict

def generate_complex_trade_comp_id(trade):
    """generate the complexTradeComponentId, prefixed with DP for a DealPackage, TP for a TradePackage 
    and CR for trade.connected_reference. If none of these connected, return None"""
    complex_trade_comp_id = None
    if trade.DealPackageTradeLinks():
        deal_package = trade.DealPackageTradeLinks()[0].DealPackage()
        complex_trade_comp_id = "DP" + deal_package
    elif trade.TradePackage():
        complex_trade_comp_id = "TP" + str(trade.TradePackage().Oid())
    elif trade.ConnectedTrade().Oid() != trade.Oid():
        complex_trade_comp_id = "CR" + str(trade.ConnectedTrade().Oid())
    return complex_trade_comp_id

def get_instrument_sub_type(trade):
    """specific classification of instrument type"""
    ins_type = None
    if trade:
        if trade.Instrument().InsType() == 'Swap':
            leg_type = {}
            for leg in trade.Instrument().Legs():
                val = 0
                if leg.LegType() in leg_type:
                    val = leg_type[leg.LegType()]
                leg_type[leg.LegType()] = val + 1
            if 'Float' in leg_type:
                leg_count = leg_type['Float']
                if leg_count == 2:
                    ins_type = 'Basis Swap'
                elif leg_count == 1 and  'Fixed' in leg_type and leg_type['Fixed'] == 1 :
                    ins_type = 'Fixed Float Swap'
                elif leg_count == 1 and  'Fixed Accretive' in leg_type and leg_type['Fixed Accretive'] == 1 :
                    ins_type = 'Fixed Float Swap'
                else:
                    FRegulatoryLogger.WARN(logger, "We are currently supporting only Fixed/Fixed Accretive Float IRS, Basis Swap and Stock")
        elif trade.Instrument().InsType() == 'Future/Forward':
            ins_type = 'Future/Forward'
            if trade.Instrument().Underlying().Cid()=='Curr':
                ins_type='Future/Forward-Curr'
        else:
            ins_type=trade.Instrument().InsType()
    else:
        FRegulatoryLogger.ERROR(logger, "Please provide a valid Trade to infer its Instrument Sub Type")
    return ins_type

def is_settle_ccy_major(trade):
    settle_in_major_ccy = False
    currency1 = trade.Currency().Name()
    currency2 = trade.Instrument().Underlying().Name()
    ccy_pair = acm.FCurrencyPair.Select01("currency1 = '%s' and currency2 = '%s'"%(currency1, currency2), None)
    if not ccy_pair:
        ccy_pair = acm.FCurrencyPair.Select01("currency1 = '%s' and currency2 = '%s'"%(currency2, currency1), None)
    if ccy_pair:
        major_ccy = ccy_pair.Name().split('/')[0] 
        #minor_ccy = ccy_pair.Name().split('/')[1]
        if currency1 == major_ccy:
            settle_in_major_ccy = True
    return settle_in_major_ccy

def us_buyer(trade):
    weBuyer = False
    ins_type = get_instrument_sub_type(trade)
    if ins_type == 'Basis Swap':
        counter = 0
        for leg in trade.Instrument().Legs():
            if (trade.Nominal() > 0 and leg.PayLeg()) or (trade.Nominal() < 0 and (not leg.PayLeg())):
                leg_nbr = operator.xor(1, counter)
                spread = leg.Spread()
                spread1 = trade.Instrument().Legs()[leg_nbr].Spread()
                if (spread1 == 0.0 and spread != 0.0) or (spread - spread1 > 0):
                    weBuyer = True
            counter += 1
    elif ins_type == 'Fixed Float Swap':
        if (trade.Instrument().FirstFixedLeg().PayLeg() and trade.Nominal() > 0) or (not trade.Instrument().FirstFixedLeg().PayLeg() and trade.Nominal() < 0) :
            weBuyer = True
    elif ins_type in ['TotalReturnSwap']:
        for leg in trade.Instrument().Legs():
            if (not leg.PayLeg() and trade.Nominal() > 0) or (leg.PayLeg() and trade.Nominal() < 0):
                if (leg.LegType() == 'Total Return' and ins_type == 'TotalReturnSwap'):                    
                    weBuyer = True

    elif ins_type in ['CreditDefaultSwap']:
        for leg in trade.Instrument().Legs():
            if (not leg.PayLeg() and trade.Nominal() < 0) or (leg.PayLeg() and trade.Nominal() > 0):
                if (leg.LegType() == 'Fixed'):
                    weBuyer = True
    elif ins_type == 'Future/Forward-Curr':
        if trade.BaseCostDirty() > 0 or trade.Nominal() > 0:
            if trade.BaseCostDirty() > 0:
                weBuyer = True
                if trade.Nominal() < 0 and abs(trade.Nominal()) == abs(trade.BaseCostDirty()):
                    weBuyer = False
            elif not is_settle_ccy_major(trade):
                weBuyer = True
        else:#if the nominal/basecost dirty is negative and the trade currency is the major currency, it means we are buyer
            currency1 = trade.Currency().Name()
            currency2 = trade.Instrument().Underlying().Name()
            ccy_pair = acm.FCurrencyPair.Select01("currency1 = '%s' and currency2 = '%s'"%(currency1, currency2), None)
            if not ccy_pair:
                ccy_pair = acm.FCurrencyPair.Select01("currency1 = '%s' and currency2 = '%s'"%(currency2, currency1), None)
            if ccy_pair:
                if is_settle_ccy_major(trade):
                    weBuyer = True
    elif ins_type == 'CurrSwap':
        leg=trade.Instrument().Legs()[0]
        pay_leg = None
        receive_leg = None
        if leg.PayLeg():
            pay_leg = leg
            receive_leg = trade.Instrument().Legs()[1]
        else:
            pay_leg=trade.Instrument().Legs()[1]
            receive_leg=leg
        if receive_leg.Currency().Name() < pay_leg.Currency().Name():
            if trade.Nominal() > 0:
                weBuyer = True
        else:
            if trade.Nominal() < 0:
                weBuyer = True
    elif ins_type == 'Curr':
        if trade.BaseCostDirty() > 0 or trade.Nominal() > 0:
            weBuyer = True
    elif ins_type == 'FXOptionDatedFwd':
        if trade.Quantity() < 0:
            weBuyer = True
    elif ins_type in ['BasketRepo/Reverse', 'BasketSecurityLoan', 'Portfolio Swap']:        
        if trade.Quantity() > 0:
            weBuyer = True  
    elif ins_type == 'Deposit':
        if trade.Nominal() < 0:
            weBuyer = True  
    else:
        if trade.Nominal() > 0:
            weBuyer = True
    return weBuyer

def get_uti_from_trade_attribute(trade):
    uti = None
    try:
        uti = trade.UniqueTradeIdentifier()
    except:#it means that this attribute is not present on trade because it is being run on a lower version of acm
        pass
    if not uti:
        FRegulatoryLogger.INFO(logger, "UniqueTradeIdentifier is not present on trade <%d>"%trade.Oid())
    return uti

def get_uti_from_trade_alais(trade):
    uti = None
    try:
        aliasType = 'UTI'
        aliases = acm.FTradeAlias.Select("type = '%s' and trade = %d"%(aliasType, trade.Oid()))
        if aliases:
            uti = aliases[0].Alias()
        if not uti:
            FRegulatoryLogger.INFO(logger, "UTI TradeAlias is not present on trade <%d>"%trade.Oid())
    except Exception as e:
        FRegulatoryLogger.ERROR(logger, "Error in get_uti_from_trade_alais. Error: <%s>"%str(e))
    return uti

def get_uti_from_trade_addinfo(trade):
    uti = None
    try:
        uti = trade.AdditionalInfo().UTI_1part() + trade.AdditionalInfo().UTI_2part()
        return uti
    except:#it means these AddInfos are not present on the trade
        pass

def get_check_sum(str_val):
    checkSum = None
    numeric_val = getNumericConversion(str_val)
    numeric_val = numeric_val + '00'
    checkSum = str(98 - int(numeric_val) % 97)
    return checkSum

def is_valid_check_sum(str_val):
    b_correct_check_sum = False
    if str_val[-2:] == get_check_sum(str_val[:-2]):
        b_correct_check_sum = True
    if not b_correct_check_sum and str_val[-1:] == get_check_sum(str_val[:-1]):
        b_correct_check_sum = True
    return b_correct_check_sum

def getNumericConversion(lei_val):
    numeric_lei = ''
    if not lei_val.isdigit():
        for each_char in lei_val:
            if each_char.isalpha():
                numeric_lei += str(ord(each_char.upper()) - 55)
            elif each_char.isdigit():
                numeric_lei += each_char
    else:
        numeric_lei = lei_val
    return numeric_lei

def isValidLEI(lei_val, expected_len = 20):
    'Verify that lei follows ISO7064 and last two digits are check digits'
    bValidLei = False
    msg = None
    if len(lei_val) == expected_len:
        check_sum_val = lei_val[-2:]
        if check_sum_val.isdigit():
            numeric_lei = getNumericConversion(lei_val)
            if int(numeric_lei) % 97 == 1:
                bValidLei = True
            else:
                msg = "the checkSum is incorrect."
        else:
            msg = "the last 2 characters are not numeric."
    else:
        msg = "it is of length <%d> characters. The expected length is <%d> characters."%(len(lei_val), expected_len)
    if not bValidLei:
        log_msg = 'The given LEI <%s> is invalid as '%lei_val 
        log_msg = log_msg + msg
        FRegulatoryLogger.INFO(logger, log_msg)
    return bValidLei

def generateLEIWithCheckSum(lei_val, expected_len = 18):
    """generate the checkSum for the given lei"""
    checkSum = None
    if len(lei_val) == expected_len:
        numeric_lei = ''
        if lei_val.isalnum():
            checkSum = get_check_sum(lei_val)
        else:
            raise Exception("The provided lei <%s> is not a valid alphanumeric value."%lei_val)
    else:
        raise Exception("Wrong length with <%d> characters for lei <%s>. Expected length to generate checkSum is <%d> characters."%(len(lei_val), lei_val, expected_len))
    return lei_val + checkSum, checkSum

def isValidIsin(isin_val):
    """verify that ISIN structure is valid, and checksum correct"""
    bValidISIN = False
    if isin_val:
        isin_val = isin_val.strip().upper()
        charmap = dict([(i, ord(i)-55) for i in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'] + [(i, int(i)) for i in '0123456789'])
        if re.match('^([A-Z][A-Z])([A-Z0-9]{9}\d)$', isin_val):
            try:
                sum_digits_str = ''.join([str(charmap[each_char]) for each_char in isin_val[:11]])
                total_sum = 0
                parity = len(sum_digits_str) % 2
                for n, c in enumerate(sum_digits_str):
                    a = int(c)
                    if n % 2 != parity:
                        a = a * 2
                    total_sum += int(a / 10)
                    total_sum += int(a % 10)
                check_digit = (10 - (total_sum % 10)) % 10
                if isin_val[11] == str(check_digit):
                    bValidISIN = True
            except KeyError:
                pass
    return bValidISIN

def getPartyFromLEI(lei_val):
    party_obj = None
    if lei_val:
        party_obj = acm.FParty.Select01("legalEntityId = '%s'"%lei_val, None)
    return party_obj
        
def getPartyFromMIC(mic_val):
    party_obj = None
    alias_obj = None    
    alias_typ_spec = acm.FPartyAliasType['MIC']
    if not alias_typ_spec:
        raise Exception('<MIC> is not a valid PartyAliasType')
    else:
        alias_obj = acm.FPartyAlias.Select01("type=%d and name = '%s'"%(alias_typ_spec.Oid(), mic_val), None)
    if alias_obj:
        party_obj = alias_obj.Party()
    return party_obj

def check_sum(utiVal):
    """generate check sum for a UTI"""
    if utiVal:
        utiVal = utiVal + get_check_sum(utiVal)
    return utiVal

def upi(instrument):
    return ""

def get_lei(party):
    parent_list = []
    lei = ''
    lei = party.LEI()
    if lei:
        FRegulatoryLogger.DEBUG(logger, "Party LEI <%s> being directly picked up for party <%s>"%(lei, party.Name()))
    if not lei:
        lei = party.LegalEntityId()
        orig_party = party
        if not lei:
            if party.Parent():
                    while party.Parent() and not lei:
                        if party.Parent().Name() not in parent_list:
                            parent_list.append(party.Parent().Name())
                            party = party.Parent()
                            lei = party.LegalEntityId()
                            if lei:
                                FRegulatoryLogger.DEBUG(logger, "The LEI <%s> being selected for party <%s> is from parent <%s> in its hierarchy"%(lei, orig_party.Name(), party.Name()))
                        else:
                            FRegulatoryLogger.ERROR(logger, "The LEI for party <%s> cannot be determined as there is a cyclic dependency upon it."%(orig_party.Name()))
                            break
    return lei

def tech_record_identification(trade):
    """function that returns the technical record identification if present on the trade. If not present, it generates and returns this value"""
    tech_record_identification = ''
    if trade:
        lei = ''
        reporting_entity = trade.RegulatoryInfo().ReportingEntity()
        if reporting_entity:
            lei = get_lei(reporting_entity)
        value_day = (ael.date_from_string(trade.ValueDay())).to_string(ael.DATE_ISO)
        value_day = value_day.replace('-', '')
        buff = ''
        if len(lei + value_day + str(trade.Oid())) < 35:
            buff_len = 35 - len(lei + value_day + str(trade.Oid()))
            buff = '0' * buff_len
        tech_record_identification = lei + value_day + buff + str(trade.Oid())
        tech_record_identification = tech_record_identification[0:35]
    return tech_record_identification

def get_regulatory_instance(add_info_recs):
    acm_object = None
    if add_info_recs:
        if len(add_info_recs) > 1:
            pass
            #FRegulatoryLogger.WARN(logger, "There are multiple records with the value <%s> on <%s>. Returning the first found instance."%(str(add_info_recs[0].FieldValue()), add_info_recs[0].RecType()))
        add_info_rec = add_info_recs[0]
        recType = None
        try:
            recType = add_info_rec.RecType()
        except:#this condition is hit for versions below 15.3 where the RecType function was not directly available on the AddInfo object
            recType = add_info_rec.AddInf().RecType() 
        if recType == 'Contact':
            acm_object = acm.FContact[add_info_rec.Recaddr()]
        elif recType == 'Party':
            acm_object = acm.FParty[add_info_rec.Recaddr()]
    return acm_object

def getObjectFromCrmId(crm_id):
    acm_object = None
    acm_object = acm.FPerson.Select01("crmId  = '%s'"%crm_id, None)
    if not acm_object:
        add_info_recs = acm.FAdditionalInfo.Select("addInf=%d and fieldValue ='%s'"\
                    %(acm.FAdditionalInfoSpec['regContactCrmId'].Oid(),  crm_id)) 
        acm_object = get_regulatory_instance(add_info_recs)
    if not acm_object:
        add_info_recs = acm.FAdditionalInfo.Select("addInf=%d and fieldValue ='%s'"\
                    %(acm.FAdditionalInfoSpec['regPtyCrmId'].Oid(),  crm_id)) 
        acm_object = get_regulatory_instance(add_info_recs)
    return acm_object

def getObjectFromExchangeId(exchange_id):
    acm_object = None
    try:
        acm_object = acm.FPerson.Select01("exchangeId  = %d"%exchange_id, None)
        if not acm_object:
            add_info_recs = acm.FAdditionalInfo.Select('addInf=%d and fieldValue =%d'\
                        %(acm.FAdditionalInfoSpec['regContExchangeId'].Oid(),  int(exchange_id))) 
            acm_object = get_regulatory_instance(add_info_recs)
        if not acm_object:
            add_info_recs = acm.FAdditionalInfo.Select('addInf=%d and fieldValue =%d'\
                        %(acm.FAdditionalInfoSpec['regPtyExchangeId'].Oid(),  int(exchange_id)))
            acm_object = get_regulatory_instance(add_info_recs)
    except ValueError as e:
        raise ValueError("Kindly provide a valid value for the ExchangeId. %s"%e)
    return acm_object

rts_28_ins_type_dict = {
    'Stock'             : 'Equities - Shares & Depositary Receipts',
    'Depositary Receipt': 'Equities - Shares & Depositary Receipts',
    'ETF'               : 'Exchange traded products (Exchange traded funds, exchange traded notes and exchange traded commodities)',
    'MBS/ABS'           : 'Structured finance instruments', 
    'CLN'               : 'Structured finance instruments',
    'Bill'              : 'Debt instruments - Money markets instruments',
    'IndexLinkedBond'   : 'Debt instruments - Bonds',
    'DualCurrBond'      : 'Debt instruments - Bonds',
    'Convertible'       : 'Other instruments' ,
    'Flexi Bond'        : 'Other instruments',
    'Warrant'           : 'Securitized Derivatives - Warrants and Certificate Derivatives',
    'Rolling Schedule'  : 'Commodities derivatives and emission allowances Derivatives - Other commodities derivatives and emission allowances derivatives',
    'Swap'              : 'Interest Rates Derivatives - Swaps, forwards, and other interest rates derivatives',
    'CurrSwap'          : 'Interest Rates Derivatives - Swaps, forwards, and other interest rates derivatives',
    'IndexLinkedSwap'   : 'Interest Rates Derivatives - Swaps, forwards, and other interest rates derivatives',
    'FRA'               : 'Interest Rates Derivatives - Swaps, forwards, and other interest rates derivatives',
    'Cap'               : 'Interest Rates Derivatives - Futures and options admitted to trading on a trading venue',
    'Floor'             : 'Interest Rates Derivatives - Futures and options admitted to trading on a trading venue',
    'PriceSwap'         : 'Commodities derivatives and emission allowances Derivatives - Other commodities derivatives and emission allowances derivatives', 
    'CreditDefaultSwap' : 'Credit Derivatives - Other credit derivatives',
    'Bond'              : 'DERIVE_FROM_TENOR',
    'FRN'               : 'DERIVE_FROM_TENOR',
    'PromisLoan'        : 'DERIVE_FROM_TENOR',
    'Zero'              : 'DERIVE_FROM_TENOR',
}


'''
def get_rts28(instrument):
    cfi_code = instrument.RegulatoryInfo().CfiCode()
    if not cfi_code:
        cfi_code = FRegulatoryCfiCodeGeneration.compute_cfi_code(instrument) 
    rts28_ins_type = get_rts28_from_cfi_code(cfi_code)
    return rts28_ins_type
'''

def __derive_rts28_from_tenor(instrument):
    rts_28_ins_type = 'Debt instruments - Bonds'
    if instrument.Issuer() and instrument.Issuer().BusinessStatus() and 'MUNICIPAL' in instrument.Issuer().BusinessStatus().Name().upper():
        pass
    else:
        tenure = FRegulatoryCfiCodeGeneration.get_tenure(instrument)
        if tenure <= 366:
            rts_28_ins_type = 'Debt instruments - Money markets instruments'
    return rts_28_ins_type

def get_rts28(instrument, rts28_lookup_dict = None, base_instrument = False, counter = 0):
    if not rts28_lookup_dict:
        rts28_lookup_dict = rts_28_ins_type_dict
    rts_28_ins_type = 'Other instruments'
    
    if instrument.InsType() in rts28_lookup_dict:
        counter = counter + 1
        val = rts28_lookup_dict[instrument.InsType()]
        if val == 'DERIVE_FROM_TENOR':
            rts_28_ins_type = __derive_rts28_from_tenor(instrument)
        else:
            rts_28_ins_type = rts28_lookup_dict[instrument.InsType()]
    else:
        if instrument.InsType() in ['Option']:
            if not FRegulatoryCfiCodeGeneration.is_otc_option(instrument):
                if instrument.Underlying().InsType() in ['Curr']:
                    rts_28_ins_type = 'Currency derivatives - Futures and options admitted to trading on a trading venue'
                elif instrument.Underlying().InsType() in ['Cap', 'Floor']:
                    rts_28_ins_type = 'Interest Rates Derivatives - Futures and options admitted to trading on a trading venue'
                elif instrument.Underlying().InsType() in ['FRA']:
                    rts_28_ins_type = 'Interest Rates Derivatives - Swaps, forwards, and other interest rates derivatives'
                elif instrument.Underlying().InsType() in ['Stock', 'Depositary Receipt']:
                    rts_28_ins_type = 'Equity Derivatives - Options and Futures admitted to trading on a trading venue'
                elif instrument.Underlying().InsType() in ['Commodity', 'Commodity Variant', 'Average Future/Forward',]:
                    rts_28_ins_type = 'Commodities derivatives and emission allowances Derivatives - Options and Futures admitted to trading on a trading venue'
                
            else:
                if instrument.Underlying().InsType() in ['CreditDefaultSwap', 'CLN']:
                    rts_28_ins_type = 'Credit Derivatives - Futures and options admitted to trading on a trading venue'
                elif instrument.Underlying() and instrument.Underlying().InsType() in ['Stock', 'EquityIndex', 'Depositary Receipt', 'Dividend Point Index'] or \
                    (instrument.InsType() in ['CFD'] and instrument.Underlying().InsType() in ['Stock', 'EquityIndex']) or \
                    (instrument.Underlying() and instrument.Underlying().InsType() in ['VarianceSwap'] and \
                    instrument.Underlying().Underlying().InsType() in ['Stock', 'EquityIndex', 'Depositary Receipt',]) or \
                    (instrument.Underlying() and instrument.Underlying().InsType() in ['Stock', 'EquityIndex', 'Depositary Receipt', 'Dividend Point Index']) or \
                    (instrument.InsType() in ['CFD'] and instrument.Underlying().InsType() in ['Stock', 'EquityIndex']) or \
                    (instrument.Underlying() and instrument.Underlying().InsType() in ['Option', 'Warrant', 'CFD'] and instrument.Underlying().Underlying().InsType() in ['Stock', 'EquityIndex', 'Depositary Receipt', 'Dividend Point Index'] or \
                    (instrument.Underlying() and instrument.Underlying().Underlying() and instrument.Underlying().Underlying().InsType() in ['CFD'] and \
                    instrument.Underlying().Underlying().Underlying().InsType() in ['Stock', 'EquityIndex'])) or \
                    (instrument.Underlying() and instrument.Underlying().InsType() in ['Future/Forward'] and instrument.Underlying().Underlying().InsType() in ['Dividend Point Index', 'EquityIndex', 'Stock', 'Depositary Receipt']):
                    rts_28_ins_type = 'Equity Derivatives - Options and Futures admitted to trading on a trading venue'
                elif instrument.Underlying().InsType() in ['Curr'] or (instrument.Underlying().Underlying() and instrument.Underlying().Underlying().InsType() in ['Curr']):
                    rts_28_ins_type = 'Currency derivatives - Futures and options admitted to trading on a trading venue'
                elif instrument.Underlying().InsType() in ['Bill', 'Bond', 'FRN', 'Convertible', 'Deposit',  'Zero', 'PromisLoan', 'Swap', \
                        'IndexLinkedSwap', 'Cap', 'Floor', 'FRA', 'CurrSwap', 'RateIndex'] or (instrument.Underlying().Underlying() and instrument.Underlying().Underlying().InsType() in \
                        ['Bill', 'Bond', 'Convertible', 'Deposit', 'FRA', 'FRN', 'RateIndex', 'Zero', 'IndexLinkedBond', 'Swap', 'PromisLoan']):
                    rts_28_ins_type = 'Interest Rates Derivatives - Futures and options admitted to trading on a trading venue'
                elif instrument.Underlying().InsType() in ['Commodity', 'Commodity Variant', 'Commodity Index', 'Average Future/Forward'] or \
                    (instrument.Underlying().Underlying() and instrument.Underlying().Underlying().InsType() in ['Commodity', 'Commodity Variant', 'Commodity Index', 'Average Future/Forward']):
                        rts_28_ins_type = 'Commodities derivatives and emission allowances Derivatives - Options and Futures admitted to trading on a trading venue'
                elif instrument.Underlying().InsType() in ['Future/Forward']:
                    underlyer = instrument.Underlying().Underlying()
                    if underlyer.InsType() in ['Average Future/Forward', 'Commodity', 'Commodity Variant', 'Commodity Index']:
                        rts_28_ins_type = 'Commodities derivatives and emission allowances Derivatives - Options and Futures admitted to trading on a trading venue'
                    elif underlyer.InsType() in ['Bill', 'Bond', 'Convertible', 'Deposit', 'FRA', 'FRN', 'RateIndex', 'Zero', 'IndexLinkedBond', 'Swap', 'PromisLoan']:
                        rts_28_ins_type = 'Interest Rates Derivatives - Futures and options admitted to trading on a trading venue'
                    elif underlyer.InsType() in ['Combination']:
                        code = FRegulatoryCfiCodeGeneration.get_combination_classification_char(underlyer)
                        if code == 'T':
                            rts_28_ins_type = 'Commodities derivatives and emission allowances Derivatives - Options and Futures admitted to trading on a trading venue'
                        elif code == 'E':
                            rts_28_ins_type = 'Equity Derivatives - Options and Futures admitted to trading on a trading venue'
                        elif code == 'C':
                            rts_28_ins_type = 'Credit Derivatives - Futures and options admitted to trading on a trading venue'
                        elif code == 'F':
                            rts_28_ins_type = 'Currency derivatives - Futures and options admitted to trading on a trading venue'
                        elif code == 'R':
                            rts_28_ins_type = 'Interest Rates Derivatives - Futures and options admitted to trading on a trading venue'
                    elif underlyer.InsType() in ['CreditDefaultSwap', 'CLN', ]:
                        rts_28_ins_type = 'Credit Derivatives - Futures and options admitted to trading on a trading venue'
                    elif underlyer.InsType() in ['Curr']:
                        rts_28_ins_type = 'Currency derivatives - Futures and options admitted to trading on a trading venue'
                    elif underlyer.InsType() in ['Dividend Point Index', 'EquityIndex', 'Stock', 'Depositary Receipt']:
                        rts_28_ins_type = 'Equity Derivatives - Options and Futures admitted to trading on a trading venue'
                elif instrument.Underlying().InsType() in ['Combination', 'TotalReturnSwap']:
                    code = None
                    if instrument.Underlying().InsType() in ['Combination']:
                        code = FRegulatoryCfiCodeGeneration.get_combination_classification_char(instrument.Underlying())
                    else:
                        for leg in instrument.Underlying().Legs():
                            if leg.LegType() == 'Total Return':
                                code = FRegulatoryCfiCodeGeneration.get_TRS_float_rate_ref_classification(leg.FloatRateReference())
                                break
                    if code == 'T':
                        rts_28_ins_type = 'Commodities derivatives and emission allowances Derivatives - Options and Futures admitted to trading on a trading venue'
                    elif code == 'E':
                        rts_28_ins_type = 'Equity Derivatives - Options and Futures admitted to trading on a trading venue'
                    elif code == 'C':
                        rts_28_ins_type = 'Credit Derivatives - Futures and options admitted to trading on a trading venue'
                    elif code == 'F':
                        rts_28_ins_type = 'Currency derivatives - Futures and options admitted to trading on a trading venue'
                    elif code == 'R':
                        rts_28_ins_type = 'Interest Rates Derivatives - Futures and options admitted to trading on a trading venue'
        elif instrument.InsType() in ['Future/Forward', 'Average Future/Forward', 'CFD']:
            if (not instrument.Otc()):
                if instrument.InsType() in ['Average Future/Forward']:
                    rts_28_ins_type = 'Commodities derivatives and emission allowances Derivatives - Options and Futures admitted to trading on a trading venue'
                if instrument.Underlying() and instrument.Underlying().InsType() in ['Combination']:
                    if FRegulatoryCfiCodeGeneration.get_combination_classification(instrument.Underlying())[1]:
                        rts_28_ins_type = 'Commodities derivatives and emission allowances Derivatives - Options and Futures admitted to trading on a trading venue'
                    else:
                        rts_28_ins_type = 'Other instruments'
                elif instrument.Underlying() and instrument.Underlying().InsType() in ['ETF', 'Bill', 'Bond', 'FRN', 'Convertible', \
                    'Deposit', 'Zero', 'PromisLoan', 'IndexLinkedBond', 'EquityIndex', 'Commodity Index', \
                    'Dividend Point Index', 'Average Future/Forward', 'Commodity', 'Commodity Variant']:
                    rts_28_ins_type = 'Other instruments'
                elif instrument.Underlying() and instrument.Underlying().InsType() in ['Curr']:
                    rts_28_ins_type = 'Currency derivatives - Swaps, forwards, and other currency derivatives'
                elif instrument.Underlying() and instrument.Underlying().InsType() in ['RateIndex']:
                    rts_28_ins_type = 'Interest Rates Derivatives - Futures and options admitted to trading on a trading venue'
                elif instrument.Underlying() and instrument.Underlying().InsType() in ['Stock', 'Depositary Receipt']:
                    rts_28_ins_type = 'Equity Derivatives - Options and Futures admitted to trading on a trading venue'
            else:
                underlyer = None
                if instrument.InsType() == 'Average Future/Forward':
                    underlyer = instrument.Legs()[0].FloatRateReference()
                else:
                    underlyer = instrument.Underlying()
                if underlyer.InsType() in ['CreditDefaultSwap', 'CLN']:
                    rts_28_ins_type = 'Credit Derivatives - Futures and options admitted to trading on a trading venue'
                elif (underlyer.InsType() in ['Stock', 'EquityIndex', 'Dividend Point Index', 'Depositary Receipt']) or \
                        (instrument.InsType() in ['CFD'] and underlyer.InsType() in ['Stock', 'EquityIndex']):
                    rts_28_ins_type = 'Equity Derivatives - Options and Futures admitted to trading on a trading venue'
                    if instrument.InsType() in ['CFD'] and instrument.Underlying().InsType() in ['Stock', 'EquityIndex'] and (instrument.Otc()):
                        rts_28_ins_type = 'Contracts for difference'
                elif underlyer.InsType() in ['Curr']:
                    rts_28_ins_type = 'Currency derivatives - Swaps, forwards, and other currency derivatives'
                elif underlyer.InsType() in ['RateIndex', 'Bill', 'Bond', 'FRN', 'Deposit', 'Zero', 'PromisLoan', 'FRA', 'IndexLinkedBond', 'Convertible', 'Swap']:
                    rts_28_ins_type = 'Interest Rates Derivatives - Swaps, forwards, and other interest rates derivatives'
                elif underlyer.InsType() in ['Commodity', 'Commodity Variant', 'Commodity Index', \
                                            'Average Future/Forward', 'Precious Metal Rate', 'Rolling Schedule']:
                    rts_28_ins_type = 'Commodities derivatives and emission allowances Derivatives - Other commodities derivatives and emission allowances derivatives'
                elif underlyer.InsType() in ['CFD'] and underlyer.Underlying().InsType() in ['Stock', 'EquityIndex'] and (instrument.Otc()):
                    rts_28_ins_type = 'Contracts for difference'
                elif underlyer.InsType() in ['Combination']:
                    code = FRegulatoryCfiCodeGeneration.get_combination_classification_char(underlyer)
                    if code == 'T':
                        rts_28_ins_type = 'Commodities derivatives and emission allowances Derivatives - Other commodities derivatives and emission allowances derivatives'
                    elif code == 'E':
                        rts_28_ins_type = 'Equity Derivatives - Options and Futures admitted to trading on a trading venue'
                    elif code == 'C':
                        rts_28_ins_type = 'Credit Derivatives - Futures and options admitted to trading on a trading venue'
                    elif code == 'F':
                        rts_28_ins_type = 'Currency derivatives - Swaps, forwards, and other currency derivatives'
                    elif code == 'R':
                        rts_28_ins_type = 'Interest Rates Derivatives - Futures and options admitted to trading on a trading venue'
        elif instrument.InsType() in ['TotalReturnSwap']:
            classification_char = None
            for leg in instrument.Legs():
                if leg.LegType() == 'Total Return':
                    classification_char = FRegulatoryCfiCodeGeneration.get_TRS_float_rate_ref_classification(leg.FloatRateReference())
                    if classification_char == 'C':
                        rts_28_ins_type = 'Credit Derivatives - Other credit derivatives'
                    elif classification_char == 'E':
                        rts_28_ins_type = 'Equity Derivatives - Swaps and other equity derivatives'
                    elif classification_char == 'R':
                        rts_28_ins_type = 'Interest Rates Derivatives - Swaps, forwards, and other interest rates derivatives'
                    elif classification_char == 'T':
                        rts_28_ins_type = 'Commodities derivatives and emission allowances Derivatives - Other commodities derivatives and emission allowances derivatives'
                    elif classification_char == 'F':
                        rts_28_ins_type = 'Currency derivatives - Swaps, forwards, and other currency derivatives'
        elif instrument.InsType() in ['VarianceSwap', 'VolatilitySwap']:
            rts_28_ins_type = 'Other instruments'
            if instrument.Underlying().InsType() in ['Stock', 'EquityIndex', 'Depositary Receipt'] or \
                (instrument.Underlying().InsType() in ['Combination'] and FRegulatoryCfiCodeGeneration.get_combination_classification(instrument.Underlying())[0]):
                rts_28_ins_type = 'Equity Derivatives - Swaps and other equity derivatives'
    return rts_28_ins_type

def get_rts28_from_cfi_code(cfi_code):
    counter = 0
    cfi_char_dict = FRegulatoryLookup.cfi_char_dict
    rts28_ins_type = None
    try:
        while not rts28_ins_type:
            if cfi_code[counter] in cfi_char_dict:
                key_val = cfi_code[counter]
            else:
                key_val = '*'
            dict_val = cfi_char_dict[key_val]
            if isinstance(dict_val, str):
                rts28_ins_type = dict_val
            else:
                cfi_char_dict = dict_val
                counter = counter + 1
    except:
        pass
    if not rts28_ins_type:
        rts28_ins_type = 'Other instruments'
    return rts28_ins_type

def their_org(trade):
    their_org = None
    import FRegulatoryLib
    if trade.RegulatoryInfo().TheirOrganisation():
        lei = FRegulatoryLib.PartyRegInfo(trade.RegulatoryInfo().TheirOrganisation()).LEI()
        if lei:
            their_org = FRegulatoryLib.PartyRegInfo.partyFromLEI(lei)
        if their_org:
            if their_org != trade.RegulatoryInfo().TheirOrganisation():
                FRegulatoryLogger.INFO(logger, "TheirOrganisation <%s> on trade <%d> does not have an LEI on it. Hence TheirOrg retuned <%s> as it is a parent of <%s> with LEI on it"%(\
                trade.RegulatoryInfo().TheirOrganisation().Name(), trade.Oid(), their_org.Name(), trade.RegulatoryInfo().TheirOrganisation().Name()))
        else:
            FRegulatoryLogger.INFO(logger, "No LEI found on TheirOrganisation <%s>. Hence verifying Counterparty"%trade.RegulatoryInfo().TheirOrganisation().Name())
    if (not their_org) and trade.Counterparty():
        lei = FRegulatoryLib.PartyRegInfo(trade.Counterparty()).LEI()
        if lei:
            their_org = FRegulatoryLib.PartyRegInfo.partyFromLEI(lei)
        if their_org:
            if their_org != trade.Counterparty():
                FRegulatoryLogger.INFO(logger, "Counterparty <%s> on trade <%d> does not have an LEI on it. Hence TheirOrg retuned <%s> as it is a parent of <%s> with LEI on it"%(\
                trade.Counterparty().Name(), trade.Oid(), their_org.Name(), trade.Counterparty().Name()))
    if not their_org:
        FRegulatoryLogger.INFO(logger, "Neither TheirOrganisation nor Counterparty are set on the trade or do not have LEI. Hence TheirOrg is None")
    return their_org

def our_org(trade):
    our_org = None
    import FRegulatoryLib
    if trade.RegulatoryInfo().OurOrganisation():
        lei = FRegulatoryLib.PartyRegInfo(trade.RegulatoryInfo().OurOrganisation()).LEI()
        if lei:
            our_org = FRegulatoryLib.PartyRegInfo.partyFromLEI(lei)
        if our_org:
            if our_org != trade.RegulatoryInfo().OurOrganisation():
                FRegulatoryLogger.INFO(logger, "OurOrganisation <%s> on trade <%d> does not have an LEI on it. Hence OurOrg retuned <%s> as it is a parent of <%s> with LEI on it"%(\
                trade.RegulatoryInfo().OurOrganisation().Name(), trade.Oid(), our_org.Name(), trade.RegulatoryInfo().OurOrganisation().Name()))
        else:
            FRegulatoryLogger.INFO(logger, "No LEI found on OurOrganisation <%s>. Hence verifying Acquirer"%trade.RegulatoryInfo().OurOrganisation().Name())
    if (not our_org) and trade.Acquirer():
        lei = FRegulatoryLib.PartyRegInfo(trade.Acquirer()).LEI()
        if lei:
            our_org = FRegulatoryLib.PartyRegInfo.partyFromLEI(lei)
        if our_org:
            if our_org != trade.Acquirer():
                FRegulatoryLogger.INFO(logger, "Acquirer <%s> on trade <%d> does not have an LEI on it. Hence OurOrg retuned <%s> as it is a parent of <%s> with LEI on it"%(\
                trade.Acquirer().Name(), trade.Oid(), our_org.Name(), trade.Acquirer().Name()))
    if not our_org:
        FRegulatoryLogger.INFO(logger, "Neither OurOrganisation nor Acquirer are set on the trade or do not have LEI. Hence OurOrg is None")
    return our_org

def get_swap_type(instrument):
    float_leg_counter = 0
    fixed_leg_counter = 0
    swap_type = None
    for leg in instrument.Legs():
        if leg.LegType() in ['Fixed', 'Fixed Accretive', 'Zero Coupon Fixed']:
            fixed_leg_counter = fixed_leg_counter + 1
        elif leg.LegType() in ['Float', 'Total Return']:
            float_leg_counter = float_leg_counter + 1
    if float_leg_counter == 2:
        swap_type = 'Basis Swap'
    elif float_leg_counter == 1 and fixed_leg_counter == 1:
        swap_type = 'Vanilla Swap'
    if fixed_leg_counter == 2:
        swap_type = 'Fixed Fixed Swap'
    return swap_type

def set_rating(acm_object, rating_name, rating_val):
    choicelist = acm.FChoiceList.Select01("list = 'Ratings' and name = '%s'"%rating_name, None)
    if choicelist:
        sort_order = choicelist.SortOrder()
        try:
            if acm_object.IsKindOf(acm.FParty):
                eval('acm_object.Rating' + str(sort_order) + '(' + str(rating_val) +')')
            elif acm_object.IsKindOf(acm.FInstrument):
                eval('acm_object.Rating' + str(sort_order) + 'ChlItem(' + str(rating_val) +')')
        except:
            pass

def get_rating(acm_object, rating_name):
    """return the rating value on the acm object requested"""
    rating_val = None
    choicelist = acm.FChoiceList.Select01("list = 'Ratings' and name = '%s'"%rating_name, None)
    if choicelist:
        sort_order = choicelist.SortOrder()
        try:
            if acm_object.IsKindOf(acm.FParty):
                rating_val = eval('acm_object.Rating' + str(sort_order) + '()')
            elif acm_object.IsKindOf(acm.FInstrument):
                rating_val = eval('acm_object.Rating' + str(sort_order) + 'ChlItem()')
        except:
            pass
    return rating_val


def commit_into_fparameters(fparameter, fparameter_val, extension):
    """commit the FParameters with the value being sent """
    if sys.version_info[0] >= 3 and isinstance(fparameter_val, bytes):
        fparameter_val = fparameter_val.decode()
    elif sys.version_info[0] < 3 and isinstance(fparameter_val, unicode):
        fparameter_val = fparameter_val.encode('utf-8', 'strict')

    ext_context = acm.GetDefaultContext()
    param_object = ext_context.GetExtension('FParameters', 'FObject', extension)
    template = param_object.Value()
    for key_val in template.Keys():
        if str(key_val) == fparameter:
            template[str(key_val)] = fparameter_val
    template.Commit()
    em = param_object.Module()
    em.AddExtension(param_object)
    em.Commit()
    FRegulatoryLogger.DEBUG(logger, "%s : %s set with value %s." % (extension, fparameter, fparameter_val))


def save_apis_in_fparameters(api_dict, add_infos):
    """commit the api list selected on GUI to FParameters"""
    config_param.set_paramvalue('FREGULATORY_API', str(api_dict))
    config_param.set_paramvalue('FREGULATORY_ADDINFO', add_infos)
    commit_into_fparameters('FREGULATORY_API', str(api_dict), 'FRegulatoryAPIConfig')
    commit_into_fparameters('FREGULATORY_ADDINFO', add_infos, 'FRegulatoryAPIConfig')
    FRegulatoryLogger.INFO(logger, "Committed <%s> and <%s>" % (str(api_dict), add_infos))

def is_valid_for_country(iban_val):
    """returns True if the length of the given IBAN value is as expected for the country it belongs to"""
    is_valid_len = False
    country_dict = dict(list(zip(list(FRegulatoryLookup.country_code_dict.values()), \
                                              list(FRegulatoryLookup.country_code_dict.keys()))))
    country_code = iban_val[0:2]
    if country_code in FRegulatoryLookup.iban_len_lookup.keys():
        country_code_len = FRegulatoryLookup.iban_len_lookup[country_code]
        if len(iban_val) == country_code_len:
            is_valid_len = True
        else:
            if country_code in country_dict.keys():
                FRegulatoryLogger.INFO(logger, "The length of the IBAN value for country <%s> is expected to be <%d>. However, the length of <%s> is <%d>. Hence this is not a valid IBAN value."%(\
                    country_dict[country_code], country_code_len, iban_val, len(iban_val)))
            else:
                FRegulatoryLogger.INFO(logger,"The length of the IBAN value for country code <%s> is expected to be <%d>. However, the length of <%s> is <%d>. Hence this is not a valid IBAN value."%(\
                    country_code, country_code_len, iban_val, len(iban_val)))
    else:
        FRegulatoryLogger.INFO(logger, "The IBAN defined length for country code <%s> is not known. Hence defaulting to False"%country_code)
    return is_valid_len

def is_valid_iban_check_sum(iban_val):
    """validate the checkcum value in the given iban"""
    is_valid_cs = False
    check_sum = iban_val[2:4]
    isDigit = True
    for each_char in check_sum:
        if not each_char.isdigit():
            isDigit = False
    if not isDigit:
        FRegulatoryLogger.INFO(logger, "The checksum is not at the expected position in the given value <%s>. Hence, this is not a valid IBAN value"%iban_val)
    else:
        iban_val = iban_val.upper()
        first_four_char = iban_val[0:4]
        iban_modified_val = iban_val[4:] + first_four_char
        converted_iban = ''
        for each_char in iban_modified_val:
            if each_char.isdigit():
                converted_val = each_char
            else:
                converted_val = ord(each_char) - ord('A') + 10
            converted_iban = converted_iban + str(converted_val)
        if int(converted_iban) % 97 == 1:
            is_valid_cs = True
        else:
            FRegulatoryLogger.INFO(logger, "The checksum <%s> within <%s> is not valid. Hence, this is not a valid IBAN value"%(check_sum, iban_val))
    return is_valid_cs


...

  FRegulatoryLibWrapper
"""------------------------------------------------------------------------
MODULE
    FRegulatoryLibWrapper -
DESCRIPTION:
    This file consists of the calls to the functions required for
    the Regulatory APIs that can be made available on different objects
VERSION: 1.0.29(0.1.1278)
RESTRICTIONS/ LIMITATIONS:
    1. Any modifications to the scripts/ encrypted modules/ clear text code within the core is not supported. 
    2. This module is not customizable
    3. The component may not work as expected with any modifications done to this module at user end
--------------------------------------------------------------------------"""
import FRegulatoryLib
import FRegulatoryLibUtils
import acm
import FRegulatoryLogger
logger = 'FRegulatoryLibWrapper'

class wrapper(object):
    """base class for all wrapper classes"""
    def checkAddInfoValueExists(self, acm_object, add_info_spec, acm_object_type, acm_object_name):
        """check of the AddInfo value exists for the given AddInfoSpec and object"""
        addInfoSpec = acm.FAdditionalInfoSpec[add_info_spec]
        add_info_val_exists = False
        add_info_val = acm.FAdditionalInfo.Select01(\
                    "addInf = %d and recaddr = %d"%(addInfoSpec.Oid(), acm_object.Oid()), None)
        if add_info_val in [None, '']:
            FRegulatoryLogger.INFO(logger, "AdditionalInfo <%s> does not have a value set on %s <%s>. Hence, inferring the value"%(add_info_spec, acm_object_type, acm_object_name))
        else:
            add_info_val_exists = True
        return add_info_val_exists
    
    def get_tristate_boolean(self, tristate_val):
        """returns the tristate choicelist value in a boolean state"""
        is_tristate_val = False
        try:
            if tristate_val.IsKindOf(acm.FChoiceList):
                if tristate_val.Name() == 'True':
                    is_tristate_val = True
        except:
            is_tristate_val = tristate_val
        return is_tristate_val

    def get_tristate_string(self, tristate_val):
        """returns the tristate choicelist value in a string state"""
        is_tristate_val = None
        try:
            if tristate_val.IsKindOf(acm.FChoiceList):
                if tristate_val.Name() != 'None':
                    is_tristate_val = tristate_val.Name()
        except:
            is_tristate_val = tristate_val
        return is_tristate_val

class JurisdictionNRegulatoryAuthority(wrapper):
    def __init__(self, jurisdiction_lookup = None, regulatory_authority_lookup = None):
        self.__jurisdiction_lookup = jurisdiction_lookup
        self.__regulatory_authority_lookup = regulatory_authority_lookup

    def isJurisdictionT(self, acm_object, jurisdiction):
        """returns the tristate value of IsJuridiction"""
        return self.get_tristate_string(self.isJurisdiction(acm_object, jurisdiction))

    def isJurisdictionB(self, acm_object, jurisdiction):
        """returns the boolean value of IsJuridiction"""
        return self.get_tristate_boolean(self.isJurisdiction(acm_object, jurisdiction))

    def isJurisdiction(self, acm_object, jurisdiction):
        """set the given value of IsJuridiction"""
        is_juridiction_val = None
        if acm_object.IsKindOf(acm.FParty):
            is_juridiction_val = FRegulatoryLib.PartyRegInfo(acm_object).is_jurisdiction(jurisdiction, self.__jurisdiction_lookup)
        if acm_object.IsKindOf(acm.FInstrument):
            is_juridiction_val = FRegulatoryLib.InstrumentRegInfo(acm_object).is_jurisdiction(jurisdiction, self.__jurisdiction_lookup)  
        return is_juridiction_val

    def isRegulatoryAuthorityT(self, acm_object, regulatory_authority):
        """returns the tristate value of IsRegulatoryAuthority for the given instrument/party"""
        return self.get_tristate_string(self.isRegulatoryAuthority(acm_object, regulatory_authority))

    def isRegulatoryAuthorityB(self, acm_object, regulatory_authority):
        """returns the boolean value of IsRegulatoryAuthority for the given instrument/party"""
        return self.get_tristate_boolean(self.isRegulatoryAuthority(acm_object, regulatory_authority))

    def isRegulatoryAuthority(self, acm_object, regulatory_authority):
        """returns the value of IsRegulatoryAuthority for the given instrument/party"""
        regulatory_authority_val = None
        if acm_object.IsKindOf(acm.FParty):
            regulatory_authority_val = FRegulatoryLib.PartyRegInfo(acm_object).is_regulatory_authority(regulatory_authority, self.__regulatory_authority_lookup)
        if acm_object.IsKindOf(acm.FInstrument):
            regulatory_authority_val = FRegulatoryLib.InstrumentRegInfo(acm_object).is_regulatory_authority(regulatory_authority, self.__regulatory_authority_lookup)
        return regulatory_authority_val

class accountWrapper(wrapper):
    """wrapper class for all APIs related to FAccount"""
   
    def allocated(self, account):
        """return the inferred allocated value"""
        return None

    def is_allocated_getter(self, account):
        """get the value of allocated if set on AddInfo"""
        is_allocated_val = None
        if self.checkAddInfoValueExists(account, 'regIsCmdtyAllocated', 'account', account.Name()):
            is_allocated_val = account.AdditionalInfo().RegIsCmdtyAllocated()
        if not is_allocated_val:
            is_allocated_val = self.allocated(account)
        return is_allocated_val

    def trade_depository(self, account):
        """returns the trade depository value on the account"""
        trade_depository_val = account.CorrespondentBank5()
        if not trade_depository_val:
            trade_depository_val = account.CorrespondentBank4()
        if not trade_depository_val:
            trade_depository_val = account.CorrespondentBank3()
        if not trade_depository_val:
            trade_depository_val = account.CorrespondentBank2()
        if not trade_depository_val:
            trade_depository_val = account.CorrespondentBank()
        return trade_depository_val

    def is_allocated_setter(self, account, is_allocated_val):
        """set the value of allocated on AddInfo"""
        account.AdditionalInfo().RegIsCmdtyAllocated(is_allocated_val)

    def trade_depository_getter(self, account):
        """returns the trade depository value on the account"""
        trade_depository_val = None
        if self.checkAddInfoValueExists(account, 'regTradeDepository', 'account', account.Name()):
            trade_depository_val = account.AdditionalInfo().RegTradeDepository()
        if not trade_depository_val:
            trade_depository_val = self.trade_depository(account)
        return trade_depository_val

    def trade_depository_setter(self, account, trade_depository_val):
        """set the value of tradeDepository on AddInfo"""
        account.AdditionalInfo().RegTradeDepository(trade_depository_val)

class partyWrapper(wrapper):
    """wrapper class for all APIs related to FParty"""
    def mic(self, party):
        """returns the alias MIC value on the party"""
        return FRegulatoryLib.PartyRegInfo(party).MIC()

    def is_subsidiary(self, party, issubsidiary_party):
        """returns True if the ultimate parent for both parties is the same"""
        is_subsidiary_party = False
        if FRegulatoryLib.PartyRegInfo(party).ultimate_parent() ==\
            FRegulatoryLib.PartyRegInfo(issubsidiary_party).ultimate_parent():
            is_subsidiary_party = True
        return is_subsidiary_party

    def exceution_venue_type_getter(self, party):
        """returns the exceution venue type on the Venue on trade"""
        execution_venue_type = None
        if self.checkAddInfoValueExists(party, 'regExecVenueType', 'party', party.Name()):
            execution_venue_type = party.AdditionalInfo().RegExecVenueType()
        return execution_venue_type

    def exceution_venue_type_setter(self, party, execution_venue_type_val):
        """set the lei name on the party"""
        party.AdditionalInfo().RegExecVenueType(execution_venue_type_val)

    def lei_name_getter(self, party):
        """get the lei name on the party set on AddInfo"""
        lei_name_val = None
        if self.checkAddInfoValueExists(party, 'regLEIName', 'party', party.Name()):
            lei_name_val = party.AdditionalInfo().RegLEIName()
        return lei_name_val

    def lei_name_setter(self, party, lei_name_val):
        """set the lei name on the party"""
        party.AdditionalInfo().RegLEIName(lei_name_val)
   
    def ultimate_parent_getter(self, party):
        """get the ultimate parent on the party"""
        return FRegulatoryLib.PartyRegInfo(party).ultimate_parent()

    def ultimate_parent_setter(self, party, ultimate_parent_val):
        """set the ultimate parent on the party"""
        FRegulatoryLib.PartyRegInfo(party).ultimate_parent(parent_party=ultimate_parent_val)

    def emir_category_getter(self, party):
        """get the emir category classification of the party"""
        emir_category_val = None
        if self.checkAddInfoValueExists(party, 'regEMIRCategory', 'party', party.Name()):
            emir_category_val = party.AdditionalInfo().RegEMIRCategory()
        return emir_category_val

    def emir_category_setter(self, party, emir_category_val):
        """set the emir category classification of the party"""
        party.AdditionalInfo().RegEMIRCategory(emir_category_val)


class instrumentWrapper(wrapper):
    """wrapper class for all APIs related to FInstrument"""
    def floating_rate_index(self, ins):
        """returns the floating rate index on the instrument"""
        float_rate_index = None
        if self.checkAddInfoValueExists(ins, 'ESMAIndex', 'instrument', ins.Name()):
            float_rate_index = ins.AdditionalInfo().ESMAIndex()
        return float_rate_index

    def is_government_guaranteed(self, ins):
        """if the AdditionalInfo or the AdditionalInfoSpec does
         not exist, return the inferred the IsGovernmentGuaranteed value"""
        return FRegulatoryLib.InstrumentRegInfo(ins).is_government_guaranteed()

    def is_government_guaranteed_getter(self, ins):
        """get the value of the IsGovtGuaranteed AdditionalInfo
         value if present, else take it from Provider API"""
        is_govt_guaranteed_val = None
        if self.checkAddInfoValueExists(ins, 'regIsGovtGuaranteed', 'instrument', ins.Name()):
            is_govt_guaranteed_val = ins.AdditionalInfo().RegIsGovtGuaranteed()
            is_govt_guaranteed_val = FRegulatoryLibUtils.get_tristate_choiceList(is_govt_guaranteed_val)
        if not is_govt_guaranteed_val:
            is_govt_guaranteed_val = self.is_government_guaranteed(ins)
        return is_govt_guaranteed_val

    def is_government_guaranteed_setter(self, ins, is_govt_guaranteed_val):
        """set the value on the IsGovtGuaranteed AdditionalInfo"""
        ins.AdditionalInfo().RegIsGovtGuaranteed(is_govt_guaranteed_val)

    def is_covered(self, ins):
        """if the AdditionalInfo or the AdditionalInfoSpec does
         not exist, return the inferred the IsCovered value"""
        return FRegulatoryLib.InstrumentRegInfo(ins).is_covered()

    def is_covered_getter(self, ins):
        """get the value of the regIsCovered AdditionalInfo value
         if present, else get it from ProviderData if available"""
        is_covered_val = None
        if self.checkAddInfoValueExists(ins, 'regIsCovered', 'instrument', ins.Name()):
            is_covered_val = ins.AdditionalInfo().RegIsCovered()
        if not is_covered_val:
            is_covered_val = self.is_covered(ins)
        if is_covered_val == 'None':
            is_covered_val = FRegulatoryLibUtils.get_tristate_choiceList(is_covered_val)
        return is_covered_val

    def is_covered_setter(self, ins, is_covered_val):
        """set the value on the IsCovered AdditionalInfo"""
        ins.AdditionalInfo().RegIsCovered(is_covered_val)

    def outstanding_shares(self, ins):
        """if the AdditionalInfo or the AdditionalInfoSpec does
         not exist, return the inferred the OutstandingShares value"""
        return FRegulatoryLib.InstrumentRegInfo(ins).outstanding_shares()

    def outstanding_shares_getter(self, ins):
        """get the value of the regOutStndingShares AdditionalInfo value
         if present, else get it from ProviderData if available"""
        market_cap_val = None
        if self.checkAddInfoValueExists(ins, 'regOutStndingShares', 'instrument', ins.Name()):
            market_cap_val = ins.AdditionalInfo().RegOutStndingShares ()
        if not market_cap_val:
            market_cap_val = self.outstanding_shares(ins)
        return market_cap_val

    def outstanding_shares_setter(self, ins, outstanding_shares_val):
        """set the value on the MarketCap AdditionalInfo"""
        ins.AdditionalInfo().RegOutStndingShares (outstanding_shares_val)

    def issuer_type(self, ins):
        """if the AdditionalInfo or the AdditionalInfoSpec does
         not exist, return the inferred the IssuerType value"""
        return FRegulatoryLib.InstrumentRegInfo(ins).issuer_type()

    def issuer_type_getter(self, ins):
        """get the value of the issuerType AdditionalInfo
         value if present, else get it from ProviderData if available"""
        issuer_type_val = None
        if self.checkAddInfoValueExists(ins, 'regIssuerType', 'instrument', ins.Name()):
            issuer_type_val = ins.AdditionalInfo().RegIssuerType()
        if not issuer_type_val:
            issuer_type_val = self.issuer_type(ins)
        return issuer_type_val

    def issuer_type_setter(self, ins, issuer_type_val):
        """set the value on the IssuerType AdditionalInfo"""
        ins.AdditionalInfo().RegIssuerType(issuer_type_val)

    def country_of_issue(self, ins):
        """if the AdditionalInfo or the AdditionalInfoSpec does
         not exist, return the inferred the CountryOfIssue value"""
        return FRegulatoryLib.InstrumentRegInfo(ins).country_of_issue()

    def country_of_issue_setter(self, ins, country_of_issue_val):
        """set the value on the CountryOfIssue AdditionalInfo"""
        ins.AdditionalInfo().RegCountryOfIssue(country_of_issue_val)

    def country_of_issue_getter(self, ins):
        """get the value of the countryOfIssue AdditionalInfo
         value if present, else infer it if possible"""
        country_of_issue_val = None
        if self.checkAddInfoValueExists(ins, 'regCountryOfIssue', 'instrument', ins.Name()):
            country_of_issue_val = ins.AdditionalInfo().RegCountryOfIssue()
        if not country_of_issue_val:#it means the AddInfo exists, but the value is not set on it.
            country_of_issue_val = self.country_of_issue(ins)
        return country_of_issue_val

    def hi_qlty_liquid_asset_getter(self, ins):
        """get the value of the regHiQltyLqdAsset AdditionalInfo value if present"""
        hi_qlty_lqd_asset_val = ''
        if self.checkAddInfoValueExists(ins, 'regHiQltyLqdAsset', 'instrument', ins.Name()):
            hi_qlty_lqd_asset_val = ins.AdditionalInfo().RegHiQltyLqdAsset()
        return hi_qlty_lqd_asset_val

    def hi_qlty_liquid_asset_setter(self, ins, hi_qlty_liquid_asset_val):
        """set the value on the regHiQltyLqdAsset AdditionalInfo"""
        ins.AdditionalInfo().RegHiQltyLqdAsset(str(hi_qlty_liquid_asset_val))
   
    def bond_type(self, ins):
        """if the AdditionalInfo or the AdditionalInfoSpec does
         not exist, return the inferred the BondType value"""
        return FRegulatoryLib.InstrumentRegInfo(ins).bond_type()

    def bond_type_getter(self, ins):
        """get the value of the regBondType AdditionalInfo
         value if present, else get it from ProviderData
          if available"""
        bond_type_val = ''
        if self.checkAddInfoValueExists(ins, 'regBondType', 'instrument', ins.Name()):
            bond_type_val = ins.AdditionalInfo().RegBondType()
        if not bond_type_val:
            bond_type_val = self.bond_type(ins)
        return bond_type_val

    def bond_type_setter(self, ins, bond_type):
        """set the value on the regBondType AdditionalInfo"""
        ins.AdditionalInfo().RegBondType(bond_type)

    def bbg_collateral_type(self, ins):
        """if the AdditionalInfo or the AdditionalInfoSpec does
         not exist, return the inferred the CollateralType value"""
        return FRegulatoryLib.InstrumentRegInfo(ins).bbg_collateral_type()

    def bbg_collateral_type_getter(self, ins):
        """get the value of the collateralType AdditionalInfo value
         if present, else get it from ProviderData if available"""
        collateral_type_val = ''
        if self.checkAddInfoValueExists(ins, 'regCollateralType', 'instrument', ins.Name()):
            collateral_type_val = ins.AdditionalInfo().RegCollateralType()
        if not collateral_type_val:
            collateral_type_val = self.bbg_collateral_type(ins)
        return collateral_type_val

    def bbg_collateral_type_setter(self, ins, collateral_type):
        """set the value on the regCollateralType AdditionalInfo"""
        ins.AdditionalInfo().RegCollateralType(collateral_type)

    def is_equity_getter(self, ins):
        """get the value of the isEquity AdditionalInfo
         value if present, else infer it"""
        is_equity_val = None
        if self.checkAddInfoValueExists(ins, 'regIsEquity', 'instrument', ins.Name()):
            is_equity_val = ins.AdditionalInfo().RegIsEquity()
        if not is_equity_val:
            is_equity_val = self.is_equity(ins)
        return is_equity_val

    def is_equity_setter(self, ins, is_equity_val):
        """set the value on the IsEquity AdditionalInfo"""
        ins.AdditionalInfo().RegIsEquity(is_equity_val)

    def is_equity(self, ins):
        """if the AdditionalInfo or the AdditionalInfoSpec does
         not exist, return the inferred the EquityType value"""
        return FRegulatoryLib.InstrumentRegInfo(ins).is_equity()

    def fund_type_getter(self, ins):
        """get the value of the fundType AdditionalInfo value if present, else get it from ProviderData if available"""
        fund_type_val = ''
        if self.checkAddInfoValueExists(ins, 'regFundType', 'instrument', ins.Name()):
            fund_type_val = ins.AdditionalInfo().RegFundType()
        if not fund_type_val:
            fund_type_val = self.fund_type(ins)
        return fund_type_val

    def fund_type_setter(self, ins, fund_type):
        """set the value on the FundType AdditionalInfo"""
        ins.AdditionalInfo().RegFundType(fund_type)

    def fund_type(self, ins):
        """if the AdditionalInfo or the AdditionalInfoSpec does
         not exist, return the inferred the FundType value"""
        return FRegulatoryLib.InstrumentRegInfo(ins).fund_type()

    def main_trading_place_getter(self, ins):
        """get the value of the mainTradinPlace AdditionalInfo value if present, else infer it from ProviderData if available"""
        main_trading_place = ''
        if self.checkAddInfoValueExists(ins, 'regMainTradingPlace', 'instrument', ins.Name()):
            main_trading_place = ins.AdditionalInfo().RegMainTradingPlace()
        if not main_trading_place:
            main_trading_place = FRegulatoryLib.InstrumentRegInfo(ins).main_trading_place()
        return main_trading_place

    def main_trading_place_setter(self, ins, main_trading_place):
        """set the value on the MainTradingPlace AdditionalInfo"""
        ins.AdditionalInfo().RegMainTradingPlace(main_trading_place)

    def main_trading_place(self, ins):
        """if the AdditionalInfo or the AdditionalInfoSpec does
         not exist, return the inferred MainTradingPlace value"""
        return FRegulatoryLib.InstrumentRegInfo(ins).main_trading_place()

    def sftr_security_type(self, ins):
        """if the AdditionalInfo or the AdditionalInfoSpec does
         not exist, return the inferred SFTRSecurityType value"""
        return FRegulatoryLib.InstrumentRegInfo(ins).sftr_security_type()

    def sftr_security_type_getter(self, ins):
        """get the value of the sFTRSecurityType AdditionalInfo value
         if present, else get it from ProviderData if available"""
        SFTR_security_type = ''
        if self.checkAddInfoValueExists(ins, 'regSFTRSecurityType',\
                                         'instrument', ins.Name()):
            SFTR_security_type = ins.AdditionalInfo().RegSFTRSecurityType()
        if not SFTR_security_type:
            SFTR_security_type = self.sftr_security_type(ins)
        return SFTR_security_type

    def sftr_security_type_setter(self, ins, sftr_security_type):
        """set the value on the SFTRSecurityType AdditionalInfo"""
        ins.AdditionalInfo().RegSFTRSecurityType(sftr_security_type)

    def is_by_tenor(self, ins):
        """returns if the instrument is to be considered by Tenor or not"""
        return FRegulatoryLib.InstrumentRegInfo(ins).is_by_tenor()

    def is_government_guaranteed_tristate(self, ins):
        """returns the string value of the IsGovernmentGuaranteed True/False/None"""
        return self.get_tristate_string(FRegulatoryLib.InstrumentRegInfo(ins).is_government_guaranteed())

    def is_government_guaranteed_boolean(self, ins):
        """returns the boolean value of the IsGovernmentGuaranteed True/False"""
        return self.get_tristate_boolean(FRegulatoryLib.InstrumentRegInfo(ins).is_government_guaranteed())

    def is_covered_tristate(self, ins):
        """returns the string value of the IsCovered True/False/None"""
        return self.get_tristate_string(FRegulatoryLib.InstrumentRegInfo(ins).is_covered())

    def is_covered_boolean(self, ins):
        """returns the boolean value of the IsCovered True/False"""
        return self.get_tristate_boolean(FRegulatoryLib.InstrumentRegInfo(ins).is_covered())

    def is_government_guaranteed_t_getter(self, ins):
        """returns the string value of the IsGovernmentGuaranteed True/False/None"""
        return self.get_tristate_string(self.is_government_guaranteed_getter(ins))

    def is_government_guaranteed_t_setter(self, ins, is_govt_guaranteed):
        """set the value on the IsGovtGuaranteed AdditionalInfo with the string value True/False/None provided"""
        ins.AdditionalInfo().RegIsGovtGuaranteed(FRegulatoryLibUtils.get_tristate_choiceList(is_govt_guaranteed))

    def is_government_guaranteed_b_getter(self, ins):
        """returns the boolean value of the IsGovernmentGuaranteed True/False"""
        return self.get_tristate_boolean(self.is_government_guaranteed_getter(ins))

    def is_government_guaranteed_b_setter(self, ins, is_govt_guaranteed):
        """set the value on the IsGovtGuaranteed AdditionalInfo with the boolean value True/False provided"""
        ins.AdditionalInfo().RegIsGovtGuaranteed(FRegulatoryLibUtils.get_tristate_choiceList(is_govt_guaranteed))

    def is_covered_t_getter(self, ins):
        """returns the string value of the IsCovered True/False/None"""
        return self.get_tristate_string(self.is_covered_getter(ins))

    def is_covered_t_setter(self, ins, is_covered):
        """set the value on the IsCovered AdditionalInfo with the string value True/False/None provided"""
        ins.AdditionalInfo().RegIsCovered(FRegulatoryLibUtils.get_tristate_choiceList(is_covered))

    def is_covered_b_getter(self, ins):
        """returns thee boolean value of the IsCovered True/False"""
        return self.get_tristate_boolean(self.is_covered_getter(ins))

    def is_covered_b_setter(self, ins, is_covered):
        """set the value on the IsCovered AdditionalInfo with the boolean value True/False provided"""
        ins.AdditionalInfo().RegIsCovered(FRegulatoryLibUtils.get_tristate_choiceList(is_covered))

    def has_standard_term(self, ins):
        """returns the value of HasStandardTerm for the instrument"""
        return self.has_standard_term_getter(ins)

    def has_standard_term_tristate(self, ins):
        """returns the string value of the IsCovered True/False/None"""
        return self.get_tristate_string(self.has_standard_term(ins))

    def has_standard_term_boolean(self, ins):
        """returns the boolean value of the IsCovered True/False"""
        return self.get_tristate_boolean(self.has_standard_term(ins))

    def has_standard_term_getter(self, ins):
        """get the value of the hasStandardTerm AdditionalInfo
         value if present, else infer it"""
        has_standard_term_val = None
        if self.checkAddInfoValueExists(ins, 'regHasStandardTerm', 'instrument', ins.Oid()):
            has_standard_term_val = ins.AdditionalInfo().RegHasStandardTerm()
        has_standard_term_val = FRegulatoryLibUtils.get_tristate_choiceList(has_standard_term_val)
        return has_standard_term_val

    def has_standard_term_setter(self, ins, has_standard_term_val):
        """set the given has standard term value on the instrument"""
        ins.AdditionalInfo().RegHasStandardTerm(FRegulatoryLibUtils.get_tristate_choiceList(has_standard_term_val))

    def has_standard_term_t_getter(self, ins):
        """returns the string value of the HasStandardTerm True/False/None"""
        return self.get_tristate_string(self.has_standard_term_getter(ins))

    def has_standard_term_b_getter(self, ins):
        """returns the boolean value of the HasStandardTerm True/False"""
        return self.get_tristate_string(self.has_standard_term_getter(ins))

    def has_standard_term_t_setter(self, ins, has_standard_term):
        """set the value on the HasStandardTerm AdditionalInfo with the string value True/False/'' provided"""
        ins.AdditionalInfo().RegHasStandardTerm(FRegulatoryLibUtils.get_tristate_choiceList(has_standard_term))

    def has_standard_term_b_setter(self, ins, has_standard_term):
        """set the value on the HasStandardTerm AdditionalInfo with the boolean value True/False provided"""
        ins.AdditionalInfo().RegHasStandardTerm(FRegulatoryLibUtils.get_tristate_choiceList(has_standard_term))

    def sftr_day_count_method(self, ins):
        return FRegulatoryLib.SFTRLib(ins).sftr_day_count_method()

    def implied_volatility(self, ins):
        """returns the implied volatility on the trade"""
        return FRegulatoryLib.MMSLib(ins).implied_volatility()
    
    def delta(self, ins):
        """returns the delta on the instrument"""
        return FRegulatoryLib.MMSLib(ins).delta()
    
    def current_spread(self, ins):
        """returns the current spread on the instrument"""
        return FRegulatoryLib.MMSLib(ins).current_spread()
            
class tradeWrapper(wrapper):
    """wrapper class for all APIs related to FTrade"""
    def is_short_sell(self, trd):
        isshort_sell = ''
        if trd.ShortSellIndicator():
            if 'Short' in  trd.ShortSellIndicator().Name():
                isshort_sell = True
            else:
                isshort_sell = False
        return FRegulatoryLibUtils.get_tristate_choiceList(isshort_sell)

    def is_cleared_getter(self, trd):
        """get the value of the IsCleared AdditionalInfo
         value if present, else infer it"""
        is_cleared_val = None
        if self.checkAddInfoValueExists(trd, 'regIsCleared', 'trade', trd.Oid()):
            is_cleared_val = trd.AdditionalInfo().RegIsCleared()
        else:
            is_cleared_val = self.is_cleared(trd)
        return is_cleared_val

    def is_cleared_setter(self, trd, is_cleared_val):
        """set the value on isCleared AdditionalInfo"""
        trd.AdditionalInfo().RegIsCleared(is_cleared_val)

    def is_cleared(self, trd):
        """if the AdditionalInfo or the AdditionalInfoSpec does
         not exist, return the inferred the IsCleared value"""
        return FRegulatoryLib.TradeRegInfo(trd).is_cleared()

    def sftr_is_collateral_provider_t_getter(self, trd):
        """returns True/False/None Tristate value depending upon whether the trade is a collateral provider or not"""
        return self.get_tristate_string(self.sftr_is_collateral_provider_getter(trd))

    def sftr_is_collateral_provider_t_setter(self, trd, collateral_provider):
        """sets the tristate value on the trade to whether it is a collateral provider or not"""
        trd.AdditionalInfo().RegIsCollatrlPrvdr(FRegulatoryLibUtils.get_tristate_choiceList(collateral_provider))

    def notional_amount(self, trd):
        """returns the notional amount on the trade"""
        return FRegulatoryLib.TradeRegInfo(trd).notional_amount()

    def master_agreement_type(self, trd):
        """returns the master agreemnent type of the trade"""
        return FRegulatoryLib.TradeRegInfo(trd).master_agreement_type()

    def sftr_is_collateral_provider_b_getter(self, trd):
        """returns True/False boolean value depending upon whether the trade is a collateral provider or not"""
        return self.get_tristate_boolean(self.sftr_is_collateral_provider_getter(trd))

    def sftr_is_collateral_provider_b_setter(self, trd, collateral_provider):
        """sets the boolean value on the trade to whether it is a collateral provider or not"""
        trd.AdditionalInfo().RegIsCollatrlPrvdr(FRegulatoryLibUtils.get_tristate_choiceList(collateral_provider))

    def sftr_is_collateral_provider_tristate(self, trd):
        """returns the string value of the IsCollateralProvider True/False/None"""
        is_collateral_provider = FRegulatoryLib.TradeRegInfo(trd).sftr_is_collateral_provider()
        return self.get_tristate_string(is_collateral_provider)

    def sftr_is_collateral_provider_boolean(self, trd):
        """returns the boolean value of the IsCollateralProvider True/False"""
        is_collateral_provider = FRegulatoryLib.TradeRegInfo(trd).sftr_is_collateral_provider()
        return self.get_tristate_boolean(is_collateral_provider)

    def sftr_is_collateral_provider(self, trd):
        """if the AdditionalInfo or the AdditionalInfoSpec does
         not exist, return the inferred the SFTRIsCollateralProvider value"""
        return FRegulatoryLib.TradeRegInfo(trd).sftr_is_collateral_provider()

    def sftr_is_collateral_provider_getter(self, trd):
        """get the value of the isCollateralProvdr AdditionalInfo
         value if present, else get it from ProviderData if available"""
        is_collateral_proivder_val = None
        if self.checkAddInfoValueExists(trd, 'regIsCollatrlPrvdr', 'trade', trd.Name()):
            is_collateral_proivder_val = trd.AdditionalInfo().RegIsCollatrlPrvdr()
            is_collateral_proivder_val = FRegulatoryLibUtils.get_tristate_choiceList(is_collateral_proivder_val)
        if not is_collateral_proivder_val:
            is_collateral_proivder_val = self.sftr_is_collateral_provider(trd)
        return is_collateral_proivder_val

    def sftr_is_collateral_provider_setter(self, trd, is_coll_provider_val):
        """set the value on the IsCollateralProvdr AdditionalInfo"""
        trd.AdditionalInfo().RegIsCollatrlPrvdr(is_coll_provider_val)

    def sftr_type(self, trd):
        """returns the sftr type of the trade"""
        return FRegulatoryLib.SFTRLib(trd).sftr_type()

    def sftr_type_getter(self, trd):
        """get the value of the sFTTRype AdditionalInfo value
         if present, else get it from fallback"""
        sf_type = ''
        if self.checkAddInfoValueExists(trd, 'regSFTRType',\
                                         'trade', trd.Name()):
            sf_type = trd.AdditionalInfo().RegSFTRType()
        if not sf_type:
            sf_type = self.sftr_type(trd)
        return sf_type

    def sftr_type_setter(self, trd, sftype_val):
        """set the value on the SFTRType AdditionalInfo"""
        trd.AdditionalInfo().RegSFTRType(sftype_val)

    def sftr_asset(self, trd):
        """retuns the sftr asset type of the trade"""
        return FRegulatoryLib.SFTRLib(trd).sftr_asset_type()

    def sftr_asset_getter(self, trd):
        """get the value of the sFTRAsset AdditionalInfo value
         if present, else get it from fallback"""
        sftr_asset = ''
        if self.checkAddInfoValueExists(trd, 'regSFTRAsset',\
                                         'trade', trd.Name()):
            sftr_asset = trd.AdditionalInfo().RegSFTRAsset()
        if not sftr_asset:
            sftr_asset = self.sftr_asset(trd)
        return sftr_asset

    def sftr_asset_setter(self, trd, sftr_asset_val):
        """set the value on the SFTRAsset AdditionalInfo"""
        trd.AdditionalInfo().SFTRAsset(sftr_asset_val)

    def sftr_security_quality(self, trd):
        """returns the sftr security quality of the trade"""
        return FRegulatoryLib.SFTRLib(trd).sftr_security_quality()

    def sftr_security_quality_getter(self, trd):
        """get the value of the regSFTRSecurityQlty AdditionalInfo value
         if present, else get it from fallback"""
        sftr_security_quality = ''
        if self.checkAddInfoValueExists(trd, 'regSFTRSecurityQlty',\
                                         'trade', trd.Name()):
            sftr_security_quality = trd.AdditionalInfo().RegSFTRSecurityQlty()
        if not sftr_security_quality:
            sftr_security_quality = self.sftr_security_quality(trd)
        return sftr_security_quality

    def sftr_security_quality_setter(self, trd, sec_qlty_val):
        """set the value on the regSFTRSecurityQlty AdditionalInfo"""
        trd.AdditionalInfo().RegSFTRSecurityQlty(sec_qlty_val)

    def product_sub_group_getter(self, trd):
        """get the value of the regProductSubGroup AdditionalInfo value
         if present, else get it from fallback"""
        product_sub_group = ''
        if self.checkAddInfoValueExists(trd, 'regProductSubGroup',\
                                         'trade', trd.Name()):
            product_sub_group = trd.AdditionalInfo().RegProductSubGroup()
        if not product_sub_group:
            product_sub_group = self.product_sub_group(trd)
        return product_sub_group

    def product_sub_group_setter(self, trd, product_sub_group_val):
        """set the value on the regProductSubGroup AdditionalInfo"""
        trd.AdditionalInfo().RegProductSubGroup(product_sub_group_val)

    def product_sub_group(self, trd):
        """returns the prodcut sub group of the trade"""
        return FRegulatoryLib.MMSLib(trd).product_sub_group()

    def asset_class_getter(self, trd):
        """get the value of the regAssetClass AdditionalInfo value
         if present, else get it from fallback"""
        asset_class = ''
        if self.checkAddInfoValueExists(trd, 'regAssetClass',\
                                         'trade', trd.Name()):
            asset_class = trd.AdditionalInfo().RegAssetClass()
        if not asset_class:
            asset_class = self.asset_class(trd)
        return asset_class

    def asset_class_setter(self, trd, asset_class_val):
        """set the value on the regAssetClass AdditionalInfo"""
        trd.AdditionalInfo().RegAssetClass(asset_class_val)

    def asset_class(self, trd):
        """returns the asset class of the trade"""
        return FRegulatoryLib.MMSLib(trd).asset_class()

...

  FRegulatoryLogger
"""------------------------------------------------------------------------
MODULE
    FRegulatoryLogger -
DESCRIPTION:
    This file is used for logging all messages within the component
VERSION: 1.0.29(0.1.1278)
RESTRICTIONS/ LIMITATIONS:
    1. Any modifications to the scripts/ encrypted modules/ clear text code within the core is not supported. 
    2. This module is not customizable
    3. The component may not work as expected with any modifications done to this module at user end 
--------------------------------------------------------------------------"""
from FLogger import FLogger
import FRegulatoryConfigParam


logger = None
bNotification = False
try:
    notifier = None
    import FANotification
    bNotification = True
except:
    pass

def getLogger(verbosityLevel, loggerName):
    global logger    
    if not logger:        
        logger = FLogger.HasLogger(name=loggerName)
    if not logger:
        logger = FLogger(name=loggerName, level= verbosityLevel, keep= False, logOnce=False,
                  logToConsole=True, logToPrime=False,
                  logToFileAtSpecifiedPath=False, filters=None)        
    if logger.Level() !=  verbosityLevel:            
            logger = logger.Reinitialize(level= verbosityLevel, keep= False, logOnce=False,
                  logToConsole=True, logToPrime=False,
                  logToFileAtSpecifiedPath=False, filters=None)            
    return logger

def createLogMessage(sourceFile, message, param):    
    if param != "":        
        if param.find(':') != -1:
            param_tuple = param.split(':')
            i = 0
            while i < len(param_tuple):
                str_replace = '<%s>'
                if i > 0:
                    str_replace = '<%s' + str(i) + '>'
                message = message.replace(str_replace, param_tuple[i])
                i = i + 1
        else:
            message = message.replace('%s', param)
    message = sourceFile + ": " + message
    return message

def LogMessage(funcCall, msg):
    config_parameters = FRegulatoryConfigParam.FRegulatoryConfigParam()
    global logger
    if not config_parameters.get_paramvalue('FREGULATORY_VERBOSITY_LEVEL'):
        config_parameters.set_paramvalue('FREGULATORY_VERBOSITY_LEVEL', 2)
    global notifier
    bTrace = 0
    if bNotification and config_parameters.get_paramvalue('FREGULATORY_NOTIFICATION_MEDIA') != 'OFF':
        log_level = config_parameters.get_paramvalue('FREGULATORY_MESSAGE_VERBOSE')
        if log_level == 'WARNING':
            log_level = 'WARN'
        notifier = FANotification.FANotification(name = config_parameters.get_paramvalue('FREGULATORY_LOGGER_NAME'), \
                                                 notification_media = config_parameters.get_paramvalue('FREGULATORY_NOTIFICATION_MEDIA'), \
                                                 notify_level = config_parameters.get_paramvalue('FREGULATORY_NOTIFY_LEVEL'), \
                                                 logging_level = log_level, \
                                                 message_broker = config_parameters.get_paramvalue('FREGULATORY_NOTIFICATION_MESSAGE_BROKER'), \
                                                 user = config_parameters.get_paramvalue('FREGULATORY_NOTIFY_USERS'), \
                                                 user_emails = config_parameters.get_paramvalue('FREGULATORY_USER_EMAILS'), \
                                                 smtp_server = config_parameters.get_paramvalue('FREGULATORY_SMTP_SERVER'))
        if funcCall == 'ERROR':
            if 'DEBUG' == config_parameters.get_paramvalue('FREGULATORY_MESSAGE_VERBOSE').strip():
                bTrace = 1
            notifier.ERROR(msg, exc_info = bTrace)
        elif funcCall == 'DEBUG':
            notifier.DEBUG(msg)
        elif funcCall == 'WARN':
            notifier.WARN(msg)
        elif funcCall == 'INFO':
            notifier.INFO(msg)
    else:
        notifier = getLogger(config_parameters.get_paramvalue('FREGULATORY_VERBOSITY_LEVEL'), \
                       config_parameters.get_paramvalue('FREGULATORY_LOGGER_NAME'))
        if 'DEBUG' == config_parameters.get_paramvalue('FREGULATORY_MESSAGE_VERBOSE').strip():
            bTrace = 1
        if funcCall == 'ERROR':
            notifier.ELOG(msg, exc_info = bTrace)
        elif funcCall == 'DEBUG':
            notifier.DLOG(msg)
        elif funcCall == 'WARN':
            notifier.WLOG(msg)
        elif funcCall == 'INFO':
            notifier.LOG(msg)

def DEBUG(sourceFile, msg, param = ''):
    msg = createLogMessage(sourceFile, msg, param)        
    LogMessage('DEBUG', msg)

def INFO(sourceFile, msg, param = ''):
    msg = createLogMessage(sourceFile, msg, param)    
    LogMessage('INFO', msg)

def ERROR(sourceFile, msg, param = ''):
    msg = createLogMessage(sourceFile, msg, param)    
    LogMessage('ERROR', msg)

def WARN(sourceFile, msg, param = ''):
    msg = createLogMessage(sourceFile, msg, param)    
    LogMessage('WARN', msg)


...

  FRegulatoryNotionalAmount
"""------------------------------------------------------------------------
MODULE
    FRegulatoryNotionalAmount -
DESCRIPTION:
    This file consists of the functions to infer the NotionalAmount for trades
VERSION: 1.0.29(0.1.1278)
RESTRICTIONS/ LIMITATIONS:
    1. Any modifications to the scripts/ encrypted modules/ clear text code within the core is not supported. 
    2. This module is not customizable
    3. The component may not work as expected with any modifications done to this module at user end
--------------------------------------------------------------------------"""
import acm
import FRegulatoryLogger

calc_space = None
calc_space_collection = acm.FCalculationSpaceCollection()
gridBuilderConfig = acm.Report.CreateDealGridConfiguration(False, True, True)
logger = 'FRegulatoryNotionalAmount'


class FRegulatoryNotionalAmount(object):
    def __init__(self, trade):
        self.__trade = trade
        self.__instrument = trade.Instrument()
    # -------------------------------- API's based on InsType, returning Notional amount ----------------------------
    def Warrant(self):
        """API for notional amount calculation for InsType: Warrant"""
        return self._notional_amount_based_on_quantity_contractsize_strikeprice()

    def _trade_premium(self):
        return self.__trade.Premium()

    def _trade_nominal(self):
        """Covering Instrument types: 'Bill', 'Bond', 'Convertible', 'Zero', 'FRN', 'IndexLinkedBond', 
        'PromisLoan', 'DualCurrBond', 'Flexi_Bond', 'CD', 'FRA', 'MBS_ABS', 'CLN', 'BasketSecurityLoan', 
        'BuySellback', 'Cap', 'Floor', 'Deposit_Loan', 'IndexLinkedSwap', 'CreditDefaultSwap', 
        'CurrSwap', 'FX_Option', 'TotalReturnSwap', Certificate, Swap for notional amount calculation"""
        return self._notional_amount_based_on_nominal()

    def _trade_remaining_premium(self):
        """Covering Instrument types: 'PriceSwap', 'FXOptionDatedFwd', 'Average_Future_Forward' for notional amount calculation"""
        return self._notional_amount_based_on_remaining_premium()

    def _trade_notional_on_start_cash(self):
        """Covering Instrument types: 'Repo_Reverse', 'BasketRepo_Reverse' for notional amount calculation"""
        return self._notional_amount_based_on_start_cash()

    def CFD(self):
        """API for notional amount calculation for InsType: CFD"""
        notional_amount = None
        if self.__instrument.Underlying():
            if self.__instrument.Underlying().InsType() in ['Stock', 'Depository Receipt', 'EquityIndex', 'Warrant', 'ETF']:
                notional_amount = self._notional_amount_based_on_remaining_premium()
            if self.__instrument.Underlying().InsType() == 'Bond':
                notional_amount = self._notional_amount_based_on_underlyernominal_remainingpremium()
        return notional_amount

    def Future_Forward(self):
        """API for notional amount calculation for InsType: Future_Forward"""
        notional_amount = None
        if self.__instrument.Underlying():
            if self.__instrument.Underlying().InsType() in ['CurrSwap', 'Swap', 'Average Future/Forward', 'CreditDefaultSwap', 'Deposit', 'FRA', \
                    'FreeDefCF', 'Future/Forward', 'RateIndex', 'Combination']:
                notional_amount = self._notional_amount_based_on_nominal()
            elif self.__instrument.Underlying().InsType() in ['Bill', 'Bond', 'Convertible', 'Zero','CLN', 'FRN','IndexLinkedBond','PromisLoan']:
                notional_amount = self._notional_amount_based_on_underlyernominal_remainingpremium()
            elif self.__instrument.Underlying().InsType() in ['Curr', 'Commodity', 'Commodity Variant', \
                    'Commodity Index', 'ETF', 'Dividend Point Index', 'Stock', 'Depository Receipt', \
                    'EquityIndex']:
                notional_amount = self._notional_amount_based_on_remaining_premium()
        return notional_amount

    def Option(self):
        """API for notional amount calculation for InsType: Option"""
        notional_amount = None
        if self.__instrument.Underlying():
            if self.__instrument.Underlying().InsType() in ['Commodity', 'Commodity Variant', \
                    'Commodity Index', 'ETF', 'EquityIndex', 'Stock', 'Depositary Receipt']: #no extra
                notional_amount = self._notional_amount_based_on_quantity_contractsize_strikeprice()
            
            elif self.__instrument.Underlying().InsType() in ['Swap', 'CurrSwap']:
                notional_amount = self._notional_amount_based_on_underlyernominal_quantity()
            elif self.__instrument.Underlying().InsType() == 'CreditDefaultSwap':
                #if self.__instrument.Underlying().Underlying(): 
                #    if self.__instrument.Underlying().Underlying().InsType() in ['CreditIndex', 'Bill', 'Bond', \
                #        'Convertible','Zero', 'FRN', 'IndexLinkedBond', 'PromisLoan']:
                notional_amount = self._notional_amount_based_on_underlyernominal_quantity()
            elif self.__instrument.Underlying().InsType() in ['Bill', 'Bond', 'Convertible', 'Zero', 'CLN', 'FRN',\
                                                              'IndexLinkedBond', 'PromisLoan']:
                notional_amount = self._notional_amount_based_on_quantity_contractsize_strikeprice_underlyernominal()
            else:#'RateIndex', 'Curr', 'Combination'
                notional_amount = self._notional_amount_based_on_nominal()#defaulting it to the trade nominal
        return notional_amount

    # -------------------------------------------------------------Calculation API's-----------------------------------------------------------------------------------
    def _notional_amount_based_on_nominal(self):
        """API to calculate Notional Amount, where notional amount = nominal """
        nominal, error_msg = self._nominal()
        if error_msg:
            raise Exception('Cannot infer NominalAmount for trade <%d>. Error : <%s>.' % (self.__trade.Oid(), error_msg))
        return nominal

    def _notional_amount_based_on_start_cash(self):
        """API to calculate Notional Amount, where notional_amount = start_cash"""
        start_cash, error_msg = self._start_cash()
        if error_msg:
            raise Exception(
                'Cannot infer Nominal Amount for trade <%d>. Error : <%s>.' % (self.__trade.Oid(), error_msg))
        return start_cash

    def _notional_amount_based_on_remaining_premium(self):
        """API to calculate Notional Amount, where notional amount = remaining premium
             Followed for instrument types like: [PriceSwap', 'FXOptionDatedFwd', 'Average_Future_Forward']"""
        remaining_premium, error_msg = self._remaining_premium()
        if error_msg:
            raise Exception(
                'Cannot infer NominalAmount for trade <%d>. Error : <%s>.' % (self.__trade.Oid(), error_msg))
        return remaining_premium

    def _notional_amount_based_on_quantity_contractsize_strikeprice(self):
        """API to calculate Notional Amount, where notional amount = quantity * contract_size * strike_price
            Followed for instrument types like: [Option, Warrant] """
        err_msg = ''
        notional_amount = None
        contract_size, error_msg = self._contract_size()
        err_msg = err_msg + '\n' + error_msg
        strike_price, error_msg = self._absolute_strike_price()
        err_msg = err_msg + '\n' + error_msg
        quantity, error_msg = self._quantity()
        err_msg = err_msg + '\n' + error_msg
        err_msg = err_msg.strip()
        if err_msg:
            raise Exception('Cannot infer NominalAmount for trade <%d>. Error : <%s>.' % (self.__trade.Oid(), err_msg))
        try:
            notional_amount = quantity * contract_size * strike_price
        except Exception as e:
            raise Exception('Cannot calculate notional amount for trade <%d>. Error : <%s>.' % (self.__trade.Oid(), e))
        return notional_amount

    def _notional_amount_based_on_quantity_contractsize_strikeprice_underlyernominal(self):
        """API to calculate Notional Amount, where notional_amount = quantity * contract_size * strike_price * nominal_underlying
            Followed for instrument types like: [Option] """
        err_msg = ''
        notional_amount = None
        contract_size, error_msg = self._contract_size()
        err_msg = err_msg + '\n' + error_msg
        strike_price, error_msg = self._absolute_strike_price()
        err_msg = err_msg + '\n' + error_msg
        quantity, error_msg = self._quantity()
        err_msg = err_msg + '\n' + error_msg
        nominal_underlying, error_msg = self._nominal_underlying()
        err_msg = err_msg + '\n' + error_msg
        err_msg = err_msg.strip()
        if err_msg:
            raise Exception('Cannot infer Notional Amount for trade <%d>. Error : <%s>.' % (self.__trade.Oid(), err_msg))
        try:
            notional_amount = quantity * contract_size * strike_price * nominal_underlying
        except Exception as e:
            raise Exception('Cannot calculate Notional Amount for trade <%d>. Error : <%s>.' % (self.__trade.Oid(), e))
        return notional_amount

    def _notional_amount_based_on_underlyernominal_remainingpremium(self):
        """API to calculate Notional Amount, where notional_amount = remaining_premium * underlyer_nominal
            Followed for instrument types like: [CFD, Future/Forward] """
        err_msg = ''
        notional_amount = None
        remaining_premium, error_msg = self._remaining_premium()
        err_msg = err_msg + '\n' + error_msg
        underlyer_nominal, err_msg = self._nominal_underlying()
        err_msg = err_msg + '\n' + error_msg
        err_msg = err_msg.strip()
        if err_msg:
            raise Exception('Cannot infer Nominal Amount for trade <%d>. Error : <%s>.' % (self.__trade.Oid(), err_msg))
        try:
            notional_amount = remaining_premium * underlyer_nominal
        except Exception as e:
            raise Exception('Cannot calculate Notional Amount for trade <%d>. Error : <%s>.' % (self.__trade.Oid(), e))
        return notional_amount

    def _notional_amount_based_on_underlyernominal_quantity(self):
        """API to calculate Notional Amount, where notional_amount = underlyer_nominal * quantity
            Followed for instrument types like: [Option] """
        err_msg = ''
        notional_amount = None
        underlyer_nominal, error_msg = self._nominal_underlying()
        err_msg = err_msg + '\n' + error_msg
        quantity, error_msg = self._quantity()
        err_msg = err_msg + '\n' + error_msg
        err_msg = err_msg.strip()
        if err_msg:
            raise Exception('Cannot infer Nominal Amount for trade <%d>. Error : <%s>.' % (self.__trade.Oid(), err_msg))
        elif underlyer_nominal and quantity:
            try:
                notional_amount = underlyer_nominal * quantity
            except Exception as e:
                raise Exception('Cannot calculate Notional Amount for trade <%d>. Error : <%s>.' % (self.__trade.Oid(), e))
        return notional_amount

    # ------------------------------------------------------------- API's for retrieving field values --------------------------------------------------------------------------------

    def _nominal_underlying(self):
        """Retrieve nominal value of underlying instrument for instrument on given trade"""
        nominal_underlying = None
        err_msg = ''
        try:
            nominal_underlying = self.__instrument.Underlying().NominalAmount()
            msg = "Retrieved Nominal <%d> of underlying instrument <%s> for Notional calculation for trade <%d>." % (
            nominal_underlying, self.__instrument.Name(), self.__trade.Oid())
            if nominal_underlying == 0:
                FRegulatoryLogger.WARN(logger, msg + ' Hence Nominal inferred will also be zero.')
            else:
                FRegulatoryLogger.DEBUG(logger, msg)
        except Exception as e:
            err_msg = "Error while accessing Nominal of underlying instrument <%s> for trade <%s>. Error: <%s>." % (
            self.__instrument.Name(), self.__trade.Oid(), str(e))
            FRegulatoryLogger.ERROR(logger, err_msg)
        return nominal_underlying, err_msg

    def _contract_size(self):
        """Retrieve value of contract size of instrument for given trade """
        contract_size = None
        err_msg = ''
        try:
            contract_size = self.__instrument.ContractSize()
            msg = "Retrieved ContractSize <%d> of instrument <%s> for Notional calculation for trade <%d>." % (
            contract_size, self.__instrument.Name(), self.__trade.Oid())
            if contract_size == 0:
                FRegulatoryLogger.WARN(logger, msg + ' Hence Nominal inferred will also be zero.')
            else:
                FRegulatoryLogger.DEBUG(logger, msg)
        except Exception as e:
            err_msg = "Error while accessing ContractSize of instrument <%s> for trade <%s>. Error: <%s>." % (
            self.__instrument.Name(), self.__trade.Oid(), str(e))
            FRegulatoryLogger.ERROR(logger, err_msg)
        return contract_size, err_msg

    def _nominal(self):
        """Retrieve nominal value for given trade """
        nominal = None
        err_msg = ''
        try:
            nominal = self.__trade.Nominal()
            msg = "Retrieved Nominal <%d> for Notional calculation for trade <%d>." % (nominal, self.__trade.Oid())
            if nominal == 0:
                FRegulatoryLogger.WARN(logger, msg + 'Hence Nominal inferred will also be zero.')
            else:
                FRegulatoryLogger.DEBUG(logger, msg)
        except Exception as e:
            err_msg = "Error while accessing Nominal for trade <%s>. Error: <%s>." % (self.__trade.Oid(), str(e))
            FRegulatoryLogger.ERROR(logger, err_msg)
        return nominal, err_msg

    def _start_cash(self):
        """Retrieve startcash value for given trade"""
        start_cash = None
        err_msg = ''
        try:
            start_cash = self.__trade.StartCash()
            msg = "Retrieved StartCash <%d> for Notional calculation for trade <%d>." % (start_cash, self.__trade.Oid())
            if start_cash == 0:
                FRegulatoryLogger.WARN(logger, msg + 'Hence Nominal inferred will also be zero.')
            else:
                FRegulatoryLogger.DEBUG(logger, msg)
        except Exception as e:
            err_msg = "Error while accessing StartCash for trade <%s>. Error: <%s>." % (self.__trade.Oid(), str(e))
            FRegulatoryLogger.ERROR(logger, err_msg)
        return start_cash, err_msg

    def _absolute_strike_price(self):
        """Retrieve absolute strike price value of instrument for given trade"""
        absolute_strike_price = None
        err_msg = ''
        try:
            absolute_strike_price = acm.GetCalculatedValueFromString(acm.FInstrument[self.__instrument.Name()],
                                                                     acm.GetDefaultContext(), "absoluteStrikePrice",
                                                                     None).Value().Number()
            msg = "Retrieved AbsoluteStrikePrice <%d> of instrument <%s> for Notional calculation for trade <%d>" % (\
                absolute_strike_price, self.__instrument.Name(), self.__trade.Oid())
            if absolute_strike_price == 0:
                FRegulatoryLogger.WARN(logger, msg + 'Hence Nominal inferred will also be zero.')
            else:
                FRegulatoryLogger.DEBUG(logger, msg)
        except Exception as e:
            err_msg = "Error while accessing AbsoluteStrikePrice of instrument <%s> for trade <%s>. Error: <%s>." % (
            self.__instrument.Name(), self.__trade.Oid(), str(e))
            FRegulatoryLogger.ERROR(logger, err_msg)
        return absolute_strike_price, err_msg

    def _quantity(self):
        """Retrieve quantity value from trade"""
        quantity = None
        err_msg = ''
        try:
            quantity = self.__trade.Quantity()
            msg = "Retrieved Quantity <%d> for Notional calculation for trade <%d>." % (quantity, self.__trade.Oid())
            if quantity == 0:
                FRegulatoryLogger.WARN(logger, msg + 'Hence Nominal inferred will also be zero.')
            else:
                FRegulatoryLogger.DEBUG(logger, msg)
        except Exception as e:
            err_msg = "Error while accessing Quantity for trade <%s>. Error: <%s>." % (self.__trade.Oid(), str(e))
            FRegulatoryLogger.ERROR(logger, err_msg)
        return quantity, err_msg

    def _trade_quantity(self):
        """trade quantity as notinal in case of fxSwaps"""
        notional, err_msg = self._quantity()
        if err_msg:
            raise Exception('Cannot infer Notional Amount for trade <%d>. Error : <%s>.' % (self.__trade.Oid(), err_msg))
        return notional

    def _remaining_premium(self):
        """Retrieve remaining premium value for given trade"""
        remaining_premium = None
        err_msg = ''
        global calc_space
        global gridBuilderConfig
        global calc_space_collection
        if calc_space:
            calc_space.Clear()
        calc_space_collection.Clear()
        calc_space = calc_space_collection.GetSpace('FDealSheet', acm.GetDefaultContext(), gridBuilderConfig)
        try:
            remaining_premium = calc_space.CalculateValue(self.__trade, 'Remaining Premium').Number()
            msg = "Retrieved RemainingPremium <%d> for Notional calculation for trade <%d>." % (remaining_premium, self.__trade.Oid())
            if remaining_premium == 0:
                FRegulatoryLogger.WARN(logger, msg + 'Hence Nominal inferred will also be zero.')
            else:
                FRegulatoryLogger.DEBUG(logger, msg)
        except Exception as e:
            err_msg = "Error while accessing RemainingPremium for trade <%s>. Error: <%s>." % (self.__trade.Oid(), str(e))
            FRegulatoryLogger.ERROR(logger, err_msg)
        return remaining_premium, err_msg

    # ------------------------------------------------------------- API for Notional Amount -----------------------------------------------------------------------------------
    def notional_amount(self):
        """Returns notional amount for given trade"""
        instrument_type = self.__instrument.InsType()
        if instrument_type.find('/') != -1:
            instrument_type = instrument_type.replace('/', '_')
        if instrument_type.find(' ') != -1:
            instrument_type = instrument_type.replace(' ', '_')
        notional_amount = None
        try:
            if instrument_type in ['Bill', 'Convertible', 'Zero', 'FRN', 'IndexLinkedBond', 'PromisLoan',\
                                   'DualCurrBond', 'Flexi_Bond', 'CD', 'FRA', 'MBS_ABS', 'CLN', 'BasketSecurityLoan',\
                                   'BuySellback', 'Cap', 'Floor', 'Deposit', 'IndexLinkedSwap', \
                                   'CreditDefaultSwap', 'CurrSwap', 'FX_Option', 'TotalReturnSwap', 'Swap', 'Certificate']:
                instrument_type = '_trade_nominal'
            elif instrument_type in ['Bond']:
                instrument_type = '_trade_premium'
            elif instrument_type in ['PriceSwap', 'Average_Future_Forward']:
                instrument_type = '_trade_remaining_premium'
            elif instrument_type in ['Repo_Reverse', 'BasketRepo_Reverse']:
                instrument_type = '_trade_notional_on_start_cash'
            elif self.__trade.IsFxForward():
                if self.__trade.QuantityIsDerived():
                    instrument_type = '_trade_premium'
                else:
                    instrument_type = '_trade_quantity'
            elif (instrument_type == 'Curr' and self.__trade.IsFxSwap()) or \
                instrument_type in ['VarianceSwap', 'VolatilitySwap', 'FXOptionDatedFwd'] or \
                instrument_type == 'Future_Forward' and self.__instrument.Underlying().InsType() == 'Curr':
                instrument_type = '_trade_quantity'
            notional_amount = eval('self.' + instrument_type + '()')
        except Exception as e:
            if instrument_type in ['Combination', 'Commodity', 'Curr', 'Commodity_Index', 'Commodity_Variant',
                                   'Credit_Balance', 'CreditIndex', 'Depositary_Receipt', \
                                   'Dividend_Point_Index', 'ETF', 'EquityIndex', 'FreeDefCF', \
                                   'PriceIndex', 'RateIndex', 'Rolling_Schedule', 'SecurityLoan',\
                                   'Collateral', 'CreditIndex', 'Stock',\
                                   'Fund', 'Portfolio_Swap', 'Fx_Rate', 'Precious_Metal_Rate']:
                raise Exception('Trade Nominal calculation on instrument of type <%s> is currently not supported.' %self.__instrument.InsType())
            else:
                raise Exception('Cannot infer NominalAmount for trade <%d> with instrument type <%s>. Error : <%s>.' %(\
                self.__trade.Oid(), self.__instrument.InsType(), e))
        return notional_amount


...

  FRegulatorySupportAPIs
"""------------------------------------------------------------------------
MODULE
    FRegulatorySupportAPIs -
DESCRIPTION:
    This file consists of the Regulatory APIs that can be made available on different objects
VERSION: 1.0.29(0.1.1278)
RESTRICTIONS/ LIMITATIONS:
    1. Any modifications to the scripts/ encrypted modules/ clear text code within the core is not supported.
    2. This module is not customizable
    3. The component may not work as expected with any modifications done to this module at user end
--------------------------------------------------------------------------"""
import FRegulatoryLogger
import acm
import FRegulatoryUtils
logger = 'FRegulatorySupportAPIs'

addInfoSpecs = [
    {'FieldName': 'regIsCleared', 'Description': 'Identifier if the trade is cleared on clearing house or not',
     'Default': '', 'TypeGroup': 'Standard',
     'Type': 'Boolean', 'Table': 'Trade', },
    {'FieldName': 'regHiQltyLqdAsset',
     'Description': 'Categorization of a collateral to judge how willingly one would want to use as collateral. Values like 1, 2A, 2B, 3, NA.',
     'Default': '', 'TypeGroup': 'Standard',
     'Type': 'String', 'Table': 'Instrument', },
    {'FieldName': 'regCountryOfIssue', 'Description': 'country of issue of the instrument',
     'Default': '', 'TypeGroup': 'Standard',
     'Type': 'String', 'Table': 'Instrument', },
    {'FieldName': 'MoodysRating', 'Description': 'Moodys',
     'Default': '', 'TypeGroup': 'RecordRef',
     'Type': 'ChoiceList', 'Table': 'Instrument', },
    {'FieldName': 'MoodysShortRating', 'Description': 'MoodysShort',
     'Default': '', 'TypeGroup': 'RecordRef',
     'Type': 'ChoiceList', 'Table': 'Instrument', },
    {'FieldName': 'SnPRating', 'Description': 'S&P',
     'Default': '', 'TypeGroup': 'RecordRef',
     'Type': 'ChoiceList', 'Table': 'Instrument', },
    {'FieldName': 'SnPShortRating', 'Description': 'S&PShort',
     'Default': '', 'TypeGroup': 'RecordRef',
     'Type': 'ChoiceList', 'Table': 'Instrument', },
    {'FieldName': 'FitchRating', 'Description': 'Fitch',
     'Default': '', 'TypeGroup': 'RecordRef',
     'Type': 'ChoiceList', 'Table': 'Instrument', },
    {'FieldName': 'FitchShortRating', 'Description': 'FitchShort',
     'Default': '', 'TypeGroup': 'RecordRef',
     'Type': 'ChoiceList', 'Table': 'Instrument', },
    {'FieldName': 'DBRSRating', 'Description': 'DBRS',
     'Default': '', 'TypeGroup': 'RecordRef',
     'Type': 'ChoiceList', 'Table': 'Instrument', },
    {'FieldName': 'DBRSShortRating', 'Description': 'DBRSShort',
     'Default': '', 'TypeGroup': 'RecordRef',
     'Type': 'ChoiceList', 'Table': 'Instrument', },
    {'FieldName': 'MoodysRtg', 'Description': 'Moodys',
     'Default': '', 'TypeGroup': 'RecordRef',
     'Type': 'ChoiceList', 'Table': 'Party', },
    {'FieldName': 'MoodyShortRtg', 'Description': 'MoodysShort',
     'Default': '', 'TypeGroup': 'RecordRef',
     'Type': 'ChoiceList', 'Table': 'Party', },
    {'FieldName': 'SnPRtg', 'Description': 'S&P',
     'Default': '', 'TypeGroup': 'RecordRef',
     'Type': 'ChoiceList', 'Table': 'Party', },
    {'FieldName': 'SnPShortRtg', 'Description': 'S&PShort',
     'Default': '', 'TypeGroup': 'RecordRef',
     'Type': 'ChoiceList', 'Table': 'Party', },
    {'FieldName': 'FitchRtg', 'Description': 'Fitch',
     'Default': '', 'TypeGroup': 'RecordRef',
     'Type': 'ChoiceList', 'Table': 'Party', },
    {'FieldName': 'FitchShortRtg', 'Description': 'FitchShort',
     'Default': '', 'TypeGroup': 'RecordRef',
     'Type': 'ChoiceList', 'Table': 'Party', },
    {'FieldName': 'DBRSRtg', 'Description': 'DBRS',
     'Default': '', 'TypeGroup': 'RecordRef',
     'Type': 'ChoiceList', 'Table': 'Party', },
    {'FieldName': 'DBRSShortRtg', 'Description': 'DBRSShort',
     'Default': '', 'TypeGroup': 'RecordRef',
     'Type': 'ChoiceList', 'Table': 'Party', },
    {'FieldName': 'regBondType', 'Description': 'bond type of the instrument',
     'Default': '', 'TypeGroup': 'Standard',
     'Type': 'String', 'Table': 'Instrument', },
    {'FieldName': 'regCollateralType', 'Description': 'collateral type of the instrument',
     'Default': '', 'TypeGroup': 'Standard',
     'Type': 'String', 'Table': 'Instrument', },
    {'FieldName': 'regIsGovtGuaranteed', 'Description': 'Tristate',
     'Default': '', 'TypeGroup': 'RecordRef',
     'Type': 'ChoiceList', 'Table': 'Instrument', },
     {'FieldName': 'regHasStandardTerm', 'Description': 'Tristate',
     'Default': '', 'TypeGroup': 'RecordRef',
     'Type': 'ChoiceList', 'Table': 'Instrument', },
    {'FieldName': 'regIsCovered', 'Description': 'Tristate',
     'Default': '', 'TypeGroup': 'RecordRef',
     'Type': 'ChoiceList', 'Table': 'Instrument', },
    {'FieldName': 'regIsEquity', 'Description': 'Is the instrument of equity type',
     'Default': '', 'TypeGroup': 'Standard',
     'Type': 'Boolean', 'Table': 'Instrument', },
    {'FieldName': 'regIsCmdtyAllocated', 'Description': 'Is the commodity allocated',
     'Default': '', 'TypeGroup': 'Standard',
     'Type': 'Boolean', 'Table': 'Account', },
    {'FieldName': 'regTradeDepository', 'Description': 'Is Account depository',
     'Default': '', 'TypeGroup': 'RecordRef',
     'Type': 'Party', 'Table': 'Account', },
    {'FieldName': 'regFundType', 'Description': 'the fund type of the instrument',
     'Default': '', 'TypeGroup': 'Standard',
     'Type': 'String', 'Table': 'Instrument', },
    {'FieldName': 'regMainTradingPlace', 'Description': "the instrument's main trading place",
     'Default': '', 'TypeGroup': 'Standard',
     'Type': 'String', 'Table': 'Instrument', },
    {'FieldName': 'regSFTRSecurityType', 'Description': "SFTR Secutiry type of the instrument",
     'Default': '', 'TypeGroup': 'Standard',
     'Type': 'String', 'Table': 'Instrument', },
    {'FieldName': 'regOutStndingShares', 'Description': "outstanding shares required for collateral limits",
     'Default': '', 'TypeGroup': 'Standard',
     'Type': 'String', 'Table': 'Instrument', },
    {'FieldName': 'regIsCollatrlPrvdr', 'Description': 'Tristate',
     'Default': '', 'TypeGroup': 'RecordRef',
     'Type': 'ChoiceList', 'Table': 'Trade', },
    {'FieldName': 'regIssuerType', 'Description': 'Type of issuer of the instrument',
     'Default': '', 'TypeGroup': 'Standard',
     'Type': 'String', 'Table': 'Instrument', },
    {'FieldName': 'regIsCmdtyAllocated',
     'Description': 'Settlements, typically commodities and typically Precious Metals, will settle physically and from a specific depository.',
     'Default': '', 'TypeGroup': 'Standard',
     'Type': 'Boolean', 'Table': 'Account', },
    {'FieldName': 'regAssetClass', 'Description': 'asset class',
     'Default': '', 'TypeGroup': 'Standard',
     'Type': 'String', 'Table': 'Trade', },
    {'FieldName': 'regSFTRType', 'Description': 'SFTRType of the instrument of the trade',
     'Default': '', 'TypeGroup': 'Standard',
     'Type': 'String', 'Table': 'Trade', },
    {'FieldName': 'regProductSubGroup', 'Description': 'product sub group',
     'Default': '', 'TypeGroup': 'Standard',
     'Type': 'String', 'Table': 'Trade', },
    {'FieldName': 'regSFTRAsset', 'Description': 'classification of the asset in SFTR',
     'Default': '', 'TypeGroup': 'Standard',
     'Type': 'String', 'Table': 'Trade', },
    {'FieldName': 'regSFTRSecurityQlty', 'Description': 'SFTRSecurityQuality of the instrument of the trade',
     'Default': '', 'TypeGroup': 'Standard',
     'Type': 'String', 'Table': 'Trade', },
    {'FieldName': 'securityQuality', 'Description': 'security quality',
     'Default': '', 'TypeGroup': 'Standard',
     'Type': 'String', 'Table': 'Instrument', },
    {'FieldName': 'masterAgreementType',
     'Description': 'master agreement code translated into 4 character code in SFTR',
     'Default': '', 'TypeGroup': 'Standard',
     'Type': 'String', 'Table': 'Instrument', },
    {'FieldName': 'sFTRDayCountMethod', 'Description': 'SFTR code representing the DayCountConvention',
     'Default': '', 'TypeGroup': 'Standard',
     'Type': 'String', 'Table': 'Instrument', },
    {'FieldName': 'regEMIRCategory', 'Description': 'EMIR Category classification of a party',
     'Default': '', 'TypeGroup': 'Standard',
     'Type': 'String', 'Table': 'Party', },
    {'FieldName': 'regLEIName', 'Description': 'LEIName of a party',
     'Default': '', 'TypeGroup': 'Standard',
     'Type': 'String', 'Table': 'Party', },
    {'FieldName': 'regExecVenueType', 'Description': 'ExecutionVenueType',
     'Default': '', 'TypeGroup': 'RecordRef',
     'Type': 'ChoiceList', 'Table': 'Party', },
    ]


def create_additional_info_spec(add_info_spec_attr):
    """ Create AdditionalInfoSpec details provided as input arguments"""
    ais = acm.FAdditionalInfoSpec[add_info_spec_attr['FieldName']]
    table_name = add_info_spec_attr['Table']
    if ais:
        FRegulatoryLogger.INFO(logger, "Additional info <%s> exists on table <%s>" % (ais.Name(), table_name))
    else:
        ais = acm.FAdditionalInfoSpec()
        add_info_spec_attr['FieldName']
        FRegulatoryUtils.set_additional_info_spec_attr(ais, add_info_spec_attr)
        FRegulatoryLogger.INFO(logger, "Creating AdditionalInfoSpec <%s> on table <%s>" % (
        add_info_spec_attr['FieldName'], table_name))


def createAddInfosForRegLib():
    """create all the AdditionalInfoSpecs introduced for the RegulatoryLib"""
    for addInfoSpec in addInfoSpecs:
        create_additional_info_spec(addInfoSpec)


def clearAddInfos(addInfo_Specs=None):
    """Delete all the AddInfo values introduced for the RegulatoryLib"""
    if addInfo_Specs:
        addInfoSpecs = addInfo_Specs
    for addInfoSpec in list(addInfoSpecs):
        ais = acm.FAdditionalInfoSpec[addInfoSpec['FieldName']]
        if ais:
            add_infos = acm.FAdditionalInfo.Select("addInf = %d" % ais.Oid())
            for add_info in list(add_infos):
                add_info.Delete()


def getAddInfoSpecDetails(addInfoSpecName):
    ret_val = None
    for addInfoSpec in addInfoSpecs:
        if addInfoSpec['FieldName'] == addInfoSpecName:
            ret_val = addInfoSpec
            break
    return ret_val


def deleteAddInfoSpecs():
    """deleted all the AdditionalInfoSpecs introduced for the RegulatoryLib"""
    for addInfoSpec in list(addInfoSpecs):
        ais = acm.FAdditionalInfoSpec[addInfoSpec['FieldName']]
        if ais:
            FRegulatoryLogger.INFO(logger, "Deleting AddInfoSpec <%s> on table <%s>" % (
            addInfoSpec['FieldName'], addInfoSpec['Table']))
            ais.Delete()


...

  FRegulatoryLib
"""------------------------------------------------------------------------
MODULE
    FRegulatoryLib -
DESCRIPTION:
    This file is provided to the user to add overrides to the default implementation of the API provided in FRegulatoryLibBase
VERSION: 1.0.29(0.1.1278)
--------------------------------------------------------------------------"""
import FRegulatoryLibBase

class InstrumentRegInfo(FRegulatoryLibBase.InstrumentRegInfoBase):

    def __init__(self, instrument=None):
        super(InstrumentRegInfo, self).__init__(instrument)


class ISO3166CountryCode(FRegulatoryLibBase.ISO3166CountryCodeBase):

    def __init__(self, custom_dict={}):
        super(ISO3166CountryCode, self).__init__(custom_dict)

class PartyRegInfo(FRegulatoryLibBase.PartyRegInfoBase):

    def __init__(self, party=None):
        super(PartyRegInfo, self).__init__(party)

class Taxonomy(FRegulatoryLibBase.TaxonomyBase):

    def __init__(self, acm_object=None):
        super(Taxonomy, self).__init__(acm_object)


class TradeRegInfo(FRegulatoryLibBase.TradeRegInfoBase):

    def __init__(self, trade=None):
        super(TradeRegInfo, self).__init__(trade)


class PersonRegInfo(FRegulatoryLibBase.PersonRegInfoBase):
    
    def __init__(self, acm_object):
        super(PersonRegInfo, self).__init__(acm_object)


class UniqueTradeIdentifier(FRegulatoryLibBase.UniqueTradeIdentifierBase):

    def __init__(self, acm_object=None):
        super(UniqueTradeIdentifier, self).__init__(acm_object)


class MMSLib(FRegulatoryLibBase.MMSLibBase):

    def __init__(self, trade=None):
        super(MMSLib, self).__init__(trade)


class SFTRLib(FRegulatoryLibBase.SFTRLibBase):
    
    def __init__(self, trade=None):
        super(SFTRLib, self).__init__(trade)


class AccountRegInfo(FRegulatoryLibBase.AccountRegInfoBase):

    def __init__(self, account=None):
        super(AccountRegInfo, self).__init__(account)
        


...

  FRegulatoryLibBase
"""------------------------------------------------------------------------
MODULE
    FRegulatoryLibBase -
DESCRIPTION:
    This file consists of the default implementation of the API open to customizations to users
VERSION: 1.0.29(0.1.1278)
--------------------------------------------------------------------------"""
import acm
import FRegulatoryCfiCodeGeneration
import FRegulatoryLogger
import ael
import operator
import FRegulatoryLibUtils
try:
    import __builtin__
except:
    import builtins
logger = 'FRegulatoryLibBase'
import FRegulatoryLookup
import FInstrumentClassification
import FRegulatoryNotionalAmount
import datetime
import unicodedata
import FRegulatoryISITCode
config_param = None
try:
    import FRegulatoryConfigParam
    config_param = FRegulatoryConfigParam.FRegulatoryConfigParam()
except:
    pass
space = acm.Calculations().CreateStandardCalculationsSpaceCollection()

stage1 = (ael.date('2018-03-01'), ael.date('2019-05-15'))
stage2 = (ael.date('2019-05-16'), ael.date('2020-05-15'))
stage3 = (ael.date('2020-05-16'), ael.date('2021-05-15'))
stage4 = (ael.date('2021-05-16'),)


class InstrumentRegInfoBase(object):
    """This file consists of the support functions that are used to populate the ADM.InstrumentRegulatoryInfo. supplying logic and enabling Storage"""
    ext_fin_ins_identification_type_code = {'BLOM' : 'BB_TICKER', 'FIGI' : 'FIGI', \
                        'CUSP' : 'CUSIP', 'RCMD' : 'RED_CODE', 'RICC' : 'RIC', \
                        'SEDL' : 'SEDOL', 'VALO' : 'VALOREN', 'WKNR' : 'WKN'}
    countrycode_identifier = {'GB' : 'SEDOL', 'US' : 'CUSIP', 'NT': 'SEDOL'}

    def __init__(self, instrument=None):
        """class that maintains all data related to the regulatory on the FTrade"""
        self.instrument = None
        self.current_date = ael.date_today()
        if instrument:
            self.instrument = instrument
            self.reg_info = self.instrument.RegulatoryInfo()
        self.parent_list = []

    def mifid2_rts28_instype(self, instrument=None):
        """get the instype for rts28 as per mifid classification"""
        mifid2_rts28_type = None
        instrument = self.__get_instrument(instrument)
        if instrument:
            mifid2_rts28_type = FRegulatoryLibUtils.get_rts28(instrument)
        else:
            FRegulatoryLogger.WARN(logger, "Please provide a valid instrument for its MiFID-II RTS28 InsType")
        return mifid2_rts28_type

    def mifid2_rts2_instype(self, instrument=None):
        """get the instype for rts2 as per mifid classification"""
        mifid2_rts2_type = None
        instrument = self.__get_instrument(instrument)
        if instrument:
            self.__rts2_classify = FInstrumentClassification.FInstrumentClassification(instrument)
            mifid2_rts2_type = self.__rts2_classify.mifid2_rts2_instype()
        else:
            FRegulatoryLogger.WARN(logger, "Please provide a valid instrument for its MiFID-II RTS2 InsType")
        return mifid2_rts2_type

    def mifid2_rts2_inssubtype(self, instrument=None):
        """get the inssubtype for rts2 as per mifid classification"""
        mifid2_rts2_subtype = None
        instrument = self.__get_instrument(instrument)
        if instrument:
            self.__rts2_classify = FInstrumentClassification.FInstrumentClassification(instrument)
            mifid2_rts2_subtype = self.__rts2_classify.mifid2_rts2_inssubtype()
        else:
            FRegulatoryLogger.WARN(logger, "Please provide a valid instrument for its MiFID-II RTS2 InsSubType")
        return mifid2_rts2_subtype

    def __get_instrument(self, instrument=None):
        """returns a valid instrument object or None depending on the input argument"""
        ins = self.instrument
        if instrument and instrument.IsKindOf(acm.FInstrument):
            ins = instrument
        return ins
    
    def isin(self, instrument=None):
        """added to ensure backward compatibility if this api is already consumed by any user"""
        return self.Isin(instrument)

    def Isin(self, instrument=None):
        """returns the ISIN of the instrument"""
        isin = None
        instrument = self.__get_instrument(instrument)
        if instrument:
            isin = instrument.Isin()
            if not isin:
                FRegulatoryLogger.INFO(logger, "Instrument <%s> has no Isin on it." % instrument.Name())
                isin = FRegulatoryLibUtils.get_isin_from_similar_isin(instrument)
                if isin:
                    FRegulatoryLogger.INFO(logger, "Instrument <%s> has no Isin on it. The SimilarIsin <%s> is being identified as the Isin of the instrument" % (instrument.Name(), isin))
            if not isin:
                isin = FRegulatoryLibUtils.get_isin_from_alias(instrument)  # check if there is an instrument Alias of the name ISIN
            if not isin:
                isin = FRegulatoryLibUtils.get_isin_from_addinfo(instrument)  # check if there is an instrument AdditionalInfo of the name ISIN
        else:
            FRegulatoryLogger.WARN(logger, "Please provide a valid instrument for its Isin")
        return isin

    def cfi_code(self, instrument=None, set_cfi_code=False):
        """generates and returns the CFI code of the instrument (if not present), else it returns the CFI code on the instrument"""
        cfi_code = None
        instrument = self.__get_instrument(instrument)
        if instrument:
            taxonomy = TaxonomyBase(instrument)
            cfi_code = taxonomy.cfi(None, None, set_cfi_code)
        else:
            FRegulatoryLogger.WARN(logger, "Please provide a valid instrument for its CfiCode")
        return cfi_code

    def isValidIsin(self, instrument=None, isin_val=None):
        """verify that the given Isin has a valid ISIN structure and checksum correct"""
        is_valid_isin = False
        if isin_val:
            is_valid_isin = FRegulatoryLibUtils.isValidIsin(isin_val)
        else:
            ins = self.__get_instrument(instrument)
            isin = self.Isin(ins)
            is_valid_isin = FRegulatoryLibUtils.isValidIsin(isin)
        return is_valid_isin

    @classmethod
    def get_large_in_scale(cls, average_daily_transactions, exchange_rate):
        """calc based on Orders large in scale compared with normal market size for shares and depositary receipts from RTS 1"""
        adt = float(average_daily_transactions)
        rate = float(exchange_rate)
        lisEUR = 0
        if adt < 50000:
            lisEUR = 15000
        elif adt < 100000:
            lisEUR = 30000
        elif adt < 500000:
            lisEUR = 60000
        elif adt < 1000000:
            lisEUR = 100000
        elif adt < 5000000:
            lisEUR = 200000
        elif adt < 25000000:
            lisEUR = 300000
        elif adt < 50000000:
            lisEUR = 400000
        elif adt < 100000000:
            lisEUR = 500000
        else:
            lisEUR = 650000
        return str(lisEUR * rate)

    def isLiquid(self, instrument=None):
        """Indicates if the security is liquid, as defined by the Committee of European Securities Regulators (CESR) under the Markets in Financial Instruments Directive (MiFID)."""
        instrument = self.__get_instrument(instrument)
        if not instrument:
            FRegulatoryLogger.WARN(logger, "Please provide a valid instrument for its isLiquid")
            return None
        isliquid_status = False
        if self.current_date < ael.date("2018-02-16"):
            FRegulatoryLogger.WARN(logger, "Not supported before 16 Feb 2018")
            return None
        global space
        space.Clear()
        from_currency = instrument.Currency()
        to_currency = acm.FCurrency['EUR']
        unshifted_val = from_currency.Calculation().FXRate(space, to_currency)
        total_issued_euro = int(instrument.TotalIssued() * unshifted_val.Number())
        self.rts2_classify = FRegulatoryLookup.RTS2Classification(instrument, self.current_date)
        total_nominal_value, businessdays, dates = self.rts2_classify.get_total_nominal_value()
        dates, average_daily_trades, percentage_days_traded, first_trade_ind = self.rts2_classify.get_average_daily_trades(
            businessdays, dates)
        try:
            if (not len(instrument.Trades())) or first_trade_ind or (
                            ael.date(str(instrument.IssueDay())) <= dates[0] and ael.date(
                        str(instrument.IssueDay()))) >= dates[1]:
                if instrument.InsType() == "Bond":
                    if instrument.SeniorityChlItem() and instrument.SeniorityChlItem().Name() == "SNRFOR":
                        if ((total_issued_euro >= 1000000000 and stage1[0] <= self.current_date and stage2[
                            1] >= self.current_date) or (total_issued_euro >= 500000000 and stage3[0] <= self.current_date)):
                            isliquid_status = True
                    elif instrument.ValuationGrpChlItem() and instrument.ValuationGrpChlItem().Name() == "Government":
                        if total_issued_euro >= 1000000000:
                            isliquid_status = True
                    elif instrument.CategoryChlItem() and instrument.CategoryChlItem().Name() == "Municipal":
                        if total_issued_euro >= 500000000:
                            isliquid_status = True
                    elif instrument.CategoryChlItem() and instrument.CategoryChlItem().Name() == "Corporate":
                        if ((total_issued_euro >= 1000000000 and stage1[0] <= ael.date_today() and stage2[
                            1] >= ael.date_today()) or (
                                        total_issued_euro >= 500000000 and stage3[0] <= ael.date_today())):
                            isliquid_status = True
                    else:
                        isliquid_status = False
                elif instrument.InsType() == "Convertible":
                    if total_issued_euro >= 500000000:
                        isliquid_status = True
                else:
                    FRegulatoryLogger.INFO(logger, "'isLiquid' API is applicable only for Bond instruments")
                    isliquid_status = None
            else:
                if instrument.InsType() in ["Bond", "Convertible"]:
                    if total_nominal_value * unshifted_val.Number() > 100000 and percentage_days_traded >= 80:
                        if stage1[0] <= self.current_date and stage1[1] >= self.current_date and average_daily_trades >= 15:
                            isliquid_status = True
                        elif stage2[0] <= self.current_date and stage2[1] >= self.current_date and average_daily_trades >= 10:
                            isliquid_status = True
                        elif stage3[0] <= self.current_date and stage3[1] >= self.current_date and average_daily_trades >= 7:
                            isliquid_status = True
                        elif stage4[0] <= self.current_date and average_daily_trades >= 2:
                            isliquid_status = True
        except Exception as e:
            FRegulatoryLogger.WARN(logger, "Insufficient information to determine liquid status.")
        return isliquid_status

    def get_liquidity_band(self, instrument=None, compute=True):
        """get the LiquidityBand for the given instrument on the basis of the average daily turnover"""
        instrument = self.__get_instrument(instrument)
        liquidity_band = None
        if instrument:
            reg_info = instrument.RegulatoryInfo()
            if acm.FAdditionalInfoSpec['regLiquidityBand']:
                liquidity_band = reg_info.AdditionalInfo().RegLiquidityBand()
            if str(liquidity_band) == 'None' and compute:
                average_daily_turnover = reg_info.AverageDailyTurnover()
                if average_daily_turnover:
                    liquidity_band = 0
                    if average_daily_turnover < 0:
                        liquidity_band = 0
                    elif average_daily_turnover < 10:
                        liquidity_band = 1
                    elif average_daily_turnover < 80:
                        liquidity_band = 2
                    elif average_daily_turnover < 600:
                        liquidity_band = 3
                    elif average_daily_turnover < 2000:
                        liquidity_band = 4
                    elif average_daily_turnover < 9000:
                        liquidity_band = 5
                    else:
                        liquidity_band = 6  # more than 9000 transactions per day
                else:
                    FRegulatoryLogger.INFO(logger, "The LiquidityBand cannot be inferred as the averageDailyTurnOver is not present on the instrument.")
        else:
            FRegulatoryLogger.WARN(logger, "Please provide a valid instrument for its get_liquidity_band")
        return liquidity_band

    def is_equity_like(self, instrument=None):
        """returns True if the instrument is an equity/equity like instrument"""
        equity_like = None
        instrument = self.__get_instrument(instrument)
        if instrument:
            equity_like = False
            ins_type = instrument.InsType()
            if not self.mifid2_rts2_instype(instrument):
                if ins_type in ['Stock', 'ETF', 'Depositary_Receipt']:
                    return True
                elif ins_type in ['Combination']:
                    for cons in instrument.Constituents(acm.Time.DateFromYMD(1970, 1, 1)):
                        if InstrumentRegInfoBase(cons.Instrument()).is_equity_like():
                            equity_like = True
                        else:
                            equity_like = False
                            break
        else:
            FRegulatoryLogger.WARN(logger, "Please provide a valid instrument for its is_equity_like")
        return equity_like

    def is_equity(self, instrument=None):
        """returns True or False based on if the Instrument is of Equity type"""
        instrument = self.__get_instrument(instrument)
        is_equity = None
        if instrument:
            is_equity = False
            ins_type = instrument.InsType()
            if ins_type in ['Stock', 'Depositary_Receipt', 'Certificate', 'Warrant']:
                is_equity = True
            elif ins_type in ['Combination']:
                for cons in instrument.Constituents(acm.Time.DateFromYMD(1970, 1, 1)):
                    if InstrumentRegInfoBase(cons.Instrument()).is_equity():
                        is_equity = True
                    else:
                        is_equity = False
                        break
        else:
            FRegulatoryLogger.WARN(logger, "Please provide a valid instrument for its is_equity")
        return is_equity

    def is_bond_like(self, instrument=None):
        """returns True if the instrument is an bond/bond like instrument"""
        instrument = self.__get_instrument(instrument)
        bond_like = None
        if instrument:
            bond_like = False
            if self.mifid2_rts2_instype(instrument) == 'Bonds':
                bond_like = True
            elif instrument.InsType() in ['Combination']:
                for cons in instrument.Constituents(acm.Time.DateFromYMD(1970, 1, 1)):
                    if InstrumentRegInfoBase(cons.Instrument()).is_bond_like(instrument):
                        bond_like = True
                    else:
                        bond_like = False
                        break
        else:
            FRegulatoryLogger.WARN(logger, "Please provide a valid instrument for its is_bond_like")
        return bond_like

    def is_interest_rate_derivative(self, instrument=None):
        """returns True if the instrument is an interest rate derivative instrument"""
        instrument = self.__get_instrument(instrument)
        ir_derivative = None
        if instrument:
            ir_derivative = False
            if self.mifid2_rts2_instype(instrument) == 'Interest Rate Derivatives':
                ir_derivative = True
            elif instrument.InsType() in ['Combination']:
                for cons in instrument.Constituents(acm.Time.DateFromYMD(1970, 1, 1)):
                    if InstrumentRegInfoBase(cons.Instrument()).is_interest_rate_derivative(instrument):
                        ir_derivative = True
                    else:
                        ir_derivative = False
                        break
        else:
            FRegulatoryLogger.WARN(logger, "Please provide a valid instrument for its is_interest_rate_derivative")
        return ir_derivative
        
    def is_equity_derivative(self, instrument=None):
        """returns True if the instrument is an equity derivative instrument"""
        instrument = self.__get_instrument(instrument)
        equity_derivative = None
        if instrument:
            equity_derivative = False
            ins_type = instrument.InsType()
            if self.mifid2_rts2_instype(instrument) == 'Equity Derivatives':
                equity_derivative = True
            elif ins_type in ['Dividend_Point_Index', 'EquityIndex']:
                equity_derivative = True
            elif ins_type in ['Combination']:
                for cons in instrument.Constituents(acm.Time.DateFromYMD(1970, 1, 1)):
                    if InstrumentRegInfoBase(cons.Instrument()).is_equity_derivative(instrument):
                        equity_derivative = True
                    else:
                        equity_derivative = False
                        break
        else:
            FRegulatoryLogger.WARN(logger, "Please provide a valid instrument for its is_equity_derivative")
        return equity_derivative

    def is_c10_derivative(self, instrument=None):
        """returns True if the instrument is a C10 derivative instrument"""
        c10_derivative = None
        instrument = self.__get_instrument(instrument)
        if instrument:
            c10_derivative = False
        else:
            FRegulatoryLogger.WARN(logger, "Please provide a valid instrument for its is_c10_derivative")
        return c10_derivative

    def is_fx_derivative(self, instrument=None):
        """returns True if the instrument is a FX derivative instrument"""
        fx_derivative = None
        instrument = self.__get_instrument(instrument)
        if instrument:
            fx_derivative = False
            if self.mifid2_rts2_instype(instrument) == 'Foreign Exchange Derivatives':
                fx_derivative = True
            elif instrument.InsType() in ['Combination']:
                for cons in instrument.Constituents(acm.Time.DateFromYMD(1970, 1, 1)):
                    if InstrumentRegInfoBase(cons.Instrument()).is_fx_derivative(instrument):
                        fx_derivative = True
                    else:
                        fx_derivative = False
                        break
        else:
            FRegulatoryLogger.WARN(logger, "Please provide a valid instrument for its is_fx_derivative")
        return fx_derivative

    def is_cfd(self, instrument=None):
        """returns True if the instrument is a cfd instrument"""
        cfd = None
        instrument = self.__get_instrument(instrument)
        if instrument:
            cfd = False
            if self.mifid2_rts2_instype(instrument) == 'Financial contracts for differences':
                cfd = True
            elif instrument.InsType() in ['Combination']:
                for cons in instrument.Constituents(acm.Time.DateFromYMD(1970, 1, 1)):
                    if InstrumentRegInfoBase(cons.Instrument()).is_cfd():
                        cfd = True
                    else:
                        cfd = False
                        break
        else:
            FRegulatoryLogger.WARN(logger, "Please provide a valid instrument for its is_cfd")
        return cfd

    @classmethod
    def get_conversion_factor(cls, currency1, currency2):
        """return the conversion factor between the two currencies provided"""
        conversion_factor = 0
        curr_pair = acm.FCurrencyPair.Select01("currency1 = '%s' and currency2 = '%s'" % (currency1, currency2), None)
        if not curr_pair:
            curr_pair = acm.FCurrencyPair.Select01("currency1 = '%s' and currency2 = '%s'" % (currency2, currency1), None)
            if curr_pair:
                conversion_factor = curr_pair.PointValueInverse()
        else:
            conversion_factor = curr_pair.PointValue()
        return conversion_factor, curr_pair

    def is_basket_cds(self, instrument=None):
        """returns True if the instrument is a basket CDS"""
        instrument = self.__get_instrument(instrument)
        basket_cds = None
        if instrument:
            basket_cds = False
            for leg in instrument.Legs():
                if leg.LegType() == 'Credit Default' and leg.CreditRef().InsType() == 'Combination':
                    basket_cds = True
        else:
            FRegulatoryLogger.WARN(logger, "Please provide a valid instrument for its is_basket_cds")
        return basket_cds

    def is_commodity_derivative(self, instrument=None):
        """returns True if the instrument is a commodity derivative"""
        commodity_classification = ['Commodity Index', 'Commodity Variant', 'Commodity', 'Average Future/Forward', 'Precious Metal Rate', 'Rolling Schedule', 'PriceSwap', 'PriceIndex']
        is_cmdty_derivative = None
        instrument = self.__get_instrument(instrument)
        if instrument:
            is_cmdty_derivative = False
            if instrument.InsType() in commodity_classification or \
                            instrument.Underlying() and instrument.Underlying().InsType() in commodity_classification:
                is_cmdty_derivative = True
            if (not is_cmdty_derivative) and instrument.Underlying() and instrument.Underlying().InsType() == 'Combination':
                cmdty_counter = 0
                other_counter = 0
                for ins_map in instrument.Underlying().InstrumentMaps():
                    if ins_map.Instrument().InsType() in commodity_classification:
                        cmdty_counter = cmdty_counter + 1
                    else:
                        other_counter = other_counter + 1
                    if cmdty_counter > 0 and other_counter == 0:
                        is_cmdty_derivative = True
        else:
            FRegulatoryLogger.WARN(logger, "Please provide a valid instrument for its is_commodity_derivative")
        return is_cmdty_derivative

    def ISITC_type_code(self, instrument=None):
        """returns the ISITC Type code classification for the instrument"""
        isitic_code = None
        instrument = self.__get_instrument(instrument)
        if instrument:
            isitic_code_obj = FRegulatoryISITCode.ISITCodeType(instrument)
            isitic_code = isitic_code_obj.get_isitic_classification()
        else:
            FRegulatoryLogger.WARN(logger, "Please provide a valid instrument for its ISITC_type_code")
        return isitic_code
    
    @classmethod
    def get_instrument_alias_type(cls, country_code):
        """get the instrument alias type that needs to be referred to for the given country code"""
        alias_type = None       
        if country_code in cls.countrycode_identifier.keys():
            alias_type = cls.countrycode_identifier[country_code]
        else:
            FRegulatoryLogger.WARN(logger, "The countrycode_identifier dictionary does not have the country code <%s> provided." % country_code)
        return alias_type
    
    @classmethod
    def get_identifier_from_external_fin_ins_identification_type_code(cls, identification_type_code):
        """get the identifier from the external finanicial instrument identification type code"""
        identifier_type = None
        if identification_type_code in cls.ext_fin_ins_identification_type_code:
            identifier_type = cls.ext_fin_ins_identification_type_code[identification_type_code]
        else:
            FRegulatoryLogger.WARN(logger, "External Financial Instrument Identification type code <%s> is not present in dict ext_fin_ins_identification_type_code" % identification_type_code)
        return identifier_type
        
    @classmethod
    def get_instrument_from_external_fin_ins_identification_type_code(cls, identification_type_code, identifier_value):
        """get the instrument with the provided identifier value from the external finanicial instrument identification type code"""
        identifier_type = cls.get_identifier_from_external_fin_ins_identification_type_code(identification_type_code)
        instruments = None
        if identifier_type:
            instruments = cls.get_instruments(identifier_type, identifier_value)
        return instruments
    
    @classmethod
    def get_instrument_from_alias(cls, identifier_type, identifier_value):
        """get the instrument for the given alias type and value"""
        instrument = None
        alias = None
        alias_type = acm.FInstrAliasType[identifier_type]
        if alias_type:
            query = "type=%d and alias=%s" % (alias_type.Oid(), str(identifier_value))
            alias = acm.FInstrumentAlias.Select01(query, None)
        else:
            FRegulatoryLogger.WARN(logger, "AliasType <%s> does not exist in ADS" % (identifier_type))   
        if alias:
            instrument = alias.Instrument()
        return instrument

    @classmethod
    def get_instruments_from_similar_isin(cls, isin_val):
        """get the instruments with similar isin value as that of the value provided"""
        instruments = []
        add_info_spec = acm.FAdditionalInfoSpec['regSimilarIsin']
        if add_info_spec:
            addinfos = acm.FAdditionalInfo.Select("addInf=%d and fieldValue = '%s'" % (add_info_spec.Oid(), isin_val))

            for addinfo in addinfos:
                if addinfo.RecType() == 'InstrRegulatoryInfo':
                    instruments.append(addinfo.Parent().Instrument())
                elif addinfo.RecType() == 'Instrument':
                    instruments.append(addinfo.Parent())
                elif addinfo.RecType() in ['TradeRegulatoryInfo', 'Trade']:
                    FRegulatoryLogger.INFO(logger, "AddInfo <%s> is linked to <%s>. This is applicable only in case of FXSwaps. Instrument for these deals is currency. Hence, not considering the currency instrument." % (add_info_spec, addinfo.RecType()))
        return instruments
    
    @classmethod
    def get_instruments_from_isin(cls, isin_value):
        """get instruments with the isin value provided - either in the ISIN field of the instrument or on its SimilarIsin field"""
        instruments = []
        instrument = acm.FInstrument.Select01("isin = '%s'" % isin_value, None)
        if instrument:
            instruments.append(instrument)
        sim_isin_ins = cls.get_instruments_from_similar_isin(isin_value)
        if sim_isin_ins:
            instruments.extend(sim_isin_ins)
        return instruments

    @classmethod
    def get_instruments(cls, identifier_type, identifier_value):
        """get instruments with the provided identifier value in the alias of the provided identifer type"""
        instruments = []
        if identifier_type.upper() == 'ISIN':
            FRegulatoryLogger.DEBUG(logger, "getting the instruments for the given isin", identifier_value)
            instruments = cls.get_instruments_from_isin(identifier_value)
        # elif identifier_type.upper() in ['SEDOL', 'CUSIP', 'BB_TICKER', 'FIGI', 'RIC', 'RED_CODE', 'VALOREN', 'WKN', 'BB_UNIQUE']:
        else:  # the condition is generic to also allow instrument alias of proprietary types
            instrument = cls.get_instrument_from_alias(identifier_type, identifier_value)
            if instrument:
                instruments.append(instrument)
        return instruments
    
    @classmethod
    def getInstrumentFromNationalInstrumentIdentifierScheme(cls, identifier_value, identifier_type=None, country_code=None, ext_fin_type_code=None, proprietary=None):
        """get instruments from the provided national instrument identifier scheme"""
        instruments = None
        process_further = True
        country_code_identifier = None
        ext_fin_type_identifier = None
        if country_code:
            country_code_identifier = cls.get_instrument_alias_type(country_code)         
        if ext_fin_type_code:
            ext_fin_type_identifier = cls.get_identifier_from_external_fin_ins_identification_type_code(ext_fin_type_code)
        if identifier_type:
            if identifier_type and identifier_type == 'TS':
                identifier_type = 'BB_TICKER'
            if country_code and country_code_identifier != identifier_type:
                FRegulatoryLogger.WARN(logger, "The country code infers to <%s>. Whereas the Identifier type provided is <%s>. Cannot process this further." % (country_code_identifier, identifier_type))
                process_further = False
            if ext_fin_type_code and ext_fin_type_identifier != identifier_type:
                FRegulatoryLogger.WARN(logger, "External Financial Instrument Identification type code value infers to <%s>. Whereas the Identifier type provided is <%s>. Cannot process this further." % (ext_fin_type_identifier, identifier_type))
                process_further = False
        else:
            if (not country_code) and (not ext_fin_type_code):
                identifier_type = 'ISIN'  # defaulting the identifier_type to ISIN when no other value is provided.
            if proprietary:
                identifier_type = 'PROPRIETARY'
        if process_further:
            if identifier_type:
                instruments = cls.get_instruments(identifier_type, identifier_value)
            elif country_code:               
                instruments = cls.get_instruments(country_code_identifier, identifier_value)
            elif ext_fin_type_code:
                instruments = cls.get_instrument_from_external_fin_ins_identification_type_code(ext_fin_type_code, identifier_value)
        return instruments

    def __get_issuer_country(self, party):
        """get the issuer country for the given party"""
        country_of_issuer = None
        if party.RiskCountry():
            country_of_issuer = party.RiskCountry()
            if country_of_issuer:
                country_of_issuer = country_of_issuer.Name()
        elif party.Country():
            country_of_issuer = party.Country()
        return country_of_issuer

    def country_of_issue(self, instrument=None):
        """returns the value of the country of risk on the issuer"""
        country_of_issuer_val = None
        instrument = self.__get_instrument(instrument)
        if instrument:
            party = instrument.Issuer()
            if party:
                original_party = party
                self.parent_list = []
                country_of_issuer_val = self.__get_issuer_country(party)
                if not country_of_issuer_val:
                    while party.Parent() and not country_of_issuer_val:
                        if party.Parent().Name() not in self.parent_list:
                            party = party.Parent()
                            country_of_issuer_val = self.__get_issuer_country(party)
                            self.parent_list.append(party.Parent().Name())
                        else:
                            FRegulatoryLogger.ERROR(logger, "Cannot get country of issuer for party <%s> as there is a setup issue with cyclic dependency while configuring party parent."%original_party.Name())
                            break                           
            else:
                FRegulatoryLogger.WARN(logger, "Cannot infer the country of issue as the instrument <%s> does not have an issuer set on it."%instrument.Name()) 
        else:
            FRegulatoryLogger.WARN(logger, "Please provide a valid instrument for its country_of_issue")
        return country_of_issuer_val

    def country_code(self, instrument=None):
        """returns the value of the country_code of the issuer party"""
        instrument = self.__get_instrument(instrument)
        country_code_val = None
        if instrument:
            country_of_issue_val = self.country_of_issue(instrument)
            if country_of_issue_val:
                country_code_val = ISO3166CountryCodeBase().country_code_from_string(country_of_issue_val)
            else:
                FRegulatoryLogger.WARN(logger, "Cannot infer country code for instrument <%s> as the issuer's country is not set."%instrument.Name())
        else:
            FRegulatoryLogger.WARN(logger, "Please provide a valid instrument for its country_code")
        return country_code_val    

    def bbg_collateral_type(self, instrument=None):
        """returns collateral type of the instrument available from DataLoader"""
        collateral_type_val = None
        instrument = self.__get_instrument(instrument)
        if instrument:
            if FRegulatoryLibUtils.get_provider_data_exists():
                collateral_type_val = instrument.GetProviderDataFieldValue('COLLAT_TYP')
        else:
            FRegulatoryLogger.WARN(logger, "Please provide a valid instrument for its bbg_collateral_type")
        return collateral_type_val

    def is_jurisdiction(self, jurisdiction, instrument=None, jurisdiction_lookup = None):
        """return True if the Issuer of the instrument falls within the given jurisdiction, else return False"""
        is_jurisdiction_val = None
        instrument = self.__get_instrument(instrument)
        if instrument:
            if instrument.Issuer():
                is_jurisdiction_val = FRegulatoryLibUtils.is_party_in_jurisdiction(instrument.Issuer(), jurisdiction, jurisdiction_lookup)
            else:
                FRegulatoryLogger.WARN(logger,\
                    "IsJurisdiction cannot be inferred for instrument <%s> as Issuer is not set on it"\
                    %instrument.Name())
        else:
            FRegulatoryLogger.WARN(logger, "Please provide a valid instrument for its is_jurisdiction")
        return FRegulatoryLibUtils.get_tristate_choiceList(is_jurisdiction_val)

    def is_regulatory_authority(self, regulatory_authority, instrument=None, regulatory_authority_lookup = None):
        """return True if the Issuer of the instrument is governed by the given regulatory authority, else return False"""
        regulatory_authority_val = None
        instrument = self.__get_instrument(instrument)
        if instrument:
            if instrument.Issuer():
                regulatory_authority_val = FRegulatoryLibUtils.is_party_in_regulatory_authority(instrument.Issuer(), regulatory_authority, regulatory_authority_lookup)
            else:
                FRegulatoryLogger.WARN(logger,\
                    "IsRegulatoryAuthority cannot be inferred for instrument <%s> as Issuer is not set on it"\
                    %instrument.Name()) 
            return FRegulatoryLibUtils.get_tristate_choiceList(regulatory_authority_val)
        else:
            FRegulatoryLogger.WARN(logger, "Please provide a valid instrument for its is_regulatory_authority")
        
    def bond_type(self, instrument=None):
        """retuns bond type of the instrument inferred from the Provider data available from DataLoader"""
        bond_type_val = None
        instrument = self.__get_instrument(instrument)
        if instrument:
            if FRegulatoryLibUtils.get_provider_data_exists():
                collat_typ = instrument.GetProviderDataFieldValue('COLLAT_TYP')
                is_covered = instrument.GetProviderDataFieldValue('IS_COVERED')
                industry_sector = instrument.GetProviderDataFieldValue('INDUSTRY_SECTOR')
                security_typ2 = instrument.GetProviderDataFieldValue('SECURITY_TYP2')
                bullet = instrument.GetProviderDataFieldValue('BULLET')
                security_typ = instrument.GetProviderDataFieldValue('SECURITY_TYP')
                inflation_linked_indicator = instrument.GetProviderDataFieldValue('INFLATION_LINKED_INDICATOR')
                catastrophe = instrument.GetProviderDataFieldValue('CATASTROPHE')
                market_sector_des = instrument.GetProviderDataFieldValue('MARKET_SECTOR_DES')
                if collat_typ:
                    if collat_typ == "JUMBO PFANDBRIEF":
                        bond_type_val = 'Jumbo Pfandbrief';
                    elif collat_typ == "PFANDBRIEFE" :
                        bond_type_val = 'Pfandbrief'
                    elif collat_typ in ["ASSET BACKED", "COLLATERAL TRUST"]:
                        bond_type_val = 'ABS'
                    elif collat_typ in ["1ST MORTGAGE", "MORTGAGE", "MORTGAGE BACKED", "1ST REF MORTGAGE"]:
                        bond_type_val = 'MBS'
                    elif collat_typ == 'BILLS' and bullet and bullet == 'Y':
                        bond_type_val = 'Bill'
                if (not bond_type_val) and is_covered and is_covered == "Y":
                    bond_type_val = 'Covered Bond'
                if (not bond_type_val) and industry_sector and security_typ2:
                    if industry_sector == "Mortgage Securities":
                        if security_typ2 == "Pool":
                            bond_type_val = 'Pool'
                        elif security_typ2 == "CMO":
                            bond_type_val = 'CMO'
                        elif security_typ2 == "Whole Loan":
                            bond_type_val = 'Whole Loan'
                    elif industry_sector == 'Asset Backed Securities':
                        bond_type_val = 'ABS'
                if (not bond_type_val) and security_typ and security_typ2:
                    if security_typ == "US GOVERNMENT":
                        if security_typ2 == 'Bill':
                            bond_type_val = 'TBill'
                        if security_typ2 == 'Bond':
                            bond_type_val = 'TBond'
                        if security_typ2 == 'Note':
                            bond_type_val = 'TNote'
                if (not bond_type_val) and security_typ2 and security_typ2 == 'CP':
                    bond_type_val = 'Commercial Paper'
                if (not bond_type_val) and security_typ:
                    if security_typ == 'Agncy CMO IO':  # INTEREST_ONLY
                        bond_type_val = 'Interest Only (PO) Strips'
                    if security_typ == 'Agncy CMO PO':  # PRINCIPAL_ONLY
                        bond_type_val = 'Principal Only (IO) Strips'
                if (not bond_type_val) and bullet:
                    if bullet == 'Y':
                        bond_type_val = 'Bullet'
                    elif bullet == 'N':
                        bond_type_val = 'Non Bullet'
                if (not bond_type_val) and inflation_linked_indicator and inflation_linked_indicator == "Y":
                    bond_type_val = 'TIPS'  # this need to be checked
                if (not bond_type_val) and catastrophe and catastrophe == 'Y':
                    bond_type_val = 'CAT'
                if (not bond_type_val) and market_sector_des and market_sector_des == 'Equity':
                    bond_type_val = ''
                else:
                    bond_type_val = 'Other Bond'
            if bond_type_val:
                bond_type_val = FRegulatoryLibUtils.BondTypeEnum().number(bond_type_val)
        else:
            FRegulatoryLogger.WARN(logger, "Please provide a valid instrument for its bond_type")      
        return bond_type_val

    def is_government_guaranteed(self, instrument=None):
        """returns True if it is a government guaranteed bond else False"""
        is_govt_guaranteed = None
        instrument = self.__get_instrument(instrument)
        if instrument:
            if FRegulatoryLibUtils.get_provider_data_exists():
                market_sector_des = instrument.GetProviderDataFieldValue('MARKET_SECTOR_DES')
                if market_sector_des:
                    if 'GOVT' in market_sector_des.upper() or\
                        'MUNI' in market_sector_des.upper() or\
                        'CORP' in market_sector_des.upper():
                        is_govt_guaranteed = True
                    else:
                        is_govt_guaranteed = False
            return FRegulatoryLibUtils.get_tristate_choiceList(is_govt_guaranteed)
        else:
            FRegulatoryLogger.WARN(logger, "Please provide a valid instrument for its is_government_guaranteed")

    def is_covered(self, instrument=None):
        """returns True if it is a covered instrument and False if it is not.
        If this value is not present on the instrument, it returns None"""
        instrument = self.__get_instrument(instrument)
        if instrument:
            is_covered = None
            if FRegulatoryLibUtils.get_provider_data_exists():
                is_covered = instrument.GetProviderDataFieldValue('IS_COVERED')
                if is_covered == 'Y':
                    is_covered = True
                elif is_covered == 'N':
                    is_covered = False
            return FRegulatoryLibUtils.get_tristate_choiceList(is_covered)
        else:
            FRegulatoryLogger.WARN(logger, "Please provide a valid instrument for its is_covered")

    def fund_type(self, instrument=None):
        """returns the type of fund"""
        fund_type_val = None
        instrument = self.__get_instrument(instrument)
        if instrument:
            if FRegulatoryLibUtils.get_provider_data_exists():
                fund_type_val = instrument.GetProviderDataFieldValue('FUND_TYP')
        else:
            FRegulatoryLogger.WARN(logger, "Please provide a valid instrument for its fund_type")
        return fund_type_val 

    def main_trading_place(self, instrument=None):
        """returns the main trading place that this instrument is traded at"""
        main_trd_place = None
        instrument = self.__get_instrument(instrument)
        if instrument:
            isin = self.Isin(instrument)
            if isin:
                if isin.startswith('XS'):
                    main_trd_place = 'ALL'
                elif isin.startswith('EU'):
                    main_trd_place = 'EB'
            if not main_trd_place:
                if FRegulatoryLibUtils.get_provider_data_exists():
                    main_trd_place = instrument.GetProviderDataFieldValue('EQY_PRIM_SECURITY_COMP_EXCH')
        else:
            FRegulatoryLogger.WARN(logger, "Please provide a valid instrument for its main_trading_place")
        return main_trd_place

    def sftr_security_type(self, instrument=None):
        """returns the SFTR classification for the selected security if present in database"""
        sftr_security_type_val = None
        instrument = self.__get_instrument(instrument)
        if instrument:
            if FRegulatoryLibUtils.get_provider_data_exists():
                sftr_security_type_val = instrument.GetProviderDataFieldValue('SFTR_SECURITY_TYPE')
        else:
            FRegulatoryLogger.WARN(logger, "Please provide a valid instrument for its sftr_security_type")
        return sftr_security_type_val
    
    def moodys_rating(self, instrument=None):
        """returns the Moody's rating on the instrument"""
        moodys_rating_val = None
        instrument = self.__get_instrument(instrument)
        if instrument:
            moodys_rating_val = FRegulatoryLibUtils.get_rating(instrument, 'Moodys')
        else:
            FRegulatoryLogger.WARN(logger, "Please provide a valid instrument for its moodys_rating")
        return moodys_rating_val

    def snp_rating(self, instrument=None):
        """returns the SnP's rating on the instrument"""
        snp_rating_val = None
        instrument = self.__get_instrument(instrument)
        if instrument:
            snp_rating_val = FRegulatoryLibUtils.get_rating(instrument, 'SnP')
            if not snp_rating_val:
                snp_rating_val = FRegulatoryLibUtils.get_rating(instrument, 'StandardsAndPoor')
            if not snp_rating_val:
                snp_rating_val = FRegulatoryLibUtils.get_rating(instrument, 'S&P')
            if not snp_rating_val:
                snp_rating_val = FRegulatoryLibUtils.get_rating(instrument, 'Standards&Poor')
        else:
            FRegulatoryLogger.WARN(logger, "Please provide a valid instrument for its snp_rating")
        return snp_rating_val

    def fitch_rating(self, instrument=None):
        """returns the Fitch rating on the instrument"""
        fitch_rating_val = None
        instrument = self.__get_instrument(instrument)
        if instrument:
            fitch_rating_val = FRegulatoryLibUtils.get_rating(instrument, 'Fitch')
        else:
            FRegulatoryLogger.WARN(logger, "Please provide a valid instrument for its fitch_rating")
        return fitch_rating_val

    def outstanding_shares(self, instrument=None):
        """returns the outstanding shares detailed available from ProviderData"""
        outstanding_shares_val = None
        instrument = self.__get_instrument(instrument)
        if instrument:
            if FRegulatoryLibUtils.get_provider_data_exists():
                outstanding_shares_val = instrument.GetProviderDataFieldValue('EQY_SH_OUT_REAL')
        else:
            FRegulatoryLogger.WARN(logger, "Please provide a valid instrument for its outstanding_shares")
        return outstanding_shares_val

    def sf_type(self, instrument=None):
        """returns the SFType for the given instrument"""
        sf_type_val = None
        instrument = self.__get_instrument(instrument)
        if instrument:
            sf_type_dict = {'Repo/Reverse' : 'REPO', 'SecurityLoan' : 'SLEB', 'BuySellback' : 'SBSC'}
            ins_type = instrument.InsType()
            if ins_type in sf_type_dict.keys():
                sf_type_val = sf_type_dict[ins_type]
        else:
            FRegulatoryLogger.WARN(logger, "Please provide a valid instrument for its sf_type")
        return sf_type_val
    
    def issuer_type(self, instrument=None):
        """returns the type of issuer"""
        issuer_type_val = None
        instrument = self.__get_instrument(instrument)
        if instrument:
            if FRegulatoryLibUtils.get_provider_data_exists():
                issuer_industry_val = instrument.GetProviderDataFieldValue('INDUSTRY_SUBGROUP')
                if issuer_industry_val and issuer_industry_val == 'SUPRA-NATIONAL':
                    issuer_type_val = 'Supranational'
                if not issuer_type_val:
                    market_sector_des_val = instrument.GetProviderDataFieldValue('MARKET_SECTOR_DES')
                    if market_sector_des_val == 'Govt':
                        if issuer_industry_val and issuer_industry_val == 'Central Bank':
                            issuer_type_val = 'Central Bank'
                        else:
                            issuer_type_val = 'Government/Sovereign'
                    elif market_sector_des_val == 'Mtge':
                        mtg_is_agency_backed_val = instrument.GetProviderDataFieldValue('MTG_IS_AGENCY_BACKED')
                        if mtg_is_agency_backed_val == 'Y':
                            issuer_type_val = 'Sovereign Agency'
                    elif market_sector_des_val == 'Muni':
                        issuer_type_val = 'Municipal'
                    elif market_sector_des_val == 'Corp':
                        industry_group_val = instrument.GetProviderDataFieldValue('INDUSTRY_GROUP')
                        if industry_group_val != 'Banks':
                            issuer_type_val = 'Corporate'
                if not issuer_type_val:
                    industry_group_val = instrument.GetProviderDataFieldValue('INDUSTRY_GROUP')
                    if industry_group_val == 'Banks':
                        issuer_type_val = 'Bank'
        else:
            FRegulatoryLogger.WARN(logger, "Please provide a valid instrument for its issuer_type")
        return issuer_type_val

    def is_by_tenor(self, instrument=None):
        """returns True if the instrument is to be considered by Tenor, else False"""
        is_by_tenor = True
        instrument = self.__get_instrument(instrument)
        if instrument:
            tenor_count = None
            tenor_unit = ''
            if instrument and instrument.Legs():
                for leg in instrument.Legs():
                    tenor_count = leg.EndPeriodCount()
                    tenor_unit = leg.EndPeriodUnit()
                    if len(instrument.Legs()) > 1 and leg.PayLeg():
                        break
            if tenor_count and tenor_unit:
                if (tenor_unit == 'Days' and tenor_count > 6) or\
                (tenor_unit == 'Weeks' and tenor_count > 4) or\
                (tenor_unit == 'Months' and tenor_count > 23):
                    is_by_tenor = False
        else:
            FRegulatoryLogger.WARN(logger, "Please provide a valid instrument for its issuer_type")
        return is_by_tenor
    
    @classmethod
    def get_instruments_with_isin(cls, isin):
        """return instruments for the given isin"""
        instruments = []
        ins = acm.FInstrument.Select01("isin = '%s'" % isin.strip(), None)
        if ins:
            instruments.append(ins)
    
        ins_regs = acm.FInstrumentRegulatoryInfo.Select('')
        for ins_reg in ins_regs:
            if ins_reg.SimilarIsin() and ins_reg.SimilarIsin() == isin:
                instruments.append(ins_reg.Instrument())
    
        insAliases = acm.FInstrumentAlias.Select("type = 'Isin'")
        for insAlias in insAliases:
            if insAlias.Alias() == isin:
                instruments.append(insAlias.Instrument())
    
        ais = acm.FAdditionalInfoSpec['isin']
        if ais:
            addinfos = list(acm.FAdditionalInfo.Select('addInf=%s'%ais.Oid()))
            try:
                for addinfo in addinfos:
                    if addinfo.FieldValue() == isin:
                        instruments.append(addinfo.Parent())
            except:
                FRegulatoryLogger.INFO(logger, "Error while fetching instruments using AddInfo isin")
                
        return instruments

class MMSLibBase(object):
    def __init__(self, acm_object=None):
        self.trade = None
        self.instrument = None
        if acm_object and acm_object.IsKindOf(acm.FTrade):
            self.trade = acm_object
            self.instrument = self.trade.Instrument()
        elif acm_object and acm_object.IsKindOf(acm.FInstrument):
            self.instrument = acm_object
        self.ins_type_lookup = {'Cap' : 'Cap', 'Floor' : 'Floor', 'FRA' : 'FRA'}

    def __get_trade(self, trade=None):
        """returns a valid trade object or None depending on the input argument"""
        trd = self.trade
        if trade and trade.IsKindOf(acm.FTrade):
            trd = trade
        return trd

    def __get_instrument(self, instrument=None):
        """returns a valid instrument object or None depending on the input argument"""
        ins = self.instrument
        if instrument and instrument.IsKindOf(acm.FInstrument):
            ins = instrument
        return ins

    def asset_class(self, trade=None):
        """returns the asset class for the given trade on the basis of its instrument"""
        asset_class_val = None
        trade = self.__get_trade(trade)
        if trade:
            instrument = trade.Instrument()
            if instrument.InsType() in [\
                'Cap', 'Floor', 'FRA', 'CurrSwap', 'Swap'] or\
                (instrument.InsType() == 'Option' and\
                  instrument.Underlying().InsType() == 'Swap'):
                asset_class_val = 'Interest Rate Derivatives'
            elif instrument.InsType() in ['VarianceSwap'] or\
                (instrument.InsType() == 'Option' and\
                  instrument.Underlying().InsType() == 'Stock'):
                asset_class_val = 'Equities'
            elif instrument.InsType() == 'TotalReturnSwap':
                for leg in instrument.Legs():
                    if leg.LegType() == 'Total Return' and\
                     leg.FloatRateReference().InsType() in [\
                        'EquityIndex', 'Stock']:
                        asset_class_val = 'Equities'
            elif instrument.InsType() == 'CreditDefaultSwap':
                asset_class_val = 'Credit Derivatives'
            elif (instrument.InsType() == 'Future/Forward'\
             and instrument.Underlying().InsType() == 'Curr') or \
             instrument.InsType() == 'Curr' or\
             (instrument.InsType() == 'Option'\
             and instrument.Underlying().InsType() == 'Curr') or\
             instrument.InsType() == 'FXOptionDatedFwd':
                asset_class_val = 'Foreign Exchange'
            elif instrument.InsType() in ['PriceSwap', 'Commodity',\
                'Commodity Index', 'Commodity Variant',\
                'Average Future/Forward', 'Average Option'] or\
                (instrument.InsType() == 'Option' and\
                 instrument.Underlying().InsType() in ['Commodity',\
                'Commodity Index', 'Commodity Variant', 'Average Future/Forward']) or\
                (instrument.InsType() == 'Future/Forward' and\
                 instrument.Underlying().InsType() in ['Commodity',\
                'Commodity Index', 'Commodity Variant', 'Average Future/Forward']) :
                asset_class_val = 'Commodities'
        else:
            FRegulatoryLogger.WARN(logger, "Please provide a valid trade for its asset_class")
        return asset_class_val

    def product_sub_group(self, trade=None):
        """returns the product sub group for the given trade"""
        commodity_base_lookup = {'NRGY' : 'Energy',
                            'METL' : 'Metal',
                            'AGRI' : 'Agriculture',
                            'FRGT' : 'Freight'}
        commodity_sub_lookup = {'COAL' : 'Coal',
                                'ELEC' : 'Electricity',
                                'NGAS' : 'Natural Gas',
                                'OILP' : 'Oil',
                                'NPRM' : 'Base',
                                'PRME' : 'Precious',
                                'EMIS' : 'Emissions',}
        product_sub_group_val = None
        trade = self.__get_trade(trade)
        if trade:
            instrument = trade.Instrument()
            if instrument.InsType() == 'Swap':
                ois_ins = False
                float_counter = 0
                for leg in instrument.Legs():
                    if leg.LegType() == 'Float':
                        float_counter = float_counter + 1
                        if leg.RollingPeriodCount() == 1 and leg.RollingPeriodUnit() == "Days":
                            ois_ins = True                        
                    elif leg.LegType() == 'Zero Coupon Fixed':
                        product_sub_group_val = 'Zero Coupon Swap'
                if not product_sub_group_val:        
                    if ois_ins:
                        product_sub_group_val = 'OIS (Overnight Index Swap)'
                    elif float_counter == 2:
                        product_sub_group_val = 'Basis Swap'
                    else:
                        product_sub_group_val = 'Interest Rate Swap (Vanilla)'
            elif instrument.InsType() == 'CurrSwap':
                product_sub_group_val = 'Cross Currency Swap'
            elif instrument.InsType() in self.ins_type_lookup.keys():
                product_sub_group_val = self.ins_type_lookup[instrument.InsType()]
            elif instrument.InsType() == 'Option' and instrument.Underlying().InsType() == 'Swap':
                product_sub_group_val = 'Swap Option'
            elif instrument.InsType() in ['VarianceSwap']:
                product_sub_group_val = 'Variance Swap'
            elif (instrument.InsType() == 'Option' and\
                  instrument.Underlying().InsType() == 'Stock'):
                product_sub_group_val = 'Options'
            elif instrument.InsType() == 'TotalReturnSwap':
                for leg in instrument.Legs():
                    if leg.LegType() == 'Total Return' and\
                     leg.FloatRateReference().InsType() in [\
                        'EquityIndex', 'Stock']:
                        product_sub_group_val = 'Equity Swaps'
            elif instrument.InsType() == 'CreditDefaultSwap':
                if instrument.Underlying().InsType() in [\
                    'Bill', 'Bond', 'Convertible',\
                    'Zero', 'FRN', 'IndexLinkedBond', 'PromisLoan']:
                    product_sub_group_val = 'Single Name'
                elif instrument.Underlying().InsType() in ['CreditIndex']:
                    product_sub_group_val = 'Index'
            elif instrument.InsType() == 'Option' and\
             instrument.Underlying().InsType() == 'CreditDefaultSwap':#unit test for this case is pending
                product_sub_group_val = 'Option'
            elif instrument.InsType() == "FxSwap" or (\
                instrument.InsType() == "Curr" and trade.IsFxSwap()):
                product_sub_group_val = 'FX SWAP'
            elif instrument.InsType() == "Curr" and (not trade.IsFxSwap()):
                product_sub_group_val = 'Spot'
            elif (instrument.InsType() == 'Future/Forward' and\
                instrument.Underlying().InsType() == 'Curr') or\
                instrument.InsType() == 'FXOptionDatedFwd':
                product_sub_group_val = 'Forward'
            elif instrument.InsType() == 'Option' and\
                 instrument.Underlying().InsType() == 'Curr':
                product_sub_group_val = 'Option'
            elif instrument.InsType() in ['PriceSwap', 'Average Future/Forward'] or\
                (instrument.InsType() in ['Option', 'Future/Forward'] and\
                  instrument.Underlying().InsType() in ['Commodity',\
                'Commodity Index', 'Commodity Variant', 'Average Future/Forward']):
                product_sub_grp_val = None
                if instrument.InsType() in ['PriceSwap']:
                    product_sub_grp_val = 'Swap'
                elif instrument.InsType() == 'Option' and\
                 instrument.Underlying().InsType() in ['Commodity',\
                'Commodity Index', 'Commodity Variant', 'Average Future/Forward']:
                    product_sub_grp_val = 'Option'
                elif instrument.InsType() == 'Average Future/Forward' or\
                 (instrument.InsType() == 'Future/Forward' and\
                 instrument.Underlying().InsType() in ['Commodity',\
                'Commodity Index', 'Commodity Variant', 'Average Future/Forward']):
                    product_sub_grp_val = 'Forward'
                if instrument.RegulatoryInfo().CommodityProduct():
                    base_product_val = None
                    sub_product_val = None
                    base_product = instrument.RegulatoryInfo().CommodityBaseProduct()
                    sub_product = instrument.RegulatoryInfo().CommoditySubProduct()
                    if base_product.Name() in commodity_base_lookup.keys():
                        base_product_val = commodity_base_lookup[base_product.Name()]
                    if sub_product.Name() in commodity_sub_lookup.keys():
                        sub_product_val = commodity_sub_lookup[sub_product.Name()]
                    
                    if base_product_val:
                        product_sub_group_val = base_product_val
                    else:
                        product_sub_group_val = ''
                    if sub_product_val:
                        product_sub_group_val = product_sub_group_val + ' ' + sub_product_val
                        product_sub_group_val = product_sub_group_val.strip()
                    if product_sub_grp_val:
                        product_sub_group_val = product_sub_group_val + ' ' + product_sub_grp_val
                        product_sub_group_val = product_sub_group_val.strip()
            else:
                FRegulatoryLogger.INFO(logger, "ProductSubGroup is currently not support for <%s> instruments." % instrument.InsType())
        else:
            FRegulatoryLogger.WARN(logger, "Please provide a valid trade for its ProductSubGroup")
        return product_sub_group_val

    def implied_volatility(self, instrument=None):
        """returns the implied volatility of the instrument"""
        global space
        space.Clear()
        instrument = self.__get_instrument(instrument)
        return instrument.Calculation().ImpliedVolatility(space)
    
    def delta(self, instrument=None):
        """delta needs to be supported"""
        instrument = self.__get_instrument(instrument)
        return None
    
    def current_spread(self, instrument=None):
        """returns the current_spread of the instrument"""
        current_spread_val = None
        instrument = self.__get_instrument(instrument)
        if instrument:
            if instrument.InsType() in ['CreditDefaultSwap']:
                for leg in instrument.Legs():
                    if leg.LegType() == 'Float':
                        current_spread_val = leg.Spread()
            else:
                FRegulatoryLogger.INFO(logger, "current_spread API is supported for CreditDefaultSwaps only.")
        else:
            FRegulatoryLogger.WARN(logger, "Please provide a valid instrument for its current_spread value.")
        return current_spread_val

class SFTRLibBase(object):
    def __init__(self, acm_object=None):
        self.trade = None
        self.instrument = None
        if acm_object and acm_object.IsKindOf(acm.FTrade):
            self.trade = acm_object
            self.instrument = self.trade.Instrument()
        elif acm_object and acm_object.IsKindOf(acm.FInstrument):
            self.instrument = acm_object
        self.sf_type_lookup = {'Repo/Reverse' : 'REPO', 'SecurityLoan' : 'SLEB', 'BuySellback' : 'SBSC'}

    def __get_trade(self, trade=None):
        """returns a valid trade object or None depending on the input argument"""
        trd = self.trade
        if trade and trade.IsKindOf(acm.FTrade):
            trd = trade
        return trd

    def __get_instrument(self, instrument=None):
        """returns a valid instrument object or None depending on the input argument"""
        ins = self.instrument
        if instrument and instrument.IsKindOf(acm.FInstrument):
            ins = instrument
        return ins

    def sftr_type(self, trade=None):
        """returns the sftype of the trade depending upon its underlying instrument"""
        sf_type_val = None
        trade = self.__get_trade(trade)
        if trade:
            if trade.Instrument().InsType() in self.sf_type_lookup:
                sf_type_val = self.sf_type_lookup[trade.Instrument().InsType()]
            else:
                FRegulatoryLogger.INFO(logger, "SFTRType is not supported for trades on instrument of type <%s>" % trade.Instrument().InsType())
        else:
            FRegulatoryLogger.WARN(logger, "Please provide a valid trade for its sftr_type")
        return sf_type_val

    def sftr_day_count_method(self, instrument=None):
        """returns the day count method on the repo/reverse instrument"""
        sftr_day_cnt_mtd_val = None
        instrument = self.__get_instrument(instrument)
        if instrument.InsType() in ['Repo/Reverse']:
            leg = instrument.Legs()[0]
            day_count_method = leg.DayCountMethod()
            sftr_day_cnt_mtd_val = day_count_method
            if day_count_method in FRegulatoryLookup.sftr_day_count_method.keys():
                sftr_day_cnt_mtd_val = FRegulatoryLookup.sftr_day_count_method[day_count_method]
        else:
            FRegulatoryLogger.WARN(logger, "SFTRDayCountMethod is supported for Repos only.\
             Instrument <%s> passed to this API is of type <%s>."%(instrument.Name(), instrument.InsType()))
        return sftr_day_cnt_mtd_val

    @classmethod
    def date_period_unit(self, date_period_unit_val):
        """returns the corresponding SFTR date period unit for the given date period unit value"""
        self.date_period_unit_lookup = {'Months' : 'MNTH', 'Days' : 'DAYS', 'Weeks' : 'WEEK', 'Years' : 'YEAR'}
        date_prd_unit_val = None
        if date_period_unit_val in self.date_period_unit_lookup:
            date_prd_unit_val = self.date_period_unit_lookup[date_period_unit_val]
        return date_prd_unit_val
    
    def sftr_asset_type(self, trade=None):
        """returns the sftr asset type for a given trade on the basis of its instrument"""
        sftr_asset_type_val = None
        trade = self.__get_trade(trade)
        if trade:
            if trade.Instrument().InsType() in self.sf_type_lookup:
                if trade.Instrument().Underlying().InsType() in ['Commodity', 'Commodity Variant']:
                    sftr_asset_type_val = 'COMM'
                else:
                    sftr_asset_type_val = 'SECU'
            else:
                FRegulatoryLogger.INFO(logger, "SFTRAssetType is not supported for trades on instrument of type <%s>" % trade.Instrument().InsType())
        else:
            FRegulatoryLogger.WARN(logger, "Please provide a valid trade for its sftr_asset_type")
        return sftr_asset_type_val

    def sftr_security_quality(self, trade=None):
        """returns the SFTR security quality for a given trade on the basis of the provider data field value"""
        sftr_security_quality_val = None
        trade = self.__get_trade(trade)
        if trade:
            instrument = trade.Instrument()
            if FRegulatoryLibUtils.get_provider_data_exists():
                sftr_security_quality_val = instrument.GetProviderDataFieldValue('SFTR_SECURITY_QUALITY')
        else:
            FRegulatoryLogger.WARN(logger, "Please provide a valid trade for its sftr_security_quality")
        return sftr_security_quality_val

class ISO3166CountryCodeBase(object):
    def __init__(self, custom_dict={}):
        self.__custom_dict = custom_dict
        self.__default_dict = FRegulatoryLookup.country_code_dict
        self.__city_state_lookup = FRegulatoryLookup.city_state_dict  # this dict can be extended if required here
        self.__subjurisdiction_dict = FRegulatoryLookup.subjurisdiction_codes

    def country_code(self, party):
        """the country code will be returned for the country of the party"""
        party = FRegulatoryLibUtils.get_party_handle(party)
        country_code = None
        if party:
            if party.Country():
                country = party.Country()
                country_code = self.country_code_from_string(country)
            if not country_code:
                while party.Parent() and not country_code:
                    party = party.Parent()
                    if party.Country():
                        country = party.Country()
                        country_code = self.country_code_from_string(country)
                        if not country_code:
                            FRegulatoryLogger.ERROR(logger, 'The CountryCode for country <%s> on Party <%s> could not be identified' % (party.Country(), party.Name()))
            if not country_code:
                FRegulatoryLogger.ERROR(logger, 'The CountryCode for Party <%s> could not be identified' % (party.Name()))
        return country_code

    def country_code_from_string(self, country):
        """return country code for the provided country name"""
        try:
            if type(country) == unicode:
                country = unicodedata.normalize('NFKD', country).encode('ascii', 'ignore')
        except:
            pass
        country = country.strip()
        country_code = self.__get_country_code_from_dict(country, True)
        if not country_code:
            country_code = self.__get_country_code_from_dict(country, True)
        return country_code

    def __get_country_code_from_dict(self, country, custom_dict=False):
        """get the country code from dict"""
        country_code = None
        lookup_dict = None
        dictionary_name = 'default'
        if custom_dict and self.__custom_dict:
            for country_val, country_code_val in self.__custom_dict.items():
                self.__custom_dict.update({country_val.upper(): country_code_val})
                lookup_dict = self.__custom_dict
                dictionary_name = 'custom'
        else:
            for country_val, country_code_val in list(self.__default_dict.items()):
                self.__default_dict.update({country_val.upper(): country_code_val})
                lookup_dict = self.__default_dict
        if country in lookup_dict:
            country_code = lookup_dict[country]
            FRegulatoryLogger.DEBUG(logger, "countryCode <%s> being picked from the %s dictionary provided" %(country_code, dictionary_name))
        if (not country_code) and country.upper() in lookup_dict:
                country_code = lookup_dict[country.upper()]
                FRegulatoryLogger.DEBUG(logger, "countryCode <%s> being picked from the %s dictionary provided" % (country_code, dictionary_name))
        if (not country_code) and country in lookup_dict.values():
            country_code = country
        if (not country_code) and country.upper() in lookup_dict.values():
            country_code = country.upper()
        return country_code

    def subJurisdiction(self, country_name, city_name):
        """return the subjurisdiction if applicable"""
        state_code = ''
        sub_jurisdiction = self.country_code_from_string(country_name)

        if not sub_jurisdiction:
            FRegulatoryLogger.WARN(logger, "countryCode not found for country <%s>." % country_name)
        else:
            if city_name in self.__city_state_lookup:
                state = self.__city_state_lookup[city_name]
                if country_name in self.__subjurisdiction_dict:
                    states = self.__subjurisdiction_dict[country_name]
                    if state in states:
                        state_code = states[state]
                    else:
                        FRegulatoryLogger.WARN(logger, "subjurisdiction not found for state <%s> in country <%s>." % (state, country_name))
            else:
                if city_name:
                    FRegulatoryLogger.WARN(logger, "subjurisdiction not found for city <%s> as its state not found in city-state lookup." % (city_name))
                else:
                    FRegulatoryLogger.WARN(logger, "subjurisdiction not found as city details are not present")
            if state_code:
                sub_jurisdiction = sub_jurisdiction + '-' + state_code
        return sub_jurisdiction

    def city_code(self, city_name, country_name=None, city_country_override_dict=None, override_dict=None):
        """generates the business center code for a given city in a country on the basis of the country code and the name of the city"""
        city_code_val = ''
        lookup_dict = override_dict
        if not lookup_dict:
            lookup_dict = FRegulatoryLookup.city_code_lookup
        if not country_name:
            city_country_lookup = city_country_override_dict
            if not city_country_lookup:
                city_country_lookup = FRegulatoryLookup.city_country_lookup
            country_name = ''
            if city_name in list(city_country_lookup.keys()):
                country_name = city_country_lookup[city_name]
            
        if country_name in list(lookup_dict.keys()):
            if city_name in list(lookup_dict[country_name].keys()):
                city_code_val = (lookup_dict[country_name])[city_name]
        if not city_code_val:
            country_code = self.country_code_from_string(country_name)
            if country_code:
                total_words = city_name.split(' ')
                if len(total_words) > 1:
                    for each_word in total_words:
                        if len(city_code_val) == 2:
                            break
                        city_code_val = city_code_val + each_word[0].upper()
                else:
                    city_code_val = city_name[0:2].upper()
                city_code_val = country_code + city_code_val
            else:
                FRegulatoryLogger.WARN(logger, "Cannot infer the country code as the country code for <%s> is not available in the lookup. Kindly add it to the custom_dict" % (country_name))
        return city_code_val

class PartyRegInfoBase(object):
    def __init__(self, party=None):        
        self.party = party
        self.default_jurisdiction_dic = {'ESMA':['BE', 'BG', 'CZ', 'DK', 'DE', 'EE', 'IE', 'GR', 'ES', 'FR', 'HR', 'IT', 'CY', 'LV', 'LT', 'LU', 'HU', 'MT', 'NL', 'AT', 'PL', 'PT', 'RO', 'SI', 'SK', 'FI', 'SE', 'GB'],
            'SEC': ['US'],
            'CSRC': ['CN'],
            'ASIC': ['AU'],
            'SEBI': ['IN'],
            'FMA': ['NZ'],
            'FSA': ['JP'],
            }
        self.parent_list = []

    def __get_party(self, party=None):
        """returns a valid party object or None depending on the input argument"""
        party_obj = self.party
        if party:
            party_obj = FRegulatoryLibUtils.get_party_handle(party)
            if (not party_obj) and (isinstance(party, str)):
                FRegulatoryLogger.ERROR(logger, "Party of name <%s> does not exist in ADS"%party)
        return party_obj

    def country(self, party=None):
        """get the country of the party"""
        country_val = None
        self.parent_list = []
        party = self.__get_party(party)
        if party:
            original_party = party
            if party.Country():
                country_val = party.RiskCountry()
                if not country_val:
                    country_val = party.Country()
                try:
                    if type(country_val) == unicode:
                        country_val = unicodedata.normalize('NFKD', country_val).encode('ascii', 'ignore')
                except:
                    pass
            if not country_val:
                while party.Parent() and not country_val:
                    if party.Parent().Name() not in self.parent_list:
                        party = party.Parent()
                        country_val = party.RiskCountry()
                        if not country_val:
                            country_val = party.Country()
                        self.parent_list.append(party.Parent().Name())
                    else:
                        FRegulatoryLogger.ERROR(logger, "Cannot get country for party <%s> as there is a setup issue with cyclic dependency while configuring party parent."%original_party.Name())
                        break
        else:
            FRegulatoryLogger.ERROR(logger, "A valid party in ADS needs to be passed to get its country")
        return country_val
 
    def jurisdiction(self, party=None):
        """returns the 2 character JurisdictionCountryCode of the party, irrespective of language"""
        jurisdiction = None
        party = self.__get_party(party)
        if party:
            jurisdiction = party.JurisdictionCountryCode()
            if not jurisdiction:
                try:
                    jurisdiction = party.AdditionalInfo().JurisdictionCountryCode()
                except:  # it means the JurisdictionCountryCode AdditionalInfo doesnt exist on the Party
                    FRegulatoryLogger.INFO(logger, "The JurisdictionCountryCode AdditionalInfo is not set on the Party")
                    iso_obj = ISO3166CountryCodeBase()
                    jurisdiction = iso_obj.country_code(party)
        else:
            FRegulatoryLogger.WARN(logger, "Kindly provide a valid Party to retrieve it's jurisdiction")
        return jurisdiction

    def swift_jurisdiction(self, party=None, customer_dic={}):
        """returns group jurisdiction, like ESMA"""
        party = self.__get_party(party)
        if party:
            jurisdiction = self.jurisdiction(party)
            swift_jurisdiction = None
            if jurisdiction:
                if customer_dic:
                    rever_customer_dic = FRegulatoryLibUtils.reverse_dict(customer_dic)
                    if jurisdiction in rever_customer_dic:
                        swift_jurisdiction = rever_customer_dic[jurisdiction]
                if (not swift_jurisdiction) and self.default_jurisdiction_dic:
                    reverse_default_dic = FRegulatoryLibUtils.reverse_dict(self.default_jurisdiction_dic)
                    if jurisdiction in reverse_default_dic:
                        swift_jurisdiction = reverse_default_dic[jurisdiction]
            else:
                if party:
                    FRegulatoryLogger.WARN(logger, "The jurisdiction is not present on the party <%s>. Hence, the swift code cannot be inferrred" % self.party.Name())
        else:
            FRegulatoryLogger.WARN(logger, "A valid party will have a jurisdiction")
        return swift_jurisdiction

    def MIC(self, party=None):
        """returns the MIC alias on the party"""
        mic_code = None
        party_val = party
        party = self.__get_party(party)
        if party:
            if party.Aliases():
                for alias in party.Aliases():
                    if alias.Type().Name() == 'MIC':
                        FRegulatoryLogger.DEBUG(logger, "MIC <%s> being picked from party alias MIC on party <%s>" % (alias.Name(), party.Name()))
                        mic_code = alias.Name()
            if not mic_code and party.Free1():
                FRegulatoryLogger.DEBUG(logger, "MIC being mapped from Free Text 1")
                mic_code = party.Free1()
        elif party_val and isinstance(party_val, str):
                FRegulatoryLogger.WARN(logger, "Party <%s> is not a valid party in ADS. Cannot infer its MIC"%party_val)
        return mic_code

    def LEI(self, party=None):
        """returns the LEI of the party. If not present, then it traverses up the hierarchy to look for LEI"""
        lei = None
        party_val = party
        party = self.__get_party(party)
        if party:
            lei = FRegulatoryLibUtils.get_lei(party)
        elif party_val and isinstance(party_val, str):
                FRegulatoryLogger.WARN(logger, "Party <%s> is not a valid party in ADS. Cannot infer its LEI"%party_val)
        return lei

    def subJurisdiction(self, party=None):
        """returns the subjuridiction on the basis of the country and the city details on the party"""
        sub_jurisdiction = None
        iso_cc = ISO3166CountryCodeBase()
        party_val = party
        party = self.__get_party(party)
        if party:
            sub_jurisdiction = iso_cc.subJurisdiction(party.Country(), party.City())
        elif party_val and isinstance(party_val, str):
                FRegulatoryLogger.WARN(logger, "Party <%s> is not a valid party in ADS. Cannot infer its subJurisdiction"%party_val)
        return sub_jurisdiction

    def __set_parent(self, party, parent_party):
        """set the given party with the given parent.
        If the parent does not exist, create it and then link them"""
        parent_party_val = parent_party
        parent_party = self.__get_party(parent_party)
        if not parent_party:
            parent_party = eval('acm.' + FRegulatoryLibUtils.party_lookup[party.Type()] + '()')
            parent_party.Name(parent_party_val)
            if party.Type() == 'Issuer':
                parent_party.Issuer(True)
            parent_party.Commit()
            FRegulatoryLogger.DEBUG(logger, "Parent party <%s> does not exist in ADS. Creating it."%(parent_party_val))        
        party.Parent(parent_party)
        FRegulatoryLogger.DEBUG(logger, "Parent for party <%s> is set to <%s>."%(\
                                            party.Name(), parent_party_val))
        party.Commit()

    def ultimate_parent(self, party=None):
        """returns the top node of a Party hierarchy"""
        party_val = party
        party = self.__get_party(party)
        if party:
            original_party = party
            self.parent_list = []
            while party.Parent():
                if party.Parent():
                    if party.Parent().Name() not in self.parent_list:
                        self.parent_list.append(party.Parent().Name())
                        party = party.Parent()
                    else:
                        FRegulatoryLogger.ERROR(logger, "Cannot get the ultimate parent for party <%s> as there is a setup issue with cyclic dependency while configuring party parent."%original_party.Name())
                        break
        elif party_val and isinstance(party_val, str):
            FRegulatoryLogger.WARN(logger, "Party <%s> is not a valid party in ADS. Cannot infer its ultimateParent"%party_val)
        return party

    def set_parent(self, parent_name, party=None, create_parent=False):
        """sets parent of the party"""
        party_val = party
        party = self.__get_party(party)
        if party:
            parent_party = acm.FParty[parent_name]        
            if party.Parent():
                if party.Parent().Name() == parent_name:
                    FRegulatoryLogger.INFO(logger, "Parent for party <%s> is already set to <%s>"%(party.Name(), parent_name))
                else:
                    if parent_party:
                        FRegulatoryLogger.INFO(logger, "Parent for party <%s> is already set to <%s>. Hence, not overriding with value <%s>."%(party.Name(), party.Parent().Name(), parent_name))
                    else:
                        FRegulatoryLogger.WARN(logger, "Party <%s> does not exist in ADS" %parent_name)
            else:
                if parent_party:
                    party.Parent(parent_party)
                    party.Commit()
                    FRegulatoryLogger.INFO(logger, "Parent for party <%s> is set to <%s>"%(party.Name(), parent_party.Name()))
                else:
                    if create_parent:
                        self.__set_parent(party, parent_name)
                    else:
                        FRegulatoryLogger.INFO(logger, "Party <%s> does not exist in ADS. Hence, cannot set it as parent to party <%s>."%(parent_name, party.Name()))
        elif party_val and isinstance(party_val, str):
            FRegulatoryLogger.WARN(logger, "Party <%s> is not a valid party in ADS. Cannot set it parent."%party_val)
        return party

    @classmethod
    def isValidMIC(self, mic_val, mic_codes_override=None):
        """return True if the give MIC code is a valid ISO10383 MIC code"""
        is_valid_mic = False
        mic_codes = FRegulatoryLookup.mic_codes
        if mic_codes_override:
            mic_codes = mic_codes_override
        if mic_val in mic_codes:
            is_valid_mic = True
        return is_valid_mic

    @classmethod
    def countryCodeFromMIC(self, mic_val):
        """return the country code of the party which has the given MIC value"""
        country_code = None
        party = FRegulatoryLibUtils.getPartyFromMIC(mic_val)
        if party:
            FRegulatoryLogger.DEBUG(logger, "Party <%s> Found in ADS with MIC <%s>" % (party.Name(), mic_val))
            country_code_obj = ISO3166CountryCodeBase()
            country_code = country_code_obj.country_code(party)
        else:
            FRegulatoryLogger.INFO(logger, "No Party with MIC <%s> present in ADS" % (mic_val))
        return country_code

    @classmethod
    def partyFromLEI(self, lei_val):
        """return the party which has the given LEI value"""
        party = FRegulatoryLibUtils.getPartyFromLEI(lei_val)
        if party:
            FRegulatoryLogger.DEBUG(logger, "Party <%s> found in ADS with LEI <%s>" % (party.Name(), lei_val))
        else:
            FRegulatoryLogger.INFO(logger, "No Party with LEI <%s> present in ADS" % (lei_val))
        return party

    @classmethod
    def partyFromMIC(self, mic_val):
        """return the party which has the given MIC value"""
        party = FRegulatoryLibUtils.getPartyFromMIC(mic_val)
        if party:
            FRegulatoryLogger.DEBUG(logger, "Party <%s> Found in ADS with MIC <%s>" % (party.Name(), mic_val))
        else:
            FRegulatoryLogger.INFO(logger, "No Party with MIC <%s> present in ADS" % (mic_val))
        return party

    @classmethod
    def isValidLEI(self, lei_val):
        """verify that the given lei follows ISO7064 and that the last two digits are check digits"""
        return FRegulatoryLibUtils.isValidLEI(lei_val)

    @classmethod
    def isValidBIC(self, bic_val):
        """returns True if the given BIC is valid, else False"""
        valid_bic = False
        if len(bic_val) == 8 or len(bic_val) == 11:
            valid_bic = True
        else:
            FRegulatoryLogger.INFO(logger, "BIC value : <%s> provided is not a valid BIC"%bic_val)
        return valid_bic

    @classmethod
    def generateLEIWithCheckSum(self, lei_val):
        """generate the checkSum for the given lei of 18 characters"""
        return FRegulatoryLibUtils.generateLEIWithCheckSum(lei_val)

    def is_jurisdiction(self, jurisdiction, party=None, jurisdiction_lookup=None):
        """return True if the country of the party falls within the given jurisdiction, else return False"""
        is_jurisdiction_val = None
        party_val = party
        party = self.__get_party(party)
        if party:
            is_jurisdiction_val = FRegulatoryLibUtils.is_party_in_jurisdiction(party, jurisdiction, jurisdiction_lookup)
            if is_jurisdiction_val == None:
                FRegulatoryLogger.WARN(logger,\
                "IsJurisdiction cannot be inferred for party <%s> as it is not set"\
                %party.Name())
        elif party_val and isinstance(party_val, str):
            FRegulatoryLogger.WARN(logger,\
                "IsJurisdiction cannot be inferred for party <%s> as it is not as valid party in ADS"\
                %party_val)
        return FRegulatoryLibUtils.get_tristate_choiceList(is_jurisdiction_val)

    def is_regulatory_authority(self, regulatory_authority, party=None, regulatory_authority_lookup = None):
        """return True if the party is governed by the given regulatory authority, else return False"""
        regulatory_authority_val = None
        party_val = party
        party = self.__get_party(party)
        if party:
            regulatory_authority_val = FRegulatoryLibUtils.is_party_in_regulatory_authority(party, regulatory_authority, regulatory_authority_lookup)
            if regulatory_authority_val == None:
                FRegulatoryLogger.WARN(logger,\
                "IsRegulatoryAuthority cannot be inferred for party <%s> as it is not set"\
                 %party.Name())
        elif party_val and isinstance(party_val, str):
            FRegulatoryLogger.WARN(logger,\
                "IsRegulatoryAuthority cannot be inferred for party <%s> as it is not a valid party in ADS"\
                %party_val) 
        return FRegulatoryLibUtils.get_tristate_choiceList(regulatory_authority_val)

class TaxonomyBase(object):
    def __init__(self, acm_object=None):
        self.trade = None
        self.instrument = None
        if acm_object and acm_object.IsKindOf('FTrade'):
            self.trade = acm_object
            self.trd_reg_info = self.trade.RegulatoryInfo()
        elif acm_object and acm_object.IsKindOf('FInstrument'):
            self.instrument = acm_object
            self.instr_reg_info = self.instrument.RegulatoryInfo()

    def __get_trade(self, trade=None):
        """returns a valid trade object or None depending on the input argument"""
        trd = self.trade
        if trade and trade.IsKindOf(acm.FTrade):
            trd = trade
        return trd

    def cfi(self, acm_object=None, cfi_code=None, generate=True):
        """generates and returns the CFI code for the instrument if not present on it. If already present on the instrument, it returns the existing CFICode"""
        instrument = None
        trade = None
        if acm_object:
            if acm_object.IsKindOf(acm.FTrade):
                trade = acm_object
            elif acm_object.IsKindOf(acm.FInstrument):
                instrument = acm_object
        else:
            instrument = self.instrument
            trade = self.trade
        if instrument:
            instr_reg_info = instrument.RegulatoryInfo()
            if cfi_code:
                instr_reg_info.CfiCode(cfi_code)
            else:
                cfi = instr_reg_info.CfiCode()
                if (not cfi) and generate:
                    cfi = FRegulatoryCfiCodeGeneration.compute_cfi_code(instrument)
                return cfi
        elif trade:
            trd_reg_info = trade.RegulatoryInfo()
            if (trade.Instrument().InsType() == 'Curr') or \
            (trade.Instrument().InsType() in ['Option', 'Future/Forward'] and trade.Instrument().Underlying().InsType() == 'Curr'):
                if cfi_code:
                    trd_reg_info.CfiCode(cfi_code)
                else:
                    cfi = trd_reg_info.CfiCode()
                    if (not cfi) and generate:
                        cfi = FRegulatoryCfiCodeGeneration.compute_cfi_code(trade)
                    return cfi
            else:
                FRegulatoryLogger.INFO(logger, "CfiCode for trades is available for FX trades only.")
        else:
            FRegulatoryLogger.ERROR(logger, "Please provide a valid instrument")

    def upi(self, trade=None):
        """return or generate UPI"""
        upi = None
        trade = self.__get_trade(trade)
        if trade:
            upi = FRegulatoryLibUtils.upi(trade)
        else:
            FRegulatoryLogger.ERROR(logger, "Please provide a valid trade")
        return upi

class TradeRegInfoBase(object):
    def __init__(self, trade=None):
        """class that maintains all data related to the regulatory on the FTrade"""
        self.trade = trade
        pass

    def __get_trade(self, trade=None):
        """returns a valid trade object or None depending on the input argument"""
        trd = self.trade
        if trade and trade.IsKindOf(acm.FTrade):
            trd = trade
        return trd

    def sftr_is_collateral_provider(self, trade=None):
        """infers if the instrument has the IsCollateralProvider flag set to True or False"""
        is_collateral_provider = None
        trade = self.__get_trade(trade)
        if trade:
            if trade.Instrument().InsType() in ['Repo/Reverse', 'BuySellback', 'SecurityLoan']:
                if trade.Premium() > 0:
                    if trade.Instrument().InsType() in ['Repo/Reverse', 'BuySellback']:
                        is_collateral_provider = True
                    else:
                        is_collateral_provider = False
                else:
                    if trade.Instrument().InsType() in ['Repo/Reverse', 'BuySellback']:
                        is_collateral_provider = False
                    else:
                        is_collateral_provider = True
            else:
                FRegulatoryLogger.WARN(logger, "SFTRIsCollateralProvider is not supported for InsType <%s>"%trade.Instrument().InsType())
            is_collateral_provider = FRegulatoryLibUtils.get_tristate_choiceList(is_collateral_provider)
        else:
            FRegulatoryLogger.WARN(logger, "Please provide a valid trade for its SFTRIsCollateralProvider")
        return is_collateral_provider

    def tech_record_identification(self, trade=None):
        """function that returns the technical record identification if present on the trade. If not present, it generates and returns this value"""
        tech_record_identification_val = None
        trade = self.__get_trade(trade)
        if trade:
            tech_record_identification_val = FRegulatoryLibUtils.tech_record_identification(trade)
        else:
            FRegulatoryLogger.WARN(logger, "Please provide a valid trade for its tech_record_identification")
        return tech_record_identification_val

    def buyer(self, trade=None):
        """returns the buyer on the deal. It is often the acquirer or the counterparty on the trade depending on the direction of the transaction"""
        buyer = None
        trade = self.__get_trade(trade)
        if trade:
            us_buyer = FRegulatoryLibUtils.us_buyer(trade)
            if us_buyer:
                buyer = FRegulatoryLibUtils.our_org(trade)
                if not buyer:
                    if trade.RegulatoryInfo().OurOrganisation():
                        buyer = trade.RegulatoryInfo().OurOrganisation()
                    else:
                        buyer = trade.Acquirer()
                    FRegulatoryLogger.ERROR(logger, "LEI is not present on buyer <%s> or its linked parent party." % buyer.Name())
            else:
                buyer = FRegulatoryLibUtils.their_org(trade)  # self.trade.RegulatoryInfo().TheirOrg()
                if not buyer:
                    if trade.RegulatoryInfo().TheirOrganisation():
                        buyer = trade.RegulatoryInfo().TheirOrganisation()
                    else:
                        buyer = trade.Counterparty()
                    FRegulatoryLogger.ERROR(logger, "LEI is not present on buyer <%s> or its linked parent party." % buyer.Name())
        else:
            FRegulatoryLogger.ERROR(logger, "Please provide a valid trade for its buyer")
        return buyer

    def us_buyer(self, trade=None):
        """returns True if we are the buyer of the trade"""
        us_buyer_val = None
        trade = self.__get_trade(trade)
        if trade:
            us_buyer_val = FRegulatoryLibUtils.us_buyer(trade)
        else:
            FRegulatoryLogger.ERROR(logger, "Please provide a valid trade for its us_buyer")
        return us_buyer_val

    def us_seller(self, trade=None):
        """returns True if we are the seller of the trade"""
        is_us_seller = None
        trade = self.__get_trade(trade)
        if trade:
            is_us_seller = False
            if not FRegulatoryLibUtils.us_buyer(trade):
                is_us_seller = True
        else:
            FRegulatoryLogger.ERROR(logger, "Please provide a valid trade for its us_seller")
        return is_us_seller

    def seller(self, trade=None):
        """returns the seller on the deal It is often the acquirer or the counterparty on the trade depending on the direction of the transaction"""
        seller = None
        trade = self.__get_trade(trade)
        if trade:
            us_buyer = FRegulatoryLibUtils.us_buyer(trade)
            if us_buyer:
                seller = FRegulatoryLibUtils.their_org(trade)  # self.trade.RegulatoryInfo().TheirOrg()
                if not seller:  # it means the LEI is not present and hence was not found
                    if trade.RegulatoryInfo().TheirOrganisation():
                        seller = trade.RegulatoryInfo().TheirOrganisation()
                    else:
                        seller = trade.Counterparty()
                    FRegulatoryLogger.ERROR(logger, "LEI is not present on seller <%s> or its linked parent party." % seller.Name())
            else:
                seller = FRegulatoryLibUtils.our_org(trade)  # self.trade.RegulatoryInfo().OurOrg()
                if not seller:
                    if trade.RegulatoryInfo().OurOrganisation():
                        seller = trade.RegulatoryInfo().OurOrganisation()
                    else:
                        seller = trade.Acquirer()
                    FRegulatoryLogger.ERROR(logger, "LEI is not present on seller <%s> or its linked parent party." % seller.Name())
        else:
            FRegulatoryLogger.ERROR(logger, "Please provide a valid trade for its seller")
        return seller

    def is_increase(self, trade=None):
        """return if the trade implies an increase or decrease of notional"""
        is_increase_decrease = None
        trade = self.__get_trade(trade)
        if trade:
            if trade.Contract().Oid() != trade.Oid():
                trade_nominal = trade.Nominal()
                contract_nominal = trade.Contract().Nominal()
                if trade_nominal > contract_nominal:
                    is_increase_decrease = 'INCR'
                elif trade_nominal < contract_nominal:
                    is_increase_decrease = 'DECR'
        else:
            FRegulatoryLogger.ERROR(logger, "Please provide a valid trade for its is_increase")
        return is_increase_decrease

    def country_of_branch(self, trade=None):
        """return country of the branch membership field"""
        country_of_branch = None
        branch_membership = None
        trade = self.__get_trade(trade)
        if trade:
            regulatory_info = trade.RegulatoryInfo()
            branch_membership = regulatory_info.BranchMembership()
            if branch_membership:
                country_of_branch = branch_membership.Country()
            else:
                FRegulatoryLogger.INFO(logger, "BranchMembership is not defined on trade <%d>" % trade.Oid())
            if branch_membership and not country_of_branch:
                FRegulatoryLogger.INFO(logger, "Country is not defined on party <%s> assigned as BranchMembership on trade <%d>" % (branch_membership.Name(), trade.Oid()))
        else:
            FRegulatoryLogger.ERROR(logger, "Please provide a valid trade for its country_of_branch")
        return country_of_branch

    def country_code_of_branch(self, trade=None):
        """return country code of the branch membership field"""
        country_code_of_branch = None
        country_of_branch = self.country_of_branch(trade)
        if not country_of_branch:
            FRegulatoryLogger.INFO(logger, "Country is not defined. Hence country code cannot be inferred.")
        else:
            iso_obj = ISO3166CountryCodeBase()
            country_code_of_branch = iso_obj.country_code_from_string(country_of_branch)
        return country_code_of_branch

    def complex_trade_component_id(self, trade=None):
        """Generates and returns the complex trade component id on the trade (if not present), else it returns the regComplexTrdCmptId AddInfo value on the Trade"""
        complex_cmpt_id = None
        trade = self.__get_trade(trade)
        if trade:
            complex_cmpt_id = trade.RegulatoryInfo().AdditionalInfo().RegComplexTrdCmptId()
            if not complex_cmpt_id:
                complex_cmpt_id = FRegulatoryLibUtils.generate_complex_trade_comp_id(trade)
        else:
            FRegulatoryLogger.ERROR(logger, "Please provide a valid trade for its complex_trade_component_id")
        return complex_cmpt_id

    def trading_capacity(self, trade=None):
        """what role do we have in the deal, investor, broker, and so on"""
        trading_capacity = None
        trade = self.__get_trade(trade)
        if trade:
            trading_capacity = trade.RegulatoryInfo().TradingCapacity()
            if (not trading_capacity) or trading_capacity == 'None':
                trading_capacity = 'DEAL'
                reporting_entity = trade.RegulatoryInfo().ReportingEntity()
                if reporting_entity:
                    if trade.Acquirer():
                        if trade.Acquirer() != reporting_entity:
                            trading_capacity = 'AOTC'
        else:
            FRegulatoryLogger.ERROR(logger, "Please provide a valid trade for its trading_capacity")
        return trading_capacity

    def cfi_code(self, trade=None, set_cfi_code=False):
        """generates and returns the CFI code of the Trade (if not present), else it returns the CFI code on the Trade. This is applicable only in case of FX Trades"""
        cfi_code = None
        trade = self.__get_trade(trade)
        if trade:
            taxonomy = TaxonomyBase(trade)
            cfi_code = taxonomy.cfi(None, None, set_cfi_code)
        else:
            FRegulatoryLogger.ERROR(logger, "Please provide a valid trade for its cfi_code")
        return cfi_code

    def notional_amount(self, trade=None):
        """ Returns notional amount for trade"""
        notional_amt = None
        trade = self.__get_trade(trade)
        if trade:
            notional_amt = FRegulatoryNotionalAmount.FRegulatoryNotionalAmount(trade).notional_amount()
        else:
            FRegulatoryLogger.ERROR(logger, "Please provide a valid trade for its notional_amount")
        return notional_amt

    def is_fx_forward(self, trade=None):
        """returns True if the trade is an FXForward"""
        fx_forward = None
        trade = self.__get_trade(trade)
        if trade:
            fx_forward = False
            try:
                if trade.IsFxForward():
                    fx_forward = True
            except:
                pass
        else:
            FRegulatoryLogger.ERROR(logger, "Please provide a valid trade for its is_fx_forward")
        return fx_forward

    def is_fx_swap(self, trade=None):
        """returns True if the trade is one of the legs in an FXSwap"""
        fx_swap = None
        trade = self.__get_trade(trade)
        if trade:
            fx_swap = False
            try:
                if trade.FxSwapFarLeg():
                    fx_swap = True
                if trade.FxSwapNearLeg():
                    fx_swap = True
            except:
                pass
        else:
            FRegulatoryLogger.ERROR(logger, "Please provide a valid trade for its is_fx_swap")
        return fx_swap

    def is_near_leg_fx_swap(self, trade=None):
        """returns True if the trade is the near leg of an FXSwap"""
        fx_swap = None
        trade = self.__get_trade(trade)
        if trade:
            fx_swap = False
            try:
                if trade.FxSwapFarLeg():
                    fx_swap = True
            except:
                pass
        else:
            FRegulatoryLogger.ERROR(logger, "Please provide a valid trade for its is_near_leg_fx_swap")
        return fx_swap
    
    def isin(self, trade=None):
        """added to ensure backward compatibility if this api is already consumed by any user"""
        return self.Isin(trade)

    def Isin(self, trade=None):
        """returns the Isin on the trade if present, else fallback to Isin on the instrument and then similarIsin on the instrument's RegulatoryInfo"""
        isin = None
        trade = self.__get_trade(trade)
        if trade:
            try:
                if trade.RegulatoryInfo().AdditionalInfo().RegInsIsin():
                    isin = trade.RegulatoryInfo().AdditionalInfo().RegInsIsin()
            except:
                if trade.AdditionalInfo().RegInsIsin():
                    isin = trade.RegulatoryInfo().RegInsIsin()
            if not isin:
                ins = trade.Instrument()
                ins_reg = InstrumentRegInfoBase(ins)
                isin = ins_reg.Isin()
        else:
            FRegulatoryLogger.ERROR(logger, "Please provide a valid trade for its isin")
        return isin

    def reported_price(self):  # this is the clean price
        # TODO:
        pass

    def price(self, trade=None):
        """returns the Transaction Price amount of the trade"""
        price = None
        trade = self.__get_trade(trade)
        if trade:
            instrument = trade.Instrument()
            ins_type = instrument.InsType()
            if (ins_type in ['Bill', 'Bond', 'Convertible', \
                             'DualCurrBond', 'FRN', 'PromisLoan', \
                             'Zero', 'Flexi Bond', 'IndexLinkedBond']):
                if instrument.Quotation().Name() == 'Yield':
                    price = trade.Price() / instrument.Quotation().QuotationFactor()
                else:
                    price = trade.Price() * instrument.Quotation().QuotationFactor() * 100
            elif ins_type in ['Stock', 'Deposit', \
                              'CD', 'MBS/ABS', 'Commodity Index', \
                'Future/Forward', 'FreeDefCF'] or (ins_type == 'Curr' and (self.is_fx_forward(trade))):
                price = trade.Price()
            elif ins_type in ['IndexLinkedSwap', 'TotalReturnSwap', 'Swap'] and \
                            FRegulatoryLibUtils.get_swap_type(instrument) in ['Fixed Fixed Swap', 'Vanilla Swap']:
                fixed_rate = 0
                for leg in trade.Instrument().Legs():
                    if FRegulatoryLibUtils.get_swap_type(instrument) == 'Fixed Fixed Swap':
                        if leg.LegType() == 'Fixed':
                            if fixed_rate:
                                fixed_rate = fixed_rate - leg.FixedRate()
                            else:
                                fixed_rate = leg.FixedRate()
                    else:
                        fixed_rate = instrument.FirstFixedLeg().FixedRate()
                price = fixed_rate
            elif ins_type in ['Swap', 'IndexLinkedSwap', 'TotalReturnSwap', 'CurrSwap'] and \
                            FRegulatoryLibUtils.get_swap_type(instrument) == 'Basis Swap':
                float_rate = 0
                for leg in trade.Instrument().Legs():
                    if leg.Spread():
                        if not float_rate:
                            float_rate = leg.Spread()
                            price = float_rate
                        else:
                            msg = "Cannot infer the Price for trade <%d> on instrument <%s> as it has spread on both the legs." % (trade.Oid(), instrument.Name())
                            FRegulatoryLogger.ERROR(logger, msg)
                            raise Exception(msg)
            elif ins_type in ['CurrSwap'] and FRegulatoryLibUtils.get_swap_type(instrument) in ['Vanilla Swap']:
                price = instrument.FirstFixedLeg().FixedRate()
            elif ins_type in ['FRA']:
                price = (trade.Instrument().Legs()[0].FixedRate())
            elif ins_type in ['CreditDefaultSwap']:
                # decorater = acm.FTradeLogicDecorator(self.trade, None)
                # price = decorater.ViceVersa()
                # price = (price) * 100
                price = trade.Instrument().FirstFixedLeg().FixedRate()
            elif ins_type == 'Curr' and self.is_fx_swap(trade):
                both_trades = True
                if config_param:
                    if config_param.get_paramvalue('FREGULATORY_FXSWAP_TRADES') and \
                                    config_param.get_paramvalue('FREGULATORY_FXSWAP_TRADES').upper() == 'SINGLE':
                        both_trades = False
                if both_trades:
                    price = trade.Price()
                else:
                    currency1 = instrument.Name()
                    currency2 = trade.Currency().Name()
    
                    conversion_factor, curr_pair = InstrumentRegInfoBase.get_conversion_factor(currency1, currency2)
                    if not curr_pair:
                        FRegulatoryLogger.ERROR(logger, "PriceAmount could not be calculated for trade <%d> as the currency pair for <%s> and <%s> is not available in ADS" % (trade.Oid(), currency1, currency2))
                    if conversion_factor:
                        price = (trade.Price() - trade.FxSwapFarLeg().Price()) / conversion_factor
                        price = (price)
            elif ins_type in ['Option']:
                if instrument.Underlying().InsType() == 'Curr':
                    call_currency = instrument.Underlying().Name()
                    premium_currency = trade.Currency().Name()
                    if call_currency != premium_currency:
                        conversion_factor, curr_pair = InstrumentRegInfoBase.get_conversion_factor(call_currency, premium_currency)
                        if not curr_pair:
                            FRegulatoryLogger.ERROR(logger, "PriceAmount could not be calculated for trade <%d> as the currency pair for <%s> and <%s> is not available in ADS" % (trade.Oid(), call_currency, premium_currency))
                        if conversion_factor:
                            price = trade.Price() * conversion_factor
                    else:
                        price = trade.Price()
                else:
                    price = trade.Price()
            elif ins_type in ['Cap', 'Floor']:
                price = trade.Price()
                if 'Per Unit' in trade.Instrument().Quotation().QuotationType():
                    price = price * trade.Instrument().Quotation().QuotationFactor()
                elif 'Factor' in trade.Instrument().Quotation().QuotationType():
                    price = price * 100 * trade.Instrument().Quotation().QuotationFactor()
            elif ins_type in ['FXOptionDatedFwd']:
                if trade.Instrument().ExerciseEvents():
                    price = trade.Instrument().ExerciseEvents()[0].Strike()
            else:
                FRegulatoryLogger.ERROR(logger, "Price could not be inferred for trade <%d> as instrument type <%s> is currently not supported" % (trade.Oid(), trade.Instrument().InsType()))
        else:
            FRegulatoryLogger.ERROR(logger, "Please provide a valid trade for its price")
        return price

    def ISITC_type_code(self, trade=None):
        """"returns the ISIT classification code for the FXTrade"""
        trade = self.__get_trade(trade)
        ISITC_type_code_val = None
        if trade:
            isitic_code_obj = FRegulatoryISITCode.ISITCodeType(trade)
            ISITC_type_code_val = isitic_code_obj.get_isitic_classification()
        else:
            FRegulatoryLogger.ERROR(logger, "Please provide a valid trade for its ISITC_type_code value")
        return ISITC_type_code_val

    def is_cleared(self, trade=None):
        """return True of the trade is cleared at clearing house, else False"""
        trade = self.__get_trade(trade)
        is_cleared_trd = None
        if trade:
            if trade.RegulatoryInfo() and trade.RegulatoryInfo().ClearingHouse():
                is_cleared_trd = True
            else:
                is_cleared_trd = False
        else:
            FRegulatoryLogger.ERROR(logger, "Please provide a valid trade for its is_cleared value")
        return is_cleared_trd

    def master_agreement_type(self, master_agreement_type_override_dict=None, trade=None):
        """returns the master agreement type on the trade"""
        master_agreement_type_val = None
        trade = self.__get_trade(trade)
        if trade:
            if trade.AgreementLinks() and\
            trade.AgreementLinks()[0].MasterAgreement():
                if master_agreement_type_override_dict:
                    master_agreement_type_dict =\
                    FRegulatoryLookup.master_agreement_type_dict.extend(\
                    master_agreement_type_override_dict)
                master_agreement_typ = trade.AgreementLinks()[0].MasterAgreement().DocumentType()
                if master_agreement_typ in FRegulatoryLookup.master_agreement_type_dict.keys():
                    master_agreement_type_val = FRegulatoryLookup.master_agreement_type_dict[master_agreement_typ]
        else:
            FRegulatoryLogger.ERROR(logger, "Please provide a valid trade for its master_agreement_type value")
        return master_agreement_type_val

    def implied_volatility(self, trade=None):
        """Returns the implied volatility of the trade."""
        return None #currently not implemented

class PersonRegInfoBase(object):
    def __init__(self, person):
        self.contact = None
        self.person = None
        try:
            if person.IsKindOf(acm.FContact):
                self.contact = person
            elif person.IsKindOf(acm.FPerson):
                self.person = person               
        except:
            pass

    def national_id(self):
        """generate, and possibly store, the NationalId based on the CONCAT"""
        return self.concat()

    def concat(self):
        """generate the CONCAT national ID on the basis of the contact's first and last name and data of birth"""
        national_id = None
        reg_info = None
        partyReg = None
        if self.contact:
            reg_info = self.contact.RegulatoryInfo()
            partyReg = PartyRegInfoBase(self.contact.Party())
        elif self.person:
            reg_info = self.person
            if self.person.Contacts():
                partyReg = PartyRegInfoBase(self.person.Contacts()[0].Party())
        if reg_info:
            national_id = reg_info.NationalId()
            if not national_id:
                first_name = ''
                last_name = ''
                date_of_birth = ''
                if reg_info.FirstName():
                    first_name = (reg_info.FirstName() + '#####')[0:5]
                if reg_info.LastName():
                    last_name = (reg_info.LastName() + '#####')[0:5]
                if reg_info.DateOfBirth():
                    try:
                        date_of_birth = ''.join(ael.date_from_string(reg_info.DateOfBirth()).to_string(ael.DATE_ISO).split('-'))
                    except Exception as e:
                        FRegulatoryLogger.ERROR(logger, "Error while getting the date of birth from Person. Error: <%s>" % str(e)) 

                national_id = date_of_birth + first_name.upper() + last_name.upper()
                if partyReg.jurisdiction():
                    national_id = partyReg.jurisdiction() + national_id
        else:
            FRegulatoryLogger.ERROR(logger, "Please provide a valid contact/person")
        return national_id

class UniqueTradeIdentifierBase(object):
    uti_installation = None
    uti_system = None
    uti_category = None
    uti_user_check_sum = None

    def __init__(self, acm_trade=None, installation='Prod', system='FrontArena', utiCategory="E02", useChecksum=True):
        # Store installation, system, utiCtegory and useChecksum
        # Store them statically since they should be initialized at "Organization" level
        UniqueTradeIdentifierBase.uti_installation = installation
        UniqueTradeIdentifierBase.uti_system = system
        UniqueTradeIdentifierBase.uti_category = utiCategory
        UniqueTradeIdentifierBase.uti_user_check_sum = useChecksum
        self.trade = acm_trade

    def __get_trade(self, trade=None):
        """returns a valid trade object or None depending on the input argument"""
        trd = self.trade
        if trade:
            trd = trade
        return trd

    def check_sum(self, utiVal):
        """generate check sum for a UTI"""
        return FRegulatoryLibUtils.check_sum(utiVal)

    def generateUTI(self, trade=None, uti_category=None, uti_system=None, uti_installation=None):
        """generate a UTI, with a bank-defined, structure, to be used across the bank"""
        uti = None
        trade = self.__get_trade(trade)
        if uti_category:
            UniqueTradeIdentifierBase.uti_category = uti_category
        if uti_system:
            UniqueTradeIdentifierBase.uti_system = uti_system
        if uti_installation:
            UniqueTradeIdentifierBase.uti_installation = uti_installation
        our_org = FRegulatoryLibUtils.our_org(trade)
        lei = None
        if our_org:
            lei = our_org.LegalEntityId()
        if not lei:
            FRegulatoryLogger.ERROR(logger,
                                    "UniqueTradeIdentifier cannot be generated for trade <%d> as either the OurOrganisation or the Acquirer are not set or they do not have a valid LEI." % trade.Oid())
        else:
            uti = UniqueTradeIdentifierBase.uti_category.upper() + lei + UniqueTradeIdentifierBase.uti_system.upper() + UniqueTradeIdentifierBase.uti_installation.upper() + str(
                trade.Oid())
            uti = self.check_sum(uti)
        return uti

    def uti(self, trade=None, generateIfNotExists=False):
        """Generates and returns the UTI for the trade if not present on it. If already present on the trade, it returns the existing UTI"""
        uti = None
        trade = self.__get_trade(trade)
        if trade:
            uti = FRegulatoryLibUtils.get_uti_from_trade_attribute(trade)
            if not uti:
                uti = FRegulatoryLibUtils.get_uti_from_trade_alais(trade)
            if not uti:
                uti = FRegulatoryLibUtils.get_uti_from_trade_addinfo(trade)
            try:
                if (not uti) and acm.FTradeAdditionalInfo.GetMethod('UTI1_Part', 0):
                    uti = trade.AdditionalInfo().UTI1_Part() + trade.AdditionalInfo().UTI2_Part()
            except:
                FRegulatoryLogger.INFO(logger, "The UTI1_Part and UTI2_Part AdditionalInfoSpecs are not present on the Trade")
            if (not uti) and generateIfNotExists:
                uti = self.generateUTI(trade, UniqueTradeIdentifierBase.uti_category, UniqueTradeIdentifierBase.uti_system, UniqueTradeIdentifierBase.uti_installation)
        else:
            FRegulatoryLogger.ERROR(logger, "Please provide a valid trade for its UTI")
        return uti

    def is_correct_check_sum(self, uti_val):
        """validate the check sum"""
        b_correct_check_sum = None
        if uti_val:
            b_correct_check_sum = FRegulatoryLibUtils.is_valid_check_sum(uti_val)
        else:
            FRegulatoryLogger.INFO(logger, "Please provide a UTI value to verify checksum")
        return b_correct_check_sum

    def trade_UTI_has_correct_check_sum(self, trade=None):
        """validate the check sum of a UTI"""
        b_correct_check_sum = None
        trade = self.__get_trade(trade)
        if trade:
            uti_val = self.uti(trade)
            b_correct_check_sum = False
            if uti_val:
                b_correct_check_sum = FRegulatoryLibUtils.is_valid_check_sum(uti_val)
            else:
                FRegulatoryLogger.INFO(logger, "Trade <%d> does not have UTI on it" % trade.Oid())
        else:
            FRegulatoryLogger.ERROR(logger, "Please provide a valid trade for its trade_UTI_has_correct_check_sum")
        return b_correct_check_sum

    def have_we_generated_UTI(self, trade=None):
        """was this UTI generated by the bank, or imported"""
        b_generated_uti = None
        trade = self.__get_trade(trade)
        if trade:
            b_generated_uti = False
            if self.uti(trade) == self.generateUTI(trade):
                b_generated_uti = True
        else:
            FRegulatoryLogger.ERROR(logger, "Please provide a valid trade for its have_we_generated_UTI")
        return b_generated_uti

class AccountRegInfoBase(object):
    def __init__(self, account=None):
        self.account = account
    
    @classmethod
    def isValidIBAN(self, iban_val):
        """returns True if the given iban value is a valid IBAN"""
        isValidIBAN = False
        iban_val = iban_val.upper()
        iban_val = iban_val.replace(' ', '')
        iban_val = iban_val.strip()
        if len(iban_val) > 34:
            FRegulatoryLogger.INFO(logger,\
            "The maximum length of IBAN is 34 characters. The length of <%s> is <%s> characters. Hence, this is not a valid IBAN value"%(\
            iban_val, len(iban_val)))
        else:
            isValidIBAN = FRegulatoryLibUtils.is_valid_for_country(iban_val)
            if isValidIBAN:
                isValidIBAN = FRegulatoryLibUtils.is_valid_iban_check_sum(iban_val)
        return isValidIBAN



...

  FRegulatoryLookup
import acm, ael
currency_codes = [
                    'AED', 'AFN', 'ALL', 'AMD',
                    'ANG', 'AOA', 'ARS', 'AUD',
                    'AWG', 'AZN', 'BAM', 'BBD',
                    'BDT', 'BGN', 'BHD', 'BIF',
                    'BMD', 'BND', 'BOB', 'BRL',
                    'BSD', 'BTN', 'BWP', 'BYN',
                    'BZD', 'CAD', 'CDF', 'CHF',
                    'CLP', 'CNY', 'COP', 'CRC',
                    'CUC', 'CUP', 'CVE', 'CZK',
                    'DJF', 'DKK', 'DOP', 'DZD',
                    'EGP', 'ERN', 'ETB', 'EUR',
                    'FJD', 'FKP', 'GBP', 'GEL',
                    'GGP', 'GHS', 'GIP', 'GMD',
                    'GNF', 'GTQ', 'GYD', 'HKD',
                    'HNL', 'HRK', 'HTG', 'HUF',
                    'IDR', 'ILS', 'IMP', 'INR',
                    'IQD', 'IRR', 'ISK', 'JEP',
                    'JMD', 'JOD', 'JPY', 'KES',
                    'KGS', 'KHR', 'KMF', 'KPW',
                    'KRW', 'KWD', 'KYD', 'KZT',
                    'LAK', 'LBP', 'LKR', 'LRD',
                    'LSL', 'LYD', 'MAD', 'MDL',
                    'MGA', 'MKD', 'MMK', 'MNT',
                    'MOP', 'MRU', 'MUR', 'MVR',
                    'MWK', 'MXN', 'MYR', 'MZN',
                    'NAD', 'NGN', 'NIO', 'NOK',
                    'NPR', 'NZD', 'OMR', 'PAB',
                    'PEN', 'PGK', 'PHP', 'PKR',
                    'PLN', 'PYG', 'QAR', 'RON',
                    'RSD', 'RUB', 'RWF', 'SAR',
                    'SBD', 'SCR', 'SDG', 'SEK',
                    'SGD', 'SHP', 'SLL', 'SOS',
                    'SPL', 'SRD', 'STN', 'SVC',
                    'SYP', 'SZL', 'THB', 'TJS',
                    'TMT', 'TND', 'TOP', 'TRY',
                    'TTD', 'TVD', 'TWD', 'TZS',
                    'UAH', 'UGX', 'USD', 'UYU',
                    'UZS', 'VEF', 'VND', 'VUV',
                    'WST', 'XAF', 'XCD', 'XDR',
                    'XOF', 'XPF', 'YER', 'ZAR',
                    'ZMW', 'ZWD']
mic_codes = [
        'DRSP', 'XCNQ', 'PURE', 'ZODM', 'FNFX', 'NORX', 'POSE', 'PUND',
        'UCBG', 'NZFX', 'BBLX', 'BACR', 'SPBE', 'OTCM', 'STUF', 'XSTP',
        'STUE', 'FREX', 'HCER', 'IDXM', 'MBCP', 'GMBG', 'OCEA', 'OSDS',
        'OSSG', 'RR4G', 'TRUK', 'UGEN', 'XGLO', 'WIND', 'CNOD', 'BGLU',
        'FNIX', 'LATG', 'GFAM', 'TMCY', 'UBEC', 'ENSL', 'ESLO', 'IOTF',
        'SEBA', 'XUBS', 'AMLG', 'BRED', 'DBMO', 'DBLN', 'RUSX', 'UNGB',
        'XLQC', 'XMOS', 'ABXX', 'CFIC', 'HBFR', 'KLSH', 'MUDX', 'TRAX',
        'TRNL', 'XPET', 'LEVL', 'EBXV', 'FXRS', 'FXPS', 'XBIS', 'STRM',
        'ABNC', 'BNPC', 'PBGR', 'SIDX', 'SIFX', 'TEUR', 'TPEE', 'AILT',
        'ARAX', 'CGXS', 'EQOC', 'EQOD', 'AQED', 'EIXE', 'HPCS', 'MIDC',
        'RABL', 'RMMS', 'RMMX', 'MABX', 'CECA', 'HPCO', 'ICOR', 'JNSI',
        'TPER', 'XSDX', 'XSWX', 'XDLP', 'XSWM', 'XSEB', 'XBTR', 'XQOD',
        'XQMH', 'BNPX', 'BTRL', 'NTUK', 'EQOS', 'LMNR', 'CEDX', 'EQCA',
        'EQUS', 'EVOL', 'RBCC', 'BEBG', 'CBKS', 'XTXD', 'XOAS', 'XOSL',
        'SGA2', 'EWRM', 'MERK', 'XOBD', 'BSAB', 'BSPL', 'BSTX', 'XNOM',
        'BBOK', 'BLFX', 'OLBB', 'SGMU', 'AFEX', 'BNPL', 'CAPL', 'CCMX',
        'ONEC', 'MBSI', 'MSBI', 'SGMV', 'SGMW', 'T212', 'TMEX', 'XCBO',
        'C2OX', 'PEPQ', 'PEPY', 'PEPH', 'PEPM', 'XPOM', 'GROW', 'CLST',
        'LLAT', 'EPRD', 'GSPL', 'IMMH', 'ENMS', 'FAST', 'TLCM', 'ILCM',
        'LELE', 'MCXX', 'MEMD', 'EBSO', 'PEPW', 'WFLB', 'WFSE', 'VNDM',
        'WABR', 'XSCA', 'TMCC', 'EDBT', 'EDGL', 'ETLX', 'BASP', 'BTEQ',
        'EQSE', 'VABD', 'IMCC', 'NBFL', 'NEXT', 'NEXN', 'NEXF', 'NEXX',
        'NEXG', 'NEXL', 'NEXD', 'MAXD', 'BTBS', 'SKBB', 'BDSK', 'DEXE',
        'OTPR', 'SBIU', 'XSBI', 'SBIV', 'SBIJ', 'XOTP', 'EQSL', 'JSER',
        'XBVM', 'HESP', 'HEDE', 'MAQE', 'MEMX', 'PARK', 'PJCX', 'PIPR',
        'SKYX', 'CIMA', 'GLOM', 'TRAI', 'CBOE', 'CGEE', 'CGEC', 'CGMC',
        'COHR', 'STFX', 'XLCH', 'CLCH', 'BUYN', 'BGHX', 'CSAS', 'LTSE',
        'MALM', 'XPSF', 'XPOT', 'XFEX', 'CALH', 'OMIP', 'XLIS', 'DAUK',
        'BSLB', 'CFIL', 'CGMU', 'CSCL', 'CSVW', 'RBCM', 'THRE', 'BKKT',
        'UKRE', 'UKOR', 'IUOB', 'TUOB', 'XPUS', 'BMLS', 'BMLI', 'SGMZ',
        'PFXD', 'TRQC', 'ITGL', 'XAMM', 'AMNL', 'BETA', 'VFGB', 'SEBL',
        'XPOL', 'XPAL', 'VIUK', 'ASPI', 'ASMT', 'ASPN', 'CISD', 'CDSI',
        'RESF', 'EBSF', '24EX', 'BBSX', 'SCOT', 'XDEX', 'DOWE', 'SPEX',
        'IFAD', 'JLQD', 'LAMP', 'RCMA', 'IEBS', 'ERIS', 'MKTF', 'MKAA',
        'XSGB', 'YKNA', 'CGET', 'CSDA', 'DOWM', 'GSXC', 'GSXK', 'GSXT',
        'VAGM', 'BMCM', 'NSME', 'ABFI', 'BEUP', 'CEUD', 'CEUX', 'CEUO',
        'DASH', 'MISX', 'XBND', 'BLKX', 'PLPD', 'BAJD', 'NMSX', 'XLOD',
        'NEOE', 'NEOD', 'NEON', 'NEOC', 'TRPX', 'KOME', 'TRCX', 'ERBX',
        'FLTR', 'IBER', 'ALLT', 'BATE', 'BATF', 'BATD', 'BILU', 'BTQE',
        'BTQG', 'CBSK', 'CODA', 'SMBD', 'STFL', 'XALT', 'EBRA', 'XCAN',
        'XRMO', 'XNCO', 'SAGE', 'ARCH', 'EXPM', 'TNLK', 'XDRK', 'VDRK',
        'GFPO', 'JPMS', 'SNUK', 'ARKX', 'PUMX', 'SVXI', 'VWDA', 'XALS',
        'BGFU', 'CGMG', 'PUMA', '4AXE', 'EBHU', 'FNUK', 'XMFX', 'TRFW',
        'UCHU', 'CBNL', 'FTUS', 'BGUK', 'CLVE', 'NLAX', 'CPGX', 'CEPL',
        'CEPU', 'DBAB', 'OTCN', 'RTSL', 'TRAL', 'TDGF', 'UBSB', 'UBSI',
        'UBSL', 'XETV', 'XETW', 'XETU', 'FRAV', 'FRAW', 'FRAU', 'BFPT',
        'CONC', 'IFBX', 'IPXW', 'ZERO', 'SCXS', 'SCXO', 'SCXM', 'SYFX',
        'SSIL', 'TPIR', 'XCHI', 'XCIS', 'MANL', 'CELP', 'BETX', 'BTLX',
        'CCEX', 'ZBUL', 'IMSB', 'AQEU', 'AQEA', 'AQXA', 'AQXE', 'BKDM',
        'BNLD', 'CAVD', 'GIPB', 'GSPX', 'ICPM', 'IMGI', 'IMRD', 'IMET',
        'IMGB', 'IMMM', 'IMFD', 'IMCE', 'IMED', 'JLEU', 'SMFF', 'SPTR',
        'ELXE', 'SCAG', 'SGAS', 'SMFE', 'TRXE', 'JBUL', 'MHBE', 'CSGI',
        'EUCC', 'BLEQ', 'BREA', 'MCAD', 'EBMX', 'XMSM', 'XESM', 'UKGD',
        'XTXE', 'BLUE', 'BTAM', 'CABV', 'RFBK', 'TOWR', 'GBUL', 'FLWX',
        'BLUX', 'DBLX', 'DHLX', 'KHHU', 'MCID', 'NCME', 'TRQM', 'XBLK',
        'ISWO', 'ISWP', 'ISWN', 'ISWT', 'MSEL', 'NCML', 'FXRQ', 'FXFM',
        'PBUL', 'XPUK', 'CSAG', 'XETF', 'GSEI', 'GSBE', 'HREU', 'CREM',
        'DWFI', 'BNPP', 'CBKC', 'CIBH', 'CSMD', 'SIMD', 'GMES', 'GMEO',
        'KBLC', 'KBLS', 'KBLT', 'KBLL', 'MHBP', 'MHEU', 'UBCZ', 'XETS',
        'FRAS', 'ATLN', 'LBCW', 'VALX', 'AGBP', 'CESI', 'EBSN', 'ECEU',
        'TPIO', 'TPIC', 'XTRD', 'MLEX', 'MLER', 'MLES', 'DSME', 'FSME',
        'XNFI', 'SSME', 'ATHL', 'BCSC', 'CFIF', 'JESI', 'JEFE', 'MHBL',
        'NOWX', 'PKOP', 'VCRS', 'VUSA', 'VFMI', 'ABAN', 'BRDS', 'EQIE',
        'EQLD', 'GPBC', 'RTSX', 'OHVO', 'RBCG', 'RMTF', 'UCBA', 'UCDE',
        'UCIT', 'BRGA', 'XNOR', 'XNXD', 'BCMA', 'CSOB', 'ICXR', 'ICUR',
        'IFXC', 'IFXA', 'IFXR', 'MUSN', 'SPDX', 'MESI', 'NIBC', 'UICE',
        'XNDU', 'GBWB', 'ECSL', 'MSEU', 'BRDL', 'BRDE', 'CIBC', 'CIBP',
        'FTFM', 'FTFS', 'CABK', 'BARU', 'BEUO', 'BEUT', 'CCRM', 'CAPA',
        'LISZ', 'CCXE', 'DEKA', 'IATS', 'ICOT', 'IPXP', 'ISSI', 'JYSI',
        'NWNV', 'OTPB', 'RBHU', 'RENC', 'TPEU', 'WSIL', 'INGW', 'MAKX',
        'WSIN', 'BGFX', 'BGFI', 'SLHB', 'SIBC', 'WELN', 'BMLB', 'XSAT',
        'BAIP', 'BAEP', 'DAVY', 'LIGA', 'MBPL', 'WELS', 'CBAL', 'SCXA',
        'SIAB', 'BKSK', 'CMCI', 'MHBD', 'CSOT', 'MUSE', 'NABA', 'ABNA',
        'BBIS', 'BBIE', 'ERST', 'IKBS', 'TQEX', 'TQEB', 'TQEM', 'TQEA',
        'APAW', 'NABL', 'OBKL', 'TWJP', 'HRTF', 'SMBB', 'CGMD', 'EXYY',
        'EXSF', 'EXSP', 'EXSD', 'EXSB', 'EXSH', 'HEMO', 'IMCT', 'METZ',
        'MUBL', 'MUBM', 'MUBP', 'RBIV', 'SMBG', 'TRQB', 'MUBE', 'JPEU',
        'SMBE', 'SMBP', 'LEUE', 'LEUF', 'HELA', 'NESI', 'BHWA', 'FINN',
        'ISBV', 'KBCB', 'MAQI', 'MAQU', 'XFCI', 'XFDA', 'FICO', 'LBBW',
        'LBWL', 'LBWS', 'EDGA', 'EDGD', 'EDGO', 'EDGX', 'BATS', 'BATY',
        'BYXD', 'BZXD', 'EDDP', 'BATO', 'ZFXM', 'BAPE', 'BASE', 'BCEE',
        'BLIQ', 'BSFX', 'BDEA', 'BLBS', 'BPKO', 'BTFE', 'HRSI', 'R5FX',
        'SISI', 'BEIS', 'BLBB', 'BASX', 'HRTX', 'INCR', 'MSRP', 'OCSI',
        'EDRF', 'BNSX', 'EXSE', 'MSSI', 'MELO', 'AIXK', 'CIOI', 'LBCM',
        'RLBO', 'SBEX', 'VTBC', 'XEHQ', 'ZARX', 'IPSX', 'COMM', 'MOSE',
        'DOSE', 'ATLB', 'CCMS', 'DAIW', 'IBEQ', 'IINX', 'EMLD', 'OPCO',
        'TSBX', 'BELF', 'BELB', 'IMTF', 'MAGM', 'ASXC', 'CFBC', 'BLXA',
        'GFKS', 'SGOE', 'UBSA', 'UBSS', 'IBIS', 'TFSD', 'TRAS', 'TSIG',
        'UTSL', 'CSZH', 'EUWA', 'EXSY', 'A2XX', 'FXOP', 'TCDS', 'TRDE',
        'ZAPA', 'AKIS', 'BPSX', 'ISWE', 'ISWV', 'IGDL', 'HPCV', 'JSSI',
        'TWGP', 'GMGD', 'GMGL', 'NPEX', 'OAPA', 'DDTX', 'HPCX', 'SB1M',
        'ANTS', 'SGMY', 'SGMX', 'SSBM', 'SSBI', 'DBES', 'DBAG', 'MKAP',
        'GSAL', 'GSXH', 'SIGH', 'SWEE', 'SWLT', 'SWLV', 'TECO', 'XZAP',
        'ODDO', 'ODOC', 'SANT', 'UBIN', 'CSLB', 'JISI', 'JEFS', 'VTPS',
        'VWDX', 'VTLS', 'BAMX', 'IMCO', 'SEBS', 'INCA', 'SSOB', 'XABC',
        'GFIC', 'KELR', 'XBOX', 'NORD', 'OTXB', 'SEMX', 'XAPA', 'AACA',
        'ABSI', 'BINV', 'GLMX', 'GTXE', 'JPCB', 'REST', 'NLBX', 'XREP',
        'ROSR', 'XROT', 'XLLB', 'XVPB', 'HBPL', 'LMAO', 'LMAE', 'LMAF',
        'XABG', 'ALSI', 'APCL', 'SBSI', 'TDBL', 'BNPA', 'BNPF', 'BNPS',
        'SEDX', 'ICEO', 'IECL', 'IOFI', 'IOFX', 'IOGB', 'IOCD', 'IOED',
        'IOGI', 'IOIR', 'IOMM', 'ISWA', 'MDRV', 'NWMS', 'RBCE', 'IFSM',
        'XSGA', 'ANLP', 'KBLM', 'KOTF', 'LASP', 'MACB', 'TDON', 'TSAF',
        'UBIS', 'BRFQ', 'BNTW', 'BLOX', 'IOTC', 'XIEL', 'XOAA', 'BASI',
        'BANA', 'BOAL', 'CSEC', 'MLSI', 'MLIX', 'MLRQ', 'SVEX', 'SVES',
        'AAPA', 'CIMV', 'CIMB', 'CIME', 'CIMD', 'CURX', 'INGE', 'INGF',
        'SKSI', 'SQUA', 'SSBT', 'SSFX', 'AFSO', 'AFSX', 'AFSL', 'AFSA',
        'AFSI', 'ARIA', 'DVFX', 'ETPA', 'LOUI', 'RABO', 'BBVA', 'BTNL',
        'CAPI', 'XRCB', 'APEX', 'XGAT', 'TGSI', 'TGAT', 'XGRM', 'CGMT',
        'NYSI', 'XMAL', 'CASI', 'CNSI', 'TRQA', 'XOSA', 'CCEU',
        'XTXM', 'GFSM', 'GFSO', 'AURO', 'AURB', 'EXSI', 'ISWR', 'ISWC',
        'ISWB', 'TSCB', 'VAGL', 'BCSL', 'BCSI', 'BGCO', 'GFBM', 'GFBO',
        'GFIB', 'GFIF', 'GFIN', 'GFIR', 'INGB', 'SFCL', 'TPSL', 'TSMR',
        'VONT', 'BKBR', 'BKBF', 'CBKA', 'TSRE', 'TSCD', 'TSGB', 'TSFI',
        'TSED', 'TSGI', 'TSMM', 'TPSO', 'CBKD', 'CBKF', 'CBKE', 'CBKG',
        'CGML', 'CPTX', 'MAQL', 'DZBK', 'XPOS', 'TPEL', 'TEFD', 'TEMF',
        'TEMI', 'TIRD', 'TEMB', 'TEMR', 'TERE', 'TEFX', 'TEMM', 'TEGI',
        'TEIR', 'TPEO', 'TEGB', 'TWHK', 'TWJT', 'TWSG', 'WOOD', 'XRFQ',
        'XPAC', 'LOYD', 'SCXF', 'BOFS', 'SUNT', 'SWBI', 'WBKP', 'BGSI',
        'BPLC', 'BBSI', 'LSSI', 'JSEB', 'BIVA', 'BKLN', 'BKLF', 'FISU',
        'JBSI', 'NAPA', 'POTC', 'PPEX', 'ESTO', 'ONSE', 'BAAD', 'INVE',
        'XDNB', 'IFLS', 'EXOT', 'ANZL', 'BMEA', 'EBSC', 'ECHO', 'FBSI',
        'HSBC', 'HSBT', 'NATX', 'STAN', 'VCMO', 'AIMX', 'XLOM', 'ADVT',
        'SICS', 'CSIN', 'CSSI', 'DOWG', 'AMPX', 'FXGB', 'TRSI', 'RBSI',
        'RTSI', 'MUND', 'MUNC', 'BTEE', 'EBSS', 'RBCB', 'RBCT', 'WIPO',
        'GSIB', 'BISI', 'HUDX', 'IEXD', 'IMCS', 'UBSY', 'XEYE', 'XDUB',
        'XATL', 'BILT', 'XHNF', 'MUFP', 'VFIL', 'VFSI', 'VFXO', 'CCML',
        'CFTW', 'DAPA', 'VLEX', 'XSBT', '3579', 'MHIP', 'WINS', 'WINX',
        'ALXB', 'MLXB', 'ENXL', 'ALXL', 'XMLI', 'ALXP', 'SGMT', 'MASG',
        'TCML', 'FRTE', 'THEM', 'LEDG', 'MTSD', 'MTSF', 'MUTI', 'NDCM',
        'IMEQ', 'NDXS', 'NDEX', 'SPEC', 'ETFP', 'BART', 'BARO', 'BCRM',
        'BARK', 'BMTS', 'MTUS', 'GOTC', 'MFXC', 'MFXR', 'MFXA', 'SNSI',
        'VERT', 'IBUL', 'APXL', 'CLTD', 'DRCT', 'MTXX', 'CAVE', 'OTCB',
        'PINL', 'PINI', 'PINX', 'OTCQ', 'PSGM', 'PINC', 'XEER', 'XEEO',
        'XEEE', 'MTSO', 'MTSC', 'ELUK', 'ELNO', 'ELSE', 'ELEU', 'FREI',
        'NOSI', 'CSBX', 'CXOT', 'XBDV', 'DKED', 'DKFI', 'NOED', 'SEED',
        'PNED', 'USWB', 'NOFI', 'FIED', 'EBON', 'EUWB', 'DIFX', 'TREA',
        'TREO', 'AUTB', 'AUTX', 'AUTP', 'CXRT', 'ACKF', 'NEXS', 'VIRT',
        'BALT', 'BLTX', 'CGMA', 'CGMH', 'CGMI', 'LQFI', 'CGMX', 'CITX',
        'CITD', 'GRIO', 'LQED', 'MTXA', 'PTPG', 'UFEX', 'TSAD', 'XKAR',
        'XLGT', 'XSTF', 'STUC', 'STUD', 'XRSP', 'PEEL', 'XPHX', 'JPBX',
        'JPSI', 'AREX', 'HOTC', 'XADE', 'ENAX', 'XATH', 'CSAU', 'CFAU',
        'CSEU', 'CSCF', 'CSHK', 'CFHK', 'CSJP', 'CFJP', 'FICX', 'GBOT',
        'GRIF', 'IBGH', 'IEXG', 'LMEC', 'NEXO', 'NMRJ', 'NXJP', 'NXVW',
        'PARX', 'ELIX', 'TRDX', 'XBEL', 'BLBF', 'XBLB', 'XMOT', 'MOTX',
        'MUNB', 'MUNA', 'XMUN', 'XNXC', 'XOPV', 'XVES', '360T', 'AATS',
        'ACEX', 'AFDL', 'AFET', 'AFSE', 'AQUA', 'ASEX', 'XIPO', 'AWBX',
        'AWEX', 'BACE', 'MLCO', 'MLVX', 'BAML', 'BAPA', 'BAPX', 'BCDX',
        'BARL', 'BARX', 'BARD', 'BBSF', 'BCFS', 'XMVL', 'BCMM', 'BCSE',
        'CHIO', 'BATP', 'CHID', 'BOTC', 'BCXE', 'LISX', 'CHIX', 'BEAM',
        'BEEX', 'BETP', 'BFEX', 'BGCF', 'BGCD', 'FNCS', 'BGCB', 'BGCI',
        'BHSF', 'BIDS', 'BLEV', 'BLPX', 'BPOL', 'BLTD', 'SEND', 'XDRF',
        'MARF', 'BMCL', 'MERF', 'XBIL', 'XMAD', 'BMEX', 'SBIL', 'SBAR',
        'XVAL', 'XBAR', 'XLAT', 'XMPW', 'XMRV', 'BMTF', 'VTEX', 'NYFX',
        'BNYC', 'BOAT', 'BOSC', 'BOVA', 'BOVM', 'BRIX', 'BRNX', 'BSEX',
        'ICSU', 'BTEC', 'BVCA', 'BVMF', 'BVUR', 'CAND', 'CANX', 'CMAP',
        'CATS', 'CCFX', 'CCLX', 'CCO2', 'CDED', 'ASTR', 'FXCL', 'CDSL',
        'FXSW', 'CETI', 'CGQD', 'CGDB', 'CGTR', 'CGIT', 'CGND', 'CGEB',
        'CGQT', 'CGCM', 'CGGD', 'CHEV', 'BLNK', 'CXAR', 'CXAC', 'CXAP',
        'CXAM', 'CXAQ', 'CXAV', 'CXAF', 'CXAN', 'CXAW', 'CHIA', 'XCX2',
        'CHIC', 'CHIJ', 'KAIX', 'CHIS', 'CHIV', 'CLAU', 'CLHK', 'CLJP',
        'CLMX', 'CLPH', 'CMEC', 'CMEE', 'CMET', 'CMMT', 'CMSF', 'COAL',
        'COMG', 'COTC', 'CRED', 'CAES', 'CRYD', 'CRYP', 'CRYX', 'CSSX',
        'DASI', 'DBHK', 'AUTO', 'DBOX', 'DCSX', 'DEAL', 'DGCX', 'DKTC',
        'DOTS', 'DSMD', 'DUMX', 'ECAG', 'ECGS', 'ECAL', 'EEAL', 'EESE',
        'EGMT', 'EGSI', 'EMBX', 'EMIB', 'EMID', 'EMIR', 'EMDR', 'ENCL',
        'EOTC', 'EPEX', 'ETSC', 'EXOR', 'EXVP', 'EXMP', 'EXLP', 'EXEU',
        'EXCP', 'EXBO', 'EXDC', 'EXGM', 'XEDA', 'XEID', 'EXTR', 'FAIR',
        'FGEX', 'XADF', 'FINC', 'FINO', 'FINR', 'FINY', 'OOTC', 'FISH',
        'FLTB', 'FMTS', 'FSEF', 'FSHX', 'FXAL', 'FXCM', 'G1XX', 'GEMX',
        'GETB', 'GLLC', 'GLPS', 'GLPX', 'XGDX', 'XLDX', 'XGCX', 'GMEG',
        'XGSX', 'GMTF', 'GOVX', 'GREE', 'GRSE', 'GSCI', 'GSCO', 'GSEF',
        'GSIL', 'GSSI', 'GSXL', 'GTCO', 'GTSX', 'GTXS', 'GXMA', 'HCHC',
        'HDAT', 'HEGX', 'HMOD', 'HMTF', 'HRFQ', 'HPPO', 'HSFX', 'HSTC',
        'XHNX', 'HSXA', 'HUPX', 'IBAL', 'IBEX', 'ICDX', 'ICEL', 'ICXL',
        'IFCA', 'IFLX', 'IFLL', 'IFEN', 'IFLO', 'IFEU', 'IFUT', 'IFSG',
        'IMFX', 'IFED', 'IFUS', 'IEPA', 'IMCG', 'IMIR', 'IMCR', 'IMEN',
        'ICES', 'IMAG', 'IMBD', 'IMEX', 'ISDA', 'ISEX', 'ITGI', 'IVZX',
        'JADX', 'JEFX', 'JNST', 'JPMI', 'JPMX', 'JSES', 'JSJX', 'KCCP',
        'KLEU', 'KNIG', 'KNEM', 'KNLI', 'KNCM', 'KRME', 'LASF', 'LCHC',
        'LCUR', 'LICA', 'LIQH', 'LIQU', 'LIQF', 'LIUS', 'LIUH', 'LIFI',
        'LMAD', 'LMAX', 'LOTC', 'PLDX', 'LPPM', 'LMNX', 'LTAA', 'LXJP',
        'MAEL', 'MXLM', 'MALX', 'MXNL', 'MAQH', 'MAQJ', 'MAQX', 'MATN',
        'MATX', 'MBUL', 'MCXR', 'MCXS', 'MCUR', 'MFGL', 'MIBG', 'EPRL',
        'MPRL', 'MIHI', 'XMIO', 'MIZX', 'MSAL', 'MSPL', 'MSCO', 'MSTX',
        'MSIP', 'MSMS', 'BVUS', 'MTSB', 'MTXS', 'MTXC', 'MTXM', 'MYTR',
        'N2EX', 'NAMX', 'NASX', 'NBLX', 'NBOT', 'NCEL', 'NFSD', 'XSTM',
        'NFSA', 'NFSC', 'NGXC', 'NILX', 'NLPX', 'NMCE', 'NMRA', 'ICSH',
        'ICSZ', 'ICKR', 'ICHK', 'NXSE', 'ICTW', 'NODX', 'NOFF', 'NOPS',
        'NOSC', 'NOTC', 'NPGA', 'NSXB', 'NXEU', 'NXUS', 'NYPC', 'OLLC',
        'OMEL', 'OMGA', 'LYNX', 'OMIC', 'OPEX', 'OPRA', 'OSLC', 'OTCE',
        'OTCX', 'PAVE', 'PDEX', 'PFTS', 'PFTQ', 'PIEU', 'PIPE', 'PIRM',
        'PRSE', 'PVMF', 'PXIL', 'QWIX', 'RBSX', 'RICX', 'RICD', 'ROCO',
        'ROFX', 'ROTC', 'RPDX', 'RSEX', 'RTSP', 'S3FM', 'SECC', 'SECD',
        'SECE', 'SECF', 'SEDC', 'SELC', 'SEPE', 'SGEX', 'SGMA', 'SHAR',
        'SHAW', 'SHAD', 'SIGA', 'SIGJ', 'SIMV', 'SMEX', 'SOHO', 'SPIM',
        'SPRZ', 'SPXE', 'SSEX', 'SSTX', 'XSTV', 'STOX', 'XSCU', 'XSTX',
        'SWAP', 'SXSI', 'TERA', 'TFEX', 'TFSA', 'TFSU', 'TMID', 'TOCP',
        'TPIE', 'TPSE', 'TPSV', 'TRCK', 'TREU', 'TRQX', 'TRU2', 'TRU1',
        'TRUX', 'BNDD', 'TRWB', 'TWSF', 'DWSF', 'TSEF', 'TWEU', 'TWEM',
        'TWEA', 'TWEO', 'UBSP', 'UBSC', 'UBSG', 'UBSF', 'UBSX', 'UKEX',
        'UKPX', 'ULTX', 'VEGA', 'VFCM', 'VMFX', 'WSAG', 'XADS', 'XAFR',
        'XAFX', 'XALG', 'XEUC', 'XAMS', 'XEUI', 'TNLA', 'XEUE', 'XAQS',
        'XARM', 'XASX', 'ASXT', 'ASXB', 'ASXV', 'ASXP', 'XSFE', 'XATS',
        'XBAA', 'XBAB', 'BAJM', 'XBAH', 'XBAN', 'XBBJ', 'XBBK', 'XBCC',
        'MVCX', 'XBCL', 'XBCM', 'XBCX', 'XBCV', 'XBDA', 'BERA', 'BERB',
        'BERC', 'XBER', 'ZOBX', 'EQTA', 'EQTB', 'EQTC', 'EQTD', 'XEQT',
        'XBEY', 'XMAI', 'XBKK', 'XBKF', 'XBLN', 'XBNV', 'XBOG', 'XBOL',
        'XBOM', 'BSME', 'BOTE', 'XBOT', 'BOTV', 'XBRA', 'XBRM', 'XBRN',
        'VPXB', 'TNLB', 'XBRU', 'XBRD', 'XBRV', 'XRAS', 'XBSE', 'XBSD',
        'XBUD', 'XTND', 'XBUE', 'XMEV', 'XBUL', 'ABUL', 'XBVC', 'XBVR',
        'XCAI', 'XCAL', 'XCAS', 'XCAY', 'CBSX', 'XCBF', 'XCBT', 'FCBT',
        'XKBT', 'XCDE', 'XCET', 'XCFE', 'XCFF', 'XCGS', 'XCHG', 'XCIE',
        'FCME', 'XIMM', 'XCME', 'GLBX', 'XIOM', 'CMES', 'CBTS', 'NYMS',
        'CECS', 'XCNF', 'XCOL', 'XCOR', 'XCRO', 'DCSE', 'XCSE', 'MNDK',
        'FNDK', 'DNDK', 'MCSE', 'XCSX', 'XCUE', 'XCUR', 'XCXD', 'XCYO',
        'XCYS', 'XECM', 'XDAR', 'XDCE', 'XDES', 'XDFB', 'XDFM', 'XDHA',
        'XDPA', 'XDSE', 'XDSX', 'DUSA', 'DUSB', 'DUSC', 'DUSD', 'XDUS',
        'XQTX', 'XEBI', 'XECB', 'XECC', 'XECS', 'XELX', 'XEMD', 'XEMS',
        'XETR', 'XETB', 'XETA', 'XERT', 'XERE', 'XEUM', 'XEUP', 'XEUR',
        'XFKA', 'XFRA', 'FRAA', 'FRAB', 'XGAS', 'XGCL', 'XGHA', 'XGME',
        'XGMX', 'XGSE', 'XGTG', 'XGUA', 'HAMA', 'HAMB', 'XHAM', 'HAMM',
        'HAML', 'HAMN', 'HANB', 'HANA', 'XHAN', 'MNFI', 'FNFI', 'DNFI',
        'XHEL', 'DHEL', 'MHEL', 'XHKF', 'XHKG', 'SHSC', 'SZSC', 'XGEM',
        'XIBE', 'FNIS', 'MICE', 'XICE', 'DNIS', 'DICE', 'MNIS', 'XICX',
        'XIDX', 'XIHK', 'XIMA', 'XIMC', 'ICRO', 'XINS', 'ICBX', 'MOCX',
        'XINV', 'XIQS', 'XPMS', 'XFNO', 'XDSM', 'XIST', 'XEQY', 'XISE',
        'GMNI', 'MCRY', 'XISA', 'XISX', 'XJAM', 'XJNB', 'XTK1', 'XTKS',
        'XOSE', 'XTAM', 'XTK3', 'XTK2', 'XJPX', 'XOSJ', 'XBES', 'XJSE',
        'ALTX', 'XSAF', 'XSFA', 'YLDX', 'XKAC', 'XKAZ', 'XKCE', 'XKFB',
        'XKHA', 'XKHR', 'XKIE', 'XKIS', 'XKLS', 'MESQ', 'XKON', 'XKRX',
        'XKFE', 'XKOS', 'XKCM', 'XKEM', 'XKSE', 'XKUW', 'XLAO', 'XLBM',
        'XLFX', 'XLIM', 'MFOX', 'WQXL', 'FNLT', 'XLIT', 'XLJM', 'XLJU',
        'XLME', 'XLON', 'XLSM', 'XLUS', 'XLUX', 'EMTF', 'XMAB', 'XMAE',
        'PROS', 'XMAN', 'XMAU', 'XMDG', 'XMDS', 'XMER', 'XMEX', 'XMGE',
        'MTAH', 'ATFX', 'XMIL', 'MIVX', 'XDMI', 'MTAA', 'XMNT', 'XMNX',
        'XMOC', 'XMOD', 'XMOL', 'XMSW', 'XMTB', 'BVUK', 'XMTS', 'XMUS',
        'XNAF', 'XNAI', 'XNAM', 'NASD', 'XNMS', 'XNAS', 'XNDQ', 'XNGS',
        'XNCM', 'XNIM', 'XBOS', 'BOSD', 'XBXO', 'XPOR', 'XPSX', 'XBRT',
        'PSXD', 'XPBT', 'XPHO', 'XPHL', 'XNCD', 'XNEC', 'XNEP', 'XNGM',
        'NMTF', 'XNGO', 'XNKS', 'XNSA', 'INSE', 'XNSE', 'XNYM', 'XCEC',
        'XNYE', 'XNYL', 'ALDP', 'ARCX', 'XNYS', 'XASE', 'XNLI', 'NYSD',
        'AMXO', 'ARCD', 'ARCO', 'XNZE', 'XODE', 'XOFF', 'MERD', 'XOAM',
        'XOAD', 'XOSD', 'NIBR', 'XPAE', 'XSPM', 'MTCH', 'XPAR', 'XMAT',
        'XMON', 'XPHS', 'XPIC', 'XPOW', 'XPRA', 'XPRM', 'XPRI', 'XPST',
        'XPTY', 'XPXE', 'XQUI', 'XRBM', 'XRIS', 'FNLV', 'XRMZ', 'XROS',
        'XROX', 'XTUC', 'XRPM', 'XRUS', 'XSAM', 'XSAP', 'XSAU', 'XSC2',
        'XSC3', 'XSC1', 'XSCO', 'XSEF', 'XSES', 'XSIM', 'XSCE', 'XINE',
        'XSGE', 'XSGO', 'XSEC', 'XSHE', 'XSSC', 'XSHG', 'XSIB', 'XOSC',
        'XSOP', 'XSPS', 'XSSE', 'XSTC', 'XSTE', 'DNSE', 'FNSE', 'CSTO',
        'MNSE', 'MSTO', 'XSTO', 'DSTO', 'STUB', 'STUA', 'XSTU', 'EUWX',
        'XSVA', 'XSWA', 'XSWB', 'XTAE', 'XTAF', 'XTAI', 'XTAL', 'FNEE',
        'XTEH', 'XTFF', 'XTIR', 'XTKT', 'XTRN', 'XTRZ', 'XTSE', 'XTSX',
        'XTNX', 'XTUN', 'XUAX', 'XUGA', 'XUKR', 'XULA', 'XUNI', 'XUSE',
        'XVPA', 'RPWC', 'TBSP', 'TBSA', 'BOSP', 'WETP', 'XWAR', 'PLPO',
        'PLPS', 'WBCL', 'WBON', 'WMTF', 'WDER', 'EXAA', 'XWBO', 'WBAH',
        'WBDM', 'XVIE', 'XXSC', 'XXXX', 'XYIE', 'XZAG', 'XZCE', 'XZIM',
        'ZKBX', 'KMUX', 'UKCA', 'ASEF', 'MEMM', 'XEBS', 'NSPO', 'OTCI',
        'GFOX', 'FNFT', 'HGSP', 'TERM', 'PATF', 'BBVX', 'ODXE', 'HPSX',
        'DBDX', 'EMCE', 'HPSO', 'ARTX', 'SPTX', 'TSIR', 'STXS', 'EUFN',
        'TSFX', 'GFAU', 'CSE2', 'XIGG', 'SMBC', 'FNXB', 'BGCA', 'XFTX',
        'NABP', 'USOB', 'CMCM', 'EBLX', 'ERFQ', 'ENTW', 'FUSD', 'XETE',
        'XETX', 'SFOX', 'BJSE', 'NEEQ', 'VFEX', 'INGU', 'SISU', 'SEWB',
        'DKWB', 'NOWB', 'SEOB', 'DKOB', 'EUOB', 'GBOB', 'NOOB', 'OTXT', 
        'MXOP', 'BOCF', 'FPWB', 'SPAX', 'LEBV', 'LESI']
        
jurisdiction_codes = {'EU' : ['AT','BE', 'BG', 'CY', 'CZ', 'DE',\
                       'DK', 'EE', 'EL', 'ES', 'FI', 'FR',\
                       'HR', 'HU', 'IE', 'IT', 'LT',\
                       'LV', 'MT', 'NL', 'PL', 'PT', 'RO',\
                       'SE', 'SI', 'SK'],
                      'EEA' : ['FL', 'NO', 'IS'],
                      'EFTA' : ['CH', 'FL', 'IS', 'NO', 'LI'],
                      'Basel1988' : ['BE', 'CA', 'CH', 'DE', 'ES',\
                                     'FR', 'IT', 'JP', 'LU', 'NL',\
                                     'SE', 'UK', 'US']}

regulatory_authority = {'EU' : 'ESMA', 'US' : 'SEC',
                        'CN' : 'CSRC', 'AU' : 'ASIC',
                        'IN' : 'SEBI', 'NZ' : 'FMA',
                        'JP' : 'FSA'}
city_country_lookup = { 'Buenos Aires'      : 'Argentina',
                        'Vienna'            : 'Austria',
                        'Melbourne'         : 'Australia',
                        'Sydney'            : 'Australia',
                        'Brussels'          : 'Belgium',
                        'Sao Paulo'         : 'Brazil',
                        'Montreal'          : 'Canada',
                        'Toronto'           : 'Canada',
                        'Geneva'            : 'Switzerland',
                        'Zurich'            : 'Switzerland',
                        'Santiago'          : 'Chile',
                        'Beijing'           : 'China',
                        'Prague'            : 'Czech Republic',
                        'Frankfurt'         : 'Germany',
                        'Copenhagen'        : 'Denmark',
                        'Tallinn'           : 'Estonia',
                        'Madrid'            : 'Spain',
                        'Helsinki'          : 'Finland',
                        'Paris'             : 'France',
                        'London'            : 'Great Britain',
                        'Athens'            : 'Greece',
                        'Hong Kong'         : 'Hong Kong',
                        'Budapest'          : 'Hungary',
                        'Jakarta'           : 'Indonesia',
                        'Dublin'            : 'Ireland',
                        'Tel Aviv'          : 'Israel',
                        'Mumbai'            : 'India',
                        'Milan'             : 'Italy',
                        'Rome'              : 'Italy',
                        'Tokyo'             : 'Japan',
                        'Seoul'             : 'South Korea',
                        'Beirut'            : 'Lebanon',
                        'Colombo'           : 'Sri Lanka',
                        'Luxembourg'        : 'Luxembourg',
                        'Mexico City'       : 'Mexico',
                        'Kuala Lumpur'      : 'Malaysia',
                        'Amsterdam'         : 'Netherlands',
                        'Oslo'              : 'Norway',
                        'Auckland'          : 'New Zealand',
                        'Wellington'        : 'New Zealand',
                        'Panama City'       : 'Panama',
                        'Manila'            : 'Philippines',
                        'Warsaw'            : 'Poland',
                        'Lisbon'            : 'Portugal',
                        'Bucharest'         : 'Romania',
                        'Moscow'            : 'Russia',
                        'Riyadh'            : 'Saudi Arabia',
                        'Stockholm'         : 'Sweden',
                        'Singapore'         : 'Singapore',
                        'Bratislava'        : 'Slovakia',
                        'Bangkok'           : 'Thailand',
                        'Ankara'            : 'Turkey',
                        'Istanbul'          : 'Turkey',
                        'Taipei'            : 'Taiwan',
                        'Chicago'           : 'United States',
                        'Los Angeles'       : 'United States',
                        'New York'          : 'United States',
                        'Hanoi'             : 'Vietnam',
                        'Johannesburg'      : 'South Africa',
                        'Harare'            : 'Zimbabwe',
                        'Lusaka'            : 'Zambia',
                        'Aden'              : 'Yemen',
                        'Ho Chi Minh'       : 'Vietnam',
                        'Road Town'         : 'Virgin Islands (British)',
                        'Caracas'           : 'Venezuela',
                        'Montevideo'        : 'Uruguay',
                        'Seattle'           : 'United States',
                        'Sacramento'        : 'United States',
                        'Houston'           : 'United States',
                        'Portland'          : 'United States',
                        'Boston'            : 'United States',
                        'Tunis'             : 'Tunisia',
                        'Dodoma'            : 'Tanzania',
                        'Kiev'              : 'Ukraine',
                        'Kampala'           : 'Uganda',
                        'San Salvador'      : 'El Salvador',
                        'Dakar'             : 'Senegal',
                        'Ljubljana'         : 'Slovenia',
                        'Jeddah'            : 'Saudi Arabia',
                        'Abha'              : 'Saudi Arabia',
                        'Belgrade'          : 'Serbia',
                        'Doha'              : 'Qatar',
                        'San Juan'          : 'Puerto Rico',
                        'Karachi'           : 'Pakistan',
                        'Lima'              : 'Peru',
                        'Muscat'            : 'Oman',
                        'Kathmandu'         : 'Nepal',
                        'Rotterdam'         : 'Netherlands',
                        'Lagos'             : 'Nigeria',
                        'Abuja'             : 'Nigeria',
                        'Windhoek'          : 'Namibia',
                        'Labuan'            : 'Malaysia',
                        'Lilongwe'          : 'Malawi',
                        'Male'              : 'Maldives',
                        'Port Louis'        : 'Mauritius',
                        'Valletta'          : 'Malta',
                        'Macau'             : 'Macao',
                        'Monaco'            : 'Monaco',
                        'Rabat'             : 'Morocco',
                        'Casablanca'        : 'Morocco',
                        'Riga'              : 'Latvia',
                        'Almaty'            : 'Kazakhstan',
                        'Kuwait City'       : 'Kuwait',
                        'Nairobi'           : 'Kenya',
                        'Amman'             : 'Jordan',
                        'Kingston'          : 'Jamaica',
                        'St. Helier'        : 'Jersey',
                        'Turin'             : 'Italy',
                        'Reykjavik'         : 'Iceland',
                        'Tehran'            : 'Iran',
                        'New Delhi'         : 'India',
                        'Kolkata'           : 'India',
                        'Hyderabad'         : 'India',
                        'Chennai'           : 'India',
                        'Bangalore'         : 'India',
                        'Jerusalem'         : 'Israel',
                        'Zagreb'            : 'Republic of Croatia',
                        'Tegucigalpa'       : 'Honduras',
                        'Accra'             : 'Ghana',
                        'Saint Peter Port'  : 'Guernsey',
                        'Tbilisi'           : 'Georgia',
                        'Edinburgh'         : 'Scotland',
                        'Addis Ababa'       : 'Ethiopia',
                        'Barcelona'         : 'Spain',
                        'Cairo'             : 'Egypt',
                        'Algiers'           : 'Algeria',
                        'Santo Domingo'     : 'Dominican Republic',
                        'Stuttgart'         : 'Germany',
                        'Munich'            : 'Germany',
                        'Mainz'             : 'Germany',
                        'Leipzig'           : 'Germany',
                        'Dusseldorf'        : 'Germany',
                        'Cologne'           : 'Germany',
                        'Nicosia'           : 'Cyprus',
                        'San Jose'          : 'Costa Rica',
                        'Bogota'            : 'Colombia',
                        'Shanghai'          : 'China',
                        'Abidjan'           : "Cote d'Ivoire",
                        'Basel'             : 'Switzerland',
                        'Winnipeg'          : 'Canada',
                        'Vancouver'         : 'Canada',
                        'Ottawa'            : 'Canada',
                        'Gaborone'          : 'Botswana',
                        'Nassau'            : 'Bahamas',
                        'La Paz'            : 'Bolivia',
                        'Bandar Seri Begawan' : 'Brunei',
                        'Hamilton'          : 'Bermuda',
                        'Manama'            : 'Bahrain',
                        'Sofia'             : 'Bulgaria',
                        'Dhaka'             : 'Bangladesh',
                        'Bridgetown'        : 'Barbados',
                        'Perth'             : 'Australia',
                        'Darwin'            : 'Australia',
                        'Canberra'          : 'Australia',
                        'Brisbane'          : 'Australia',
                        'Adelaide'          : 'Australia',
                        'Luanda'            : 'Angola',
                        'Yerevan'           : 'Armenia',
                        'Dubai'             : 'United Arab Emirates',
                        'Abu Dhabi'         : 'United Arab Emirates',
                        'Wichita'           : 'United States',
                        'Honolulu'          : 'United States',
                        'Mobile'            : 'United States',
                        'Minneapolis'       : 'United States',
                        'Detroit'           : 'United States',
                        'Denver'            : 'United States',
                        'Washington'        : 'United States',
                        'Charlotte'         : 'United States',
                        'Port of Spain'     : 'Trinidad and Tobago',
                        'Dar es Salaam'     : 'Tanzania',
                        'Makati'            : 'Philippines',
                        'George Town'       : 'Cayman Islands',
                        'Calgary'           : 'Canada',
                        'Brasilia'          : 'Brazil',
                        'Rio de Janeiro'    : 'Brazil',
                       }
country_code_dict = {
    'Afghanistan': 'AF',
    'Islamic Republic of Afghanistan':'AF',
    'Aland Islands': 'AX',
    'Albania': 'AL',
    'Algeria': 'DZ',
    'American Samoa': 'AS',
    'Andorra': 'AD',
    'Angola': 'AO',
    'Anguilla': 'AI',
    'Antarctica': 'AQ',
    'Antigua and Barbuda': 'AG',
    'Argentina': 'AR',
    'Armenia': 'AM',
    'Aruba': 'AW',
    'Australia': 'AU',
    'Ashmore and Cartier Islands': 'AU',
    'Coral Sea Islands': 'AU',
    'Austria': 'AT',
    'Azerbaijan': 'AZ',
    'Bahamas': 'BS',
    'Bahrain': 'BH',
    'Bangladesh': 'BD',
    'Barbados': 'BB',
    'Belarus': 'BY',
    'Belgien': 'BE',
    'Belgique': 'BE',
    'BE': 'BE',
    'Belgium': 'BE',
    'Belize': 'BZ',
    'Benin': 'BJ',
    'Bermuda': 'BM',
    'Bhutan': 'BT',
    'Bolivia': 'BO',
    'Bolivia (Plurinational State of)': 'BO',
    'Bonaire, Sint Eustatius and Saba': 'BQ',
    'Caribbean Netherlands': 'BQ',
    'Saba': 'BQ',
    'Sint Eustatius': 'BQ',
    'Bosnia and Herzegovina': 'BA',
    'Botswana': 'BW',
    'Bouvet Island': 'BV',
    'Brazil': 'BR',
    'British Indian Ocean Territory': 'IO',
    'Brunei Darussalam': 'BN',
    'Bulgaria': 'BG',
    'Burkina Faso': 'BF',
    'Burundi': 'BI',
    'Cabo Verde': 'CV',
    'Cape Verde': 'CV',
    'Cambodia': 'KH',
    'Cameroon': 'CM',
    'Canada': 'CA',
    'Cayman Islands': 'KY',
    'Central African Republic': 'CF',
    'Chad': 'TD',
    'Chile': 'CL',
    'China': 'CN',
    "People's Republic of China": 'CN',
    'Christmas Island': 'CX',
    'Cocos Islands': 'CC',
    'Cocos (Keeling) Islands': 'CC',
    'Colombia': 'CO',
    'Comoros': 'KM',
    'Congo (the Democratic Republic of the)':'CD',
    'Democratic Republic of Congo':'CD',
    'DR Congo':'CD',
    'DRC':'CD',    
    'Republic of the Congo':'CG',
    'Congo':'CG',
    'Cook Islands': 'CK',
    'Costa Rica': 'CR',
    "Cote d'Ivoire": 'CI',
    'Ivory Coast': 'CI',
    'Ivory Cost' : 'CI',
    'Croatia': 'HR',
    'Cuba': 'CU',
    'Curacao': 'CW',
    'Cyprus': 'CY',
    'Czech Republic': 'CZ',
    'Danmark': 'DK',
    'Danemark':'DK',
    'DK': 'DK',
    'DEN': 'DK',
    'Denmark': 'DK',
    'Djibouti': 'DJ',
    'Dominica': 'DM',
    'Dominican Republic': 'DO',
    'Ecuador': 'EC',
    'Egypt': 'EG',
    'El Salvador': 'SV',
    'Equatorial Guinea': 'GQ',
    'Eritrea': 'ER',
    'Estonia': 'EE',
    'Ethiopia': 'ET',
    'Falkland Islands': 'FK',
    'Malvinas': 'FK',
    'Faroe Islands': 'FO',
    'Finland': 'FI',
    'Suomi': 'FI',
    'SF': 'FI',
    'FIN': 'FI',
    'Fiji': 'FJ',
    'Frankreich': 'FR',
    'Frankrike': 'FR',
    'FR':'FR',
    'French Guiana': 'GF',
    'French Polynesia': 'PF',
    'French Southern Territories': 'TF',
    'French Southern Lands ':'TF',
    'French Southern and Antarctic Lands':'TF',
    'France': 'FR',
    'Clipperton Island': 'FR',
    'Gabon': 'GA',
    'Gambia': 'GM',
    'Georgia': 'GE',
    'DE':'DE',
    'Deutschland':'DE',
    'Tyskland':'DE',
    'Allemagne':'DE',
    'Germany': 'DE',
    'Ghana': 'GH',
    'Gibraltar': 'GI',
    'Greece': 'GR',
    'Greenland': 'GL',
    'Grenada': 'GD',
    'Guadeloupe': 'GP',
    'Guam': 'GU',
    'Guatemala': 'GT',
    'Guernsey': 'GG',
    'Guinea': 'GN',
    'Guinea-Bissau': 'GW',
    'Guyana': 'GY',
    'Haiti': 'HT',
    'Heard Island and McDonald Islands': 'HM',
    'Holy See': 'VA',
    'Vatican City' :'VA',
    'Honduras': 'HN',
    'Hong Kong': 'HK',
    'Hungary': 'HU',
    'Iceland': 'IS',
    'India': 'IN',
    'Indonesia': 'ID',
    'Iran': 'IR',
    'Iran (Islamic Republic of)': 'IR',
    'Iraq': 'IQ',
    'Ireland': 'IE',
    'Isle of Man': 'IM',
    'Israel': 'IL',
    'Italia': 'IT',
    'Italien': 'IT',
    'IT':'IT',
    'Italy': 'IT',
    'Jamaica': 'JM',
    'Japan': 'JP',
    'Jersey': 'JE',
    'Jordan': 'JO',
    'Kazakhstan': 'KZ',
    'Kenya': 'KE',
    'Kiribati': 'KI',
    "Korea (the Democratic People's Republic of)": 'KP',
    'Korea (the Republic of)': 'KR',
    'North Korea' : 'KP',
    "Democratic People's Republic of Korea ": 'KP',
    'Republic of Korea' : 'KR',
    'South Korea' : 'KR',
    'Kuwait': 'KW',
    'Kyrgyzstan': 'KG',
    'Laos': 'LA',
    "Lao People's Democratic Republic": 'LA',
    'Latvia': 'LV',
    'Lebanon': 'LB',
    'Lesotho': 'LS',
    'Liberia': 'LR',
    'Libya': 'LY',
    'Liechtenstein': 'LI',
    'Lithuania': 'LT',
    'Luxembourg': 'LU',
    'Macao': 'MO',
    'Macedonia': 'MK',
    'Madagascar': 'MG',
    'Malawi': 'MW',
    'Malaysia': 'MY',
    'Maldives': 'MV',
    'Mali': 'ML',
    'Malta': 'MT',
    'Marshall Islands': 'MH',
    'Martinique': 'MQ',
    'Mauritania': 'MR',
    'Mauritius': 'MU',
    'Mayotte': 'YT',
    'Mexico': 'MX',
    'Federated States of Micronesia': 'FM',
    'Micronesia (Federated States of)': 'FM',
    'Micronesia': 'FM',
    'Republic of Moldova': 'MD',
    'Moldova (the Republic of)': 'MD',
    'Moldova': 'MD',
    'Monaco': 'MC',
    'Mongolia': 'MN',
    'Montenegro': 'ME',
    'Montserrat': 'MS',
    'Morocco': 'MA',
    'Mozambique': 'MZ',
    'Myanmar': 'MM',
    'Burma': 'MM',
    'Namibia': 'NA',
    'Nauru': 'NR',
    'Nepal': 'NP',
    'The Netherlands': 'NL',
    'Nederlands': 'NL',
    'Holland': 'NL',
    'Pays bas': 'NL',
    'Pays-Bas': 'NL',
    'NE':'NL',
    'Netherlands': 'NL',
    'New Caledonia': 'NC',
    'New Zealand': 'NZ',
    'Nicaragua': 'NI',
    'Niger': 'NE',
    'Nigeria': 'NG',
    'Niue': 'NU',
    'Norfolk Island': 'NF',
    'Northern Mariana Islands': 'MP',
    'Norwegen': 'NO',
    'Norge': 'NO',
    'Noreg': 'NO',
    'NO':'NO',
    'Norway': 'NO',
    'Oman': 'OM',
    'Pakistan': 'PK',
    'Palau': 'PW',
    'Palestine, State of': 'PS',
    'Panama': 'PA',
    'Papua New Guinea': 'PG',
    'Paraguay': 'PY',
    'Peru': 'PE',
    'Philippines': 'PH',
    'Pitcairn': 'PN',
    'Poland': 'PL',
    'Portugal': 'PT',
    'Puerto Rico': 'PR',
    'Qatar': 'QA',
    'Reunion': 'RE',
    'Romania': 'RO',
    'Russia': 'RU',
    'Russian Federation': 'RU',
    'Rwanda': 'RW',
    'Saint Barthelemy': 'BL',
    'Saint Helena, Ascension and Tristan da Cunha': 'SH',
    'Saint Helena': 'SH',
    'Saint Kitts and Nevis': 'KN',
    'Saint Lucia': 'LC',
    'Saint Martin': 'MF',
    'Saint Martin (French part)':'MF',
    'Saint Pierre and Miquelon': 'PM',
    'Saint Vincent and the Grenadines': 'VC',
    'Saint Vincent': 'VC',
    'Samoa': 'WS',
    'San Marino': 'SM',
    'Sao Tome and Principe': 'ST',
    'Saudi Arabia': 'SA',
    'Senegal': 'SN',
    'Serbia': 'RS',
    'Seychelles': 'SC',
    'Sierra Leone': 'SL',
    'Singapore': 'SG',
    'Sint Maarten': 'SX',
    'Sint Maarten (Dutch part)': 'SX',
    'Slovakia': 'SK',
    'Slovenia': 'SI',
    'Solomon Islands': 'SB',
    'Somalia': 'SO',
    'South Africa': 'ZA',
    'South Georgia and the South Sandwich Islands': 'GS',
    'South Georgia': 'GS',
    'South Sudan': 'SS',
    'Espana': 'ES',
    'Spanien ': 'ES',
    'Espagne': 'ES',
    'ES':'ES',
    'Spain': 'ES',
    'Sri Lanka': 'LK',
    'Sudan': 'SD',
    'Suriname': 'SR',
    'Svalbard and Jan Mayen': 'SJ',
    'Jan Mayen': 'SJ',
    'Swaziland': 'SZ',
    'Eswatini': 'SZ',
    'Sverige' : 'SE',
    'Suede' : 'SE',
    'Schweden':'SE',
    'SE':'SE',
    'Sweden': 'SE',
    'Schweitz': 'CH',
    'Suisse': 'CH',
    'la Suisse': 'CH',
    'Svizzera': 'CH',
    'CH': 'CH',
    'SUI': 'CH',
    'Switzerland': 'CH',
    'Syrian Arab Republic': 'SY',
    'Syria': 'SY',
    'Taiwan': 'TW',
    'Tajikistan': 'TJ',
    'Tanzania': 'TZ',
    'Thailand': 'TH',
    'Timor-Leste': 'TL',
    'East Timor': 'TL',
    'Togo': 'TG',
    'Tokelau': 'TK',
    'Tonga': 'TO',
    'Trinidad and Tobago': 'TT',
    'Tunisia': 'TN',
    'Turkey': 'TR',
    'Turkmenistan': 'TM',
    'Turks and Caicos Islands': 'TC',
    'Tuvalu': 'TV',
    'Uganda': 'UG',
    'Ukraine': 'UA',
    'United Arab Emirates': 'AE',
    'Emirates': 'AE',
    'Great Britain' : 'GB',
    'UK': 'GB',
    'GB': 'GB',
    'United Kingdom of Great Britain': 'GB',
    'Akrotiri and Dhekelia': 'GB',
    'England': 'GB',
    'Wales': 'GB',
    'Scotland': 'GB',
    'Northern Ireland': 'GB',
    'United Kingdom of Great Britain and Northern Ireland': 'GB',
    'United Kingdom' : 'GB',
    'United States Minor Outlying Islands': 'UM',
    'USA':'US',
    'Hawaiian Islands':'US',
    'United States of America (the)': 'US',
    'America': 'US',
    'the US': 'US',
    'US of A':'US',
    'USofA':'US',
    'US':'US',
    'United States': 'US',
    'Uruguay': 'UY',
    'Uzbekistan': 'UZ',
    'Vanuatu': 'VU',
    'Venezuela': 'VE',
    'Viet Nam': 'VN',
    'Virgin Islands (British)': 'VG',
    'British Virgin Islands': 'VG',
    'Virgin Islands (U.S.)': 'VI',
    'United States Virgin Islands': 'VI',
    'Wallis and Futuna': 'WF',
    'Western Sahara*': 'EH',
    'Sahrawi Arab Democratic Republic': 'EH',
    'Yemen': 'YE',
    'Zambia': 'ZM',
    'Zimbabwe': 'ZW',     
    'Brunei': 'BN',
    'Brunei Darussalam': 'BN',
    'Republic of Croatia' : 'HR',
    'Vietnam' : 'VN', 
    'Kosovo' : 'XK',

}

iban_len_lookup = {
'AL' : 28,#Albania*
'DZ' : 24,#Algeria
'AD' : 24,#Andorra*
'AO' : 25,#Angola
'AT' : 20,#Austria**
'AZ' : 28,#Azerbaijan*
'BH' : 22,#Bahrain*
'BY' : 28,#Belarus*
'BE' : 16,#Belgium**
'BJ' : 28,#Benin
'BA' : 20,#Bosnia and Herzegovina
'BR' : 29,#Brazil
'VG' : 24,#British Virgin Islands
'BG' : 22,#Bulgaria**
'BF' : 27,#Burkina Faso
'BI' : 16,#Burundi
'CM' : 27,#Cameroon
'CV' : 25,#Cape Verde
'CF' : 27,#Central African Republic
'CG' : 27,#Congo
'CR' : 21,#Costa Rica
'HR' : 21,#Croatia**
'CY' : 28,#Cyprus**
'CZ' : 24,#Czech Republic**
'DK' : 18,#Denmark**
'DO' : 28,#Dominican Republic
'EG' : 29,#Egypt
'EE' : 20,#Estonia**
'FO' : 18,#Faroe Islands*
'FI' : 18,#Finland**
'FR' : 27,#France**,Guadeloupe,Martinique,New Caledonia,Runion,Saint-Pierre and Miquelon
'FR' : 27,#French Guiana
'FR' : 27,#French Polynesia
'GA' : 27,#Gabon
'GE' : 22,#Georgia*
'DE' : 22,#Germany**
'GI' : 23,#Gibraltar**
'GR' : 27,#Greece**
'GL' : 18,#Greenland*
'GT' : 28,#Guatemala
'GG' : 22,#Guernsey**
'HU' : 28,#Hungary**
'IS' : 26,#Iceland**
'IR' : 26,#Iran
'IQ' : 23,#Iraq*
'IE' : 22,#Ireland**
'IM' : 22,#Isle of Man**
'IL' : 23,#Israel*
'IT' : 27,#Italy**
'CI' : 28,#Ivory Coast
'JE' : 22,#Jersey**
'JO' : 30,#Jordan*
'KZ' : 20,#Kazakhstan
'XK' : 20,#Kosovo
'KW' : 30,#Kuwait*
'LV' : 21,#Latvia**
'LB' : 28,#Lebanon*
'LI' : 21,#Liechtenstein**
'LT' : 20,#Lithuania**
'LU' : 20,#Luxembourg**
'MK' : 19,#North Macedonia
'MG' : 27,#Madagascar
'ML' : 28,#Mali
'MT' : 31,#Malta**
'MR' : 27,#Mauritania*
'MU' : 30,#Mauritius
'MD' : 24,#Moldova*
'MC' : 27,#Monaco**
'ME' : 22,#Montenegro
'MZ' : 25,#Mozambique
'NL' : 18,#Netherlands**
'NO' : 15,#Norway**
'PK' : 24,#Pakistan*
'PS' : 29,#Palestine, State of*
'PL' : 28,#Poland**
'PT' : 25,#Portugal**
'QA' : 29,#Qatar*
'RO' : 24,#Romania**
'LC' : 32,#Saint Lucia
'SM' : 27,#San Marino**
'ST' : 25,#Sao Tome and Principe
'SA' : 24,#Saudi Arabia*
'SN' : 28,#Senegal
'RS' : 22,#Serbia
'SC' : 31,#Seychelles
'SK' : 24,#Slovakia**
'SI' : 19,#Slovenia**
'ES' : 24,#Spain**
'SE' : 24,#Sweden**
'CH' : 21,#Switzerland**
'TL' : 23,#Timor-Leste
'TN' : 24,#Tunisia*f
'TR' : 26,#Turkey*
'UA' : 29,#Ukraine
'AE' : 23,#United Arab Emirates*
'GB' : 22,#United Kingdom**
'VA' : 22,#Vatican City State/the Holy See
'FR' : 27,#Wallis and Futuna
}

subjurisdiction_codes = {
    'Canada': {
        'Alberta': 'AB',
        'British Columbia': 'BC',
        'Manitoba': 'MB',
        'New Brunswick': 'NB',
        'Newfoundland and Labrador': 'NL',
        'Nova Scotia': 'NS',
        'Ontario': 'ON',
        'Prince Edward Island': 'PE',
        'Quebec': 'QC',
        'Saskatchewan': 'SK',
        'Northwest Territories': 'NT',
        'Nunavut': 'NU',
        'Yukon': 'YT',
    },
    'Australia': {
        'New South Wales': 'NSW',
        'Queensland': 'QLD',
        'South Australia': 'SA',
        'Tasmania': 'TAS',
        'Victoria': 'VIC',
        'Western Australia': 'WA',
        'Australian Capital Territory': 'ACT',
        'Northern Territory': 'NT',
        'Jervis Bay Territory': 'JBT',
    },
}

sftr_day_count_method = {
                            'Act/360'       : 'A004',
                            'Act/ActAFB'    : 'A010',
                            'Act/ActISDA'   : 'A008',
                            'Act/ActISMA'   : 'A006',
                            '30/360'        : 'A011',
                            '30/365'        : 'A002',
                            '30E/360'       : 'A007',
                            'Act/365'       : 'A005',
                            'Act/365L'      : 'A009',
                        }

cfi_char_dict = {'E' : {
                        'S'     : 'Equities - Shares & Depositary Receipts', 
                        'P'     : 'Other instruments', 
                        'C'     : 'Other instruments', 
                        'F'     : 'Other instruments', 
                        'L'     : 'Other instruments', 
                        'D'     : 'Equities - Shares & Depositary Receipts',
                        'Y'     : 'Structured finance instruments',
                        'M'     : 'Other instruments',
                        },
                'C' : {
                        'B'     : 'Other instruments', 
                        'E'     : 'Exchange traded products (Exchange traded funds, exchange traded notes and exchange traded commodities)',
                        'F'     : 'Other instruments', 
                        'H'     : 'Other instruments', 
                        'I'     : 'Other instruments', 
                        'M'     : 'Other instruments', 
                        'P'     : 'Other instruments', 
                        'S'     : 'Other instruments', 
                        },
                'D' : {
                        'A'     : 'Structured finance instruments',
                        'B'     : 'Debt instruments - Bonds',
                        'C'     : 'Other instruments',
                        'D'     : 'Other instruments',
                        'E'     : 'Structured finance instruments',
                        'G'     : 'Structured finance instruments',
                        'M'     : 'Other instruments',
                        'N'     : 'Debt instruments - Bonds',
                        'S'     : 'Structured finance instruments',
                        'T'     : 'Debt instruments - Bonds',
                        'W'     : 'Debt instruments - Bonds',
                        'Y'     : 'Debt instruments - Money markets instruments',
                       },
                'R' : {
                        'A'     : 'Securitized Derivatives - Warrants and Certificate Derivatives',
                        'D'     : 'Securitized Derivatives - Warrants and Certificate Derivatives',
                        'F'     : 'Securitized Derivatives - Other securitized derivatives',
                        'M'     : 'Securitized Derivatives - Other securitized derivatives',
                        'P'     : 'Securitized Derivatives - Warrants and Certificate Derivatives',
                        'S'     : 'Securitized Derivatives - Warrants and Certificate Derivatives',
                        'W'     : 'Securitized Derivatives - Warrants and Certificate Derivatives',
                      },
                'O' : {
                        '*'     : { '*' : {
                                        'B'     : 'Other instruments',
                                        'C'     : 'Currency derivatives - Futures and options admitted to trading on a trading venue',
                                        'D'     : 'Other instruments',
                                        'F'     : 'Other instruments',
                                        'I'     : 'Other instruments',
                                        'M'     : 'Other instruments',
                                        'N'     : 'Interest rates derivatives-Futures and options admitted to trading on a trading venue',
                                        'O'     : 'Other instruments',
                                        'S'     : 'Equity Derivatives - Options and Futures admitted to trading on a trading venue',
                                        'T'     : 'Commodities derivatives and emission allowances Derivatives - Options and Futures admitted to trading on a trading venue',
                                        'W'     : 'Other instruments',
                                      },
                              },
                        'M'     : 'Other instruments',
                      },
                'F' : {
                        'C' : 'Commodities derivatives and emission allowances Derivatives - Options and Futures admitted to trading on a trading venue',
                        'F' : {
                                    'B'     : 'Other instruments',
                                    'C'     : 'Currency derivatives - Futures and options admitted to trading on a trading venue',
                                    'D'     : 'Other instruments',
                                    'F'     : 'Other instruments',
                                    'I'     : 'Other instruments',
                                    'M'     : 'Other instruments',
                                    'N'     : 'Interest rates derivatives-Futures and options admitted to trading on a trading venue',
                                    'O'     : 'Other instruments',
                                    'S'     : 'Equity Derivatives - Options and Futures admitted to trading on a trading venue',
                                    'V'     : 'Other instruments',
                                    'W'     : 'Other instruments',
                                },                        
                      },
                'S' : {
                        'C'     : 'Credit Derivatives - Other credit derivatives',
                        'E'     : 'Equity Derivatives - Swaps and other equity derivatives',
                        'F'     : 'Currency derivatives - Swaps, forwards, and other currency derivatives',
                        'M'     : 'Other instruments',
                        'R'     : 'Interest Rate Deriviatives - Swaps, forwards, and other interest rates derivatives',
                        'T'     : 'Commodities derivatives and emission allowances Derivatives - Other commodities derivatives and emission allowances derivatives',
                      },
                'H' : {
                        'C'     : 'Credit Derivatives - Futures and options admitted to trading on a trading venue',
                        'E'     : 'Equity Derivatives - Options and Futures admitted to trading on a trading venue',
                        'F'     : 'Currency derivatives - Futures and options admitted to trading on a trading venue',
                        'M'     : 'Other instruments',
                        'R'     : 'Interest Rate Deriviatives - Futures and options admitted to trading on a trading venue',
                        'T'     : 'Commodities derivatives and emission allowances Derivatives - Options and Futures admitted to trading on a trading venue',
                      },
                'J' : {
                        'C' : {'*' : {'*' : {'F' : 'Credit Derivatives - Futures and options admitted to trading on a trading venue'}}},
                        'E' : {'*' : {'*' : {'C' : 'Contracts for difference', '*' : 'Equity Derivatives - Options and Futures admitted to trading on a trading venue'}}},
                        'F' : 'Currency derivatives - Swaps, forwards, and other currency derivatives',
                        'R' : 'Interest Rate Deriviatives - Swaps, forwards, and other interest rates derivatives',
                        'T' : {'*' : {'*' : {'C' : 'Contracts for difference', 'F' : 'Currency derivatives - Futures and options admitted to trading on a trading venue'}}},
                      },
                'K'     : 'Other instruments',
                'L'     : 'Other instruments',
                'T'     : 'Other instruments',
                'M'     : 'Other instruments',
                }

city_state_dict = {

    'Calgary': 'Alberta',
    'Edmonton': 'Alberta',
    'Red Deer': 'Alberta',
    'Strathcona County' : 'Alberta',
    'Lethbridge': 'Alberta',
    'Wood Buffalo': 'Alberta',
    'St. Albert': 'Alberta',
    'Medicine Hat': 'Alberta',
    'Grande Prairie': 'Alberta',
    'Airdrie':'Alberta',
    'Vancouver': 'British Columbia',
    'Surrey': 'British Columbia',
    'Burnaby': 'British Columbia',
    'Richmond': 'British Columbia',
    'Langley': 'British Columbia',
    'Abbotsford': 'British Columbia',
    'Coquitlam': 'British Columbia',
    'North Vancouver': 'British Columbia',
    'Kelowna': 'British Columbia',
    'Winnipeg': 'Manitoba',
    'Brandon': 'Manitoba',
    'Morden': 'Manitoba',
    'Steinbach': 'Manitoba',
    'Thompson': 'Manitoba',
    'Portage la Prairie': 'Manitoba',
    'Winkler': 'Manitoba',
    'Selkirk': 'Manitoba',
    'Dauphin': 'Manitoba',
    'Moncton': 'New Brunswick',
    'Saint John': 'New Brunswick',
    'Fredericton': 'New Brunswick',
    'Dieppe': 'New Brunswick',
    'Riverview': 'New Brunswick',
    'Quispamsis': 'New Brunswick',
    'Edmundston': 'New Brunswick',
    'Miramichi': 'New Brunswick',
    "St. John's": 'Newfoundland and Labrador',
    'Conception Bay South': 'Newfoundland and Labrador',
    'Mount Pearl': 'Newfoundland and Labrador',
    'Paradise': 'Newfoundland and Labrador',
    'Corner Brook': 'Newfoundland and Labrador',
    'Grand Falls ': 'Newfoundland and Labrador',
    'Gander': 'Newfoundland and Labrador',
    'Portugal Cove': 'Newfoundland and Labrador',
    'Happy Valley': 'Newfoundland and Labrador',
    'Torbay': 'Newfoundland and Labrador',
    'Halifax':'Nova Scotia',
    'Cape Breton ':'Nova Scotia',
    'Truro':'Nova Scotia',
    'Amherst':'Nova Scotia',
    'New Glasgow ':'Nova Scotia',
    'Bridgewater':'Nova Scotia',
    'Yarmouth':'Nova Scotia',
    'Kentville':'Nova Scotia',
    'Charlottetown': 'Prince Edward Island',
    'Summerside': 'Prince Edward Island',
    'Toronto': 'Ontario',
    'Ottawa': 'Ontario',
    'Mississauga': 'Ontario',
    'Brampton': 'Ontario',
    'Hamilton': 'Ontario',
    'London': 'Ontario',
    'Markham': 'Ontario',
    'Vaughan': 'Ontario',
    'Kitchener': 'Ontario',
    'Montreal':'Quebec',
    'Quebec City':'Quebec',
    'Laval':'Quebec',
    'Gatineau':'Quebec',
    'Longueuil':'Quebec',
    'Saguenay':'Quebec',
    'Levis':'Quebec',
    'Sherbrooke':'Quebec',
    'Saint-Jean-sur-Richelieu':'Quebec',
    'Chicoutimi':'Quebec',
    'Drummondville':'Quebec',
    'Saint-jerome':'Quebec',
    'Granby':'Quebec',
    'Saint-Hyacinthe':'Quebec',
    'Terrebonne':'Quebec',
    'Trois-Rivieres':'Quebec',
    'Saskatoon': 'Saskatchewan',
    'Regina': 'Saskatchewan',
    'Prince Albert': 'Saskatchewan',
    'Moose Jaw': 'Saskatchewan',
    'Swift Current': 'Saskatchewan',
    'Yorkton': 'Saskatchewan',
    'North Battleford': 'Saskatchewan',
    'Estevan': 'Saskatchewan',
    'Warman': 'Saskatchewan',
    'Weyburn': 'Saskatchewan',
    'Yellowknife': 'Northwest Territories',
    'Iqaluit': 'Nunavut',
    'Whitehorse': 'Yukon',
    'Sydney': 'New South Wales',
    'Albury': 'New South Wales',
    'Tweed Heads': 'New South Wales',
    'Newcastle - Maitland': 'New South Wales',
    'Maitland':'New South Wales',
    'Port Macquarie': 'New South Wales',
    'Wollongong': 'New South Wales',
    'Shellharbour': 'New South Wales',
    'Taree': 'New South Wales',
    'Penrith':'New South Wales',
    'Coffs Harbour': 'New South Wales',
    'Blacktown': 'New South Wales',
    'Gosford': 'New South Wales',
    'Wagga Wagga': 'New South Wales',
    'Tamworth': 'New South Wales',
    'Brisbane': 'Queensland',
    'Bundaberg': 'Queensland',
    'Cairns': 'Queensland',
    'Caloundra': 'Queensland',
    'Charters Towers': 'Queensland',
    'Gladstone': 'Queensland',
    'Gold Coast': 'Queensland',
    'Gympie': 'Queensland',
    'Hervey Bay': 'Queensland',
    'Ipswich':'Queensland',
    'Mackay':'Queensland',
    'Maryborough':'Queensland',
    'Toowoomba':'Queensland',
    'Warwick': 'Queensland',
    'Sunshine Coast': 'Queensland',
    'Townsville': 'Queensland',
    'Toowoomba': 'Queensland',
    'Mackay': 'Queensland',
    'Rockhampton': 'Queensland',
    'Adelaide': 'South Australia',
    'Hobart': 'Tasmania',
    'Launceston': 'Tasmania',
    'Devonport': 'Tasmania',
    'Melbourne': 'Victoria',
    'Geelong': 'Victoria',
    'Ballarat': 'Victoria',
    'Bendigo': 'Victoria',
    'Albury - Wodonga': 'Victoria',
    'Mildura': 'Victoria',
    'Shepparton': 'Victoria',
    'Traralgon': 'Victoria',
    'Wangaratta': 'Victoria',
    'Warrnambool': 'Victoria',
    'Perth': 'Western Australia',
    'Bunbury': 'Western Australia',
    'Geraldton': 'Western Australia',
    'Busselton': 'Western Australia',
    'Albany': 'Western Australia',
    'Kalgoorlie-Boulder': 'Western Australia',
    'Rockingham': 'Western Australia',
    'Mandurah': 'Western Australia',
    'Darwin': 'Northern Territory',
    'Alice Springs': 'Northern Territory',
    'Palmerston': 'Northern Territory',
    'Darwin': 'Northern Territory',
}

rts2_ins_type_lookup = {
    'CreditDefaultSwap': 'FUNCTION',
    'CLN': 'Structured Finance Products',
    'Bill': 'Bonds',
    'Bond': 'Bonds',
    'CD': 'Bonds',
    'Basket CDS': 'Structured Finance Products',
    'CDS': 'Credit Derivatives',
    'Combination': 'Structured Finance Products',
    'Convertible': 'FUNCTION',
    'Credit Balance': 'Credit Derivatives',
    'CreditIndex': 'Credit Derivatives',
    'DualCurrBond': 'Bonds',
    'Flexi Bond': 'Bonds',
    'FRN': 'Bonds',
    'Future/Forward': 'FUNCTION',
    'MBS/ABS': 'Structured Finance Products',
    'Fund': 'Structured Finance Products',
    'Option': 'FUNCTION',
    'Portfolio Swap': 'Structured Finance Products',
    'PromisLoan': 'Structured Finance Products',
    'TotalReturnSwap': 'FUNCTION',
    'Zero': 'Bonds',
    'Deposit': 'Structured Finance Products',
    'Curr': 'Foreign Exchange Derivatives',
    'CFD': 'CFDs',
    'FXOptionDatedFwd': 'Foreign Exchange Derivatives',
    'FxSwap': 'Foreign Exchange Derivatives',
    'Average Future/Forward': 'Commodity Derivatives',
    'Commodity': 'Commodity Derivatives',
    'Commodity Index': 'Commodity Derivatives',
    'Commodity Variant': 'Commodity Derivatives',
    'PriceSwap': 'Commodity Derivatives',
    'Rolling Schedule': 'Commodity Derivatives',
    'Certificate': 'Structured Finance Products',
    'Depositary Receipt': 'Equity Derivatives',
    'Dividend Point Index': 'Equity Derivatives',
    'EquityIndex': 'Equity Derivatives',
    'ETF': 'Equity Derivatives',
    'SecurityLoan': 'Structured Finance Products',
    'Stock': '',
    'VarianceSwap': 'Equity Derivatives',
    'VolatilitySwap': 'Equity Derivatives',
    'Warrant': 'Equity Derivatives',
    'BasketRepo/Reverse': 'Structured Finance Products',
    'BasketSecurityLoan': 'Structured Finance Products',
    'BuySellback': 'Structured Finance Products',
    'Cap': 'Interest Rate Derivatives',
    'FreeDefCF': 'Structured Finance Products',
    'CurrSwap': 'Structured Finance Products',
    'Floor': 'Interest Rate Derivatives',
    'Collar': 'Interest Rate Derivatives',
    'FRA': 'Structured Finance Products',
    'IndexLinkedBond': 'Bonds',
    'IndexLinkedSwap': 'Structured Finance Products',
    'PriceIndex': 'Structured Finance Products',
    'RateIndex': 'Structured Finance Products',
    'Repo/Reverse': 'Structured Finance Products',
    'Swap': 'Interest Rate Derivatives',
    'Deposit': 'Structured Finance Products',
}
rts2_sub_ins_type_lookup = {
    'CreditDefaultSwap': 'FUNCTION',
    'CLN': 'DERIVE_FROM_VALGROUP',
    'Bill': 'DERIVE_FROM_VALGROUP',
    'Bond': 'DERIVE_FROM_VALGROUP',
    'CD': 'DERIVE_FROM_VALGROUP',
    'CDS': 'Index or Single name CDS',
    'Credit Balance': 'Other Credit Derivatives',
    'CreditIndex': 'Other Credit Derivatives',
    'DualCurrBond': 'DERIVE_FROM_VALGROUP',
    'Flexi Bond': 'DERIVE_FROM_VALGROUP',
    'FRN': 'DERIVE_FROM_VALGROUP',
    'Future/Forward': 'FUNCTION',
    'Option': 'FUNCTION',
    'Zero': 'DERIVE_FROM_VALGROUP',
    'Curr': 'Other Foreign Exchange Derivatives',
    'CFD': 'FUNCTION',
    'FXOptionDatedFwd': 'Non-Deliverable Forward',
    'FxSwap': 'Non-Deliverable FX Swaps',
    'Average Future/Forward': 'Other Commodity Derivatives',
    'Commodity': 'Other Commodity Derivatives',
    'Commodity Index': 'Other Commodity Derivatives',
    'Commodity Variant': 'Other Commodity Derivatives',
    'PriceSwap': 'Other Commodity Derivatives',
    'Rolling Schedule': 'Other Commodity Derivatives',
    'Depositary Receipt': 'Other Equity Derivatives',
    'Dividend Point Index': 'Dividend Index Options',
    'EquityIndex': 'Stock Index Options',
    'ETF': 'Other Equity Derivatives',
    'Stock': '',
    'VarianceSwap': 'Other Equity Derivatives',
    'VolatilitySwap': 'Other Equity Derivatives',
    'Warrant': 'Other Equity Derivatives',
    'IndexLinkedBond': 'DERIVE_FROM_VALGROUP',
    'Swap': 'Other Interest Rate Derivatives',
    'Cap': 'Other Interest Rate Derivatives',
    'Floor': 'Other Interest Rate Derivatives',
    'FRA': 'Other Interest Rate Derivatives',
    'TotalReturnSwap': 'FUNCTION',
}

rts_28_ins_type = {
    'Stock': 'Equities - Shares & Depositary Receipts',
    'Depositary Receipt': 'Equities - Shares & Depositary Receipts',
    'Option': 'Futures and options admitted to trading on a trading venue',
    'LEPO': 'Futures and options admitted to trading on a trading venue',
    'Cap': 'Futures and options admitted to trading on a trading venue',
    'Floor': 'Futures and options admitted to trading on a trading venue',
    'Future/Forward': 'Futures and options admitted to trading on a trading venue',
    'Warrant': 'Warrants and Certificate Derivatives',
    'Bond': 'Bonds',
    'FRN': 'Bonds',
    'Zero': 'Bonds',
    'Convertible': 'Bonds',
    'IndexLinkedBond': 'Bonds',
    'DualCurrBond': 'Bonds',
    'Flexi Bond': 'Bonds',
    'PromisLoan': 'Money Market Instruments',
    'Bill': 'Money Market Instruments',
    'CD': 'Money Market Instruments',
    'Deposit': 'Money Market Instruments',
    'Repo/Reverse': 'Money Market Instruments',
    'BuySellback': 'Money Market Instruments',
    'BasketRepo/Reverse': 'Money Market Instruments',
    'Certificate': 'Money Market Instruments',
    'Swap': 'Swaps, forwards and other interest rate derivatives',
    'FRA': 'Swaps, forwards and other interest rate derivatives',
    'CurrSwap': 'Swaps, forwards and other currency derivatives',
    'FxSwap': 'Swaps, forwards and other currency derivatives',
    'FXOptionDatedFwd': 'Swaps, forwards and other currency derivatives',
    'TotalReturnSwap': 'Swaps and other equity derivatives',
    'EquitySwap': 'Swaps and other equity derivatives',
    'CreditDefaultSwap': 'Other credit derivatives',
    'CLN': 'Other credit derivatives',
    'VarianceSwap': 'Other Equity Derivatives',
    'PriceSwap': 'Structured Finance Instruments',
    'VolatilitySwap': 'Structured Finance Instruments',
    'Average Future/Forward': 'Structured Finance Instruments',
    'Portfolio Swap': 'Structured Finance Instruments',
    'MultiOption': 'Structured Finance Instruments',
    'MultiAsset ': 'Structured Finance Instruments',
    'Combination': 'Structured Finance Instruments',
    'FreeDefCF': 'Structured Finance Instruments',
    'MBS/ABS': 'Structured Finance Instruments',
    'Certificate': 'Structured Finance Instruments',
    'IndexLinkedSwap': 'Other securitized derivatives',
    'CFD': 'Contracts for Difference',
    'ETF': 'Exchange Traded Products',
    'Commodity Variant': 'Other commodities derivatives and Emission Allowances Derivatives',
    'Rolling Schedule': 'Other commodities derivatives and Emission Allowances Derivatives',
    'Commodity': 'Other Instruments',
    'Curr': 'Other Instruments',
    'EquityIndex': 'Other Instruments',
    'BondIndex': 'Other Instruments',
    'RateIndex': 'Other Instruments',
    'Collateral': 'Other Instruments',
    'SecurityLoan': 'Other Instruments',
    'PriceIndex': 'Other Instruments',
    'UnKnown': 'Other Instruments',
    'CallAccount': 'Other Instruments',
    'CashCollateral': 'Other Instruments',
    'CreditIndex': 'Other Instruments',
    'BasketSecurityLoan': 'Other Instruments',
    'Fund': 'Other Instruments',
    'Fx Rate': 'Other Instruments',
    'Commodity Index': 'Other Instruments',
    'Credit Balance': 'Other Instruments',
    'Dividend Point Index': 'Other Instruments',
}
city_code_lookup = {'United States' : { 'Wichita' : 'USWT', 
                                        'Honolulu' : 'USHL', 
                                        'Mobile' : 'USMB',
                                        'Minneapolis' : 'USMN',
                                        'Detroit' : 'USDT',
                                        'Denver' : 'USDN',
                                        'Washington' : 'USDC',
                                        'Charlotte' : 'USCR', }, 
                    'Trinidad and Tobago' : {'Port of Spain' : 'TTPS', }, 
                    'Tanzania' : {'Dar es Salaam' : 'TZDA', }, 
                    'Philippines' : {'Makati' : 'PHMK', }, 
                    'Cayman Islands' : {'George Town' : 'KYGE', }, 
                    'Canada' : {'Calgary' : 'CACL', }, 
                    'Brazil' : {'Brasilia' : 'BRDB', 'Rio de Janeiro' : 'BRDB'},
                    }

master_agreement_type_dict = {\
                                'MRA'     : 'MRAA', 
                                'GMRA'    : 'GMRA', 
                                'MSLA'    : 'MSLA',
                                'GMSLA'   : 'GMSL',
                                'ISDA'    : 'ISDA',
                                'KOFIA'   : 'KRRA',
                                'IIROC'   : 'CARA',
                                'MEFISLA' : 'MEFI', 
                                'GESLA'   : 'GESL',
                                'KOSLA'   : 'KRSL', 
                                'AMSLA'   : 'AUSL'}
class RTS2Classification(object):
    def __init__(self, instrument, current_date=None):
        self.__instrument = instrument
        self.current_date = current_date

    def CreditDefaultSwap_rts2(self):
        ins_type = 'CDS'
        rts2_instype = ''
        if self.__instrument.Underlying().InsType() in ['Combination', 'CreditIndex']:
            ins_type = 'Basket CDS'
        if ins_type in rts2_ins_type_lookup:
            rts2_instype = rts2_ins_type_lookup[ins_type]
        return rts2_instype

    def CreditDefaultSwap_rts2_sub_type(self):
        ins_type = 'CDS'
        rts2_subtype = ''
        if self.__instrument.Underlying().InsType() in ['Combination', 'CreditIndex']:
            ins_type = 'Basket CDS'
        if ins_type in rts2_sub_ins_type_lookup:
            rts2_subtype = rts2_sub_ins_type_lookup[ins_type]
        return rts2_subtype

    def Convertible_rts2(self):
        rts2_instype = 'Interest Rate Derivatives'
        if self.__instrument.Underlying().InsType() in ['Depositary Receipt', 'Stock', 'EquityIndex']:
            rts2_instype = 'Equity Derivatives'
        elif self.__instrument.Underlying().InsType() in ['Commodity Index', 'Commodity', 'Commodity Variant']:
            rts2_instype = 'Commodity Derivatives'
        return rts2_instype

    def Convertible_rts2_sub_type(self):
        rts2_subtype = 'Other Interest Rate Derivatives'
        if self.__instrument.Underlying().InsType() in ['Depositary Receipt', 'Stock', 'EquityIndex']:
            rts2_subtype = 'Other Equity Derivatives'
        elif self.__instrument.Underlying().InsType() in ['Commodity Index', 'Commodity','Commodity Variant']:  # TODO: Verify with Ishan
            rts2_subtype = 'Other Commodity Derivatives'
        return rts2_subtype

    def TotalReturnSwap_rts2(self):
        rts2_instype = 'Interest Rate Derivatives'
        total_return_leg = False
        for leg in self.__instrument.Legs():
            if leg.LegType() == 'Total Return':
                total_return_leg = True
        if total_return_leg:
            rts2_instype = 'Structured Finance Products'
        return rts2_instype

    def TotalReturnSwap_rts2_sub_type(self):
        rts2_subtype = 'Other Interest Rate Derivatives'
        total_return_leg = False
        for leg in self.__instrument.Legs():
            if leg.LegType() == 'Total Return':
                total_return_leg = True
        if total_return_leg:
            rts2_subtype = ''
        return rts2_subtype

    def Future_Forward_rts2(self):
        rts2_instype = 'Interest Rate Derivatives'
        rts2_instype = self.__rts2_classification_with_underlyer(self.__instrument)
        return rts2_instype

    def Future_Forward_rts2_sub_type(self):
        rts2_subtype = ''
        if self.__instrument.Underlying().InsType() in ['CreditDefaultSwap', 'CLN']:
            rts2_subtype = 'Other Credit Derivatives'
        if self.__instrument.Underlying().InsType() in ['FRA', 'Swap']:
            rts2_subtype = 'IR Futures & FRA'
        if self.__instrument.Underlying().InsType() in ['FRN', 'IndexLinkedBond', 'RateIndex']:
            rts2_subtype = 'Other Interest Rate Derivatives'
        elif self.__instrument.Underlying().InsType() in ['Depositary Receipt', 'Dividend Point Index', 'EquityIndex', 'Stock', 'ETF']:
            rts2_subtype = 'Stock Futures/Forwards'
        elif self.__instrument.Underlying().InsType() in ['Commodity Index', 'Commodity', 'Commodity Variant', 'Average Future/Forward']:
            rts2_subtype = 'Metal/Agriculture/Energy/ Other Commodity Derivatives'
        elif self.__instrument.Underlying().InsType() in ['Curr']:
            if self.__instrument.PayType() == 'Future':
                rts2_subtype = 'FX Futures'
            elif self.__instrument.PayType() == 'Forward':
                rts2_subtype = 'Non-Deliverable Forward'
        elif self.__instrument.Underlying().InsType() in ['Bond', 'Zero', 'Bill']:
            rts2_subtype = 'Bond Futures/Forwards'
        return rts2_subtype

    def __rts2_classification_with_underlyer(self, instrument):
        rts2_instype = 'Interest Rate Derivatives'
        if instrument.Underlying().InsType() in ['CreditDefaultSwap', 'CLN']:
            rts2_instype = 'Credit Derivatives'
        elif instrument.Underlying().InsType() in ['Curr', 'CurrSwap']:
            rts2_instype = 'Foreign Exchange Derivatives'
        elif instrument.Underlying().InsType() in ['Average Future/Forward', 'Commodity Index', 'Commodity', 'Commodity Variant']:
            rts2_instype = 'Commodity Derivatives'
        elif instrument.Underlying().InsType() in ['Depositary Receipt', 'EquityIndex', 'Stock', \
                     'Warrant', 'Dividend Point Index']:
            rts2_instype = 'Equity Derivatives'
        elif instrument.Underlying().InsType() in ['IndexLinkedSwap', 'PromisLoan', 'Convertible', \
                                                            'Combination', 'ETF', 'Fund', \
                                                            'TotalReturnSwap', 'CFD', 'FreeDefCF', 'Deposit']:
            rts2_instype = 'Structured Finance Products'
        elif instrument.Underlying().InsType() in ['Future/Forward', 'VarianceSwap']:
            rts2_instype = self.__rts2_classification_with_underlyer(instrument.Underlying())
        return rts2_instype

    def Option_rts2(self):
        rts2_instype = 'Interest Rate Derivatives'
        rts2_instype = self.__rts2_classification_with_underlyer(self.__instrument)
        return rts2_instype

    def __rts2_sub_type_classification_with_underlyer(self, instrument):
        rts2_subtype = ''
        if instrument.Underlying().InsType() in ['Zero']:
            rts2_subtype = 'IR Options'
        elif instrument.Underlying().InsType() in ['FRA']:
            rts2_subtype = 'IR Futures & FRA'
        elif instrument.Underlying().InsType() in ['CLN']:
            rts2_subtype = 'Other Credit Derivatives'
        elif instrument.Underlying().InsType() in ['CreditDefaultSwap']:
            rts2_subtype = 'CDS index options/Single name CDS options'
        elif instrument.Underlying().InsType() in ['CurrSwap']:
            rts2_subtype = 'Other Foreign Exchange Derivatives'
        elif instrument.Underlying().InsType() in ['Curr']:
            if instrument.SettlementType() == 'Cash':
                rts2_subtype = 'Non-Deliverable FX Options'
            else:
                rts2_subtype = 'Deliverable FX Options'
        elif instrument.Underlying().InsType() in ['Commodity Index', 'Commodity Variant', 'Average Future/Forward']:
            rts2_subtype = 'Other Commodity Derivatives'
        elif instrument.Underlying().InsType() in ['Commodity', ]:
            rts2_subtype = 'Agricultural/ Metal/ Energy/ Other Commodity Derivatives'
        elif instrument.Underlying().InsType() in ['Stock']:
            rts2_subtype = 'Stock Options'
        elif instrument.Underlying().InsType() in ['EquityIndex']:
            rts2_subtype = 'Stock Index Options'
        elif instrument.Underlying().InsType() in ['Bill', 'Bond']:
            rts2_subtype = 'Bond Options'
        elif instrument.Underlying().InsType() in ['Warrant', 'Depositary Receipt']:
            rts2_subtype = 'Other Equity Derivatives'
        elif instrument.Underlying().InsType() in ['Cap', 'Floor', 'FRA', 'FRN', 'RateIndex', 'Deposit']:
            rts2_subtype = 'Other Interest Rate Derivatives'
        elif instrument.Underlying().InsType() in ['TotalReturnSwap']:
            rts2_subtype = 'Other Structured Finance Products Derivatives'
        elif instrument.Underlying().InsType() in ['Swap']:
            rts2_subtype = 'Other Interest Rate Derivatives'
        elif instrument.Underlying().InsType() in ['Future/Forward', 'VarianceSwap']:
            rts2_subtype = self.__rts2_sub_type_classification_with_underlyer(instrument.Underlying())
        return rts2_subtype

    def Option_rts2_sub_type(self):
        rts2_subtype = ''
        rts2_subtype = self.__rts2_sub_type_classification_with_underlyer(self.__instrument)
        return rts2_subtype

    def CFD_rts2_sub_type(self):
        rts2_subtype = 'Equity CFDs'
        if self.__instrument.Underlying().InsType() in ['Bond']:
            rts2_subtype = 'Bond CFDs'
        return rts2_subtype

    def __derive_ins_sub_type_from_valgroup(self):
        sub_type = 'Other Bond'
        #this code was commented as only on the basis of this categorization, it is not fullproof to be applicable across insTypes
        #if self.__instrument.SeniorityChlItem() and self.__instrument.SeniorityChlItem().Name() == 'SNRFOR':
        #    sub_type = 'Covered Bond'
        if self.__instrument.CategoryChlItem():
            if self.__instrument.CategoryChlItem().Name().upper() in ['GOVERNMENT']:
                sub_type = 'Sovereign Bond'
            elif self.__instrument.CategoryChlItem().Name().upper() in ['MUNICIPAL']:
                sub_type = 'Other Public Bond'
            elif self.__instrument.CategoryChlItem().Name().upper() in ['CORPORATE']:
                sub_type = 'Corporate Bond'
        return sub_type

    def mifid2_rts2_instype(self):
        ins_type = ''
        if self.__instrument.InsType() in rts2_ins_type_lookup:
            ins_type = rts2_ins_type_lookup[self.__instrument.InsType()]
            if ins_type == 'FUNCTION':
                instrument_type = self.__instrument.InsType()
                if instrument_type.find('/') != -1:
                    instrument_type = instrument_type.replace('/', '_')
                ins_type = eval('self.' + instrument_type + '_rts2()')
        return ins_type

    def mifid2_rts2_inssubtype(self):
        ins_type = ''
        if self.__instrument.InsType() in rts2_sub_ins_type_lookup:
            ins_type = rts2_sub_ins_type_lookup[self.__instrument.InsType()]
            if ins_type == 'FUNCTION':
                instrument_type = self.__instrument.InsType()
                if instrument_type.find('/') != -1:
                    instrument_type = instrument_type.replace('/', '_')
                ins_type = eval('self.' + instrument_type + '_rts2_sub_type()')
            elif ins_type == 'DERIVE_FROM_VALGROUP':
                ins_type = self.__derive_ins_sub_type_from_valgroup()
        return ins_type

    def get_business_date_range(self):
        current_year = str(acm.Time().DateToYMD(self.current_date)[0])
        date_range_dict = {
            (ael.date(current_year + "-02-16"), ael.date(current_year + "-05-15")): (
            ael.date(current_year + "-01-31"), ael.date(str(int(current_year) - 1) + "-11-01")),
            (ael.date(current_year + "-05-16"), ael.date(current_year + "-08-15")): (
            ael.date(current_year + "-04-30"), ael.date(current_year + "-02-01")),
            (ael.date(current_year + "-08-16"), ael.date(current_year + "-11-15")): (
            ael.date(current_year + "-07-31"), ael.date(current_year + "-05-01")),
            (ael.date(current_year + "-11-16"), ael.date(current_year + "-12-31")): (
            ael.date(current_year + "-10-31"), ael.date(current_year + "-08-01")),
            (ael.date(current_year + "-01-01"), ael.date(current_year + "-02-15")): (
            ael.date(str(int(current_year) - 1) + "-10-31"), ael.date(str(int(current_year) - 1) + "-08-01")),
        }
        businessdays, dates = None, None
        from FOperationsDateUtils import GetAccountingCurrencyCalendar
        calendar = GetAccountingCurrencyCalendar()
        calInfo = calendar.CalendarInformation()
        if self.current_date <= ael.date("2018-05-15"):
            businessdays = calInfo.BankingDaysBetween(ael.date("2018-02-01"), ael.date("2018-01-03"))
            dates = (ael.date("2018-02-01"), ael.date("2018-01-03"))
        else:
            for date_range in date_range_dict:
                if self.current_date <= date_range[1] and self.current_date >= date_range[0]:
                    businessdays = calInfo.BankingDaysBetween(date_range_dict[date_range][0],
                                                              date_range_dict[date_range][1])
                    dates = date_range_dict[date_range]
                    break
        return businessdays, dates

    def get_total_nominal_value(self):
        trades = self.__instrument.Trades()
        nominal_value = 0
        businessdays, dates = self.get_business_date_range()
        if trades:
            for trade in trades:
                if ael.date(str(trade.TradeTime())[:10]) <= dates[0] and ael.date(str(trade.TradeTime())[:10]) >= dates[
                    1]:
                    nominal_value += trade.Nominal()
        return nominal_value, businessdays, dates

    def get_average_daily_trades(self, businessdays, dates):
        trades = self.__instrument.Trades()
        first_trade_ind = 0
        count_trade = 0
        trade_dates = set()
        for trade in trades:
            if ael.date(str(trade.TradeTime())[:10]) <= dates[0] and ael.date(str(trade.TradeTime())[:10]) >= dates[1]:
                count_trade += 1
                trade_dates.add(str(trade.TradeTime())[:10])
        if len(trade_dates) and min(trade_dates) <= dates[0] and ael.date(str(trade.TradeTime())[:10]) >= dates[1]:
            first_trade_ind = 1
        return dates, int(count_trade / businessdays), int(len(trade_dates) * 100.0 / businessdays), first_trade_ind


...



}
