#
# Front Arena exported extension module.
# source  
# timestamp (utc) 
# ***** DO NOT EDIT! *****
#
name        "FFTPLibrary"
description "FFTPLibrary 2.0.4 Copyright 2009-2014 FIS FRONT ARENA"

groups {
}

decls[FPythonCode] {
  "FFTPLibraryInstalledComponent" ( "installed component" ) "";
}

decls[FParameters] {
}

clx FObject [FParameters] {
  FFTPAMBSettings =
  MB_MESSAGE_BODY_ONLY=FALSE
  MESSAGE_BROKER=
  FFTP_APPLICATION_NAME=FFTPLib
  MESSAGE_FILE_NAME=
  MESSAGE_PROPERTIES={'message_source':{'TYPE': '', 'VERSION': '', 'SOURCE':'', 'MESSAGE_TAG':'', 'FILE_DATA_TAG':'' }}
  MESSAGE_RECEIVER=FFTP_MESSAGE_RECEIVER
  MESSAGE_SENDER=FFTP_MESSAGE_SENDER


  FFTPLogSettings =
  LOGGING_LEVEL=DEBUG  # choose INFO, WARNING, ERROR, DEBUG
  NOTIFICATION_MEDIA=OFF  # choose  MAIL, MESSAGE, PRIME_LOG, PRIME_LOG_TRANSIENT, OFF
  NOTIFY_LEVEL=TRACK  # choose DEBUG, TRACK, SUCCESS, WARNING, ERROR
  NOTIFY_USER=
  SMTP_SERVER=
  USER_EMAIL=
  #Please remove the comment of parameter after choosing the provided values=


  FFTPModeSettings =
  MODE=  # AMB-DIR, AMB-FTP, AMB-SFTP, AMB-AMB, DIR-DIR, DIR-AMB, DIR-FTP, DIR-SFTP, FTP-FTP, FTP-AMB, FTP-DIR, FTP-SFTP, SFTP-SFTP, SFTP-AMB, SFTP-FTP, SFTP-DIR


  FFTPSettings =
  POLL_INTERVAL=0
  POLL_RETRY=0
  POLL_TIMEOUT=0
  READ_HOST=
  READ_PORT=
  READ_PWD=
  READ_USER=
  WRITE_HOST=
  WRITE_PORT=
  WRITE_PWD=
  WRITE_USER=  
  FTP_TRANSACTION_LOG_PATH=


  FFTPSystemSettings =
  FFTPLIBRARY_VERSION=2.0.4-0.0.403
  FFTPLIBRARY_BUILD_DATE=23-Aug-2021
  TIME_INTERVAL=20


}
decls[FPythonCode] {
}

clx FObject [FPythonCode] {
  FFTPAMBOperations
"""--------------------------------------------------------------------
MODULE
    FFTPAMBOperations -  AMB operations like reading from AMB and writing to AMB database

DESCRIPTION
    This script handles the AMB operations.

VERSION: 2.0.4

--------------------------------------------------------------------"""

import os
import tempfile
import acm
import amb

import FFTPNotification
import FFTPConfig
import FFTPLibHooks
import FIntegrationUtils

utilsobj= FIntegrationUtils.FIntegrationUtils()

logger = FFTPNotification.FFTPLogger('FFTPLibrary')

mode_config_param = None
message_file_name = ''
amb_connected = False
config_variables_obj = FFTPConfig.FTPConfigSingleton('FFTPLibrary')


def event_cb_reader(channel, event, arg):
    '''
    Call back function to read message from AMB for the subscribed subject
    Args:
          channel: Channel to get
          event:

    '''
    global message_file_name
    global amb_connected
    eventstring = amb.mb_event_type_to_string(event.event_type)
    if eventstring == 'Message':
        buf = amb.mbf_create_buffer_from_data(event.message.data_p)
        org_amb_message = buf.mbf_read()
        message_obj_type = type(org_amb_message)
        msg_subject = event.message.subject
        logger.DEBUG("Received amb message with subject: {}".format(msg_subject))
        msg_source = None
        source_tag = org_amb_message.mbf_find_object('SOURCE', 'MBFE_BEGINNING')
        if source_tag:
            msg_source = source_tag.mbf_get_value()
            logger.DEBUG("AMB message source is : {}".format(msg_source))
        mode_config_param = ''
        mb_message = ''
        if org_amb_message:
            read_mode = None
            write_mode = None
            file_path = None
            file_name = None
            temp_download = False
            process_msg = 1
            if len(arg) >= 2:
                write_source_lst, file_name, msg_subject_lst, temp_file_path, mode = arg[0], arg[1], arg[2], arg[3], \
                                                                                     arg[4]
                if write_source_lst and msg_subject_lst:
                    logger.DEBUG("Get the directory path for downloading amb message for TASK")
                    if msg_subject not in msg_subject_lst:
                        logger.DEBUG("Cannot process message as the message subject: {} not in subject list: {}".format(
                            msg_subject, msg_subject_lst))
                        process_msg = 0
                    else:
                        logger.INFO("Received amb message with subject {}.".format(msg_subject))
                        # write mode is dir
                        logger.DEBUG("Write mode is {}".format(mode.split('-')[1]))
                        if mode.split('-')[1] == 'DIR':
                            if len(write_source_lst) == 1:
                                file_path = write_source_lst[0]
                            elif len(write_source_lst) > 1 and len(write_source_lst) == len(msg_subject_lst):
                                source_dict = dict(list(zip(write_source_lst, msg_subject_lst)))
                                file_path = source_dict.get(msg_subject, write_source_lst[0])
                        else:
                            file_path = temp_file_path

            if (not file_path or not file_name):
                logger.DEBUG("Get the directory path for downloading amb message")
                config_param = FFTPConfig.Parameters('FFTPModeSettings')
                mode = getattr(config_param, 'MODE', '')
                mode_lst = FFTPConfig.string_as_list(mode)
                for each_mode in mode_lst:
                    if each_mode.split('-')[0] == 'AMB':
                        logger.DEBUG("Processing amb message for mode : {}".format(each_mode))
                        read_mode, write_mode = each_mode.split('-')
                        mode_config_param = FFTPConfig.Parameters('FFTPModeSettings_' + each_mode)
                        msg_file_name = message_file_name
                        read_source_obj = getattr(mode_config_param, 'READ_SOURCE', '')
                        read_source = FFTPConfig.string_as_list(read_source_obj)
                        write_source_obj = getattr(mode_config_param, 'WRITE_SOURCE', '')
                        write_source = FFTPConfig.string_as_list(write_source_obj)
                        temp_file_path = getattr(mode_config_param, 'TEMP_FILE_PATH', '')
                        logger.DEBUG("AMB  message file name is : {}".format(msg_file_name))
                        for source in read_source:
                            file_path = None
                            file_name = None
                            subject = source
                            if subject == msg_subject:
                                process_msg = 1
                                logger.INFO("Received amb message with subject {}.".format(msg_subject))
                                org_amb_message_str = org_amb_message.mbf_object_to_string()
                                # Apply export entry hook on amb message
                                amb_message_hook, destination_path = FFTPLibHooks.fftplibrary_export_entry(read_mode,
                                                                                                           write_mode,
                                                                                                           org_amb_message_str,
                                                                                                           org_amb_message,
                                                                                                           msg_subject=msg_subject,
                                                                                                           msg_source=msg_source)

                                logger.DEBUG("Applied fftplibrary_export_entry on amb message")
                                if type(amb_message_hook) == message_obj_type:
                                    org_amb_message = amb_message_hook
                                elif amb_message_hook and isinstance(amb_message_hook, str):
                                    org_amb_message = string_to_mbf_object(amb_message_hook)
                                else:
                                    org_amb_message = None

                                if org_amb_message:
                                    logger.DEBUG("Get the path for downloading amb message")
                                    file_name = msg_file_name
                                    if write_mode == 'DIR':
                                        if destination_path:
                                            file_path = destination_path
                                        if len(write_source) == 1:
                                            file_path = write_source[0]
                                        elif len(write_source) == len(read_source):
                                            source_dict = dict(list(zip(read_source, write_source)))
                                            file_path = source_dict[source]
                                    else:
                                        file_path = temp_file_path
                                        temp_download = True
                                    break
                                else:
                                    logger.WARN("Applied export entry hook, amb message is filtered")
                                    process_msg = 0
                        logger.DEBUG("Directory path for downloading amb message is {}".format(file_path))

            if file_path == None:
                process_msg = 0

            if process_msg:
                logger.DEBUG("Process amb message")
                file_path = os.path.join(file_path, msg_subject.replace('/', '_'))
                filename, file_extension = os.path.splitext(file_name)
                mb_message_body_only = ''
                entity_name = ''

                if mode_config_param:
                    mb_message_body_only = getattr(mode_config_param, 'MB_MESSAGE_BODY_ONLY', False)

                if not mb_message_body_only:
                    amb_config_param = FFTPConfig.Parameters('FFTPAMBSettings')
                    mb_message_body_only = getattr(amb_config_param, 'MB_MESSAGE_BODY_ONLY', False)

                logger.DEBUG("Value of FParameter MB_MESSAGE_BODY_ONLY is {}".format(mb_message_body_only))

                if mb_message_body_only and str(mb_message_body_only).upper() != 'FALSE':
                    if not str(mb_message_body_only).startswith('//'):
                        logger.ERROR("Incorrect format used in Parameter MB_MESSAGE_BODY_ONLY. Use Format //root/child")
                    else:
                        mb_message_body_only_lst = str(mb_message_body_only).split('//')[1].split('/')
                        mb_message_body_only_lst = mb_message_body_only_lst[1:]
                        amb_message_tmp = org_amb_message
                        entity_name = ''
                        logger.DEBUG("Content to read from amb message is : {}".format(mb_message_body_only_lst))
                        for contents in mb_message_body_only_lst:
                            entity = amb_message_tmp.mbf_find_object(contents, 'MBFE_BEGINNING')
                            if entity:
                                entity_name = entity.mbf_get_name()
                                logger.DEBUG("AMB message entity to read is : {}".format(entity_name))
                                amb_message_tmp = entity
                                if entity.mbf_is_list():
                                    mb_message = convert_mbf_message_to_string(entity)
                                else:
                                    mb_message = entity.mbf_get_value()
                            else:
                                logger.ERROR("Tag {} not found in amb message".format(contents))
                                mb_message = ''
                        if mb_message:
                            download_amb_message(file_name, file_path, entity_name, msg_source, read_mode, write_mode,
                                                 mb_message, org_amb_message, temp_download)
                else:
                    mb_message = convert_mbf_message_to_string(org_amb_message)
                    # mb_message = org_amb_message.mbf_object_to_string()
                    if mb_message:
                        download_amb_message(file_name, file_path, entity_name, msg_source, read_mode, write_mode,
                                             mb_message, org_amb_message, temp_download)
                try:
                    amb.mb_queue_accept(channel, event.message, 'Message processing done')

                except Exception as ex:
                    logger.ERROR("Error while mb_queue_accept : {}".format(str(ex)))
            else:
                logger.DEBUG("AMB message cannot be processed")

    elif eventstring == 'Disconnect':
        amb_connected = False


def create_message_buffer(messageObj, message_buffer=''):
    """Create string from the mbg object by reading each tag"""
    if messageObj:
        message_buffer += "[{}]\n".format(messageObj.mbf_get_name())
        msg_obj = messageObj.mbf_first_object()
        while msg_obj:
            if msg_obj.mbf_is_list():
                message_buffer = create_message_buffer(msg_obj, message_buffer)
            else:
                message_buffer += msg_obj.mbf_get_name() + '=' + msg_obj.mbf_get_value()
                message_buffer += '\n'

            msg_obj = messageObj.mbf_next_object()
        else:
            message_buffer += "[/{}]\n".format(messageObj.mbf_get_name())
    return message_buffer


def convert_mbf_message_to_string(mb_object):
    """Method to convert mb message object to string"""
    logger.DEBUG("Convert amb message to string")
    message_buffer = mb_object.mbf_object_to_string()

    # Read each tag and create a message string from mbf object
    message_string = create_message_buffer(mb_object, '')
    if message_string:
        try:
            # Convert message string to mbf object and get indented message
            msg_buf = amb.mbf_create_buffer_from_data(message_string)
            mbf_object_new = msg_buf.mbf_read()
            message_string = mbf_object_new.mbf_object_to_string()
            message_buffer = message_string
        except Exception as ex:
            #logger.WARN("Cannot convert message string to mbf object")
            message_buffer = message_string
    #else:
    #    logger.WARN("Cannot convert mbf_message to string")
    return message_buffer


def download_amb_message(file_name, file_path, entity_name, msg_source, read_mode, write_mode, mb_message,
                         org_amb_message, temp_download):
    logger.DEBUG("Download amb message to file")
    org_file_path = file_path
    config_data = config_variables_obj.config_data
    logger.DEBUG("AMB message file name: {} and file path: {} before customization".format(file_name, file_path))
    file_path, file_name = get_message_file_name(file_name, file_path, entity_name, msg_source, mb_message, org_amb_message)

    # Apply export exit hook on amb message
    mb_message_obj = string_to_mbf_object(mb_message)
    mb_message, destination_path = FFTPLibHooks.fftplibrary_export_exit(read_mode, write_mode, mb_message,
                                                            mb_message_obj, destination_path=file_path)

    if type(mb_message) == type(org_amb_message):
        mb_message = convert_mbf_message_to_string(mb_message)

    if mb_message:
        if destination_path:
            logger.DEBUG("AMB message download path returned from export exit hook is: {}".format(destination_path))
            file_path = destination_path

        if temp_download:
            msg_file_path = os.path.join(org_file_path, file_name)
            msg_file_path = write_mb_message_to_file(msg_file_path, mb_message, org_amb_message)
            # Set the temperory path in config for the customized path
            if os.path.abspath(file_path) != os.path.abspath(org_file_path):
                logger.DEBUG("Adding destination path in the config dictionary, \
                                        customized by user in the extension points")
                temp_path_key = 'TEMP_{}-{}'.format(read_mode, write_mode)
                if temp_path_key not in config_data:
                    config_data[temp_path_key]={}
                config_data[temp_path_key][msg_file_path] = file_path
        else:
            msg_file_path = os.path.join(file_path, file_name)
            write_mb_message_to_file(msg_file_path, mb_message, org_amb_message)


def string_to_mbf_object(amb_message_string):
    logger.DEBUG("Convert amb message string to message object")
    mb_object = None
    try:
        buf = amb.mbf_create_buffer_from_data(str(amb_message_string))
        mb_object = buf.mbf_read()
    except Exception as ex:
        logger.WARN("Cannot convert amb message string to mbf object")
    return mb_object


def get_message_file_name(file_name, file_path, entity_name, msg_source, mb_message_to_export, org_amb_message):
    """get the message file name with the timestamp, message source and entity name
    """
    logger.DEBUG("Get amb message file name")
    filename, file_extension = os.path.splitext(file_name)
    local_time = acm.Time.RealDateNow() + ' ' + acm.Time.TimeOnlyMs()
    if not file_extension:
        file_extension = '.txt'
        logger.DEBUG("Default file extension is {}".format(file_extension))

    tmp_file_name = str(local_time).replace(':', '') + file_extension
    if entity_name:
        tmp_file_name = entity_name + '_' + tmp_file_name

    if file_name:
        file_name = file_name + '_' + tmp_file_name
    else:
        logger.WARN("FParameter <MESSAGE_FILE_NAME> is not set, using AMB message source: {} for file name".format(msg_source))
        file_name = msg_source + '_' + tmp_file_name

    # Apply extension point
    try:
        file_path_cust, file_name = FFTPLibHooks.amb_message_file_name(file_name, mb_message_to_export, org_amb_message, file_path=file_path)
        logger.DEBUG("AMB message file name after applying hook is {}".format(file_name))
        logger.DEBUG("AMB message file path after applying hook is {}".format(file_path_cust))
        if file_path_cust:
            file_path = file_path_cust
    except Exception as e:
        logger.ERROR("Exception in extension point amb_message_file_name : {}".format(str(e)))

    file_name = validate_file_name(file_name)
    logger.DEBUG("AMB message file name after validation: {}".format(file_name))
    return file_path, file_name


def write_mb_message_to_file(msg_file_path, mb_message_to_export, org_amb_message):
    # Apply extension point for message content
    logger.DEBUG("Write amb message content to file")

    try:
        mb_message_to_export = FFTPLibHooks.amb_message_content(msg_file_path, mb_message_to_export, org_amb_message)
    except Exception as e:
        logger.ERROR("Exception in extension point amb_message_content : {}".format(str(e)))

    if mb_message_to_export:
        try:
            file_path, file_name = os.path.split(msg_file_path)
            if not os.path.exists(file_path):
                os.makedirs(file_path)

            # if file already exist with same name, then create unique file name
            if os.path.exists(msg_file_path):
                filename, file_extension = os.path.splitext(msg_file_path)
                temp_string = next(tempfile._get_candidate_names())
                logger.WARN("File name: {} already exists, adding string: {} to make unique file name".format(file_name, temp_string))
                msg_file_path = filename + '_' + temp_string + file_extension

            file = open(msg_file_path, 'wb')
            file.write(mb_message_to_export.encode('UTF-8'))
            file.close()
            logger.DEBUG("AMB message is written to file : {}".format(msg_file_path))
        except Exception as ex:
            logger.ERROR("Error while writing the amb message to file_name {}".format(str(ex)))
    return msg_file_path

def event_cb_writer(channel, event, arg):
    """ Callback function for amb writer """
    (channel, amb.mb_event_type_to_string(event.event_type))
    eventstring = amb.mb_event_type_to_string(event.event_type)
    if eventstring == 'Message':
        pass


class AMBOperations(object):
    """ Class for AMB operations to read and write data within mb database using AMB APIs"""

    def __init__(self, amb_address=None, application_name='', config_variables_obj=None, *args):
        self.amb_address = amb_address
        self.is_connected = True  # self.init_amb_connection()
        self.message_prop = None
        self.application_name = application_name
        config_data = config_variables_obj.config_data if config_variables_obj else {}
        self.read_mode = config_data.get('FROM_MODE', 'FTP')
        self.write_mode = config_data.get('TO_MODE', '')
        
    def split_amb_details(self):
        amb_addr = None
        ambUser = None
        ambPassword = None
        amb_details = self.amb_address.split("/")
        if len(amb_details) > 0 and amb_details[0]:
            amb_addr = amb_details[0]
        if len(amb_details) > 1 and amb_details[1]:
            ambUser = amb_details[1]
        if len(amb_details) > 2 and amb_details[2]:
            ambPassword = amb_details[2]
        amb_detail = (amb_addr, ambUser, ambPassword)
        return amb_detail    
            

    def init_amb_connection(self):
        """ Connect to AMB """
        global amb_connected
        is_connected = False
        amb_detail = self.split_amb_details()
        if self.amb_address:
            
            try:
                utilsobj.connect_amb(self.application_name, self.amb_address)
                is_connected = True
                if amb_detail[0] and amb_detail[1]:
                    logger.INFO('AMB: <{0}> Connected for user <{1}> '.format(amb_detail[0], amb_detail[1]))
                else:
                    logger.INFO('AMB: <{0}> Connected '.format(amb_detail[0]))    
            except Exception as ex:     
                if amb_detail[0] and amb_detail[1]:           
                    error_message = "Connection to AMB <{0}> for user <{1}> failed : {2}".format(amb_detail[0], amb_detail[1], str(ex))
                else:
                    error_message = "Connection to AMB <{0}> failed : {1}".format(amb_detail[0], str(ex))    
                logger.ERROR(error_message)
                is_connected = False
        amb_connected = is_connected
        return is_connected

    @staticmethod
    def get_message_broker(mode, task_parameters, reader):
        """Get the amb address from the configured FParameters."""
        mode_config_param = FFTPConfig.Parameters('FFTPModeSettings_' + mode)
        amb_config_param = FFTPConfig.Parameters('FFTPAMBSettings')
        read_mode, write_mode = mode.split('-')
        amb_address = getattr(amb_config_param, 'MESSAGE_BROKER', '')
        if read_mode == 'AMB' and reader:
            if getattr(mode_config_param, 'READ_MESSAGE_BROKER', ''):
                amb_address = getattr(mode_config_param, 'READ_MESSAGE_BROKER', '')
        elif write_mode == 'AMB':
            if getattr(mode_config_param, 'WRITE_MESSAGE_BROKER', ''):
                amb_address = getattr(mode_config_param, 'WRITE_MESSAGE_BROKER', '')
        return amb_address

    @staticmethod
    def get_mode_params(param, mode, task_parameters=None):
        """Get the mode specific parameters"""
        mode_config_param = FFTPConfig.Parameters('FFTPModeSettings_' + mode)
        amb_config_param = FFTPConfig.Parameters('FFTPAMBSettings')
        param_value = getattr(mode_config_param, param, '')
        if task_parameters:
            param_value = task_parameters.get(param, '')
        else:
            if not param_value:
                param_value = getattr(amb_config_param, param, {})
        return param_value

    @classmethod
    def initialize(cls, mode, reader, task_parameters=None, config_variables_obj=None):
        """ Initialize the AMB connection"""
        global mode_config_param
        global message_file_name
        mode_config_param = FFTPConfig.Parameters('FFTPModeSettings_' + mode)
        amb_config_param = FFTPConfig.Parameters('FFTPAMBSettings')
        amb_address = cls.get_message_broker(mode, task_parameters, reader)
        read_source = cls.get_mode_params('READ_SOURCE', mode, task_parameters)
        write_source = cls.get_mode_params('WRITE_SOURCE', mode, task_parameters)
        if mode.split('-')[0] == 'AMB':
            message_file_name = cls.get_mode_params('MESSAGE_FILE_NAME', mode, task_parameters)
        temp_file_path = cls.get_mode_params('TEMP_FILE_PATH', mode, task_parameters)

        if not amb_address:
            logger.ERROR(
                "Configuration parameter MESSAGE_BROKER is missing. Please check FFTPAMBSettings or mode settings ")
            return None
        application_name = getattr(amb_config_param, 'FFTP_APPLICATION_NAME', '')
        obj = cls(amb_address, application_name, config_variables_obj=config_variables_obj)
        if not obj.is_connected:
            return None

        # subscribe to the incomming or outgoing channel
        if reader:
            receiver_channel = getattr(amb_config_param, 'MESSAGE_RECEIVER', '')
            subject_list = FFTPConfig.string_as_list(read_source)
            if task_parameters:
                msg_reader = obj.open_amb_reader_channel(receiver_channel, write_source, message_file_name,
                                                         subject_list, temp_file_path, mode)
            else:
                msg_reader = obj.open_amb_reader_channel(receiver_channel, None, None, None, None, None)

            if not msg_reader:
                return None
            amb_msg_subscribed = obj.subscribe_receive_msg_subject(msg_reader, subject_list)
            if not amb_msg_subscribed:
                return None
        else:
            message_prop_dict = {}
            sender_channel = getattr(amb_config_param, 'MESSAGE_SENDER', '')
            message_prop = cls.get_mode_params('MESSAGE_PROPERTIES', mode)
            try:
                message_prop_dict = eval(message_prop)
            except Exception as e:
                logger.ERROR("Incorrect data dictionary specified at FParameter MESSAGE_PROPERTIES : {}".format(
                    str(message_prop)))
                return None

            obj.message_prop = message_prop_dict  # need to check
            writer = obj.open_amb_writer_channel(sender_channel)
            if not writer:
                logger.ERROR("AMB is not initialised")
                return None
        return obj

    def read(self, subject, dest_dir, file_filter):
        """ Read downloaded amb message from AMB """
        source = None
        global amb_connected
        file_path_list = []
        logger.INFO("Checking for amb messages with subject {}.".format(subject))
        if not amb_connected:
            self.is_connected = False

        subject_source = subject.replace('/', '_')  # example BO_SETTLEMENT
        source = subject.split('/')[0]  # BO
        mfile_path = os.path.join(dest_dir, subject_source)
        if os.path.exists(mfile_path):
            file_list = os.listdir(mfile_path)
            if file_list:
                file_path_list = [os.path.join(mfile_path, each_file) for each_file in file_list]
        return file_path_list

    def write(self, file_path_list, subject, temp_dest_dict={}):
        """ Writes message to AMB """
        files_written_to_dest = []
        for file_path in file_path_list:
            if temp_dest_dict:
                temp_dest = temp_dest_dict.get(file_path)
                if temp_dest:
                    subject = temp_dest

            result = self.send_file_to_amb(file_path, subject, self.message_prop)
            if result:
                files_written_to_dest.append(file_path)
        return files_written_to_dest

    def open_amb_reader_channel(self, channel, msg_file_path, msg_file_name, msg_subject_lst, temp_file_path, mode):
        """ Iniialize AMB reader channels """
        message_rcv = None
        try:
            message_rcv = amb.mb_queue_init_reader(channel, event_cb_reader,
                                                   (
                                                   msg_file_path, msg_file_name, msg_subject_lst, temp_file_path, mode))
            self.reader = message_rcv
            logger.DEBUG('Initialized channel : {}'.format(channel))
            # amb.mb_poll()
        except Exception as e:
            if str(e) == 'Not Connected':
                amb_detail = self.split_amb_details()
                if amb_detail[1] and amb_detail[0]:
                    logger.DEBUG("AMB not connected, Connecting again {}".format(amb_detail[0] + '/' +amb_detail[1]))
                elif amb_detail[0]:  
                    logger.DEBUG("AMB not connected, Connecting again {}".format(amb_detail[0]))
                    
                self.is_connected = self.init_amb_connection()
                if self.is_connected:
                    message_rcv = self.open_amb_reader_channel(channel, msg_file_path, msg_file_name, msg_subject_lst,
                                                               temp_file_path, mode)
            else:
                error_message = "Error while initializing reader, Check if you have channel " \
                                "<{0}> in db : {1}".format(channel, str(e))
                logger.ERROR(error_message)

        return message_rcv

    def subscribe_receive_msg_subject(self, reader, subject_lst):
        """ subscribe to a AMB subject """
        amb_msg_subscribed = False
        if reader:
            try:
                for subject in subject_lst:
                    amb.mb_queue_enable(reader, subject)
                    logger.INFO('Subscribed to AMB message subject : {}'.format(subject))
                    amb.mb_poll()
                amb_msg_subscribed = True
            except Exception as e:
                logger.ERROR(str(e))
                amb_msg_subscribed = False
        else:
            w_msg = "AMB message subject is not provided"
            logger.WARN(w_msg)

        return amb_msg_subscribed

    def open_amb_writer_channel(self, channel):
        """ Initialize AMB writer """
        self.writer = 0
        try:
            self.writer = amb.mb_queue_init_writer \
                (channel, event_cb_writer, None)
            logger.DEBUG('Initialized writer channel : {}'.format(channel))
        except Exception as e:
            if str(e) == 'Not Connected':
                amb_details = self.split_amb_details()
                if amb_details[1] and amb_details[0]:
                    logger.DEBUG("AMB not connected, Connecting again {}".format(amb_details[0] + '/' +amb_details[1]))
                elif amb_details[0]:  
                    logger.DEBUG("AMB not connected, Connecting again {}".format(amb_details[0]))
                self.is_connected = self.init_amb_connection()
                if self.is_connected:
                    self.writer = self.open_amb_writer_channel(channel)
            else:
                error_message = "Error while initializing writer, Check if you have channel " \
                                "<{0}> in db : {1}".format(channel, str(e))
                logger.ERROR(error_message)
        return self.writer

    def create_amb_buffer(self, message, writer, subject):
        """creates buffer for messages"""
        if not message:
            logger.ERROR("Message is empty, check if AMB message is formed properly")
            return 0

        message_str = message.mbf_object_to_string()
        message = FFTPLibHooks.fftplibrary_import_exit(self.read_mode, self.write_mode, message_str, message)

        if message and isinstance(message, str):
            buf = amb.mbf_create_buffer_from_data(str(message_str))
            message = buf.mbf_read()

        if message:
            try:
                logger.DEBUG("Message writer: {}".format(writer))
                logger.DEBUG("Message Subject: {}".format(subject))
                # logger.DEBUG("Write message to AMB buffer: \n %s" %message)
                amb_buffer = amb.mbf_create_buffer()
                message.mbf_generate(amb_buffer)
                amb.mb_queue_write(writer, subject, \
                                   amb_buffer.mbf_get_buffer_data(), \
                                   amb_buffer.mbf_get_buffer_data_size(), 'ok')
                return 1
            except Exception as e:
                if str(e) == 'Not Connected':
                    error_message = "mbf_create_buffer failed: Not connected to AMB"
                    logger.ERROR(error_message)
                    self.is_connected = False
                    return 0
                else:
                    error_message = "Error encountered while processing AMB buffer: {}".format(str(e))
                    logger.ERROR(error_message)
                    self.is_connected = False
                    return 0

    def send_messages_to_amb(self, amb_message, writer, subject):
        """This method creates an AMB buffer and writes the message to
        the AMB buffer

        """
        res = 0
        try:
            if amb_message and writer > 0:
                res = self.create_amb_buffer(amb_message, writer, subject)
                if res:
                    logger.DEBUG("Successfully sent message to AMB")
        except Exception as ex:
            res = 0
            logger.ERROR("Error while sending message to AMB : {}".format(str(ex)))

        return res

    def send_file_to_amb(self, file_path, subject, msg_properties):
        """ Send file to AMB """
        try:
            file_sent = 0
            file_name = os.path.split(file_path)[-1]
            file_content = ''
            if file_path:
                with open(file_path, 'r') as f:
                    file_content = f.read()
                    f.close()
            if file_content:
                file_content = FFTPLibHooks.fftplibrary_import_entry(self.read_mode, self.write_mode, file_content)
                if file_content and isinstance(file_content, str):
                    amb_message = self.create_amb_message(file_content, subject, msg_properties)
                    if amb_message:
                        subject = subject.split(':')[0]
                        file_sent = self.send_messages_to_amb(amb_message, self.writer, subject)
                        if file_sent:
                            logger.INFO("Successfully sent message to AMB for file {}".format(file_name))
                else:
                    logger.ERROR("fftplibrary_import_entry does not return amb message as string")
            else:
                logger.ERROR("File {} has no contents hence ignoring the operation!".format(file_name))
        except Exception as ex:
            logger.ERROR("Error : {}".format(str(ex)))
        return file_sent

    def create_amb_message(self, amb_message, subject_str, msg_properties):
        """ Create amb message """
        mtype = 'INSERT_FTP_MESSAGE'
        mversion = '1.1'
        mtime = str(acm.Time.TimeNow())
        msource = 'FFTPLibrary'
        mtag = 'FTP_MESSAGE'
        mfield = 'MESSAGE_CONTENT'

        if msg_properties and type(msg_properties) == type({}):
            source_dict = msg_properties.get(subject_str, {})
            for key, val in list(source_dict.items()):
                if key.upper() == 'TYPE':
                    mtype = val
                elif key.upper() == 'VERSION':
                    mversion = val
                elif key.upper() == 'SOURCE':
                    msource = val
                elif key.upper() == 'MESSAGE_TAG':
                    mtag = val
                elif key.upper() == 'FILE_DATA_TAG':
                    mfield = val
        message = amb.mbf_start_message(None, mtype, mversion, mtime, msource)
        mb_msg = message.mbf_start_list(mtag)
        mb_msg.mbf_add_string(mfield, amb_message)
        mb_msg.mbf_end_list()
        message.mbf_end_message()
        return message

    def close_connection(self):
        """ Close AMB connection """
        try:
            pass
            #amb.mb_close()
        except Exception as ex:
            logger.ERROR("Error while closing AMB connection: {}".format(str(ex)))


def validate_file_name(file_name):
    """ Validate file name """
    valid_file_name = ''
    for char_i in file_name:
        if char_i in ['/', '\\']:
            char_i = '_'
        elif char_i in ['<', '>', ':', '"', '|', '?', '*']:
            char_i = ''
        valid_file_name += char_i
    if file_name != valid_file_name:
        logger.ERROR("File name:{} is not valid, replacing with file name:{}".format(file_name, valid_file_name))
    return valid_file_name


def read_from_amb(app_name, subject_list, file_path, file_name='', connstr='', channel=''):
    """ API to read data from AMB
    Input:
    subject_list : Mandatory. Subject of the AMB message to read. It can be a string and list
    file_path : Mandatory. Directory path to store the AMB message. It can be a string and list
    file_name : Optional. Name of file to store the AMB message in directory.
    connstr : Mandatory. AMB host:port 
    channel : AMB receiver channel name
    app_name : Mandatory application_name 

    """

    amb_obj = AMBOperations(connstr, app_name)
    subject_list = FFTPConfig.string_as_list(subject_list)
    file_path = FFTPConfig.string_as_list(file_path)
    reader = amb_obj.open_amb_reader_channel(channel, file_path, file_name, subject_list, None, None)
    amb_obj.subscribe_receive_msg_subject(reader, subject_list)
    amb_obj.close_connection()


def write_to_amb(app_name, file_path, subject, connstr, channel='', msg_properties={}):
    """ API to write data to AMB
    Input:
    file_path : Mandatory. Directory path to read the AMB message from. It can be a string and list
    subject : Mandatory. Subject of the AMB message to read. It can be a string and list
    connstr : Mandatory. AMB host:port and application_name
    file_name : Optional. Name of file to store the AMB message in directory.
    channel : AMB receiver channel name
    msg_properties : Optional.
    app_name : Mandatory application_name 

    """
    file_path = FFTPConfig.string_as_list(file_path)
    subject = FFTPConfig.string_as_list(subject)
    amb_obj = AMBOperations(connstr, app_name)
    writer = amb_obj.open_amb_writer_channel(channel)
    dest = ''
    source_dict = {}
    if len(subject) == 1:
        dest = subject[0]
    elif len(subject) == len(file_path):
        source_dict = dict(list(zip(file_path, subject)))
    else:
        logger.ERROR("Invalid file_path / subject pass to method.")
        return

    for source in file_path:
        if source_dict:
            dest = source_dict.get(source, '')
        for files in os.listdir(source):
            file_to_open = source + '/' + files
            file_sent = amb_obj.send_file_to_amb(file_to_open, dest, msg_properties)
            logger.DEBUG("File sent to AMB")
    amb_obj.close_connection()




...

  FFTPATSOperations
"""--------------------------------------------------------------------
MODULE
    FTPATSOperations -  This is a continuous ATS uploading/downloading file
                        over FTP which can be defined for either of modes
                        as given below.
                        1.Listen to a subject on the AMB and send the
                          message as a file over FTP.

                        2.Subscribe to the contents of a directory and send
                          every new file to a FTP directory at the Customer
                          site. The sent file will be archived.

                        3.Poll an FTP directory at the Customer site at
                          intervals, receiving the contents there to a local
                          (in the hosted environment) directory.

                        4.Poll a FTP directory at the Customer site at intervals,
                          receiving the contents and submitting each file as a
                          message on the AMB.

DESCRIPTION
    This script creates configurable
    variables from FParameters.

VERSION: 2.0.4

--------------------------------------------------------------------"""
import time

import FFTPConfig
import FFTPController
import FFTPNotification

mode_config_param = FFTPConfig.Parameters('FFTPModeSettings')
logger = FFTPNotification.FFTPLogger('FFTPLibrary')

controller_objs = []
mode_initialized = True

system_config_param = FFTPConfig.Parameters('FFTPSystemSettings')
time_interval = getattr(system_config_param, 'TIME_INTERVAL', '')


valid_modes = ['AMB-DIR', 'AMB-FTP', 'AMB-SFTP', 'AMB-AMB', 'DIR-DIR', 'DIR-AMB', 'DIR-FTP', 'DIR-SFTP', 'FTP-FTP', 'FTP-AMB', 'FTP-DIR', \
                'FTP-SFTP', 'SFTP-SFTP', 'SFTP-AMB', 'SFTP-FTP', 'SFTP-DIR']
def start():
    """ ATS start """
    global controller_objs
    read_write_mode = getattr(mode_config_param, 'MODE', '')
    if not read_write_mode:
        logger.ERROR("No mode specified at FFTPModeSettings. Please specify modes from {}".format(valid_modes))
        return

    mode_lst = FFTPConfig.string_as_list(read_write_mode)
    for each_mode in mode_lst:
        if each_mode not in valid_modes:
            logger.ERROR("Invalid mode {0} specified at FFTPModeSettings. Please specify valid modes from {1}".format(each_mode, valid_modes))
            return
        parameters_stream_name = 'FFTPModeSettings_' + each_mode
        controller_obj = FFTPController.FTPController(each_mode)
        if controller_obj and controller_obj.is_initialized:
            controller_objs.append(controller_obj)


def stop():
    """ ATS stop """
    global controller_objs
    
    for controller_obj in controller_objs:
        try:
            controller_obj.close_connection()
        except Exception as ex:
            logger.ERROR("Error while closing mode's connection : {}".format(str(ex)))

def work():
    """ ATS wrok """
    global controller_objs
    if controller_objs:
        for controller_obj in controller_objs:
            try:
                controller_obj.main()
                logger.INFO("*"*80)
            except Exception as ex:
                logger.ERROR("Error while performing read/write mode operations : {}".format(str(ex)))
        logger.INFO("Check for file(s)/AMB Message(s) at interval of : {}".format(str(time_interval)))
        time.sleep(float(time_interval))






...

  FFTPConfig
"""--------------------------------------------------------------------
MODULE
    FTPConfig - creates config data dictonary.

DESCRIPTION
    This script creates configurable 
    variables from FParameters.

VERSION: 2.0.4

--------------------------------------------------------------------"""
import acm
import FLogger

#logger = FLogger.FLogger("FFTPLibrary", level=2, keep=True, logOnce=True, \
#                                logToConsole=False, logToPrime=True, )
                                
class Singleton(object):

    """Singleton design pattern to avoid the use of global variables.
    
    """
    _instance = None
    

    def __new__(cls, *args, **kwargs):
        if not cls._instance:
            cls._instance = super(Singleton, cls).__new__(cls)
        return cls._instance


class FTPConfigSingleton(Singleton):
    
    def __init__(self, module, user=None, *args):
    
        """used to initialize the configuration variables either from 
        dictionaries, lists, tuples sent as arguments
        """
        self.__config_data = {}
        
        if module:
            self.read_config_parameters(module, user)
            
    def add_user_to_config_data(self, user):
        if self.__config_data:
            self.__config_data['USER'] = acm.UserName()
            
    def read_config_parameters(self, module, user=None):
        if module:
            self.get_config_params_from_std_module(module)
            self.get_config_params_from_customize_module(module)
            if user:
                self.add_user_to_config_data(user)
                
            read_write_data_dic = self._add_read_write_source_in_config('READ_WRITE_SOURCE')
            if read_write_data_dic:
                self.__config_data.update(read_write_data_dic)
                
            self.normalize_config_data()
            
    def get_config_params_from_std_module(self, module):
        ext_module = acm.FExtensionModule[module]
        if ext_module:
            # Read all PFarameters from specific module
            extensions_list = ext_module.GetAllExtensions('FParameters')
            if extensions_list:
                for a_extension in extensions_list:
                    fftplib_params = self._get_param_dict_from_extension(a_extension)
                    self.__config_data.update(fftplib_params) 
                
        
    def get_config_params_from_customize_module(self, module):
        custom_params_dict = {}
        context = acm.GetDefaultContext()
        ext_module = acm.FExtensionModule[module]
        if ext_module:
            # Read all PFarameters from specific module
            extensions_list = ext_module.GetAllExtensions('FParameters')
            if extensions_list:
                # Check if same FParameter is customized in other module
                for a_extension in extensions_list:
                    merged_extension = context.GetExtension("FParameters", "FObject", a_extension.Name())
                    if merged_extension:
                        merged_extension_module = context.GetModulesImplementing("FParameters", "FExtension", a_extension.Name())
                        if merged_extension_module and merged_extension_module[0].Name() != module:
                                                        
                            ext_module = acm.FExtensionModule[merged_extension_module[0].Name()]
                            if ext_module:
                                extension = ext_module.GetExtension('FParameters', \
                                    'FObject', merged_extension.Name())
                                custom_params_dict = self._get_param_dict_from_extension(extension)

                    if custom_params_dict:
                        self.__config_data.update(custom_params_dict)
                                
    def _get_param_dict_from_extension(self, extension):
        config_keys = []
        config_vals = []
        ext_params_dict = {}
        bool_vals = ['True', 'False']
        for key in extension.Value().Keys():
            config_keys.append(str(key))
            
        for vals in extension.Value().Values():
            val = str(vals).split('  ')[0]
            if val in bool_vals:
                config_vals.append(eval(val))
            else:
                config_vals.append(str(val))
        if config_keys and config_vals:
            ext_params_dict = dict(list(zip(config_keys, config_vals)))
        return ext_params_dict
        
                        
    def _add_read_write_source_in_config(self, param):
        '''
        Get the value of source, archive and destination 
        from FParameter READ_WRITE_SOURCE. 
        '''
        read_write_data_dic = {'SOURCE' : [], 'ARCHIVE' : [], 'DESTINATION' : []}
        read_write_source = {}
        try:
            read_write_source = self.__config_data.get(param, [])
            read_write_source = eval(read_write_source)
        except :
            pass
            
            
            
        if read_write_source and type(read_write_source) == type([]):
            for each_tpl in read_write_source:
                
                if each_tpl and len(each_tpl) == 3:
                    read_write_data_dic.get('SOURCE', []).append(each_tpl[0])
                    read_write_data_dic.get('ARCHIVE', []).append(each_tpl[1])
                    read_write_data_dic.get('DESTINATION', []).append(each_tpl[2])
                else:
                    read_write_source.remove(each_tpl)
                    #logger.WLOG("FParameter <READ_WRITE_SOURCE> not has valid tuple : %s" %str(each_tpl))  
            self.__config_data[param] = read_write_source
        return read_write_data_dic
        
    def normalize_config_data(self):
        if self.__config_data:
            if self.__config_data:                
                for key in self.__config_data:
                    value = self.__config_data[key]            
                    try :
                        value = eval(value)                            
                    except:
                        value = value
                            
                    self.__config_data[key] = value
                                        
    @property
    def config_data(self):
        """I'm the '__config_data' property."""
        return self.__config_data
        

def string_as_list(strng):
    lst = []
    if type(strng) == type(''):
        try:
            result = eval(strng)
            if type(result)==type([]):
                lst = result
            elif result:
                lst.append(str(result))
        except Exception:
            strng_split = strng.split(',')
            for data in strng_split:
                lst.append(data.strip())
    elif type(strng) == type([]):
        lst = strng
    return lst

class Parameters(object):
    """ Class to read FParameters"""
    def __init__(self, *names):
        try:
            self.param_name_list = []
            self.get_data(*names)
        except Exception as error:
            raise error
            #Not sure where we are using this , hence skipping it for now
            #self.get_local_data(*names)

    def get_data(self, *names):
        """ Read the FParameters from the Extension Manager"""
        for fparam in names:
            ext_context = acm.FExtensionContext[acm.GetDefaultContext().Name()]
            param_object = ext_context.GetExtension('FParameters',
                                                    'FObject', fparam)
            try:
                template = param_object.Value()
            except AttributeError as error:
                if not param_object:
                    raise Exception("FParameter %s not present" % fparam)
                else:
                    raise Exception("Unable to get content of FParameter %s. Exception : %s" % (fparam, error))

            for k in template.Keys():  #First set all the parameters
                param_name = str(k)
                attribute_name = str(template.At(k)).split('#')[0].strip()
                setattr(self, param_name, attribute_name)
                self.param_name_list.append(param_name)

            '''for k in template.Keys():  #Now override the value of old over new
                param_name = str(k)
                param_name_supp = self.suppress_deprecated_attribute(fparam, param_name)
                if param_name_supp != param_name:
                    attribute_name = str(template.At(k)).split('#')[0].strip()
                    setattr(self, param_name_supp, attribute_name)'''
            self.module_name = param_object.Module().Name()

    def get_local_data(self, *names):
        """ Read the FParameters from the Extension Manager"""
        for fparam in names:
            import os
            file_name = os.path.join('Parameters', fparam + '.py')
            try :
                with open(file_name) as file_handle:
                    for line in file_handle:
                        param_value = line.split('#')[0].strip()
                        lhs, rhs = param_value.split('=')
                        setattr(self, lhs, rhs)
            except Exception as e:
                pass

    def get_param_name_list(self):
        """ return parameters list """
        return self.param_name_list





...

  FFTPController
"""--------------------------------------------------------------------
MODULE
FTPController - This is a continuous ATS uploading/downloading file
                over FTP which can be defined for either of modes
                as given below.
                1.Listen to a subject on the AMB and send the
                message as a file over FTP.

                2.Subscribe to the contents of a directory and send
                every new file to a FTP directory at the Customer
                site. The sent file will be archived.

                3.Poll an FTP directory at the Customer site at
                intervals, receiving the contents there to a local
                (in the hosted environment) directory.

                4.Poll a FTP directory at the Customer site at
                intervals, receiving the contents and submitting
                each file as a message on the AMB.

VERSION: 2.0.4

--------------------------------------------------------------------"""
import os
import ntpath

import FFTPNotification
import FFTPConfig

from FFTPAMBOperations import AMBOperations
from FFTPOperations import FTPOperations
from FSFTPOperations import SFTPOperations
from FFTPDIROperations import DIROperations
from datetime import datetime

logger = FFTPNotification.FFTPLogger('FFTPLibrary')

config_variables_obj = FFTPConfig.FTPConfigSingleton('FFTPLibrary')
config_data = config_variables_obj.config_data
class FTPController(object):
    """ Controller class to invoke read and write operations for different modes """
    def __init__(self, mode, task_params=None):
        self.read_obj = None
        self.write_obj = None
        self.read_mode = None
        self.write_mode = None
        self.mode = mode
        self.is_initialized = True
        self.mode = mode
        self.transactiondict = None

        if self.mode:
            config_variables_obj.config_data['TEMP_{}'.format(self.mode)] = {}
            mode_split = self.mode.split('-')
            if mode_split and len(mode_split) > 1:
                self.read_mode = mode_split[0]
                self.write_mode = mode_split[1]
                config_data['FROM_MODE'] = self.read_mode
                config_data['TO_MODE'] = self.write_mode

        self.transaction_log_filename = '\Transactionlog_%s.txt' %(self.read_mode)
        self.transaction_log_filename_path = None
        if self.mode.startswith('FTP'):
            ftp_config_param = FFTPConfig.Parameters('FFTPSettings')
            self.ftp_log_file_path = getattr(ftp_config_param, 'FTP_TRANSACTION_LOG_PATH', None)
            if self.ftp_log_file_path:
                self.transaction_log_filename_path = self.ftp_log_file_path + self.transaction_log_filename
                self.transactiondict = self.read_from_transactionlog_file(self.transaction_log_filename_path)
            else:
                logger.ERROR("No path specified in FFTPModeSettings for FParameter <FTP_TRANSACTION_LOG_PATH>, transaction log functinoality wont work!")

        mode_config_param = 'FFTPModeSettings_' + self.mode
        if task_params:
            self.task_params = task_params
            self.read_source = task_params.get('READ_SOURCE', '')
            self.write_source = task_params.get('WRITE_SOURCE', '')
            self.archive_file_path = task_params.get('ARCHIVE_PATH', '')
            self.temp_file_path = task_params.get('TEMP_FILE_PATH', '')
        else:
            mode_config_param = FFTPConfig.Parameters('FFTPModeSettings_' + self.mode)
            read_source = getattr(mode_config_param, 'READ_SOURCE', None)
            write_source = getattr(mode_config_param, 'WRITE_SOURCE', None)
            self.read_source = FFTPConfig.string_as_list(read_source)
            self.write_source = FFTPConfig.string_as_list(write_source)
            self.archive_file_path = getattr(mode_config_param, 'ARCHIVE_PATH', '')
            self.temp_file_path = getattr(mode_config_param, 'TEMP_FILE_PATH', '')

        ftp_params = FFTPConfig.Parameters('FFTPSettings')
        systemsettings_param = FFTPConfig.Parameters('FFTPSystemSettings')
        self.no_timestamp = getattr(systemsettings_param, 'DONOT_TIMESTAMP_ARCHIVE_FILES', '')
        

        if not self.read_mode or not self.write_mode:
            logger.ERROR("Read mode: %s or Write mode: %s not configured properly" %(self.read_mode, self.write_mode))
            self.is_initialized = False
        elif len(self.write_source) > 1 and (len(self.write_source) != len(self.read_source)):
            logger.ERROR("Read Source <%s> or Write Source <%s> not configured properly for mode <%s>" %(self.read_source, self.write_source, self.mode))
            self.is_initialized = False
        else:
            try:
                logger.INFO("Initializing the mode {} connection(s)".format(self.mode))
                read_class = str(self.read_mode) + \
                'Operations.initialize(self.mode, reader = True, task_parameters={0}, config_variables_obj=config_variables_obj)'.format(task_params)
                write_class = str(self.write_mode) + \
                'Operations.initialize(self.mode, reader = False, task_parameters={0}, config_variables_obj=config_variables_obj)'.format(task_params)

                self.read_obj = eval(read_class)
                self.write_obj = eval(write_class)
            except Exception as ex:
                logger.ERROR("ERROR while initializing reader or writer mode: %s" % str(ex))

        self.dir_obj = DIROperations(self.no_timestamp)
        if not self.read_obj or not self.write_obj:
            self.is_initialized = False

    def main(self):
        """ Controller main to invoke read and write operations """
        logger.INFO("                 Running mode {}                 ".format(self.mode))
        logger.INFO("="*80)
        files_written_to_dest = []
        file_path_list = []

        success = 0
        destination = ''
        if self.write_source:
            destination = self.write_source[0]

        # Retry the amb connection as for AMB
        if self.read_obj and self.write_obj:
            if self.write_mode == 'AMB' and not self.write_obj.is_connected:
                logger.DEBUG("Write AMB connection has failed, retrying the connection")
                write_obj = AMBOperations.initialize(self.mode, reader=False)
                if write_obj:
                    self.write_obj = write_obj
                else:
                    logger.ERROR("Write AMB connection retry has failed")
            if self.read_mode == 'AMB' and not self.read_obj.is_connected:
                logger.DEBUG("Read AMB connection has failed, retrying the connection")
                read_obj = AMBOperations.initialize(self.mode, reader=True)
                if read_obj:
                    self.read_obj = read_obj
                else:
                    logger.ERROR("Read AMB connection retry has failed")
        else:
            logger.ERROR("Cannot proceed with mode: {} as the read and write mode are not initialized".format(self.mode))
            return 0

        if self.read_obj and self.write_obj:
            not_exists = 0
            if self.read_mode == 'DIR':
                for source in self.read_source:
                    dir_path, filter = ntpath.split(os.path.expandvars(source))
                    if os.path.isdir(dir_path):
                        logger.DEBUG("Source directory <%s> exist"%dir_path)
                    else:
                        logger.ERROR("Source directory <%s> does not exist"%dir_path)
                        not_exists = 1
            if self.write_mode == 'DIR':
                for source in self.write_source:
                    if os.path.isdir(source):
                        logger.DEBUG("Destination directory <%s> exist"%source)
                    else:
                        logger.ERROR("Destination directory <%s> does not exist"%source)
                        not_exists = 1
            if not_exists:
                return 0

            source_dict = {}
            for source in self.read_source:
                if len(self.write_source) > 1 and (len(self.read_source) == len(self.write_source)):
                    source_dict = dict(list(zip(self.read_source, self.write_source)))
                    destination = source_dict[source]
                elif not destination:
                    logger.ERROR("Destination directory doesnt exist")

                if self.write_mode == 'DIR':
                    # Set the source path to read and filter
                    if self.read_mode in ['FTP', 'DIR', 'SFTP']:
                        dir_path, filter = ntpath.split(os.path.expandvars(source))
                    else:
                        filter = None
                        dir_path = source

                    # Read files/message from the source
                    # for cases like FTP/SFTP/AMB when write mode is DIR, files/messages downloaded
                    # to destination directory in read operation only , no needd to call write
                    if self.read_mode == 'FTP' :
                        success, file_path_list = self.read_transaction_log(dir_path, destination, filter)
                    else:
                        file_path_list = self.read_obj.read(dir_path, destination, [filter])
                        if file_path_list:
                            success = 1
                else:
                    #When the write mode is other than DIR, files/messages downloaded to temp directory

                    # Set the source path to read and filter
                    if self.read_mode in ['FTP', 'DIR', 'SFTP']:
                        dir_path, filter = ntpath.split(os.path.expandvars(source))
                    else:
                        filter = None
                        dir_path = source

                    # Read files/message from the source
                    if self.read_mode == 'FTP':
                        success, file_path_list = self.read_transaction_log(dir_path, self.temp_file_path, filter)
                    else:
                        file_path_list = self.read_obj.read(dir_path, self.temp_file_path, [filter])
                        if file_path_list:
                            success = 1

                #Writes the downloaded file from source to destination
                # for mode with no DIR, Writes files from temp to destination
                # for mode with DIR, write return the downloaded files
                if file_path_list:  # If files available from read mode to write
                    if self.mode != 'AMB-DIR':
                        temp_mode_dict = config_data['TEMP_{}'.format(self.mode)]
                        files_written_to_dest = self.write_obj.write(file_path_list, destination, temp_mode_dict)
                        if self.read_mode == 'FTP':
                            for file in files_written_to_dest:
                                destination_dir, filename = os.path.split(file)
                                if self.file_details_dict:
                                    for fullfile_name in self.file_details_dict.keys():
                                        destination_dir, file = os.path.split(fullfile_name)
                                        if file == filename:
                                            self.write_to_transactiondict(fullfile_name, self.file_details_dict[fullfile_name][0], str(self.read_obj.utc_to_local(self.file_details_dict[fullfile_name][1])))

                if files_written_to_dest:
                    success = 1

                # Remove temp files
                if self.read_mode != 'DIR' and self.write_mode != 'DIR':
                    self.dir_obj.remove_files(file_path_list)

                # Archive files in case of reading from DIR/remote DIR
                if self.archive_file_path:
                    self.dir_obj.archive_files(files_written_to_dest, self.archive_file_path)
            config_data['TEMP_{}'.format(self.mode)] = {}
        else:
            logger.ERROR("Cannot proceed with mode: {} as the read and write mode are not initialized".format(self.mode))
        return success

    def close_connection(self):
        """ Close connection """
        if self.read_obj:
            self.read_obj.close_connection()
        if self.write_obj:
            self.write_obj.close_connection()
        if self.mode.startswith('FTP'):
            self.transactionlog_write_from_list_to_file()

    def read_from_transactionlog_file(self, full_filepath):
        """ Read from transaction log file """
        transaction_dict = {}
        filepath, filename = os.path.split(full_filepath)

        if os.path.exists(filepath):
            if os.path.isfile(full_filepath):
                with open(full_filepath, "r") as filehandler:
                    transaction_list = filehandler.readlines()
                    transaction_dict = self.create_transactiondict(transaction_list)
        else:
            logger.ERROR("<FTP_TRANSACTION_LOG_PATH=%s> does not exist"%(filepath))
        return transaction_dict


    def transactionlog_write_from_list_to_file(self):
        """ Write to transaction log file """
        if self.ftp_log_file_path:
            file_handler = open(self.transaction_log_filename_path, "w")
            if self.transactiondict:
                transaction_log_list = self.create_list_from_transactiondict(self.transactiondict)
                with open(self.transaction_log_filename_path, 'w') as file_handler:
                    for list_item in transaction_log_list:
                        file_handler.write("{}\n".format(list_item.strip("r\n")))


    def check_if_file_already_read(self, filename, dir_path):
        """ Check if file timestamp is equal to timestamp from log """
        already_read_flag = False
        file_details_dict = {}
        timestamp = self.read_obj.get_file_modified_timestamp(filename)
        if timestamp:
            file_details_dict = {filename: [self.mode, timestamp]}

        filename = os.path.join(dir_path, filename)
        if self.transactiondict and timestamp:
            if filename in self.transactiondict:
                if self.mode in list(self.transactiondict[filename].keys()):
                    timestamp_in_log = self.transactiondict[filename][self.mode]
                    timestamp_in_log_to_utc = self.read_obj.local_to_utc(timestamp_in_log.strip())
                    formatted_timestamp_in_log = datetime.strptime(timestamp_in_log_to_utc, "%Y-%m-%d %H:%M:%S")
                    formatted_timestamp = datetime.strptime(timestamp, '%Y%m%d%H%M%S')
                    if str(formatted_timestamp) <= str(formatted_timestamp_in_log):
                        logger.DEBUG("The file <%s> has not been modified since it was last read <%s>"%(filename, timestamp_in_log.strip("r\n")))
                        already_read_flag = True
        return already_read_flag, file_details_dict

    def check_if_file_exists_on_ftp(self, file_filter, destination_dir):
        """ Checks if file is available on ftp server """
        ftp_dir_set = 0
        file_list = []
        if self.read_obj.ftp:
            if destination_dir:
                try:
                    ftp_dir_set  = self.read_obj.change_ftp_dir(destination_dir)
                    for file_name in file_filter:
                        file_list = self.read_obj.poll_for_file(file_name)
                    if ftp_dir_set:
                        self.read_obj.change_ftp_dir('/')
                except Exception as ex:
                    logger.ERROR("Error while checking file exist on FTP path {0} : {1}".format(destination_dir, str(ex)))
        return file_list


    def retrieve_timestamp(self, filename, destination_dir):
        """ Retrieves timestamp for given file """
        ftp_dir_set = 0
        ftp_obj = self.read_obj.ftp
        if ftp_obj:
            if destination_dir:
                ftp_dir_set = self.read_obj.change_ftp_dir(destination_dir)
                timestamp = self.read_obj.get_file_modified_timestamp(filename)
                timestamp = str(self.read_obj.utc_to_local(timestamp))
                if ftp_dir_set:
                    self.read_obj.change_ftp_dir('/')
        return timestamp


    def create_transactiondict(self, simplified_list):
        """ Creates a nested dict with filename, mode, timestamp retrieved from list after reading file """
        transaction_log_dict = {}
        for each in simplified_list:
            split_list = each.split(' ')
            date_time = split_list[2] + " " + split_list[3]
            list_element = {split_list[0]:{split_list[1]:date_time}}
            if transaction_log_dict:
                if split_list[0] in list(transaction_log_dict.keys()):
                    transaction_log_dict[split_list[0]][split_list[1]] = date_time
                else:
                    transaction_log_dict[split_list[0]] = {split_list[1]:date_time}
            else:
                transaction_log_dict.update(list_element)
        return transaction_log_dict


    def create_list_from_transactiondict(self, transactiondict):
        """ Creates a list from the nested transaction dict : {Filename:{Mode:Timestamp}}"""
        transactionlist = []
        for key in list(transactiondict.keys()):
            for innerdict_key in list(transactiondict[key].keys()):
                transactionlist.append((" ").join((key, innerdict_key, transactiondict[key][innerdict_key])))
        return transactionlist


    def write_to_transactiondict(self, filename, mode, current_timestamp):
        """ Perform operations like search, update and append to nested transaction dict """

        timestamp_in_list = self.search_in_transactiondict(filename, mode)
        if timestamp_in_list:
            transactiondict = self.compare_and_update_in_transactiondict(filename, mode, current_timestamp)
        else:
            transactiondict = self.append_to_transactiondict(filename, mode, current_timestamp)
        return transactiondict


    def search_in_transactiondict(self, filename, mode):
        """ Search in transaction dict file with a given mode and return timestamp """
        if self.transactiondict:
            if filename in list(self.transactiondict.keys()):
                if mode in list(self.transactiondict[filename].keys()):
                    return self.transactiondict[filename][mode]


    def compare_and_update_in_transactiondict(self, filename, mode, file_timestamp):
        """ Update dict if given file_timestamp is greater than filestamp for given filename and mode in transaction dict"""
        if self.transactiondict:
            timestamp_in_dict = self.transactiondict[filename][mode]
            if file_timestamp > timestamp_in_dict:
                self.transactiondict[filename][mode] = file_timestamp
            return self.transactiondict


    def append_to_transactiondict(self, filename, mode, timestamp):
        """ Append to existing transaction dict given filename, mode, timestamp"""

        file_entry_exists = False
        if self.transactiondict:
            if filename in list(self.transactiondict.keys()):
                file_entry_exists = True
                self.transactiondict[filename][mode] = timestamp
            if not file_entry_exists:

                self.transactiondict[filename] = {mode:timestamp}
        else:

            self.transactiondict = {filename:{mode:timestamp}}
        return self.transactiondict

    def read_transaction_log(self, dir_path, destination, filter):
        """ Read from transaction log , check if file was read, read process"""
        success = 0
        file_path_list = []
        file_list = self.check_if_file_exists_on_ftp([filter], dir_path)
        self.file_details_dict = {}
        if len(file_list) > 1:
            for file in file_list:
                if self.check_if_file_already_read(file, dir_path)[0]:
                    file_list.remove(file)
        if len(file_list) == 1:
            if self.check_if_file_already_read(file_list[0], dir_path)[0]:
                file_list = []
                success = 1
        if file_list:
            file_path_list = self.read_obj.read(dir_path, destination, file_list)

            for file in file_list:
                self.file_details_dict.update(self.check_if_file_already_read(file, dir_path)[1])

            if file_path_list:
                success = 1
        return success, file_path_list



...

  FFTPDIROperations
"""--------------------------------------------------------------------
MODULE
    FFTPDIROperations -  Operations like reading and writing to directory

DESCRIPTION
    This script handles the DIR operations.

VERSION: 2.0.4

--------------------------------------------------------------------"""
import os
import acm
import shutil
import fnmatch
import subprocess

import FFTPConfig
import FFTPLibHooks
import FFTPNotification

logger = FFTPNotification.FFTPLogger('FFTPLibrary')


class DIROperations(object):
    def __init__(self, donot_timestamp_archive_files=False, config_variables_obj=None):
        self.donot_timestamp_archive_files = donot_timestamp_archive_files
        self.config_data = config_variables_obj.config_data if config_variables_obj else {}
        self.read_mode = self.config_data.get('FROM_MODE', 'DIR')
        self.write_mode = self.config_data.get('TO_MODE', '')

    @classmethod
    def initialize(cls, mode, reader, task_parameters, config_variables_obj=None):
        # logger.INFO("Subscribed to Directory")

        system_config_param = FFTPConfig.Parameters('FFTPSystemSettings')
        donot_timestamp_archive_files = getattr(system_config_param, 'DONOT_TIMESTAMP_ARCHIVE_FILES', '')
        obj = cls(donot_timestamp_archive_files=donot_timestamp_archive_files,
                  config_variables_obj=config_variables_obj)
        return obj

    def read(self, read_dir, dest_dir, filename_list):
        """
        Read files from the directory
        """

        logger.INFO("Looking for files in the directory : '%s'" % read_dir)
        file_path_list = []
        # read files from dir
        file_list = self.get_files_from_dir(read_dir, filename_list)
        for each_file in file_list:

            file_ref, destination_path = FFTPLibHooks.fftplibrary_export_entry(self.read_mode, self.write_mode,
                                                                               each_file)
            if file_ref and type(file_ref) == str:
                each_file = file_ref
                file_path = os.path.join(read_dir, each_file)
                file_path, destination_path = FFTPLibHooks.fftplibrary_export_exit(self.read_mode, self.write_mode,
                                                                                   file_path)
            if file_path and type(file_path) == str:
                file_path_list.append(file_path)
                if destination_path:
                    self.config_data['TEMP_{}-{}'.format(self.read_mode, self.write_mode)][file_path] = destination_path

        return file_path_list

    def write(self, file_path_list, write_dir, temp_dest_dict={}):
        """ Writes file(s) to a directory"""
        read_file_path = None
        files_written_to_dest = []
        if file_path_list:
            read_file_path = os.path.dirname(file_path_list[0])
            read_file_path = self.get_mapped_network_path(read_file_path)
        if read_file_path != write_dir:
            for file_path in file_path_list:
                if temp_dest_dict:
                    temp_dest = temp_dest_dict.get(file_path)
                    if temp_dest:
                        write_dir = temp_dest
                file_path = FFTPLibHooks.fftplibrary_import_entry(self.read_mode, self.write_mode, file_path)
                if file_path and type(file_path) == str:
                    file_path = FFTPLibHooks.fftplibrary_import_exit(self.read_mode, self.write_mode, file_path)

                if file_path and type(file_path) == str:
                    try:
                        shutil.copy(file_path, write_dir)
                        files_written_to_dest.append(file_path)

                    except Exception as ex:
                        logger.ERROR("Error while copying file :%s " % ex)
        else:
            files_written_to_dest = file_path_list
        return files_written_to_dest

    def get_files_from_dir(self, file_path, file_search_exp=None):
        """Get the list of files forom the input directory"""
        logger.DEBUG("Get files from directory")
        file_lst = []
        dir_path = self.get_mapped_network_path(file_path)
        if os.path.isdir(dir_path):
            dir_file_lst = [eachfile for eachfile in os.listdir(dir_path) if \
                            os.path.isfile(os.path.join(dir_path, eachfile))]
            if file_search_exp:
                logger.DEBUG("Searching for file/s with filter %s in directory '%s'" % (file_search_exp, dir_path))
                for file_exp in file_search_exp:
                    filter_file_lst = fnmatch.filter(dir_file_lst, file_exp)
                    if filter_file_lst:
                        file_lst.extend(filter_file_lst)
                    else:
                        if os.path.isfile((os.path.join(dir_path, file_exp))):
                            file_lst.extend(file_exp)
            else:
                file_lst = dir_file_lst
            if file_lst:
                logger.DEBUG("Found file/s %s" % file_lst)
            else:
                logger.ERROR("No matching files with filter %s found in '%s' directory" % (file_search_exp, dir_path))
        else:
            logger.ERROR("No directory named '%s' found" % dir_path)
        return set(file_lst)

    def get_mapped_network_path(self, dir_path):
        """Get the remote path for the mapped directory"""
        '''
        logger.DEBUG("Checking for Mapped network path")
        network_file_path = dir_path
        mapped_drive = dir_path[:2]
        network_drives = subprocess.check_output(['net', 'use'], shell=True).decode()  # get shared drives
        for row in network_drives.split("\n")[4:]:  # check each row after formatting
            split = row.split(':')
            if len(split) == 2:  # only check non-default shared drives
                if split[0].strip() == mapped_drive[0]:
                    mapped_netword_path = split[1].strip()
                    network_file_path = network_file_path.replace(mapped_drive, mapped_netword_path)
                    logger.INFO("Mapped directory for {} is {}.".format(mapped_drive[0], mapped_netword_path))
        '''
        return dir_path

    def copy_files_to_dir(self, file_list, source_dir, dest_dir):
        """Copy files to a directory"""
        logger.DEBUG("Copy files to a directory")
        try:
            for file_name in file_list:
                src_file = os.path.join(source_dir, file_name)
                dest_file = os.path.join(dest_dir, file_name)
                shutil.copy(src_file, dest_dir)
        except Exception as ex:
            logger.ERROR("Error while copying file : %s" % ex)

    def move_files_to_dir(self, file_list, source_dir, dest_dir):
        """Move files to a directory"""
        logger.DEBUG("Move files to a directory")
        try:
            for file_name in file_list:
                afile_name = self.get_archive_file_name(file_name)
                src_file = os.path.join(source_dir, file_name)
                dest_file = os.path.join(dest_dir, afile_name)
                shutil.move(src_file, dest_file)
        except Exception as ex:
            logger.ERROR("Error while moving files to directory : %s" % ex)

    def get_archive_file_name(self, file_name):
        """Get archive file name by adding the current timestamp"""
        archive_file_name = file_name
        utc_time = acm.Time.LocalToUtc(acm.Time.TimeNow())

        if not self.donot_timestamp_archive_files:
            split_file_name, file_extn = os.path.splitext(archive_file_name)
            if file_extn:
                file_name_time_stamp = split_file_name + '_' + str(utc_time) + file_extn
            else:
                file_name_time_stamp = split_file_name + '_' + str(utc_time)

            archive_file_name = self.validate_file_name(file_name_time_stamp)
        return archive_file_name

    def validate_file_name(self, file_name):
        valid_file_name = ''
        for char_i in file_name:
            if char_i in [' ', '/', '\\']:
                char_i = '_'
            elif char_i in ['<', '>', ':', '"', '|', '?', '*', '-']:
                char_i = ''
            valid_file_name += char_i
        return valid_file_name

    def get_archive_dir(self, read_dir, archive_dir):
        """Creates the archive directory if does not exist"""
        if not os.path.dirname(archive_dir):
            archive_rel_path = os.path.relpath(archive_dir)
            archive_dir = os.path.join(read_dir, archive_rel_path)
            if not os.path.exists(archive_dir):
                try:
                    os.makedirs(archive_dir)
                except Exception as ex:
                    logger.ERROR("Error while creating archive directory %s" % ex)
        return archive_dir

    def archive_files(self, file_path_list, archive_dir):
        """Copy files to archive directory"""
        source_dir = None
        if file_path_list:
            source_dir = os.path.dirname(file_path_list[0])
        if source_dir and archive_dir:
            file_list = [os.path.split(each_file)[1] for each_file in file_path_list]
            archive_dir = self.get_archive_dir(source_dir, archive_dir)
            if os.path.exists(archive_dir):
                self.move_files_to_dir(file_list, source_dir, archive_dir)
            else:
                logger.ERROR("Archive path %s does not exist" % archive_dir)

    def remove_files(self, file_path_list):
        """Removes files from the provided directory"""
        for file_path in file_path_list:
            try:
                os.remove(file_path)
            except Exception as ex:
                logger.ERROR("%s" % ex)

    def close_connection(self):
        pass





...

  FFTPLibHooks
"""--------------------------------------------------------------------
MODULE
    FFTPLibHooks -  FFTPLibrary custom hook

DESCRIPTION
    This script defines extension point to extend the FFTPLibrary functionality.
    User should 

VERSION: 2.0.4

--------------------------------------------------------------------"""

import FFTPConfig
import FFTPNotification
logger = FFTPNotification.FFTPLogger('FFTPLibrary')

def amb_message_file_name(file_name, mb_message_str, org_mb_message_obj, file_path=''):
    """ Extension point to customize the name of file to export mb messages
    file_name = file_name as used by FFTPLibrary
    file_path = destination file path to export the amb message
    mb_message_str = message as string to export
    org_mb_message_obj = Original amb message object

    return
    file_path : customized file path
    file_name : customized file name
    """
    """
    #Example: For AMB-FTP mode , get the destination directory of FTP server from Fparameter: WRITE_SOURCE 
    #and add subdirectory to the path and return from the function
    import os
    ftp_mode_settings = FFTPConfig.Parameters('FFTPModeSettings_AMB-FTP')
    write_source = getattr(ftp_mode_settings, 'WRITE_SOURCE', None)
    file_path = os.path.join(write_source, 'SUB DIRECTORY')
    """
    return file_path, file_name


def amb_message_content(file_name, mb_message_str, org_mb_message_obj):
    """ Extension point to customize the name of file to export mb messages
    Input: file_name = file_name as used by FFTPLibrary
    mb_message_str = message as string to export
    org_mb_message_obj = Original amb message object

    """
    return mb_message_str


def fftplibrary_import_entry(from_mode, to_mode,  content_ref, content_handler=None, **kwargs):
    """
    Import entry hook to import data to modes : DIR, AMB, FTP, SFTP, before processing that data.
    :param from_mode: The mode from which the data is importing, value can be either of FTP, SFTP, AMB, DIR
    :param to_mode: The mode to which the data is importing,values can be either of FTP, SFTP, AMB, DIR
    :param content_ref: This is the data reference like amb message, FTP/SFTP file or dir file with path
    :param content_handler: This is object of the content reference like file handler, amb message obj.
    :return: Customized value of content_ref or content_handler
    """
    return content_handler if content_handler else content_ref

def fftplibrary_import_exit(from_mode, to_mode,  content_ref, content_handler=None, **kwargs):
    """
    Import exit hook to import data to modes : DIR, AMB, FTP, SFTP, after processing that data.
    :param from_mode: The mode from which the data is importing, value can be either of FTP, SFTP, AMB, DIR
    :param to_mode: The mode to which the data is importing, values can be either of FTP, SFTP, AMB, DIR
    :param content_ref: This is the data reference like amb message, FTP/SFTP file or dir file with path
    :param content_handler: This is object of the content reference like file handler, amb message obj.
    :return: Customized value of content_ref or content_handler
    """
    return content_handler if content_handler else content_ref


def fftplibrary_export_entry(from_mode, to_mode, content_ref, content_handler=None, **kwargs):
    """
    Export entry hook to export data from modes : DIR, AMB, FTP, SFTP, before processing that data.
    :param from_mode: The mode from which the data is exporting, value can be either of FTP, SFTP, AMB, DIR
    :param to_mode: The mode to which the data is exporting, values can be either of FTP, SFTP, AMB, DIR
    :param content_ref: This is the data reference like amb message, FTP/SFTP file or dir file with path
    :param content_handler: This is object of the content reference like file handler, amb message obj.
    :return: Customized value of content_ref or content_handler and
            destination path to which data need to export like FTP/SFTP dir path, local dir path and amb subject
    kwargs :  if from_mode == 'AMB' then {'msg_subject': <amb message subject>}
    """
    destination_path = ''
    """
    Example to change the destination path 
    if from_mode == 'FTP':
        if to_mode == 'DIR':
            destination_path = "C:\Projects\Destination_FTP\Temp"
    """

    """
    Example to stop reading file from FTP
    if from_mode == 'FTP':
        file_name = content_ref 
        if file_name == 'Provider_Data_Bloomberg.txt':
            content_ref = None
    """
    return content_handler if content_handler else content_ref, destination_path


def fftplibrary_export_exit(from_mode, to_mode, content_ref, content_handler=None, **kwargs):
    """
    Import entry hook to import data to modes : DIR, AMB, FTP, SFTP, after processing that data.
    :param from_mode: The mode from which the data is importing, value can be either of FTP, SFTP, AMB, DIR
    :param to_mode: The mode to which the data is importing,values can be either of FTP, SFTP, AMB, DIR
    :param content_ref: This is the data reference like amb message, FTP/SFTP file or dir file with path
    :param content_handler: This is object of the content reference like file handler, amb message obj.
    :return: Customized value of content_ref or content_handler and
            destination path to which data need to export like FTP/SFTP dir path, local dir path and amb subject
    kwargs :  if from_mode == 'AMB' then {'msg_subject': <amb message subject>}
    """
    destination_path = ''
    return content_handler if content_handler else content_ref, destination_path




...

  FFTPLibraryInstalledComponent
'''---------------------------------------------------------------------------------
 MODULE
    InstalledComponentFFTPLibrary

DESCRIPTION
    This module runs the TestMe, ConfigMe and LogMe for installed FFTPLibrary

VERSION: 2.0.4

---------------------------------------------------------------------------------'''
import InstalledComponentBase
import FFTPConfig

config_variables_obj = FFTPConfig.FTPConfigSingleton('FFTPLibrary')
config_data = config_variables_obj.config_data

class Diagnostics(InstalledComponentBase.InstalledComponentDiagnostics):
    def __init__(self):
        super(Diagnostics, self).__init__()
        self._name = 'FFTPLibrary'
        self._version = config_data.get('FFTPLIBRARY_VERSION', '').split('-')[0]
        self._moduleList = ['FANotification']
        self._moduleVersions = {}
        self._description = "FFTPLibrary transfers files/amb messages between local directory, AMB, FTP and SFTP"
        self._releaseDate = config_data.get('FFTPLIBRARY_BUILD_DATE', '')
        self._isBuiltInModule = 'No'

...

  FFTPNotification
"""--------------------------------------------------------------------
MODULE
    FFTPNotification -  Creates FANotification class object for logging

VERSION: 2.0.4

--------------------------------------------------------------------"""
import acm
import FFTPConfig
import FANotification

config_obj = FFTPConfig.FTPConfigSingleton('FFTPLibrary')
config = config_obj.config_data

source = 'FFTPLibrary'
user = config.get('NOTIFY_USER')
if not user:
    user = acm.UserName()
    
amb_address = config.get('MESSAGE_BROKER')
notification_media = config.get('NOTIFICATION_MEDIA')
notify_level = config.get('NOTIFY_LEVEL')
log_level = config.get('LOGGING_LEVEL')
smtp_server = config.get('SMTP_SERVER')
user_email_list = config.get('USER_EMAIL')
application_name = config.get('FFTP_APPLICATION_NAME')

def FFTPLogger(source):
    logger = FANotification.FANotification(name=source, 
                    notification_media=notification_media, 
                    notify_level=notify_level,
                    logging_level=log_level, 
                    message_broker=amb_address, 
                    user=user, 
                    user_emails=user_email_list, 
                    smtp_server=smtp_server)
    return logger





...

  FFTPOperations
"""--------------------------------------------------------------------
MODULE
    FFTPOperations -  Operations like reading and writing to FTP server

DESCRIPTION
    This script handles the FTP operations.

VERSION: 2.0.4

--------------------------------------------------------------------"""
import os
import io
import time
import fnmatch
import ntpath
from ftplib import FTP

import FFTPConfig
import FFTPLibHooks
import FFTPNotification

logger = FFTPNotification.FFTPLogger('FFTPLibrary')
FTP_ERROR_codes = {'10052': 'Network dropped connection on reset',
                   '10053': 'Connection abort',
                   '10054': 'Connection reset by peer',
                   '10060': 'Connection timed out',
                   '10061': 'Connection refused'
                   }


class FTPOperations(object):
    def __init__(self, host=None, port=None, user=None, pwd=None, timeout=0, interval=0, retry=0,
                 config_variables_obj=None, *args):

        self.host = host
        self.port = port
        self.user = user
        self.pwd = pwd
        self.interval = interval
        self.timeout = timeout
        self.retry = retry
        self.ftp = self.connect()
        config_variables_obj = config_variables_obj
        self.config_data = config_variables_obj.config_data if config_variables_obj else {}
        self.read_mode = self.config_data.get('FROM_MODE', 'FTP')
        self.write_mode = self.config_data.get('TO_MODE', '')

    @classmethod
    def initialize(cls, mode, reader, task_parameters, config_variables_obj=None):
        ftp_config_param = FFTPConfig.Parameters('FFTPSettings')
        interval = getattr(ftp_config_param, 'POLL_INTERVAL', '')
        timeout = getattr(ftp_config_param, 'POLL_TIMEOUT', '')
        retry = getattr(ftp_config_param, 'POLL_RETRY', '')
        mode_config_param = FFTPConfig.Parameters('FFTPModeSettings_' + mode)
        config = None

        if mode.split('-')[0] == 'FTP' and reader:
            if task_parameters:
                host = task_parameters.get('READ_HOST', '')
                port = task_parameters.get('READ_PORT', '')
                user = task_parameters.get('READ_USER', '')
                pwd = task_parameters.get('READ_PASSWORD', '')
            else:
                host = getattr(mode_config_param, 'READ_HOST', '')
                port = getattr(mode_config_param, 'READ_PORT', '')
                user = getattr(mode_config_param, 'READ_USER', '')
                pwd = getattr(mode_config_param, 'READ_PASSWORD', '')
                config = 'FFTPModeSettings_' + mode

                if not (host and port and user and pwd):
                    host = getattr(ftp_config_param, 'READ_HOST', '')
                    port = getattr(ftp_config_param, 'READ_PORT', '')
                    user = getattr(ftp_config_param, 'READ_USER', '')
                    pwd = getattr(ftp_config_param, 'READ_PASSWORD', '')
                    config = 'FFTPSettings'
        elif mode.split('-')[1] == 'FTP':
            if task_parameters:
                host = task_parameters.get('WRITE_HOST', '')
                port = task_parameters.get('WRITE_PORT', '')
                user = task_parameters.get('WRITE_USER', '')
                pwd = task_parameters.get('WRITE_PASSWORD', '')
            else:
                host = getattr(mode_config_param, 'WRITE_HOST', '')
                port = getattr(mode_config_param, 'WRITE_PORT', '')
                user = getattr(mode_config_param, 'WRITE_USER', '')
                pwd = getattr(mode_config_param, 'WRITE_PASSWORD', '')
                config = 'FFTPModeSettings_' + mode

                if not (host and port and user and pwd):
                    host = getattr(ftp_config_param, 'WRITE_HOST', '')
                    port = getattr(ftp_config_param, 'WRITE_PORT', '')
                    user = getattr(ftp_config_param, 'WRITE_USER', '')
                    pwd = getattr(ftp_config_param, 'WRITE_PASSWORD', '')
                    config = 'FFTPSettings'

        obj = cls(host, port, user, pwd, timeout, interval, retry, config_variables_obj=config_variables_obj)
        if not host:
            if reader:
                logger.ERROR("Configuration parameters 'READ_HOST' is missing. Please check %s" % config)
            else:
                logger.ERROR("Configuration parameters 'WRITE_HOST' is missing. Please check %s" % config)
        if not port:
            if reader:
                logger.ERROR("Configuration parameters 'READ_PORT' is missing. Please check %s" % config)
            else:
                logger.ERROR("Configuration parameters 'WRITE_PORT' is missing. Please check %s" % config)

        if not user:
            if reader:
                logger.ERROR("Configuration parameters 'READ_USER' is missing. Please check %s" % config)
            else:
                logger.ERROR("Configuration parameters 'WRITE_USER' is missing. Please check %s" % config)

        if not pwd:
            if reader:
                logger.ERROR("Configuration parameters 'READ_PASSWORD' is missing. Please check %s" % config)
            else:
                logger.ERROR("Configuration parameters 'WRITE_PASSWORD' is missing. Please check %s" % config)

        if not obj.ftp:
            return None
        return obj

    def connect(self):
        ftp_conn = 1
        ftp = None
        try:
            dummy_host = ''
            ftp = FTP(host=dummy_host)
            if self.port:
                ftp.connect(self.host, int(self.port))
            else:
                ftp.connect(self.host)

                # logger.DEBUG('Connected to FTP server <%s>' % (self.host))
        except Exception as e:
            error_message = "Connection to FTP server " + str(self.host) \
                            + " failed."
            logger.ERROR(error_message)
            # logger.ERROR(str(e))
            ftp_conn = 0
            return None

        try:
            if ftp and self.user and self.pwd:
                ftp.login(self.user, self.pwd)
            elif ftp:
                anonymous_username = 'anonymous'
                anonymous_pd = ''
                ftp.login(user=anonymous_username, passwd=anonymous_pd)
            logger.DEBUG('Connected to FTP server <%s>' % self.host)
        except Exception as e:
            error_message = "Login to FTP server " \
                            + str(self.host) \
                            + " failed."
            logger.ERROR(error_message)

            # logger.ERROR(str(e))
            ftp_conn = 0

        if not ftp_conn:
            return None
        return ftp

    def retry_ftp_connection(self):
        """Retry FTP connection"""
        ftp_connected = False
        poll_retry = int(self.retry)
        logger.INFO("Re-connecting FTP server")
        for i in range(0, poll_retry + 1):
            if self.interval:
                retry_interval = self.interval
            else:
                retry_interval = 10
                logger.DEBUG("Default retry interval is {}".format(retry_interval))
            logger.INFO("~ %s in %s retry" % (str(retry_interval), str(i + 1)))
            time.sleep(int(retry_interval))
            # logger.DEBUG("Reconnecting to server")
            self.ftp = self.connect()
            if self.ftp:
                ftp_connected = True
                break
        return ftp_connected

    def poll_until_timeout(self, file_name, timeout, interval):

        """This method polls to FTP for a given time period at given
        interval of time If the reply file is
        present before the timeout then the result is returned.

        """
        file_list = []
        self.time_seconds = 0
        poll_start_time = time.time()
        if int(timeout):
            logger.INFO("Waiting for a file <{}> to download".format(file_name))
            while self.time_seconds < int(timeout):

                time.sleep(float(interval))
                seconds = str(self.time_seconds + \
                              int(interval)) + 's'
                msg = '~' + str(seconds) + ' ...'
                logger.INFO(msg)
                file_list = self.poll_for_file(file_name)
                if file_list:
                    return file_list

                self.time_seconds = self.time_seconds + \
                                    int(interval)
        else:
            file_list = self.poll_for_file(file_name)
        return file_list

    def poll_for_file(self, file_name):
        """This method polls for the reply file at ftp.
        True - if file exists at ftp server.
        false - if no file exists at ftp server.

        """
        ftp_connection = True
        filter_file_lst = []
        try:
            file_lst = self.ftp.nlst()
            filter_file_lst = fnmatch.filter(file_lst, file_name)
        except Exception as e:
            error_message = "Error while fetching reply file from FTP server"
            logger.ERROR(error_message)
            logger.ERROR(str(e))
            for error_code in FTP_ERROR_codes.keys():
                if error_code in str(e):
                    ftp_connection = False

        if not ftp_connection:
            logger.WARN("FTP is down, Trying to connect again")
            connected = self.retry_ftp_connection()
            if connected:
                self.poll_for_file(file_name)

        return filter_file_lst

    def upload_file(self, file_path, ftp_dir=None):

        """Uploads a file to the FTP server.
        storbinary is used to store the file in the binary format.
        Input - request file name to upload, request file path.

        """
        ftp_dir_set = 0
        ftp_connection = 1
        result = 1
        if self.ftp:
            try:

                if ftp_dir:
                    self.ftp.cwd(ftp_dir)
                    ftp_dir_set = 1
            except Exception as e:
                logger.ERROR("Error while changing directory in FTP : %s" % e)

            try:
                file_name = os.path.split(file_path)[-1]
                file_handler = open(file_path, 'rb')

                file_ref = FFTPLibHooks.fftplibrary_import_exit(self.read_mode, self.write_mode, file_path,
                                                                file_handler)
                if file_ref and isinstance(file_ref, io.BufferedReader):
                    file_handler = file_ref
                    file_path = file_ref.name
                else:
                    file_path = file_ref

                self.ftp.storbinary('STOR ' + \
                                    (file_name), file_handler)

                if file_path:
                    if ftp_dir:
                        logger.INFO("File uploaded to FTP server %s at path %s" % (file_name, ftp_dir))
                    else:
                        logger.INFO("File uploaded to FTP server %s" % (file_name))
                    file_handler.close()
                else:
                    # remove this file to stop download
                    result = 0

                if file_handler:
                    file_handler.close()

                if ftp_dir_set == 1:
                    self.ftp.cwd('/')

            except Exception as e:
                error_message = "Error while uploading file to FTP server"
                logger.ERROR(error_message)
                logger.ERROR(str(e))
                result = 0
                for error_code in FTP_ERROR_codes.keys():
                    if error_code in str(e):
                        ftp_connection = 0

            if not ftp_connection:
                logger.WARN("FTP is not connected while uploading file, Trying to re-connect")
                connected = self.retry_ftp_connection()
                if connected:
                    self.upload_file(file_path, ftp_dir)
                else:
                    result = 0
        else:
            result = 0

        return result

    def download_file(self, filename_lst, download_dir, ftp_dir=None):
        """Downloads a file from the FTP.
        retrbinary is used to download binary files.
        Input - reply file name, reply file path to download.
        Output - List of downloaded files from FTP server.

        """
        downloaded_file_list = []
        ftp_dir_set = 0
        if not filename_lst:
            logger.WARN("Download file name is not provided, Check file name or the READ_SOURCE FParameter")
            return downloaded_file_list

        # if self.ftp:
        if ftp_dir:
            ftp_dir_set = self.change_ftp_dir(ftp_dir)

        try:
            # self.ftp.cwd(ftp_dir)
            # ftp_dir_set = 1

            logger.DEBUG("Downloading files to dir <%s>" % download_dir)
            for file_name in filename_lst:
                file_list = self.poll_until_timeout(file_name, self.timeout, self.interval)

                if file_list:
                    for file_name in file_list:
                        tmp_file_name = file_name
                        file_name, destination_path = FFTPLibHooks.fftplibrary_export_entry(self.read_mode,
                                                                                            self.write_mode, file_name)
                        if file_name and type(file_name) == str:
                            if destination_path:
                                if self.write_mode == 'DIR':
                                    download_dir = destination_path
                                else:
                                    file_path = os.path.join(download_dir, file_name)
                                    self.config_data['TEMP_{}-{}'.format(self.read_mode, self.write_mode)][
                                        file_path] = destination_path

                            result = self._download_from_file(file_name, download_dir)
                            if result:
                                downloaded_file_list.append(file_name)
                        else:
                            logger.ERROR(
                                "File {} is filtered in fftplibrary_export_entry, returns: {}".format(tmp_file_name,
                                                                                                      str(file_name)))

                else:
                    logger.WARN("No File match with the filter provided to download from FTP Server.")

            if ftp_dir_set:
                # self.ftp.cwd('/')
                ftp_dir_set = self.change_ftp_dir('/')
        except IOError as e:
            logger.ERROR('FTP Error: %s' % str(e))

        except Exception as e:
            logger.ERROR('FTP Error: %s' % str(e))

        return downloaded_file_list

    def _download_from_file(self, file_name, download_dir):
        """Download file from FTP"""
        file_path = os.path.join(download_dir, file_name)
        file_handler = open(file_path, 'wb')

        ftp_connection = 1

        result = 0
        if file_handler:
            try:
                self.ftp.retrbinary('RETR %s' % file_name, file_handler.write)

                # export exit hook for amb message
                file_ref, destination_path = FFTPLibHooks.fftplibrary_export_exit(self.read_mode, self.write_mode,
                                                                                  file_path, file_handler)

                # Check the return valaue is file handler or file path
                if isinstance(file_ref, io.BufferedWriter):
                    file_handler = file_ref
                    file_path = file_ref.name
                else:
                    file_path = file_ref

                # close tthe file handler
                if file_handler:
                    file_handler.close()

                # Set the return destination path from extension point
                if file_path:
                    if destination_path:
                        self.config_data['TEMP_{}-{}'.format(self.read_mode, self.write_mode)][
                            file_path] = destination_path

                    logger.INFO("Downloaded file <%s> from FTP server" % file_name)
                    result = 1

            except Exception as e:
                error_message = "Error while downloading file %s from FTP" % file_name
                logger.ERROR(error_message)
                logger.ERROR(str(e))
                for error_code in FTP_ERROR_codes.keys():
                    if error_code in str(e):
                        ftp_connection = 0

        if not ftp_connection:
            logger.WARN("FTP is down, Trying to connect again")
            connected = self.retry_ftp_connection()
            if connected:
                result = self._download_from_file(download_dir, file_name)
        return result

    def change_ftp_dir(self, ftp_dir):
        """
        Change the ftp directory path to copy the file in provided directory
        :param ftp_dir: ftp directory path
        :return: result as boolean
        """
        result = 0
        is_connected = True
        try:
            self.ftp.cwd(ftp_dir)
            result = 1
        except Exception as e:
            error_message = "Error while changing FTP directory %s" % ftp_dir
            logger.ERROR(error_message)
            logger.ERROR(str(e))
            for error_code in FTP_ERROR_codes.keys():
                if error_code in str(e):
                    is_connected = False

        if not is_connected:
            connected = self.retry_ftp_connection()
            if connected:
                self.change_ftp_dir(ftp_dir)
            else:
                logger.WARN("Cannot connect to FTP after retry, FTP directory path cannot be changed")
        return result

    def get_file_modified_timestamp(self, file_name):
        """
        Get the modified timestamp of the file on FTP server.
        :param file_name: file name on FTP server
        :return: return the timestamp of file
        """
        is_connected = True
        timestamp = ''
        try:
            timestamp = self.ftp.voidcmd("MDTM " + file_name)[
                        4:].strip()  # returns datetime in UTC and YYYYMMDDHHMMSS format
        except Exception as e:
            error_message = "Error while fetching modified time of file %s from FTP" % file_name
            logger.ERROR(error_message)
            logger.ERROR(str(e))
            for error_code in FTP_ERROR_codes.keys():
                if error_code in str(e):
                    is_connected = False

        if not is_connected:
            connected = self.retry_ftp_connection()
            if connected:
                timestamp = self.get_file_modified_timestamp(file_name)
        return timestamp

    def utc_to_local(self, utc_date_string):
        """
        Covert date string from UTC date string to local date string
        :param utc_date_string: date string
        :return: date string in local time
        """
        import calendar
        from datetime import datetime, timedelta
        utc_dt = datetime.strptime(utc_date_string, '%Y%m%d%H%M%S')
        timestamp = calendar.timegm(utc_dt.timetuple())
        local_dt = datetime.fromtimestamp(timestamp)
        assert utc_dt.resolution >= timedelta(microseconds=1)
        return local_dt.replace(microsecond=utc_dt.microsecond)

    def local_to_utc(self, local_date_string):
        """Covert date string from local date string to utc date string"""
        import time
        local_time = time.strptime(local_date_string, "%Y-%m-%d %H:%M:%S")
        local_seconds = time.mktime(local_time)
        utc_time = time.gmtime(local_seconds)
        utc_time = time.strftime("%Y-%m-%d %H:%M:%S", utc_time)
        return utc_time

    def read(self, ftp_dir, dest_dir, filename_lst):
        """
        download files from the FTP directory
        :param ftp_dir: directory on FTP server
        :param dest_dir: local directory to copy files
        :param filename_lst: list of files to download from FTP
        :return:
        """
        file_path_list = []
        if not self.ftp:
            self.ftp = self.connect()

        download_file_list = self.download_file(filename_lst, dest_dir, ftp_dir)
        if download_file_list:
            for each_file in download_file_list:
                file_path_list = [os.path.join(dest_dir, each_file) for each_file in download_file_list]
        return file_path_list

    def write(self, file_path_list, ftp_dir, temp_dest_dict={}):
        """Upload files to FTP """
        files_written_to_dest = []

        if not self.ftp:
            self.ftp = self.connect()

        for file_path in file_path_list:
            tmp_file_path = file_path
            if temp_dest_dict:
                temp_dest = temp_dest_dict.get(file_path)
                if temp_dest:
                    ftp_dir = temp_dest
            file_ref = FFTPLibHooks.fftplibrary_import_entry(self.read_mode, self.write_mode, file_path)

            if file_ref and type(file_ref) == str:
                file_path = file_ref
                result = self.upload_file(file_path, ftp_dir)
                if result:
                    files_written_to_dest.append(file_path)
            else:
                logger.WARN(
                    "File {} is filtered in fftplibrary_import_entry which returned value: {}".format(tmp_file_path,
                                                                                                      str(file_ref)))

        return files_written_to_dest

    def close_connection(self):
        """Close the FTP connection"""
        if self.ftp:
            try:

                self.ftp.quit()
            except Exception as ex:
                logger.ERROR("Error while closing FTP connection %s" % str(ex))


def read_from_ftp(download_dir, connstr, \
                  ftp_dir, timeout=0, interval=0, retry=0):
    """ Download file from FTP server to local directory"""
    download_dir_lst = FFTPConfig.string_as_list(download_dir)
    ftp_dir_lst = FFTPConfig.string_as_list(ftp_dir)
    source_dict = {}
    destination = download_dir_lst[0]
    if len(download_dir_lst) > 1 and len(download_dir_lst) == len(ftp_dir_lst):
        source_dict = dict(list(zip(ftp_dir_lst, download_dir_lst)))
    elif len(download_dir_lst) > 1:
        logger.ERROR("Invalid download_dir / ftp_dir provided as input to API")
        return

    result = 0
    if connstr:
        host, port, user, pwd = '', '', '', ''
        conn_param_lst = connstr.split(':')
        if len(conn_param_lst) > 2:
            host = conn_param_lst[0]
            port = conn_param_lst[1]
        if len(conn_param_lst) == 4:
            user = conn_param_lst[2]
            pwd = conn_param_lst[3]

        ftp_obj = FTPOperations(host, port, user, pwd, timeout, interval, retry)
        for each_source in ftp_dir_lst:
            if source_dict:
                destination = source_dict[each_source]
            ftp_dir, filter = ntpath.split(os.path.expandvars(each_source))

            result = ftp_obj.download_file(filename_lst=[filter], \
                                           download_dir=destination, ftp_dir=ftp_dir)

        ftp_obj.close_connection()
    else:
        result = 0

    return result


def write_to_ftp(file_path, connstr, ftp_dir='',
                 timeout=0, interval=0, retry=0):
    """ Writes an file to FTP server at specified directory """
    try:
        file_path_lst = FFTPConfig.string_as_list(file_path)
        ftp_dir_lst = FFTPConfig.string_as_list(ftp_dir)
        source_dict = {}
        destination = ftp_dir_lst[0]
        if len(ftp_dir_lst) > 1 and len(ftp_dir_lst) == len(file_path_lst):
            source_dict = dict(list(zip(file_path_lst, ftp_dir_lst)))
        elif len(ftp_dir_lst) > 1:
            logger.ERROR("Invalid file_path / ftp_dir provided as input to API")
            return

        result = 0
        if connstr:
            host, port, user, pwd = '', '', '', ''
            conn_param_lst = connstr.split(':')
            if len(conn_param_lst) > 2:
                host = conn_param_lst[0]
                port = conn_param_lst[1]
            if len(conn_param_lst) == 4:
                user = conn_param_lst[2]
                pwd = conn_param_lst[3]

            if host:
                ftp_obj = FTPOperations(host, port, user, pwd, timeout, interval)

                for file_path in file_path_lst:
                    if source_dict:
                        destination = source_dict[file_path]
                    if os.path.isfile(file_path):
                        result = ftp_obj.upload_file(file_path, destination)
                    else:
                        for files in os.listdir(file_path):
                            file_to_open = file_path + '/' + files
                            result = ftp_obj.upload_file(file_to_open, destination)
                ftp_obj.close_connection()
            else:
                logger.ERROR("FTP host name not provided by user")
        else:
            result = 0

        return result
    except Exception as e:
        logger.ERROR(str(e))




...

  FFTPTasks
"""-------------------------------------------------------------------
MODULE
    FTPTasks - Module to create FTP ATS Tasks

DESCRIPTION
    This is a file which is saved as a python module for created
    FTP Library Tasks. The file executes when the ATS runs the
    scheduled job.

VERSION: 2.0.4

-------------------------------------------------------------------"""

import os
import acm

import FFTPConfig
import FFTPNotification
from FFTPController import FTPController

logger = FFTPNotification.FFTPLogger('FFTPLibrary')

#config_obj = FFTPConfig.FTPConfigSingleton('FFTPLibrary')
#config = config_obj.config_data

mode_config_param = FFTPConfig.Parameters('FFTPModeSettings')



# tooltip for Select ValGroup input field
tt_read_mode = '''
Select read mode
'''

# tooltip for Select ValGroup input field
tt_write_mode = '''
Select write mode
'''

tt_read_source = '''
Enter read source
'''


tt_write_source = '''
Enter write source
'''

tt_read_ftp_details = '''
Enter the read FTP credential in format Host:Port:User:Password
'''

tt_write_ftp_details  = '''
Enter the write FTP credential in format Host:Port:User:Password
'''

tt_file_name_exp = '''
Enter the file search expression which needs to be sent to destination
'''

tt_amb_msg_file_name = '''
Enter AMB message file name
'''


def get_read_mode():
    return ['FTP','SFTP','DIR','AMB']

def get_write_mode():
    return ['FTP','SFTP','DIR','AMB']


def disable_read_mode_fields(index, fieldValues):
    if fieldValues[index] in ['FTP', 'SFTP']:
        ael_variables[index+7][9] = 1
    else:
        ael_variables[index+7][9] = 0

    if fieldValues[index] == 'AMB':
        ael_variables[index+6][9] = 1
        ael_variables[index+5][9] = 0
        ael_variables[index+5][5] = 0
        fieldValues[index+5] = ''

    else:
        ael_variables[index+6][9] = 0
        ael_variables[index+5][9] = 1
        ael_variables[index+5][5] = 1


    if fieldValues[index] in ['DIR']:
        ael_variables[index+4][9] = 1
        #ael_variables[index+4][5] = 0

    else:
        ael_variables[index+4][9] = 0
        ael_variables[index+4][5] = 0
        ael_variables[index+9][9] = 1
        ael_variables[index+9][5] = 1

    if fieldValues[index] in ['DIR'] or fieldValues[index+1] in ['DIR'] :
        ael_variables[index+9][9] = 0
        ael_variables[index+9][5] = 0
    else:
        ael_variables[index+9][9] = 1
        ael_variables[index+9][5] = 1

    return fieldValues


def disable_write_mode_fields(index, fieldValues):
    if fieldValues[index] in ['FTP', 'SFTP']:
        ael_variables[index+7][9] = 1
    else:
        ael_variables[index+7][9] = 0

    if fieldValues[index] in ['DIR'] or fieldValues[index-1] in ['DIR'] :
        ael_variables[index+8][9] = 0
        ael_variables[index+8][5] = 0
    else:
        ael_variables[index+8][9] = 1
        ael_variables[index+8][5] = 1

    return fieldValues

ael_gui_parameters = {
                        'runButtonLabel': '&&OK',
                        'hideExtraControls': False
                        }


mode = getattr(mode_config_param, 'MODE', '')
read_mode = ''
write_mode = ''
if mode:
    first_mode = mode.split(',')[0]    
    read_mode = first_mode.split('-')[0]    
    write_mode = first_mode.split('-')[1]    

ael_variables = [\

#FTP Library

# List box to select a Read Mode
['read_mode', 'Read Mode_FTP Library', 'string', get_read_mode(), read_mode, 1, 0, tt_read_mode, disable_read_mode_fields, 1],


# List box to select a Write Mode
['write_mode', 'Write Mode_FTP Library', 'string', get_write_mode(), write_mode, 1, 0, tt_write_mode, disable_write_mode_fields, 1],


# Input field for read source
['read_source', 'Read Path/Subject_FTP Library', 'string', None, '', 0, 0, tt_read_source, 0, 1],


# Input field for write source
['write_source', 'Write Path/Subject_FTP Library', 'string', None, '', 0, 0, tt_write_source, 0, 1],

# Input field for archive source
['archive_source', 'Archive Path_FTP Library', 'string', None, '', 0, 0, tt_write_source, 0, 1],

['read_file_filter', 'Read File Filter_FTP Library', 'string', None, '', 1, 0, tt_file_name_exp, 0, 1],

['amb_msg_file_name', 'AMB Message File Name_FTP Library', 'string', None, '', 0, 0, tt_amb_msg_file_name, 0, 1],

# Input field for write source
['read_ftp_details', 'Read FTP_FTP Library', 'string', None, '', 0, 0, tt_read_ftp_details, 0, 1],

# Input field for write source
['write_ftp_details', 'Write FTP_FTP Library', 'string', None, '', 0, 0, tt_write_ftp_details, 0, 1],

# Input field for write source
['temp_file_path', 'Temprary File path_FTP Library', 'string', None, '', 0, 0, '', 0, 1],


]

def override_config_with_gui_input(ael_params):
    #config['READ_MODE'] = ael_params['read_mode']
    #config['WRITE_MODE'] = ael_params['write_mode']
    config_ael_params = {}

    read_mode = ael_params['read_mode']
    write_mode = ael_params['write_mode']
    fftp_mode = read_mode + '-' + write_mode
    config_ael_params['MODE'] = fftp_mode

    if ael_params['read_source']:
        read_source = ael_params['read_source']
        read_source_lst = FFTPConfig.string_as_list(read_source)

        config_ael_params['READ_SOURCE'] = read_source_lst



    if ael_params['write_source']:
        write_source = ael_params['write_source']
        write_source_lst = FFTPConfig.string_as_list(write_source)
        config_ael_params['WRITE_SOURCE'] = write_source_lst



    if ael_params['archive_source']:
        archive_source = ael_params['archive_source']
        config_ael_params['ARCHIVE_PATH'] = archive_source



    #config['READ_WRITE_SOURCE'] = [(read_source, archive_source, write_source)]

    if ael_params['read_file_filter']:
        lst = []
        str_val = ael_params['read_file_filter']

        filter_lst = FFTPConfig.string_as_list(str_val)

        read_sources = []
        if read_mode in ['DIR', 'FTP', 'SFTP']:
            for filter in filter_lst:
                for read_source in read_source_lst:
                    read_source = os.path.join(read_source, filter)
                    read_sources.append(read_source)
        config_ael_params['READ_SOURCE'] = read_sources



    if ael_params['amb_msg_file_name']:
        config_ael_params['MESSAGE_FILE_NAME'] = ael_params['amb_msg_file_name']

    if ael_params['read_ftp_details']:
        ftp_read_cred = ael_params['read_ftp_details']
        try:
            if ftp_read_cred:
                cred_list = ftp_read_cred.split(':')
                if 2 <= len(cred_list) <= 4:
                    config_ael_params['READ_HOST'] = cred_list[0]
                    config_ael_params['READ_PORT'] = cred_list[1]
                if len(cred_list) == 4:
                    config_ael_params['READ_USER'] = cred_list[2]
                    config_ael_params['READ_PASSWORD'] = cred_list[3]
        except Exception as ex:
            logger.ERROR("Enter the read FTP credential in format host:port:user:password")
            return 0

    if ael_params['write_ftp_details']:
        ftp_write_cred = ael_params['write_ftp_details']
        try:
            if ftp_write_cred:
                cred_list = ftp_write_cred.split(':')
                if 2 <= len(cred_list) <= 4:
                    config_ael_params['WRITE_HOST'] = cred_list[0]
                    config_ael_params['WRITE_PORT'] = cred_list[1]
                if len(cred_list) == 4:
                    config_ael_params['WRITE_USER'] = cred_list[2]
                    config_ael_params['WRITE_PASSWORD'] = cred_list[3]
        except Exception as ex:
            logger.ERROR("Enter the wirte FTP credential in format host:port:user:password")
            return 0

    if ael_params['temp_file_path']:
        config_ael_params['TEMP_FILE_PATH']  = ael_params['temp_file_path']

    return config_ael_params


#import ATSOperationsWork
def ael_main(ael_params):
    config_ael_params = override_config_with_gui_input(ael_params)
    mode = config_ael_params.get('MODE', '')
    controller_obj = FTPController(mode, config_ael_params)
    success = controller_obj.main()
    if success:
        logger.INFO("Task completed Successfully")
    elif not success:
        logger.ERROR("Task Failed!")
    controller_obj.close_connection()



...

  FIntegrationUtils
import sys
import string
import os
import re, base64
import FOperationsDocumentProcess

try:
    import acm
except:
    pass

try:
    import ael
except:
    pass

try:
    import amb
except:
    pass


class ConfirmationEnum(object):
    """Confirmation Enums
    """

    @staticmethod
    def GetConfirmationStatusEnum():
        """ Returns Confirmation status Enum class
        """
        from FConfirmationEnums import ConfirmationStatus
        return ConfirmationStatus

    @staticmethod
    def GetConfirmationTypeEnum():
        """Returns Confirmation Type Enum class
        """
        from FConfirmationEnums import ConfirmationType
        return ConfirmationType


class OPDocumentsEnum(object):
    """ Operations documents Enum
    """

    @staticmethod
    def GetOperationsDocumentStatusEnum():
        """Returns Operations Document status Enum class
        """
        from FOperationsDocumentEnums import OperationsDocumentStatus
        return OperationsDocumentStatus

    @staticmethod
    def GetOperationsDocumentTypeEnum():
        """Returns Operations Document Type Enum class
        """
        from FOperationsDocumentEnums import OperationsDocumentType
        return OperationsDocumentType


OPERATIONS_DOCUMENT_STATUS = OPDocumentsEnum.GetOperationsDocumentStatusEnum()


class Parameters(object):
    """ Class to read FParameters"""

    def __init__(self, *names):
        try:
            self.param_name_list = []
            self.get_data(*names)
        except Exception as error:
            raise error
            # Not sure where we are using this , hence skipping it for now
            # self.get_local_data(*names)

    def suppress_deprecated_attribute(self, fparam_name, attrib_name):
        """ Suppresses deprecated attributes """
        if 'FSwiftReaderConfig' == fparam_name:
            deprecated_dict = {'FSWIFT_AMB_HOST': 'AMBAddress',
                               'FSWIFT_AMB_READER': 'AMBReceiver',
                               'FSWIFT_AMB_SUBJECT': 'AMBReceiverSubject',
                               'FSWIFT_RELEASE_VERSION': 'version',
                               'FSWIFT_MODULES': 'Modules',
                               'FSWIFT_SENDER_SOURCE': 'AMBSenderSource'}

            name_found = deprecated_dict.get(attrib_name)
            if name_found:
                return name_found

        return attrib_name

    def get_data(self, *names):
        """ Read the FParameters from the Extension Manager"""
        for fparam in names:
            ext_context = acm.FExtensionContext[acm.GetDefaultContext().Name()]
            param_object = ext_context.GetExtension('FParameters',
                                                    'FObject', fparam)
            try:
                template = param_object.Value()
            except AttributeError as error:
                if not param_object:
                    raise Exception("FParameter %s not present" % fparam)
                else:
                    raise Exception("Unable to get content of FParameter %s. Exception : %s" % (fparam, error))

            for k in template.Keys():  # First set all the parameters
                param_name = str(k)
                attribute_name = str(template.At(k)).split('#')[0].strip()
                setattr(self, param_name, attribute_name)
                self.param_name_list.append(param_name)

            for k in template.Keys():  # Now override the value of old over new
                param_name = str(k)
                param_name_supp = self.suppress_deprecated_attribute(fparam, param_name)
                if param_name_supp != param_name:
                    attribute_name = str(template.At(k)).split('#')[0].strip()
                    setattr(self, param_name_supp, attribute_name)
            self.module_name = param_object.Module().Name()

    def get_local_data(self, *names):
        """ Read the FParameters from the Extension Manager"""
        for fparam in names:
            import os
            file_name = os.path.join('Parameters', fparam + '.py')
            try:
                with open(file_name) as file_handle:
                    for line in file_handle:
                        param_value = line.split('#')[0].strip()
                        lhs, rhs = param_value.split('=')
                        setattr(self, lhs, rhs)
            except Exception as e:
                pass

    def get_param_name_list(self):
        return self.param_name_list


class FIntegrationUtils(object):
    def get_contacts(self, party):
        """get the contacts that are available on the party"""
        contacts = set()
        for contact in party.Contacts():
            contacts.add(contact.Fullname())
        return list(contacts)

    def get_party_handle(self, party_val):
        """get the actual party object from the given input - either string or party obj"""
        party_handle = None
        try:
            if isinstance(party_val, str):
                party_handle = acm.FParty[party_val]
            elif party_val.IsKindOf(acm.FParty):
                party_handle = party_val
        except Exception as e:
            # this exception is hit when the IsKindOf is called on a None party object that is being sent
            pass
        return party_handle

    def get_instrument_handle(self, ins_val):
        """get the actual instrument object from the given input - either string or instrument obj"""
        instrument_handle = None
        try:
            if isinstance(ins_val, str):
                instrument_handle = acm.FInstrument[ins_val]
            elif ins_val.IsKindOf(acm.FInstrument):
                instrument_handle = ins_val
        except Exception as e:
            # this exception is hit when the IsKindOf is called on a None instrument object that is being sent
            pass
        return instrument_handle

    def is_valid_choice_list_val(self, choice_list, choice_list_val):
        """validate that the given value is an entry for the given choicelist"""
        is_valid_choice_list = False
        choicelists = acm.FChoiceList.Select("list = '%s' and name = '%s'" % (choice_list, choice_list_val))
        if choicelists:
            is_valid_choice_list = True
        return is_valid_choice_list

    def get_choice_list(self, choice_list, choice_list_val):
        """get the choicelist object from the given query"""
        choicelist_val = None
        choicelists = acm.FChoiceList.Select("list = '%s' and name = '%s'" % (choice_list, choice_list_val))
        if choicelists:
            choicelist_val = choicelists[0]
        return choicelist_val

    def get_valid_contact(self, party, contact):
        """validate if the given contact exists on the give party"""
        valid_contact = None
        contact_name = None
        try:
            if contact.IsKindOf(acm.FContact):
                contact_name = contact.Fullname()
        except:
            contact_name = contact
        for contactVal in party.Contacts():
            if contactVal.Fullname() == contact_name:
                valid_contact = contactVal
                break
        return valid_contact

    def create_additional_info_spec(self, add_info_spec_attr):
        """ Create additional info's"""
        ais = acm.FAdditionalInfoSpec[add_info_spec_attr['FieldName']]
        if ais:
            raise AddInfoSpecAlreadyExits("Additional info <%s> exists on table <%s>" % (
                add_info_spec_attr['FieldName'], add_info_spec_attr['Table']))
        ais = acm.FAdditionalInfoSpec()
        self.set_additional_info_spec_attr(ais, add_info_spec_attr)

    def set_additional_info_spec(self, add_info_spec_attr, filter=None):
        """set the additionalInfoSpec attributes"""
        ais = acm.FAdditionalInfoSpec[add_info_spec_attr['FieldName']]
        if not ais:
            ais = acm.FAdditionalInfoSpec()
        self.set_additional_info_spec_attr(ais, add_info_spec_attr, filter)

    def get_additional_info_spec(self, add_info, rec_addr):
        """get the additionalinfo instance on the given acm object for a given addInfoSpec"""
        add_info_obj = None
        add_info_spec = acm.FAdditionalInfoSpec[add_info]
        if add_info_spec:
            try:
                add_info_objs = acm.FAdditionalInfo.Select(
                    'addInf=%d and recaddr =%d' % (add_info_spec.Oid(), rec_addr.Oid()))
                if add_info_objs:
                    add_info_obj = add_info_objs[0]
            except Exception as e:
                raise Exception('Error while accessing additional info %s' % (add_info))

        else:
            raise AddInfoSpecNotExist('%s is not a valid AdditionalInfoSpec' % (add_info))
        return add_info_obj

    def get_alias_type(self, alias_typ):
        """get the alias type instance on the given acm object for a given alias type name"""
        alias_typ_spec = None
        alias_typ_spec = acm.FInstrAliasType[alias_typ]
        if not alias_typ_spec:
            raise AliasTypeSpecNotExist('%s is not a valid AliasType' % (alias_typ))
        return alias_typ_spec

    def get_alias_val(self, alias_typ, rec_addr):
        """get the alias value instance on the given acm object for a given alias type name"""
        alias_val = None
        alias_typ_obj = self.get_alias_type(alias_typ)
        if alias_typ_obj:
            try:
                alias_obj = acm.FInstrumentAlias.Select01(
                    'type=%d and instrument =%d' % (alias_typ_obj.Oid(), rec_addr.Oid()), 'Not found')
                if alias_obj:
                    alias_val = alias_obj.Alias()

            except Exception as e:
                raise Exception(
                    'Error while accessing %s Alias for %s : %s' % (alias_typ, str(rec_addr.Name()), str(e)))

        return alias_val

    def get_isda_index_tenor_alias_val(self, rec_addr):
        """get the ISDAIndexTenor alias value for the acm FInstrument object"""
        alias_typ_name = 'ISDAIndexTenor'
        alias_typ_obj = None
        alias_val = None
        reg = '\d{1,2}[M|Y|D]{1}'
        alias_typ_spec = acm.FInstrAliasType[alias_typ_name]
        if alias_typ_spec:
            try:
                alias_typ_obj = acm.FInstrumentAlias.Select01(
                    'type=%d and instrument =%d' % (alias_typ_spec.Oid(), rec_addr.Oid()), 'Not found')
                if alias_typ_obj:
                    alias = alias_typ_obj.Alias()
                    alias_val = alias
                    if alias.find('-') != -1:
                        split_text = alias.split('-')
                        data_to_strip = split_text[-1]
                        pattern = re.compile(reg)
                        if pattern.match(data_to_strip):
                            alias_val = '-'.join(split_text[:-1])
            except Exception as e:
                raise Exception('Error while accessing Alias %s : %s' % (alias_typ_name, str(e)))

        else:
            raise AliasTypeSpecNotExist('%s is not a valid AliasType' % (alias_typ_name))
        return alias_val

    def get_isda_index_tenor_addinfo_val(self, rec_addr):
        """get the ISDAIndexTenor AddInfo value for the acm FInstrument object"""
        addinfo_spec_name = 'ISDAIndexTenor'
        addinfo_spec_obj = None
        addinfo_val = None
        reg = '\d{1,2}[M|Y|D]{1}'
        addinfo_spec = acm.FAdditionalInfoSpec[addinfo_spec_name]
        if addinfo_spec:
            try:
                addinfo_spec_obj = acm.FAdditionalInfo.Select01(
                    'addInf=%d and recaddr =%d' % (addinfo_spec.Oid(), rec_addr.Oid()), 'Not found')
                if addinfo_spec_obj:
                    addinfo = addinfo_spec_obj.FieldValue()
                    addinfo_val = addinfo
                    if addinfo.find('-') != -1:
                        split_text = addinfo.split('-')
                        data_to_strip = '-' + split_text[-1]
                        pattern = re.compile(reg)
                        if pattern.match(data_to_strip):
                            alias_val = '-'.join(split_text[:-1])
            except Exception as e:
                raise Exception('Error while accessing AdditionalInfo %s : %s' % (addinfo_spec_name, str(e)))

        else:
            raise AdditionalInfoSpecNotExist('%s is not a valid AdditionalInfoSpec' % (addinfo_spec_name))
        return addinfo_val

    def get_isda_index_tenor(self, rec_addr):
        index_tenor_val = ''
        exception_str = ''
        try:
            index_tenor_val = self.get_isda_index_tenor_alias_val(rec_addr)
        except Exception as e:
            exception_str += str(e)

        if not index_tenor_val:
            try:
                index_tenor_val = self.get_isda_index_tenor_addinfo_val(rec_addr)
            except Exception as e:
                exception_str += '\n' + str(e)
        if exception_str:
            raise Exception(exception_str)
        return index_tenor_val

    def get_data_type_type(self, type_val):
        """get the DataTypeType to be set on the AddInfoSpec while creating it"""
        date_type_type = None
        try:
            if type_val in acm.FEnumeration['enum(B92StandardType)'].Choices():
                date_type_type = acm.FEnumeration['enum(B92StandardType)'].Enumeration(type_val)
            elif type_val in acm.FEnumeration['enum(B92RecordType)'].Choices():
                date_type_type = acm.FEnumeration['enum(B92RecordType)'].Enumeration(type_val)
        except:
            if type_val in acm.FEnumeration['enum(B92StandardType)'].Elements():
                date_type_type = acm.FEnumeration['enum(B92StandardType)'].Enumeration(type_val)
            elif type_val in acm.FEnumeration['enum(B92RecordType)'].Elements():
                date_type_type = acm.FEnumeration['enum(B92RecordType)'].Enumeration(type_val)
        return date_type_type

    def set_additional_info_spec_attr(self, ais, add_info_spec_attr, filter=None):
        """ Set additional info spec attributes"""
        try:
            ais.FieldName(add_info_spec_attr['FieldName'])
            ais.Description(add_info_spec_attr['Description'])

            ais.DefaultValue(add_info_spec_attr['Default'])

            ais.DataTypeGroup = acm.FEnumeration['enum(B92DataGroup)'].Enumeration(add_info_spec_attr['TypeGroup'])
            ais.DataTypeType(self.get_data_type_type(add_info_spec_attr['Type']))

            ais.RecType = add_info_spec_attr['Table']

            if add_info_spec_attr['Type'] == 'ChoiceList':
                choiceListValues = []
                if 'Values' in add_info_spec_attr.keys():
                    choiceListValues = add_info_spec_attr['Values']
                try:
                    self.create_choice_list(add_info_spec_attr['Description'], choiceListValues,
                                            add_info_spec_attr['Description'])
                except ChoiceListAlreadyExist as e:
                    pass
            if filter:
                for each_sub_table in filter:
                    try:
                        ais.AddSubType(each_sub_table)
                    except:
                        # it means this subType does not exist for this PRIME version. No point in raising exception here as this insType is not available on this acm Version.
                        pass
            ais.Commit()

        except Exception as e:
            raise Exception("Error occured while committing AddInfoSpec <%s>. Error: <%s>" % (
                add_info_spec_attr['FieldName'], str(e)))

    def update_element_in_choice_list(self, cl_name, cl_val, cl_val_description=None, cl_sort_order=None):
        """update the given element in the given choicelist with its description and sort order"""
        query = "list = '%s' and name ='%s'" % (cl_name, cl_val[0:39])
        cl_object = acm.FChoiceList.Select01(query, None)
        if cl_object:
            try:
                cl_object.List = cl_name
                cl_object.Name = cl_val
                if cl_val_description:
                    cl_object.Description(cl_val_description)
                if cl_sort_order:
                    cl_object.SortOrder(cl_sort_order)
                cl_object.Commit()
            except Exception as e:
                raise Exception("Error in update_element_in_choice_list", str(e))
        else:
            raise Exception(
                "Either Choice list <%s> does not exist or it does not contain element <%s>" % (cl_name, cl_val))

    def insert_element_in_choice_list(self, cl_name, cl_val, cl_val_description=None, cl_sort_order=None):
        """insert the given element into the given choicelist with its description and sort order"""
        query = "list = '%s' and name ='%s'" % (cl_name, cl_val[0:39])
        cl_object = acm.FChoiceList.Select01(query, None)
        if not cl_object:
            cl_object = acm.FChoiceList()
        else:
            raise ChoiceListAlreadyExist("Choice list <%s> already contains element <%s>" % (cl_name, cl_val))
        try:
            cl_object.List = cl_name
            cl_object.Name = cl_val
            if cl_val_description:
                cl_object.Description(cl_val_description)
            if cl_sort_order:
                cl_object.SortOrder(cl_sort_order)
            cl_object.Commit()
        except Exception as e:
            raise Exception("Error in insert_element_in_choice_list", str(e))

    def remove_element_from_choice_list(self, cl_name, cl_val):
        """remove the given element from the given choicelist"""
        query = "list = '%s' and name ='%s'" % (cl_name, cl_val[0:39])
        cl_object = acm.FChoiceList.Select01(query, None)
        if cl_object:
            try:
                cl_object.Delete()
            except Exception as e:
                raise Exception("Error in remove_element_from_choice_list", str(e))
        else:
            raise ChoiceListNotFound("<%s> does not exist in <%s> ChoiceList" % (cl_val, cl_name))

    def delete_choice_list(self, cl_name):
        """delete the given choicelist"""
        cl_object = acm.FChoiceList[cl_name]
        if cl_object:
            cl_values = None
            try:
                cl_values = cl_object.Choices().AsList()
            except:
                cl_values = cl_object.Elements().AsList()
            for cl_val in cl_values:
                self.remove_element_from_choice_list(cl_name, cl_val.Name())
            self.remove_element_from_choice_list('MASTER', cl_name)

    def create_choice_list(self, cl_name, cl_values=[], description=None, bMaster=True, bUpdate=False):
        """create the choicelist with the given values"""
        cl_object = None
        choicelist_name = cl_name
        if bMaster:
            try:
                self.insert_element_in_choice_list('MASTER', cl_name, description)
            except ChoiceListAlreadyExist as e:
                if bUpdate:
                    self.update_element_in_choice_list('MASTER', cl_name, description)
        for cl_val in cl_values:
            cl_val_description = None
            cl_val_sort_order = None
            if 'description' in cl_val.keys():
                cl_val_description = cl_val['description']
            if 'sort_order' in cl_val.keys():
                cl_val_sort_order = cl_val['sort_order']
            if 'name' in cl_val.keys():
                choicelist_name = cl_val['name']
            try:
                self.insert_element_in_choice_list(cl_name, choicelist_name, cl_val_description, cl_val_sort_order)
            except ChoiceListAlreadyExist as e:
                if bUpdate:
                    self.update_element_in_choice_list(cl_name, choicelist_name, cl_val_description, cl_val_sort_order)
                else:
                    raise ChoiceListAlreadyExist(str(e))
        return cl_object

    def update_additional_info_spec(self, spec_name, add_info_spec_attr):
        """ Update additional info spec"""
        ais = acm.FAdditionalInfoSpec[spec_name]
        if ais:
            self.set_additional_info_spec(ais, add_info_spec_attr)

    def set_additional_info(self, add_info_spec, pObject, value):
        """set additional Info"""
        if getattr(pObject.AdditionalInfo(), add_info_spec, None) is None:
            raise AddInfoSpecNotExist("Additional info %s does not exist on %s" % (add_info_spec, pObject.ClassName()))
            return
        if self.get_acm_version() >= 2016.1:
            try:
                setattr(pObject.AdditionalInfo(), add_info_spec, value)
                pObject.Commit()
            except Exception as e:
                raise Exception(
                    "Error occurred during setting AddInfo %s with value %s. Error %s" % (add_info_spec, value, str(e)))
        else:
            ais = acm.FAdditionalInfoSpec[add_info_spec]
            if not ais:
                add_info_spec = add_info_spec[0].lower() + add_info_spec[1:]
                ais = acm.FAdditionalInfoSpec[add_info_spec]
            if ais:
                ai = None
                query = 'addInf=%d and recaddr=%d' % (ais.Oid(), pObject.Oid())
                ai_vals = acm.FAdditionalInfo.Select(query)
                for ai_val in ai_vals:
                    if ai_val.Oid() > 0:
                        ai = ai_val
                        break
                if ai:
                    self.update_addtional_info(ai, value)
                else:
                    self.create_additional_info(ais, pObject, value)

    def create_additional_info(self, ais, pObject, value):
        """create new additional Info"""
        try:
            if str(value) not in ['None',
                                  '']:  # added as this are considered valid values for 15.1 and it tries to apply these values and throws error
                ai = acm.FAdditionalInfo()
                ai.Recaddr = pObject.Oid()
                ai.AddInf = ais.Oid()
                ai.FieldValue(value)
                ai.Commit()
        except Exception as e:
            raise Exception(
                "Error occurred during adding AddInfo %s with value %s. Error %s" % (ais.Name(), value, str(e)))

    def delete_add_info_spec(self, add_info_spec):
        ais = acm.FAdditionalInfoSpec[add_info_spec]
        if ais:
            try:
                if ais.DataTypeGroup() == 'RecordRef' and \
                        acm.EnumToString('B92RecordType', ais.DataTypeType()).AsString() == 'ChoiceList':
                    self.delete_choice_list(ais.Description())
                ais.Delete()

            except Exception as e:
                raise Exception("Error occured while deleting AddInfoSpec <%s>. Error: <%s>" % (add_info_spec, str(e)))
        else:
            raise AddInfoSpecNotExist("AddInfoSpec <%s> does not exist in database" % add_info_spec)

    def update_addtional_info(self, ai, value=None):
        """update the additional info"""
        try:
            if str(value) not in ['None',
                                  '']:  # added as this are considered valid values for 15.1 and it tries to apply these values and throws error
                aiC = ai.Clone()
                aiC.FieldValue(value)
                ai.Apply(aiC)
                ai.Commit()
            else:
                ai.Delete()
        except Exception as e:
            raise Exception(
                "Error occurred while updating AddInfo %s with value %s. Error %s" % (
                    ai.AddInf().Name(), value, str(e)))

    def get_extension_contents(self, ext_type, ext_name):
        """ Get Extension contents for given type and name"""

        contents = ''
        ext_obj = acm.GetDefaultContext().GetExtension(ext_type, 'FObject', ext_name)
        if ext_obj:
            contents = ext_obj.Value()
        return contents

    '''def import_modules_from_string(self, modules):
        """ Import the modules from string"""
        imported_modules = []
        for module in modules:
            imp_module = None
            try:
                try:
                    import importlib
                    imp_module = importlib.import_module(module)
                except:
                    imp_module = __import__(module)
                imported_modules.append(imp_module)
            except Exception, error:
                self.notifier.ERROR(str(error))
        return imported_modules'''

    def import_modules_from_string(self, modules):
        """ Import the modules from string"""
        try:
            imported_modules = []
            for module in modules:
                imp_module = None
                imp_module = self.import_module_from_string(module)
                if imp_module:
                    imported_modules.append(imp_module)
            return imported_modules
        except Exception as e:
            raise Exception("Exception in import_modules_from_string : %s" % str(e))

    def import_module_from_string(self, module):
        """ Import the module from string"""
        imp_module = None
        try:
            import importlib
            imp_module = importlib.import_module(module)
        except:
            imp_module = __import__(module)
        return imp_module

    def get_doc_string_for_modules(self, ext_module):
        """ Get the doc string foe extension modules"""
        module_doc_strings = []
        try:
            ext_mod = acm.FExtensionModule[ext_module]
            if ext_mod:
                python_exts = ext_mod.GetAllExtensions('FPythonCode')
                module_names = python_exts.Transform('Name', acm.FArray, None)
                module_names = module_names.Transform('Text', acm.FArray, None)
                modules = self.import_modules_from_string(module_names)
                for module in modules:
                    module_doc_strings.append((module.__file__, module.__doc__))
        except Exception as error:
            raise Exception("Exception in get_doc_string_for_modules : %s" % str(error))
        return module_doc_strings

    def python_version(self):
        """ Return python version"""
        python_version = sys.version.split()[0]
        major, minor, micro = python_version.split('.')
        return str(major) + str(minor)

    def create_alias_type(self, alias_on, alias_description, alias_type_name, name):
        acmAlias = None
        if alias_on == 'Party':
            acmAlias = acm.FPartyAliasType.Select("name='%s'" % name)
            alias_on_val = 'Party'
        if alias_on == 'Instrument':
            acmAlias = acm.FInstrAliasType.Select("name='%s'" % name)
            alias_on_val = 'Instr'
        if not acmAlias:
            alias = eval("acm.F" + alias_on_val + "AliasType()")
            alias.AliasTypeDescription(alias_description)
            alias.AliasTypeName(alias_type_name)
            alias.Name(name)
            alias.Type(alias_on)
            alias.Commit()
        else:
            raise AliasTypeAlreadyExist("AliasType <%s> exists on table <%s>" % (alias_type_name, alias_on))

    def isBool(self, input_val):
        """check if the provided input is really a boolean value or not"""
        if isinstance(input_val, str):
            if input_val.upper() in ['FALSE', '0', 'NO']:
                input_val = False
            elif input_val.upper() in ['TRUE', '1', 'YES']:
                input_val = True
            else:
                input_val = None
        elif isinstance(input_val, int):
            if input_val == 0:
                input_val = False
            if input_val == 1:
                input_val = True
        return input_val

    def remove_choicelist_entry(self, choices,
                                choicelists):  # multiple choices can be removed from multiple choicelists.
        """delete the given choicelist entry"""
        for choicelist in choicelists:
            for choice in choices:
                self.remove_element_from_choice_list(choicelist, choice)

    @staticmethod
    def get_acm_version():
        """ Get the acm version"""
        version = None
        try:
            version = (float(".".join(acm.ShortVersion().strip(string.ascii_letters).split(".")[0:2])))
        except:
            val = ".".join(acm.ShortVersion().strip(string.ascii_letters).split(".")[0:2])
            version = (float(val.split('.')[0]))
        return version

    @staticmethod
    def get_acm_version_override():
        """ Override the acm version"""
        context = acm.GetDefaultContext()
        extn = "FIntegrationUtilsOverride"
        config_extension = context.GetExtension("FParameters", "FObject", extn)
        if config_extension:
            ver = config_extension.Value()['ACM_VERSION_OVERRIDE']
            ver = float(ver.Text())
        else:
            ver = FIntegrationUtils.get_acm_version()
        return ver

    def get_dates(self, date_string, instrument=None):
        # Convert yesterday to business day
        valid_date = None
        try:
            date_string_input = date_string.upper()
            if date_string_input == 'Y' or date_string_input == 'YESTERDAY':
                date_string = '-1d'
            try:
                valid_date = ael.date_from_string(date_string)
            except:
                try:
                    valid_date = self.ParseDateField(date_string, instrument)
                except:
                    date_parameter = date_string.upper()
                    if date_parameter.upper() == 'T' or date_parameter.upper() == 'TODAY' or \
                            date_parameter == '':
                        valid_date = ael.date_today()
                    elif date_parameter.upper() == 'Y' or date_parameter.upper() == 'YESTERDAY':
                        valid_date = ael.date_today().add_days(-1)
                    else:
                        print("Please enter dates in formats supported" \
                              + " as mentioned in documentation")
        except Exception as error:
            print("Could not load module ael or incorrect date format.", str(error))

        return valid_date

    def ParseDateField(self, date_parameter, instrument=None):
        valid_date = ''
        try:
            if date_parameter:
                date_string = date_parameter.lstrip('-0123456789')
                days = date_parameter[:len(date_string) * -1]
                calendar = None

                if len(date_string) == 4:  # Business center
                    date_string = date_string.upper()
                    try:
                        calendar = acm.FCalendar.Select01('businessCenter=%s' % date_string, 'Not found')
                        if not calendar:
                            print(
                                "Please enter valid date, Calendar with business center %s not in database" % date_string)
                    except Exception as ex:
                        # For older version of prime where business calendar field not in calendar
                        print("Please enter valid date, Cannot find calendar with business center %s, %s" % (
                            date_string, str(ex)))

                elif len(date_string) == 3:  # Currency
                    date_string = date_string.upper()
                    curr_from_db = acm.FInstrument[date_string]
                    if curr_from_db:
                        calendar = curr_from_db.Calendar()
                    else:
                        print("Please enter valid date, Cannot find currency %s in database" % date_string)

                elif len(date_string) == 1 and date_string == 'd':
                    if instrument:
                        instrument = instrument[0]
                        print("Get instrument <%s> calendar" % instrument.Name())
                        calendar = instrument.SettlementCalendar()
                        if not calendar:
                            if instrument.Currency() and instrument.Currency().Calendar():
                                calendar = instrument.Currency().Calendar()
                    else:
                        valid_date = ael.date_today().add_period(date_parameter)

                else:
                    valid_date = ael.date_today().add_period(date_parameter)

                if calendar and days.lstrip('-').isdigit():
                    valid_date = calendar.AdjustBankingDays(ael.date_today(), int(days))

                if valid_date:
                    valid_date = ael.date_from_string(str(valid_date))
        except Exception as error:
            print("Could not load module ael or incorrect date format.", str(error))

        return valid_date

    def unlink_external_object(self, ael_object):
        if ael_object:
            if ael_object.record_type == 'Instrument':
                ext_obj = acm.FExternalObject.Select("instrument=%d" % ael_object.insaddr)
                if ext_obj:
                    for i in ext_obj[:]:
                        try:
                            i.Instrument = None
                            i.Commit()
                        except Exception as e:
                            raise Exception("Exception in unlink ExternalObject from Instrument : %s" % str(i.insid))
            elif ael_object.record_type == 'Settlement':
                ext_obj = acm.FExternalObject.Select("settlement=%d" % ael_object.seqnbr)
                if ext_obj:
                    for i in ext_obj[:]:
                        try:
                            i.Settlement = None
                            i.Commit()
                        except Exception as e:
                            raise Exception("Exception in unlink ExternalObject from Settlement : %s" % str(i.seqnbr))
            elif ael_object.record_type == 'Confirmation':
                ext_obj = acm.FExternalObject.Select("confirmation=%d" % ael_object.seqnbr)
                if ext_obj:
                    for i in ext_obj[:]:
                        try:
                            i.Confirmation = None
                            i.Commit()
                        except Exception as e:
                            raise Exception("Exception in unlink ExternalObject from Confirmation : %s" % str(i.seqnbr))
            elif ael_object.record_type == 'Party':
                ext_obj = acm.FExternalObject.Select("party=%d" % ael_object.ptynbr)
                if ext_obj:
                    for i in ext_obj[:]:
                        try:
                            i.Party = None
                            i.Commit()
                        except Exception as e:
                            raise Exception("Exception in unlink ExternalObject from Party : %s" % str(i.ptyid))
            elif ael_object.record_type == 'CorpAction':
                ext_obj = acm.FExternalObject.Select("corpAction=%d" % ael_object.seqnbr)
                if ext_obj:
                    for i in ext_obj[:]:
                        try:
                            i.CorpAction = None
                            i.Commit()
                        except Exception as e:
                            raise Exception("Exception in unlink ExternalObject from CorpAction : %s" % str(i.name))

    def create_price_semantic(self, semantic_name, provider_type):
        """Creating price semantic"""
        is_created = False
        semantic_obj = acm.FPriceSemantic[semantic_name]
        if not semantic_obj:
            try:
                priceSemantic = acm.FPriceSemantic()
                priceSemantic.Name(semantic_name)
                priceSemantic.ProviderType(provider_type)
                priceSemantic.Commit()
                is_created = True
            except Exception as e:
                raise Exception('Error creating semantic {} : {}'.format(semantic_name, str(e)))
        else:
            raise AlreadyExist("Semantic {} already exists in db".format(semantic_name))
        return is_created

    def create_marketplace(self, market_place_name):
        """Creating price Market Place"""
        is_created = False
        market_obj = acm.FMarketPlace[market_place_name]
        if not market_obj:

            try:
                party = acm.FMarketPlace()
                party.Name(market_place_name)
                party.Commit()
                is_created = True
            except Exception as e:
                raise Exception('Error creating market place {} : {}'.format(market_place_name, str(e)))
        else:
            raise AlreadyExist("Market Place {} already exists in db".format(market_place_name))
        return is_created

    def create_distributor(self, dist_name, dist_type):
        """Creating price distributor"""
        is_created = False
        dist_obj = acm.FPriceDistributor[dist_name]
        if not dist_obj:
            try:
                price_dist = acm.FPriceDistributor()
                price_dist.Name(dist_name)
                price_dist.DistributorType(dist_type)
                price_dist.Commit()
                is_created = True
            except Exception as e:
                raise Exception('Error creating distributor {} : {}'.format(dist_name, str(e)))
        else:
            raise AlreadyExist("Distributor {} already exists in db".format(dist_name))
        return is_created

    def copy_folder_with_options(self, src_path, dest_path, include_extension='*', ignore_folders=None,
                                 flat_hierarchy=False):
        """
        params:
        source_path = C:\\Users\\E1077313\\Work\\Veracode\\SwiftIntegration
        destination_path = C:\\Users\\E1077313\\Work\\Veracode\\ScanReady
        extension_to_copy = ['.py']
        flat_hierarchy=False, Controls whether to imitate the tree structure or copy all files in the single folder
        folders_to_skip = ['XSD', 'Parameters', 'BindingModules', 'FSwiftCustomMessage', 'LongForm','MiFIDII',
        'RegulatoryInfo','STRATE','__pycache__','TemplateFiles','FSwiftXSDGenerator','ClassDiagram','SampleMessages',
        'lib','AsgardTests','build','Deprecated','Design & Analysis','SwiftWriterExample']

        Usage:
        copy_folder_with_options(source_path, destination_path, extension_to_copy, folders_to_skip, flat_hierarchy)
        """
        import shutil

        def copy_folder(src_path, dest_path):
            file_copy_counter = 0
            scan_iter = os.scandir(src_path)
            for entry in scan_iter:
                dest_dir_or_file = dest_path + '\\' + entry.name
                src_dir_or_file = src_path + '\\' + entry.name
                file_or_folder_name = entry.name

                if flat_hierarchy:
                    dest_dir_or_file = dest_path

                if entry.is_dir():
                    if ignore_folders is None or (
                            ignore_folders is not None and file_or_folder_name not in ignore_folders):
                        if not flat_hierarchy:
                            os.makedirs(dest_dir_or_file)
                        file_copy_counter += copy_folder(src_dir_or_file, dest_dir_or_file)
                else:
                    file_ext = os.path.splitext(file_or_folder_name)[1]
                    copy_file = include_extension == '*' or file_ext in include_extension
                    if copy_file:
                        name = os.path.basename(src_dir_or_file)
                        if os.path.exists(os.path.join(dest_dir_or_file, name)):
                            print('The file is duplicate and has been overwritten', src_dir_or_file)
                        shutil.copy2(src_dir_or_file, dest_dir_or_file)
                        file_copy_counter += 1
            scan_iter.close()
            return file_copy_counter

        def clean_folder(dest_path):
            try:
                scan_iter = os.scandir(dest_path)
            except FileNotFoundError:
                if flat_hierarchy:  # Create the distination path only once
                    os.mkdir(dest_path)
                return

            for entry in scan_iter:
                dest_dir_or_file = dest_path + '\\' + entry.name
                if entry.is_dir():
                    shutil.rmtree(dest_dir_or_file)
                else:
                    os.remove(dest_dir_or_file)
            scan_iter.close()

        clean_folder(dest_path)
        return copy_folder(src_path, dest_path)

    def trigger_event(self, bpr, event_name, notes=None, param=None):
        """ Trigger event on given business process"""
        if bpr and bpr.CanHandleEvent(event_name):
            curr_step = bpr.CurrentStep()
            target_state = curr_step.TargetState(event_name).Name()
            notes_collection = [str(notes)] if notes else None
            bpr_clone = bpr.Clone()
            bpr_clone.HandleEvent(event_name, param, notes_collection)
            bpr.Apply(bpr_clone)
            bpr.Commit()
            return bpr

    def create_task(self, taskname, ael_params, moduleName='FArchiveBusinessProcesses'):
        """ Create the Task"""
        try:
            task_obj = acm.FAelTask[taskname]
            if not task_obj:
                task_obj = acm.FAelTask()
                task_obj.Name(taskname)
                task_obj.ModuleName(moduleName)
                task_obj.Parameters(ael_params)
                task_obj.Commit()
                return task_obj
        except Exception as e:
            raise Exception("Error occurred in create_or_update_task: %s" % str(e))

    def create_business_process_archive_task(self, sc_states, sc_name, sc_date='First of Month'):
        """ Creates archive tasks"""
        ael_params = {}
        ael_params['Date'] = sc_date
        task_exists_already = False
        expected_states = [state.Name() for state in acm.FStateChart[sc_name].States()]
        if sc_states not in expected_states:
            raise Exception('Error while creating archive task.'
                            'got invalid state.Got {0}.Expected states {1}'.format(sc_states, expected_states))
        ael_params['StateChart'] = sc_name
        ael_params['States'] = sc_states

        task_name = "Archive{}BusinessProcess".format(sc_name)

        if self.create_task(task_name, ael_params) is None:
            task_exists_already = True
        return task_exists_already

    def get_state_chart_states(self, sc_name):
        """ Get the states for given state chart"""
        sc = acm.FStateChart[sc_name]
        return sc.States().Transform('Name', acm.FArray, None) if sc else []

    def get_fparameter_value(self, context, module, parameter):
        """ Get FParameter value
        :param context: Extension context
        :param module: Extension module from context
        :param FParameter: FParameter name from module specifed
        :return: FParameter value
        """
        param_value = ''
        try:
            if context:
                ext_context = acm.FExtensionContext[context]
                if ext_context:
                    param_config = ext_context.GetExtension('FParameters', 'FObject', module)
                    if param_config:
                        param_value = param_config.Value().At(parameter)
        except Exception as error:
            print(str(error))
        return param_value

    def connect_amb(self, application, amb_address=None):
        """ Connect to AMB
        :param amb_address: AMB connection string (Host:Port)
        :return: bool: True if connected else False
        """
        is_connected = False
        amb_addr = ""
        ambUser = ""
        ambPassword = ""
        
        if not amb_address:
            amb_address = self.get_fparameter_value(acm.GetDefaultContext().Name(), 'FIntegrationUtilsAMBConfig',
                                                    'FINTEGRATIONUTILS_AMB_DETAILS')
    
            if not amb_address:
                print("AMB details not present in FIntegrationUtils FParameter. Hence unable to connect to AMB.")
                return is_connected
        
        amb_details = amb_address.split("/")
        if len(amb_details) > 0 and amb_details[0]:
            amb_addr = amb_details[0]
        if len(amb_details) > 1 and amb_details[1]:
            ambUser = amb_details[1]
        if len(amb_details) > 2 and amb_details[2]:
             ambPassword = amb_details[2]     
        
        if hasattr(acm, 'AMBUtils') and hasattr(acm.AMBUtils, 'ConnectToAMB'):
            try:
                acm.AMBUtils.ConnectToAMB(amb_addr, application, ambUser)
                is_connected = True
                print("Connected to AMB '%s'." % amb_addr)
            except Exception as error:
                print("Cannot connect to AMB using ConnectToAMB(). ",error)
        else:
            print("AMBUtils.ConnectToAMB() not found. Trying connecting mb_init()")
            if not is_connected:
                try:
                    amb.mb_init(amb_address)
                    is_connected = True
                    print("Connected to AMB '%s'." % amb_addr)
                except Exception as error:
                    print("Could not connect to AMB '%s'. %s" % (amb_addr, str(error)))
                    try:
                        if hasattr(amb, 'mb_enable_unicode'):
                            amb.mb_enable_unicode()
                            amb.mb_init(amb_address)
                            is_connected = True
                            print("Connected to unicode AMB '%s'." % amb_addr)
                        else:
                            print("Could not connect to unicode AMB, because 'amb' has no attribute 'mb_enable_unicode'.")
                    except Exception as error:
                        print("Could not connect to unicode AMB '%s'. %s" % (amb_addr, str(error)))
        
        return is_connected


class FManageOperation(object):
    @staticmethod
    def get_operation_component_type():
        """ Get Operation component type"""
        componentTypes = acm.FEnumeration['enum(ComponentType)']
        return componentTypes.Enumeration('Operation')

    @staticmethod
    def user_has_operation_permission(user, operation):
        """ Returns True if user has permission else False"""
        return user.IsAllowed(operation, FManageOperation.get_operation_component_type())

    @staticmethod
    def operation_exists(operation):
        """ Returns true if given operation exists else False"""
        is_operation_exist = True
        compType = 'Operation'
        queryString = 'name=\'%s\' and type=\'%s\'' % (operation, compType)
        op = acm.FComponent.Select01(queryString, '')
        if op is None:
            is_operation_exist = False
        return is_operation_exist

    @staticmethod
    def add_operation(operationName):
        """ Add component of type operation"""
        operation_exists_already = True
        if not FManageOperation.operation_exists(operationName):
            operation = FManageOperation.get_operation_component_type()
            component = acm.FComponent()
            component.Name(operationName)
            component.Type(operation)
            component.Commit()
            operation_exists_already = False
        return operation_exists_already

    @staticmethod
    def HasUserRights(operationName):
        """ Check if the calling user has the permission to perform operation"""
        has_right = True
        if FManageOperation.operation_exists(operationName):
            if not FManageOperation.user_has_operation_permission(acm.User(), operationName):
                has_right = False
        return has_right


class FParamsEncode(object):
    def __init__(self):
        self.__key = 'FrontArenaOTC'
        self.__key = self.__key

    def get_key(self):
        return self.__key

    def set_encrypted_password(self, content):
        """set the encoded value for the given content"""
        enc = []
        for i in range(len(content)):
            key_c = self.__key[i % len(self.__key)]
            enc_c = chr((ord(content[i]) + ord(key_c)) % 256)
            enc.append(enc_c)
        if sys.version_info[0] < 3:
            encoded_value = '0x4' + base64.urlsafe_b64encode("".join(enc))
        else:
            enc_string = "".join(enc)
            enc_encoded = enc_string.encode('UTF-8')
            encoded_value = base64.urlsafe_b64encode(enc_encoded)
            encoded_value = b'0x4' + encoded_value
        return encoded_value

    def get_decrypted_password(self, content):
        """get the encoded value for the given content"""
        dec = []
        content = content[3:]
        if sys.version_info[0] < 3:
            enc = base64.urlsafe_b64decode(content)
        else:
            enc = base64.urlsafe_b64decode(content).decode('UTF-8')
        for i in range(len(enc)):
            key_c = self.__key[i % len(self.__key)]
            dec_c = chr((256 + ord(enc[i]) - ord(key_c)) % 256)
            dec.append(dec_c)
        return "".join(dec)

    def get_string(self, content):
        try:
            if isinstance(content, bytes):
                content = content.decode('utf-8')
        except:
            pass
        try:
            if isinstance(content, unicode):
                content = content.encode('ascii', 'replace')
        except:
            pass
        return content


# -----------------exception classes---------------------------------------------------

class AddInfoSpecAlreadyExits(Exception):
    def _set_message(self, message):
        self.message = message

    def _get_message(self):
        return self.message

    message = property(_get_message, _set_message)


class AddInfoSpecNotExist(Exception):
    def _set_message(self, message):
        self.message = message

    def _get_message(self):
        return self.message

    message = property(_get_message, _set_message)


class ChoiceListAlreadyExist(Exception):
    def _set_message(self, message):
        self.message = message

    def _get_message(self):
        return self.message

    message = property(_get_message, _set_message)


class ChoiceListNotFound(Exception):
    def _set_message(self, message):
        self.message = message

    def _get_message(self):
        return self.message

    message = property(_get_message, _set_message)


class AliasTypeSpecNotExist(Exception):
    def _set_message(self, message):
        self.message = message

    def _get_message(self):
        return self.message

    message = property(_get_message, _set_message)


class AdditionalInfoSpecNotExist(Exception):
    def _set_message(self, message):
        self.message = message

    def _get_message(self):
        return self.message

    message = property(_get_message, _set_message)


class AliasTypeAlreadyExist(Exception):
    def _set_message(self, message):
        self.message = message

    def _get_message(self):
        return self.message

    message = property(_get_message, _set_message)


class AlreadyExist(Exception):
    def _set_message(self, message):
        self.message = message

    def _get_message(self):
        return self.message

    message = property(_get_message, _set_message)


def RemoveOperationsDocument(settlementOrConfirmation):
    if settlementOrConfirmation.Status() == "Pending Cancellation":
        return RemoveOperationsDocumentPendingCancellation()
    else:
        return RemoveOperationsDocumentDefault(settlementOrConfirmation)


def RemoveOperationsDocumentPendingCancellation():
    query = acm.CreateFASQLQuery(acm.FOperationsDocument, 'AND')
    orNode = query.AddOpNode('OR')
    AddCancellationNodeTree(orNode)
    return query.Select()


def RemoveOperationsDocumentDefault(settlementOrConfirmation):
    query = acm.CreateFASQLQuery(acm.FOperationsDocument, 'AND')
    orNode = query.AddOpNode('OR')

    if settlementOrConfirmation.IsKindOf(acm.FSettlement):
        query.AddAttrNode('Settlement.Oid', 'EQUAL', settlementOrConfirmation.Oid())
    if settlementOrConfirmation.IsKindOf(acm.FConfirmation):
        query.AddAttrNode('Confirmation.Oid', 'EQUAL', settlementOrConfirmation.Oid())

    orNode.AddAttrNode('Status', 'EQUAL', OPERATIONS_DOCUMENT_STATUS.EXCEPTION)
    orNode.AddAttrNode('Status', 'EQUAL', OPERATIONS_DOCUMENT_STATUS.SEND_FAILED)
    orNode.AddAttrNode('Status', 'EQUAL', OPERATIONS_DOCUMENT_STATUS.GENERATED)
    orNode.AddAttrNode('Status', 'EQUAL',
                       OPERATIONS_DOCUMENT_STATUS.PENDING_GENERATION)  # Since we are changing the OperationDocumentStatus to PENDING_GENERATION
    AddCancellationNodeTree(orNode)
    return RemoveAckedOpdocsThatAreCancelled(query.Select(), settlementOrConfirmation)


def AddCancellationNodeTree(parentNode):
    """Tree for finding operations documents belonging to n92 settlements no
    matter if they failed or were successful. This search is needed in order to
    clean opdocs before resending the settlement in status Release/Pending Cancellation."""
    cancellationNode = parentNode.AddOpNode('AND')
    cancellationStatusNode = cancellationNode.AddOpNode('OR')

    cancellationStatusNode.AddAttrNode('Status', 'EQUAL', OPERATIONS_DOCUMENT_STATUS.SEND_FAILED)
    cancellationStatusNode.AddAttrNode('Status', 'EQUAL', OPERATIONS_DOCUMENT_STATUS.SENT_SUCCESSFULLY)
    cancellationMtsNode = cancellationNode.AddOpNode('OR')
    cancellationMtsNode.AddAttrNode('SwiftMessageType', 'EQUAL', 192)
    cancellationMtsNode.AddAttrNode('SwiftMessageType', 'EQUAL', 192199)
    cancellationMtsNode.AddAttrNode('SwiftMessageType', 'EQUAL', 292)
    cancellationMtsNode.AddAttrNode('SwiftMessageType', 'EQUAL', 292299)


def RemoveAckedOpdocsThatAreCancelled(selection, rec):
    """Deployed selection-list will be extended with already cancelled opdocs.
    Applies only for settlements."""
    if not rec.IsKindOf(acm.FSettlement):
        return selection
    ackedMTs = []
    cancellationMTs = []
    for opdoc in rec.Documents():
        if (opdoc.Status() == OPERATIONS_DOCUMENT_STATUS.SENT_SUCCESSFULLY) or opdoc.Status() == 'Sent successfully':
            if str(opdoc.SwiftMessageType()).find("92") > -1:
                cancellationMTs.append(opdoc)
            else:
                ackedMTs.append(opdoc)

    if len(ackedMTs) <= len(cancellationMTs):
        # match so that already sent MT is cancelled, then it is ok to remove opdoc
        for mtOrig in ackedMTs:
            if mtOrig not in selection:
                selection.Add(mtOrig)

    return selection


def _assertIsSettlementOrConfirmation(fObject):
    assert hasattr(fObject, 'IsKindOf') and (fObject.IsKindOf(acm.FSettlement) or fObject.IsKindOf(
        acm.FConfirmation)), "Argument not of type FSettlement or FConfirmation"


def InSendDocumentStatus(fObject):
    """ Function InSendDocumentStatus
        Returns True if the FObject has a status which allows for
        the dispatch of an FOperationsDocument

        INPUT:  FObject fObject (FSettlement or FConfirmation)
        OUTPUT: bool True or False                                  """

    _assertIsSettlementOrConfirmation(fObject)
    return FOperationsDocumentProcess.InSendDocumentStatus(fObject)


class StateChartCreator(object):
    """
    This class provides helper function to create statechart.
    """
    @staticmethod
    def get_states(definition):
        """Get state names from transition dictionary."""
        state_names = set(definition.keys())  # Get from_state
        for all_transitions in list(definition.values()):  # Get to_state for each from_state
            to_states = set(all_transitions.values())
            state_names = state_names | to_states  # Add to_state to from_state
        return state_names

    @staticmethod
    def create_states(sc, state_names):
        """Create states for given state chart"""
        existing_states = sc.StatesByName()
        for state_name in state_names:
            if state_name not in existing_states:
                sc.CreateState(state_name)
        sc.Commit()

    @staticmethod
    def create_transitions(sc, definition):
        """Create events for given state chart from transition dictionary."""
        states = sc.StatesByName()
        for state_name, transitions in list(definition.items()):
            state = states.At(state_name)
            for event_name, to_state_name in list(transitions.items()):
                event = acm.FStateChartEvent(event_name)
                if state.TransitionForEvent(event) and state.TransitionForEvent(
                        event).ToState().Name() != to_state_name:
                    transition = state.TransitionForEvent(event)
                    transition.Delete()
                if not state.TransitionForEvent(event):
                    to_state = states.At(to_state_name)
                    state.CreateTransition(event, to_state)
        sc.Commit()

    @staticmethod
    def layout_state_chart(state_chart_name, co_string):
        """ Layout state chart with the given name from given coordinate string. """
        state_chart = acm.FStateChart[state_chart_name]
        if not state_chart:
            raise Exception("The state chart %s is not present in ADS." % state_chart_name)
        else:
            state_chart.Layout().Text(co_string)
            state_chart.Layout().Commit()

    @staticmethod
    def create_state_chart(state_chart_name, definition, old_state_chart_name=''):
        """Creates a state chart with the given name, if required.

        The definition parameter must completely define the content of the business
        process state chart, including all states and transitions between them. Its
        format is a dictionary of states mapped to a dictionary of transitions as
        event->next_state items, e.g.:

          {'state a':  {'event to go to b': 'state b', 'event to go to c': 'state c'}}

        All defined next_states values must be unique within a state's transitions
        (i.e. multiple events cannot lead to the same next_state).

        """
        if old_state_chart_name:
            sc = acm.FStateChart[old_state_chart_name]
            if sc:
                raise Exception("The old state chart <%s> still exists in system." % old_state_chart_name)
        sc = acm.FStateChart[state_chart_name]
        if not sc:
            sc = acm.FStateChart(name=state_chart_name)
        state_names = StateChartCreator.get_states(definition)
        StateChartCreator.create_states(sc, state_names)
        StateChartCreator.create_transitions(sc, definition)
        return sc


...

  FSFTPOperations
"""--------------------------------------------------------------------
MODULE
    FSFTPOperations -  Operations like reading and writing to SFTP server

DESCRIPTION
    This script handles the SFTP operations.

VERSION: 2.0.4

--------------------------------------------------------------------"""
import os
import fnmatch
import sys
import time
import ntpath
import FFTPConfig
import FFTPLibHooks
import FFTPNotification
import FIntegrationUtils
import FSFTPOperationsOverride

logger = FFTPNotification.FFTPLogger('FFTPLibrary')


class SFTPOperations(object):
    def __init__(self, app_name, host=None, port=None, user=None, pwd=None, timeout=0, interval=0, retry=0, proxy_hostname=None, proxy_portnumber=None, config_variables_obj=None, *args):
        self.sftp = None
        self.host = host
        self.port = port
        self.user = user
        self.application_name = app_name
        self.proxy_host = proxy_hostname
        self.proxy_port = proxy_portnumber
        self.pwd = pwd
        if not self.pwd:
            try:
                import FPassword
                self.pwd = FPassword.get_external_password(self.application_name)
                logger.DEBUG("import FPassword module")

            except:
                logger.INFO("Could not import FPassword module")

        self.timeout = timeout
        self.interval = interval
        self.retry = retry
        self.transport = None
        self.utilsobj = FIntegrationUtils.FParamsEncode()
        self.config_data = config_variables_obj.config_data if config_variables_obj else {}

        self.read_mode = self.config_data.get('FROM_MODE', 'SFTP')
        self.write_mode = self.config_data.get('TO_MODE', '')
        self.sftp = self.connect()

    @classmethod
    def initialize(cls, mode, reader, task_parameters, config_variables_obj=None):
        """Read the config parameters and initialize the SFTP connection"""
        conn = False
        ftp_config_param = FFTPConfig.Parameters('FFTPSettings')
        interval = getattr(ftp_config_param, 'POLL_INTERVAL', '')
        timeout = getattr(ftp_config_param, 'POLL_TIMEOUT', '')
        retry = getattr(ftp_config_param, 'POLL_RETRY', '')
        mode_config_param = FFTPConfig.Parameters('FFTPModeSettings_' + mode)
        if mode.split('-')[0] == 'SFTP' and reader:
            if task_parameters:
                host = task_parameters.get('READ_HOST', '')
                port = task_parameters.get('READ_PORT', '')
                user = task_parameters.get('READ_USER', '')
                pwd = task_parameters.get('READ_PASSWORD', '')
            else:
                host = getattr(mode_config_param, 'READ_HOST', '')
                port = getattr(mode_config_param, 'READ_PORT', '')
                user = getattr(mode_config_param, 'READ_USER', '')
                pwd = getattr(mode_config_param, 'READ_PASSWORD', '')
                if not (host and port and user and pwd):
                    host = getattr(ftp_config_param, 'READ_HOST', '')
                    port = getattr(ftp_config_param, 'READ_PORT', '')
                    user = getattr(ftp_config_param, 'READ_USER', '')
                    pwd = getattr(ftp_config_param, 'READ_PASSWORD', '')
        elif mode.split('-')[1] == 'SFTP':
            if task_parameters:
                host = task_parameters.get('WRITE_HOST', '')
                port = task_parameters.get('WRITE_PORT', '')
                user = task_parameters.get('WRITE_USER', '')
                pwd = task_parameters.get('WRITE_PASSWORD', '')
            else:
                host = getattr(mode_config_param, 'WRITE_HOST', '')
                port = getattr(mode_config_param, 'WRITE_PORT', '')
                user = getattr(mode_config_param, 'WRITE_USER', '')
                pwd = getattr(mode_config_param, 'WRITE_PASSWORD', '')
                if not (host and port and user and pwd):
                    host = getattr(ftp_config_param, 'WRITE_HOST', '')
                    port = getattr(ftp_config_param, 'WRITE_PORT', '')
                    user = getattr(ftp_config_param, 'WRITE_USER', '')
                    pwd = getattr(ftp_config_param, 'WRITE_PASSWORD', '')

        obj = cls(host, port, user, pwd, timeout, interval, retry)
        if not obj.sftp:
            return None
        return obj

    def connect(self):
        """Connect to SFTP server via Chilkat"""
        self.sftp = None
        proxyPort = ''
        Port = ''
        proxyHost=self.proxy_host
        if self.proxy_port:
            proxyPort=int(self.proxy_port)
        HostName=self.host
        if self.port:
            Port=int(self.port)
        username=self.user
        password=self.pwd
        self.sftp=FSFTPOperationsOverride.connect_override(proxyHost, proxyPort, HostName, Port, username, password)

        if not self.sftp or self.sftp == None:

            self.sftp = self.connect_chilkat()
        return self.sftp


    def connect_chilkat(self):

        sftp = None
        proxyPort = ''
        try:
            from chilkat import chilkat

            try:
                glob = chilkat.CkGlobal()
                success = glob.UnlockBundle("FSLTNS.CB4032023_xPv5yNngkRpl")
                sftp = chilkat.CkSFtp()
                proxyHost=self.proxy_host
                if self.proxy_port:
                    proxyPort=int(self.proxy_port)
                HostName=self.host
                if self.port:
                    Port=int(self.port)
                username=self.user
                password=self.pwd

                if proxyPort and proxyHost:
                    sftp.put_HttpProxyHostname(proxyHost)
                    sftp.put_HttpProxyPort(proxyPort)
                    logger.INFO("Connecting to %s server using chilkat with proxy host %s and port %s" % (self.host, proxyHost, proxyPort ))

                success = sftp.Connect(HostName,Port)
                if (success != True):
                    print(sftp.lastErrorText())


                ret_task = sftp.AuthenticatePw(username,password)
                if (ret_task != True):
                    print(sftp.lastErrorText())
                status = sftp.InitializeSftp()

                if status:
                    logger.DEBUG("Connected to {} server using chilkat".format(self.host))
                else:
                    logger.ERROR("Unable to Connect to {} server using chilkat.Please refer chilkat logs for reference".format(self.host))
                    sftp = None
            except Exception as e:
                logger.ERROR("Exception in connecting to {} server using chilkat".format(self.host))
                logger.DEBUG(str(e), exc_info=1)
                sftp = None
        except Exception as e:
            logger.WARN("%s" % e)
            sftp = None
        return sftp

    def checkIfFileExists(self, filename, sftpdir=None, sftp=None):
        """Check if filename exists on sftp server"""
        reportExists = False
        if sftp:
            self.sftp = sftp
        fullFileName = os.path.join(sftpdir, filename)
        try:
            status = self.sftp.FileExists(fullFileName, True)
            if status < 0:
                logger.ERROR("Error while checking file on SFTP server : {}".format(sftp.lastErrorText()))
            elif status:
                logger.DEBUG("File: <{0}> exists on SFTP server".format(filename))
                reportExists = True

        except Exception as e:
            logger.ERROR("Exception while checking file at SFTP server using chilkat")
            logger.ERROR(str(e), exc_info=1)

        return reportExists

    def retry_sftp_connection(self):
        """Retry the SFTP connection if connections fails in between"""
        sftp_connected = False
        poll_retry = int(self.retry)
        logger.INFO("Re-conneting SFTP server")
        for i in range(0, poll_retry + 1):
            if self.interval:
                retry_interval = self.interval
            else:
                retry_interval = 10
            logger.INFO("~ %s" % str(retry_interval))
            time.sleep(int(retry_interval))
            # logger.DEBUG("Reconnecting to server")
            connected = self.connect()
            if connected:
                sftp_connected = True
                break
        return sftp_connected

    def poll_until_timeout(self, file_name, timeout, interval):

        """This method polls to FTP for a given time period at given
        interval of time If the reply file is
        present before the timeout then the result is returned.

        """
        self.time_seconds = 0
        poll_start_time = time.time()
        if int(timeout):
            logger.INFO("Waiting for a file to download")
            while self.time_seconds < int(timeout):

                time.sleep(float(interval))
                seconds = str(self.time_seconds + \
                              int(interval)) + 's'
                msg = '~' + str(seconds) + ' ...'
                logger.INFO(msg)
                file_list = self.__poll_for_file(file_name)
                if file_list:
                    return file_list

                self.time_seconds = self.time_seconds + \
                                    int(interval)
        else:
            file_list = self.__poll_for_file(file_name)
        return file_list

    def __poll_for_file(self, file_name):
        """This method polls for the reply file at ftp.
        True - if file exists at ftp server.
        false - if no file exists at ftp server.

        """
        sftp_connection = True
        filter_file_lst = []
        try:
            file_lst = self.sftp.listdir()
            filter_file_lst = fnmatch.filter(file_lst, file_name)
        except Exception as e:
            error_message = "Error while fetching reply file from FTP server"
            logger.ERROR(error_message)
            logger.ERROR(str(e))
            if 'Server connection dropped' in str(e):
                sftp_connection = False

        if not sftp_connection:
            logger.WARN("SFTP is down, Trying to connect again")
            connected = self.retry_sftp_connection()
            if connected:
                self.__poll_for_file(file_name)

        return filter_file_lst





    def upload_file(self, file_path, upload_dir=None):
        """Uploads a file to the FTP server.
        storbinary is used to store the file in the binary format.
        Input - request file name to upload, request file path.

        """
        result = 0
        sftp = self.sftp

        result = FSFTPOperationsOverride.upload_file_override(sftp, file_path, upload_dir=None)

        if result == 0:
            result = self.upload_file_using_chilkat(file_path, upload_dir)
        return result



    def upload_file_using_chilkat(self, file_path, upload_dir):
        """ Upload file at SFTP server using putty """
        logger.DEBUG("Uploading file using Chilkat")
        file_name = os.path.split(file_path)[-1]
        file_path = FFTPLibHooks.fftplibrary_import_exit(self.read_mode, self.write_mode, file_path)
        proxyPort = ''
        Port = ''
        result = 0
        if not file_path or not type(file_path) == str:
            logger.WARN("Value returned from fftplibrary_import_exit is {} not supported".format(str(file_path)))
            return 0
        if os.path.isfile(file_path):
            try:
                from chilkat import chilkat

                try:
                    glob = chilkat.CkGlobal()
                    success = glob.UnlockBundle("FSLTNS.CB4032023_xPv5yNngkRpl")
                    sftp = chilkat.CkSFtp()
                    proxyHost=self.proxy_host
                    if self.proxy_port:
                        proxyPort=int(self.proxy_port)
                    HostName=self.host
                    if self.port:
                        Port=int(self.port)
                    username=self.user
                    password=self.pwd

                    if proxyPort and proxyHost:
                        sftp.put_HttpProxyHostname(proxyHost)
                        sftp.put_HttpProxyPort(proxyPort)

                    success = sftp.Connect(HostName,Port)
                    if (success != True):
                        print(sftp.lastErrorText())

                    ret_task = sftp.AuthenticatePw(username,password)
                    status = sftp.InitializeSftp()
                    if upload_dir:
                        remoteFilePath = upload_dir + '/' + file_name
                    else:
                        remoteFilePath = file_name

                    localFilePath =file_path
                    success = sftp.UploadFileByName(remoteFilePath, localFilePath)

                    if status:
                        logger.INFO("File uploaded to SFTP server %s at directory %s" % (file_name, upload_dir))
                        result = 1
                    else:
                        result = 0
                        logger.INFO("Failed to uploaded to SFTP server %s at directory %s" % (file_name, upload_dir))
                        logger.ERROR("possible error {}  using chilkat".format(sftp.lastErrorText()))

                except Exception as e:
                    logger.ERROR("Exception in connecting to {} server using chilkat".format(self.host))
                    logger.DEBUG(str(e), exc_info=1)
            except Exception as e:
                logger.WARN("%s" % e)

        else:
            logger.ERROR("File %s does not exist" % file_path)

        return result


    def download_file(self, filename_lst, download_dir, sftp_dir):
        """Download file from SFTP server"""
        result = 0
        sftp = self.sftp
        timeout = self.timeout
        interval = self.interval
        result = FSFTPOperationsOverride.polling_for_override(sftp, timeout, interval, filename_lst, download_dir, sftp_dir)
        if result == 0:
            result = self.polling_for_chilkat(filename_lst, download_dir, sftp_dir)
        return result



    def polling_for_chilkat(self, filename_lst, download_dir, sftp_dir=None):
        """Downloads a file from the FTP.
        retrbinary is used to download binary files.
        Input - reply file name, reply file path to download.
        Output - reply file from FTP server.

        """
        result = 0
        try:
            logger.DEBUG("Downloading files to dir <%s>" % download_dir)
            for file_name in filename_lst:
                file_path = os.path.join(download_dir, file_name)
                file_path, destination_path = FFTPLibHooks.fftplibrary_export_entry(self.read_mode,
                                                                                    self.write_mode, file_path)
                if file_path and type(file_path) == str:
                    if destination_path:
                        if self.write_mode == 'DIR':
                            download_dir = destination_path
                        else:
                            self.config_data['TEMP_{}-{}'.format(self.read_mode, self.write_mode)][
                                file_path] = destination_path

                    result = self.chilkat_poll_until_timeout(self.timeout, self.interval, file_name,
                                                           download_dir, sftp_dir)
                else:
                    result = 0

        except Exception as ex:
            logger.ERROR("Error while downloading file from SFTP")
            logger.ERROR(str(ex))
            result = 0

        return result




    def chilkat_poll_until_timeout(self, timeout, interval, filename, download_dir, sftp_dir):
        """This method polls to FTP for a given time period at given
        interval of time If the reply file is
        present before the timeout then the result is returned.
        """
        result = 0
        self.time_seconds = 0
        poll_start_time = time.time()
        if int(timeout):
            logger.INFO("Waiting for a file to download")
            while self.time_seconds < int(timeout):

                time.sleep(float(interval))
                seconds = str(self.time_seconds + \
                              int(interval)) + 's'
                msg = '~' + str(seconds) + ' ...'
                logger.INFO(msg)
                result, err_log = self.download_file_using_chilkat(filename, download_dir, sftp_dir)
                if result:
                    return result
                elif err_log:
                    logger.DEBUG('%s' % err_log)

                self.time_seconds = self.time_seconds + \
                                    int(interval)
        else:
            result, err_log = self.download_file_using_chilkat(filename, download_dir, sftp_dir)
            if err_log:
                logger.DEBUG('%s' % err_log)
        return result


    def download_file_using_chilkat(self, file_name, download_dir, sftp_dir):
        """ Download file using Putty """
        result = 0
        error_log = ''
        output = ''
        destination_path = ''
        proxyPort = ''
        Port = ''

        logger.DEBUG("Downloading file using Chilkat")
        try:
            from chilkat import chilkat

            try:
                glob = chilkat.CkGlobal()
                success = glob.UnlockBundle("FSLTNS.CB4032023_xPv5yNngkRpl")
                sftp = chilkat.CkSFtp()
                proxyHost=self.proxy_host
                if self.proxy_port:
                    proxyPort=int(self.proxy_port)
                HostName=self.host
                if self.port:
                    Port=int(self.port)
                username=self.user
                password=self.pwd

                if proxyPort and proxyHost:
                    sftp.put_HttpProxyHostname(proxyHost)
                    sftp.put_HttpProxyPort(proxyPort)

                success = sftp.Connect(HostName,Port)
                if (success != True):
                    print(sftp.lastErrorText())


                ret_task = sftp.AuthenticatePw(username,password)
                status = sftp.InitializeSftp()
                if sftp_dir:
                    remoteFilePath = sftp_dir + '/' + file_name
                else:
                    remoteFilePath = file_name

                localpath =download_dir + '/' + file_name
                success = sftp.DownloadFileByName(remoteFilePath, localpath)

                if success and os.path.isfile(localpath):
                    localpath, destination_path = FFTPLibHooks.fftplibrary_export_exit(self.read_mode, self.write_mode,
                                                                                   localpath)
                if localpath and os.path.isfile(localpath):
                    if type(localpath) == str:
                        if destination_path:
                            self.config_data['TEMP_{}-{}'.format(self.read_mode, self.write_mode)][
                                localpath] = destination_path
                        logger.DEBUG("Downloaded file <%s> from SFTP server" % file_name)
                        result = 1
                    else:
                        logger.WARN("Value returned from fftplibrary_export_exit is {} not supported".format(
                            str(localpath)))
                else:
                    result = 0

            except Exception as e:
                logger.ERROR("Exception in connecting to {} server using chilkat".format(self.host))
                logger.DEBUG(str(e), exc_info=1)
        except Exception as e:
            logger.WARN("%s" % e)

        return result, error_log


    def read(self, sftp_dir, dest_dir, file_list):
        if not self.sftp:
            self.sftp = self.connect()
        file_path_list = []

        result = self.download_file(file_list, dest_dir, sftp_dir)
        if result:
            file_list = os.listdir(dest_dir)
            # file_path_list = [os.path.join(dest_dir, filename)]
            file_path_list = [os.path.join(dest_dir, each_file) for each_file in file_list]
            # file_path_list = [ filename]

        return file_path_list

    def write(self, file_path_list, sftp_dir, temp_dest_dict={}):
        """Upload files to the SFTP server"""
        files_written_to_dest = []

        if not self.sftp:
            self.sftp = self.connect()

        for file_path in file_path_list:
            temp_file_path = file_path
            if temp_dest_dict:
                temp_dest = temp_dest_dict.get(file_path)
                if temp_dest:
                    sftp_dir = temp_dest
            file_ref = FFTPLibHooks.fftplibrary_import_entry(self.read_mode, self.write_mode, file_path)
            if file_ref and type(file_ref) == str:
                file_path = file_ref
                result = self.upload_file(file_path, sftp_dir)
                if result:
                    files_written_to_dest.append(file_path)
            else:
                logger.WARN(
                    "File {} is filtered in fftplibrary_import_entry which returned value : {}".format(temp_file_path,
                                                                                                       str(file_ref)))

        return files_written_to_dest

    def close_connection(self):
        """Close the SFTP connection"""
        '''
        
        '''


    def list_from_sftp( self, sftp_dir):
        """ gives list of file from SFTP server """
        try:
            from chilkat import chilkat
            proxyPort = ''
            file_List = []
            try:
                glob = chilkat.CkGlobal()
                success = glob.UnlockBundle("FSLTNS.CB4032023_xPv5yNngkRpl")
                sftp = chilkat.CkSFtp()
                proxyHost = self.proxy_host
                if self.proxy_port:
                    proxyPort = int(self.proxy_port)
                HostName = self.host
                if self.port:
                    Port = int(self.port)
                username = self.user
                password = self.pwd
                if proxyPort and proxyHost:
                    sftp.put_HttpProxyHostname(proxyHost)
                    sftp.put_HttpProxyPort(proxyPort)
                success = sftp.Connect(HostName,Port)
                if (success != True):
                    logger.ERROR(sftp.lastErrorText())
                ret_task = sftp.AuthenticatePw(username,password)
                if (ret_task != True):
                    logger.ERROR(sftp.lastErrorText())
                status = sftp.InitializeSftp()
                handle = sftp.openDir(sftp_dir)
                if (sftp.get_LastMethodSuccess() != True):
                    logger.ERROR(sftp.lastErrorText())# dirListing is a CkSFtpDir
                dirListing = sftp.ReadDir(handle)
                if (sftp.get_LastMethodSuccess() != True):
                    logger.ERROR(sftp.lastErrorText())# Iterate over the files.
                i = 0
                n = dirListing.get_NumFilesAndDirs()
                while i < n :# fileObj is a CkSFtpFile
                    fileObj = dirListing.GetFileObject(i)
                    file = fileObj.filename()
                    i = i + 1
                    file_List.append(str(file))
                return  file_List

            except Exception as e:
                logger.ERROR("Exception in connecting to {} server using chilkat".format(self.host))
                logger.DEBUG(str(e), exc_info=1)
        except Exception as e:
            logger.WARN("%s" % e)




def read_from_sftp(download_dir, app_name, connstr, \
                   sftp_dir='', timeout=0, interval=0, retry=0, proxy_hostname='', proxy_portnumber=''):
    """ Copies file from SFTP server to local directory """

    try:
        download_dir_lst = FFTPConfig.string_as_list(download_dir)
        sftp_dir_lst = FFTPConfig.string_as_list(sftp_dir)
        source_dict = {}
        destination = download_dir_lst[0]
        if len(download_dir_lst) > 1 and len(download_dir_lst) == len(sftp_dir_lst):
            source_dict = dict(list(zip(sftp_dir_lst, download_dir_lst)))
        elif len(download_dir_lst) > 1:
            logger.ERROR("Invalid download_dir / sftp_dir provided as input to API")
            return

        result = 0
        if connstr:
            host, port, user, pwd = '', '', '', ''
            conn_param_lst = connstr.split(':')
            if len(conn_param_lst) > 2:
                host = conn_param_lst[0]
                port = conn_param_lst[1]
            if len(conn_param_lst) == 4:
                user = conn_param_lst[2]
                pwd = conn_param_lst[3]
            sftp_obj = SFTPOperations(app_name, host, port, user, pwd, timeout, interval, retry, proxy_hostname, proxy_portnumber)

            if sftp_obj.sftp:
                for each_source in sftp_dir_lst:
                    if source_dict:
                        destination = source_dict[each_source]
                    sftp_dir, filter = ntpath.split(os.path.expandvars(each_source))
                    result = sftp_obj.download_file(filename_lst=[filter], download_dir=destination, sftp_dir=sftp_dir)
                sftp_obj.close_connection()
        else:
            result = 0
        return result
    except Exception as e:
        logger.ERROR(str(e))


def write_to_sftp(app_name, file_path='',  connstr='', ftp_dir='',
                  timeout=0, interval=0, retry=0, proxy_hostname='', proxy_portnumber=''):
    """ Writes an file to SFTP server at specified directory """
    try:
        file_path_lst = FFTPConfig.string_as_list(file_path)
        ftp_dir_lst = FFTPConfig.string_as_list(ftp_dir)

        source_dict = {}
        destination = ftp_dir_lst[0]
        if len(ftp_dir_lst) > 1 and len(ftp_dir_lst) == len(file_path_lst):
            source_dict = dict(list(zip(file_path_lst, ftp_dir_lst)))
        elif len(ftp_dir_lst) > 1:
            logger.ERROR("Invalid file_path / ftp_dir provided as input to API")
            return

        result = 0
        if connstr:
            host, port, user, pwd = '', '', '', ''
            conn_param_lst = connstr.split(':')
            if len(conn_param_lst) > 2:
                host = conn_param_lst[0]
                port = conn_param_lst[1]
            if len(conn_param_lst) == 4:
                user = conn_param_lst[2]
                pwd = conn_param_lst[3]

            sftp_obj = SFTPOperations(app_name, host, port, user, pwd, timeout, interval, retry, proxy_hostname, proxy_portnumber)

            if sftp_obj.sftp:

                for file_path in file_path_lst:
                    if source_dict:
                        destination = source_dict[file_path]

                if os.path.isfile(file_path):
                    result = sftp_obj.upload_file(file_path, destination)
                else:
                    for files in os.listdir(file_path):
                        file_to_open = file_path + '/' + files
                        result = sftp_obj.upload_file(file_to_open, destination)
            sftp_obj.close_connection()
        else:
            result = 0
        return result

    except Exception as e:
        logger.ERROR(str(e))





    '''
    def connect_putty():
        """ Connect to SFTP server using Putty"""
        sftp = 0
        utilsobj = FIntegrationUtils.FParamsEncode()        
        putty_installable_path ='putty path'        
        try:
            import subprocess
            from subprocess import PIPE, STDOUT
            try:
                os.chdir(putty_installable_path)
                sftp_server = user + '@' + host + ':abc.txt'
                cmd = 'echo n |pscp -pw %s -ls "%s"' % (pwd, sftp_server)
                p = subprocess.Popen(cmd, stdout=PIPE, stdin=PIPE, stderr=PIPE, shell=True)
                puttyres = p.communicate()
                if len(puttyres) > 1:
                    output = puttyres[0]
                    error_string = utilsobj.get_string(puttyres[1])
                    if '(y/n)' in error_string:
                        error_string = error_string.split('(y/n)')[1].strip()
                    if ('\r\n') in error_string:
                        error_string = error_string.replace('\r\n', ',')

                    if error_string:
                        error_log = "Failed to connect to SFTP server %s: %s" % (
                            sftp_server.rstrip(':abc.txt'), error_string)
                        if ('\r\n') in error_log:
                            error_log = error_log.replace('\r\n', ',')
                        logger.ERROR(str(error_log))
                        sftp = 0
                    elif output:
                        logger.DEBUG("Connected to {} server using putty".format(host))
                        sftp = 1
                    p.stdin.close()
            except Exception as e:
                logger.ERROR("Exception in connecting to {} server using Putty".format(host))
                logger.DEBUG(str(e), exc_info=1)
        except Exception as e:
            logger.WARN("%s" % e)
        return sftp
    
    '''

    '''  
    def upload_file_using_putty( file_path, upload_dir):
        """ Upload file at SFTP server using putty """
        logger.DEBUG("Uploading file using putty")
        file_name = os.path.split(file_path)[-1]
        utilsobj = FIntegrationUtils.FParamsEncode()
        putty_error = ''
        putty_installable_path = ''
        output = ''
        read_mode = ''
        write_mode = ''
        try:
            import subprocess
            from subprocess import PIPE, STDOUT
        except Exception as ex:
            logger.WARN("Cannot import python subprocess : " % str(ex))
            return None

        result = 1
        sftp_server = user + '@' + host + ':'
        os.chdir(putty_installable_path)

        if upload_dir:
            sftp_server = sftp_server + '/' + upload_dir
        
        file_path = FFTPLibHooks.fftplibrary_import_exit(read_mode, write_mode, file_path)

        if not file_path or not type(file_path) == str:
            logger.WARN("Value returned from fftplibrary_import_exit is {} not supported".format(str(file_path)))
            return 0

        if os.path.isfile(file_path):
            try:
                password = pwd
                cmd = 'echo n |pscp -pw %s "%s" %s' % (password, file_path, sftp_server)
                p = subprocess.Popen(cmd, stdout=PIPE, stdin=PIPE, stderr=PIPE, shell=True)
                puttyres = p.communicate()
                result_len = 0
                for i in puttyres:
                    result_len = result_len + 1
                if result_len > 1:
                    output = puttyres[0]
                    error_string = utilsobj.get_string(puttyres[1])
                    if '(y/n)' in error_string:
                        error_string = error_string.split('(y/n)')[1].strip()

                    if ('\r\n') in error_string:
                        error_string = error_string.replace('\r\n', ',')

                    if error_string and "The server's host key" not in error_string:
                        error_log = "Failed to upload file %s to SFTP server : %s" % (file_name, error_string)
                        if ('\r\n') in error_log:
                            error_log = error_log.replace('\r\n', ',')
                        logger.ERROR(str(error_log))
                        result = 0

                    if error_string.upper():
                        error_log = "Failed to upload file %s to SFTP server : %s" % (file_name, error_string)
                        if ('\r\n') in error_log:
                            error_log = error_log.replace('\r\n', ',')
                        logger.ERROR(str(error_log))
                        result = 0
                    elif output:
                        if upload_dir:
                            logger.INFO("File uploaded to SFTP server %s at directory %s" % (file_name, upload_dir))
                        else:
                            logger.INFO("File uploaded to SFTP server %s" % file_name)
                        result = 1
                    p.stdin.close()
            except Exception as e:
                logger.ERROR("Exception in uploading file at SFTP server using Putty: %s" % (str(e)))
                logger.DEBUG(str(e), exc_info=1)
        else:
            logger.ERROR("File %s does not exist" % file_path)
        return result    
       '''

    '''
    def polling_for_putty(filename_lst, download_dir, sftp_dir=None):
        """Downloads a file from the FTP.
        retrbinary is used to download binary files.
        Input - reply file name, reply file path to download.
        Output - reply file from FTP server.

        """
        read_mode = ''
        write_mode = ''
        result = 0
        try:
            logger.DEBUG("Downloading files to dir <%s>" % download_dir)
            for file_name in filename_lst:
                file_path = os.path.join(download_dir, file_name)
                file_path, destination_path = FFTPLibHooks.fftplibrary_export_entry(read_mode,write_mode, file_path)
                if file_path and type(file_path) == str:
                    result = putty_poll_until_timeout(timeout, interval, file_name, download_dir, sftp_dir)
                else: 
                    result = 0

        except Exception as ex:
            logger.ERROR("Error while downloading file from SFTP")
            logger.ERROR(str(ex))
            result = 0

        return result
        
        '''
    '''   
    def putty_poll_until_timeout(timeout, interval, filename, download_dir, sftp_dir):
        """This method polls to FTP for a given time period at given
        interval of time If the reply file is
        present before the timeout then the result is returned.
        """
        result = 0
        time_seconds = 0
        poll_start_time = time.time()
        if int(timeout):
            logger.INFO("Waiting for a file to download")
            while time_seconds < int(timeout):

                time.sleep(float(interval))
                seconds = str(time_seconds + \
                              int(interval)) + 's'
                msg = '~' + str(seconds) + ' ...'
                logger.INFO(msg)
                result, err_log = download_file_using_putty(filename, download_dir, sftp_dir)
                if result:
                    return result
                elif err_log:
                    logger.DEBUG('%s' % err_log)

                time_seconds = time_seconds + \
                                    int(interval)
        else:
            result, err_log = download_file_using_putty(filename, download_dir, sftp_dir)
            if err_log:
                logger.DEBUG('%s' % err_log)
        return result
        '''


    '''    
    def download_file_using_putty(file_name, download_dir, sftp_dir):
        """ Download file using Putty """
        result = 0
        error_log = ''
        putty_error = ''
        output = ''
        putty_installable_path = ''
        read_mode = ''
        write_mode = ''
        utilsobj = FIntegrationUtils.FParamsEncode()

        try:
            import subprocess, os, time
            from subprocess import PIPE, STDOUT
        except Exception as ex:
            logger.WARN("Cannot import python subprocess : " % str(ex))
            return None

        sftp_server = user + '@' + host + ':'
        localpath = os.path.join(download_dir, file_name)
        os.chdir(putty_installable_path)
        if sftp_dir:
            sftp_server = sftp_server + '/' + sftp_dir + '/' + file_name
        else:
            sftp_server = sftp_server + file_name

        try:
            password = pwd
            cmd = 'echo n |pscp -pw %s %s "%s"' % (password, sftp_server, localpath)
            p = subprocess.Popen(cmd, stdout=PIPE, stdin=PIPE, stderr=PIPE, shell=True)
            puttyres = p.communicate()
            result_len = 0
            for i in puttyres:
                result_len = result_len + 1
            if result_len > 1:
                output = puttyres[0]
                error_string = utilsobj.get_string(puttyres[1])
                if '(y/n)' in error_string:
                    error_string = error_string.split('(y/n)')[1].strip()

                if ('\r\n') in error_string:
                    error_string = error_string.replace('\r\n', ',')

                if error_string and "The server's host key" not in error_string:
                    error_log = "Failed to download file %s from SFTP server : %s" % (file_name, error_string)
                    if ('\r\n') in error_log:
                        error_log = error_log.replace('\r\n', ',')
                    result = 0
                if error_string.upper():
                    error_log = "Failed to download file %s from SFTP server : %s" % (file_name, error_string)
                    if ('\r\n') in error_log:
                        error_log = error_log.replace('\r\n', ',')
                    result = 0
                elif output:
                    localpath, destination_path = FFTPLibHooks.fftplibrary_export_exit(read_mode, write_mode,
                                                                                       localpath)
                    if localpath:
                        if type(localpath) == str:
                            logger.DEBUG("Downloaded file <%s> from SFTP server" % file_name)
                            result = 1
                        else:
                            logger.WARN("Value returned from fftplibrary_export_exit is {} not supported".format(
                                str(localpath)))
                    else:
                        result = 0
                p.stdin.close()

        except Exception as e:
            error_log = "Error while downloading file %s from SFTP server" % file_name

        return result, error_log
        
    '''




...

  FSFTPOperationsOverride
"""--------------------------------------------------------------------
MODULE
    FSFTPOperationsOverride -  This module provide override API's for Operations like reading and writing to SFTP server

DESCRIPTION
    This script handles the SFTP operations.

VERSION: 2.0.4
--------------------------------------------------------------------"""
import os
import fnmatch
import sys
import time
import ntpath

def connect_override(proxyHost, proxyPort, HostName, Port, username, password):
        """ Override API for SFTP Connect  """
        sftp = None
        '''
        Customized code for sftp connection      
        
        '''
        return sftp
    
def upload_file_override(sftp, file_path, upload_dir=None):
        """ Override API for SFTP file upload  """
        result = 0
        '''
        Customized code for sftp file upload    
        
        '''
        return result    
    
    
def polling_for_override(sftp, timeout, interval, filename_lst, download_dir, sftp_dir):
        """ Override API for SFTP polling  """
        result = 0
        '''
        Customized code for sftp file polling    
        result = self.override_poll_until_timeout(timeout, interval, file_name, download_dir, sftp_dir)
        
        '''
        
        return result   
    
    
def override_poll_until_timeout():
        """ Override API for SFTP polling timeout """
        result = 0
        '''
        Customized code for sftp file polling  timeout   
        
        '''
        result, err_log = download_file_using_override()
        return result      
    
    
def download_file_using_override():
        """ Override API for SFTP polling timeout """
        result = 0
        '''
        Customized code for sftp file polling  timeout   
        
        '''
        return result    

...



}
