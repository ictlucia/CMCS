#
# Front Arena exported extension module.
# source          ""
# timestamp (utc) "2024-10-17 02:38:43.9"
# ***** DO NOT EDIT! *****
#
name        "MarketLinkedDeposit_RangeAccrualFX"
description "$Id$"

groups {
}

decls[FCustomApplicationDefinition] {
}

clx FObject [FCustomApplicationDefinition] {
  MarketLinkedDepositDeal =
  CreationFunction=
  HostApplication=
  HostObjectType=
  HostPath=
  Name=MarketLinkedDepositDeal
  ObjectTypes=FDealPackage
  ProfileComponent=MarketLinkedDepositDeal


  MarketLinkedDepositIr =
  CreationFunction=
  HostApplication=
  HostObjectType=
  HostPath=
  Name=MarketLinkedDepositIr
  ObjectTypes=FDealPackage
  ProfileComponent=MarketLinkedDepositIr


  MarketLinkedDepositRaFx =
  CreationFunction=
  HostApplication=
  HostObjectType=
  HostPath=
  Name=MarketLinkedDepositRaFX
  ObjectTypes=FDealPackage
  ProfileComponent=MarketLinkedDepositRaFX


}

decls[FCustomInstrumentDefinition] {
}

clx FObject [FCustomInstrumentDefinition] {
  MarketLinkedDepositDeal =
  Caption=Market Linked Deposit Deal
  DealPackageDefinition=
  DefaultInstrumentName=MMLDRAFx
  DefaultInstrumentUpdateHook=
  DefaultTradeUpdateHook=
  DisabledControls=
  ExoticFixingsHook=SP_MarketLinkedDeposit_Utils.MLDRAFxExoticFixingsHook
  ExtendsConfiguration=FX Option
  FavoriteEnabledControls=
  FilterCriteria=Instrument.AdditionalInfo.StructureType=Market Linked Deposit Deal
  HelpFileIndex=
  InstantiatedAs=Concrete
  InstrumentIcon=
  LabelOverrides=
  PanesExotic=
  PanesInstrument=
  PanesTrade=
  ParentMenu=
  PricingDefaultColumns=
  PricingManualRefresh=
  PricingShowRowHeaders=
  ReplaceApplication=
  SetUpFunction=SP_MarketLinkedDeposit_Setup.SetupMLD
  ShowPlaceExcluded=
  ShowPlaceInDetail=
  ShowPlaceInSlim=
  SubMenu=
  UpdateControls=
  VisiblePanes=


  MarketLinkedDepositIR =
  Caption=Market Linked Deposit IR
  DealPackageDefinition=
  DefaultInstrumentName=MMLDID
  DefaultInstrumentUpdateHook=
  DefaultTradeUpdateHook=
  DisabledControls=
  ExoticFixingsHook=
  ExtendsConfiguration=Deposit/Loan
  FavoriteEnabledControls=
  FilterCriteria=Instrument.AdditionalInfo.StructureType=Market Linked Deposit IR
  HelpFileIndex=
  InstantiatedAs=Concrete
  InstrumentIcon=
  LabelOverrides=
  PanesExotic=
  PanesInstrument=
  PanesTrade=
  ParentMenu=
  PricingDefaultColumns=
  PricingManualRefresh=
  PricingShowRowHeaders=
  ReplaceApplication=
  SetUpFunction=SP_MarketLinkedDeposit_Setup.SetupMLD
  ShowPlaceExcluded=
  ShowPlaceInDetail=
  ShowPlaceInSlim=
  SubMenu=
  UpdateControls=
  VisiblePanes=


  MarketLinkedDepositRangeAccrualFx =
  Caption=Market Linked Deposit RAFx(Modify default)
  DealPackageDefinition=
  DefaultInstrumentName=MMLDRAFx
  DefaultInstrumentUpdateHook=
  DefaultTradeUpdateHook=
  DisabledControls=
  ExoticFixingsHook=SP_MarketLinkedDeposit_Utils.MLDRAFxExoticFixingsHook
  ExtendsConfiguration=FX Option
  FavoriteEnabledControls=
  FilterCriteria=Instrument.AdditionalInfo.StructureType=Market Linked Deposit RAFx
  HelpFileIndex=
  InstantiatedAs=Concrete
  InstrumentIcon=
  LabelOverrides=
  PanesExotic=
  PanesInstrument=
  PanesTrade=
  ParentMenu=
  PricingDefaultColumns=
  PricingManualRefresh=
  PricingShowRowHeaders=
  ReplaceApplication=
  SetUpFunction=SP_MarketLinkedDeposit_Setup.SetupMLD
  ShowPlaceExcluded=
  ShowPlaceInDetail=
  ShowPlaceInSlim=
  SubMenu=
  UpdateControls=
  VisiblePanes=


}

decls[FCustomMethod] {
}

clx FExoticEvent [FCustomMethod] {
  MLDAmount =
  Definition=MLDAmount:double
  Function=SP_MarketLinkedDeposit_Utils.MLDAmount


  MLDAmountInOut =
  Definition=MLDAmountInOut:string
  Function=SP_MarketLinkedDeposit_Utils.MLDAmountInOut


  MLDFixing =
  Definition=MLDFixing:double
  Function=SP_MarketLinkedDeposit_Utils.MLDFixing


  MLDFixingDomesticPerForeign =
  Definition=MLDFixingDomesticPerForeign:string
  Function=SP_MarketLinkedDeposit_Utils.MLDFixingDomesticPerForeign


  PayDate =
  Definition=PayDate:date
  Function=SP_MarketLinkedDeposit_Utils.PayDate


  SetPayDate =
  Definition=SetPayDate(date value)
  Function=SP_MarketLinkedDeposit_Utils.SetPayDate


}

decls[FDealPackageDefinition] {
}

clx FObject [FDealPackageDefinition] {
  MMLDIRTradeActionClose =
  CustomApplication=
  DefinitionClass=SP_MMLDCloseCommand.MMLDIRTradeActionClose
  Description=
  DisplayName=Trade Action Close (MMLD IR)
  Type=Transient


  MMLDTradeActionClose =
  CustomApplication=
  DefinitionClass=SP_MMLDCloseCommand.MMLDTradeActionClose
  Description=
  DisplayName=Trade Action Close (MMLD)
  Type=Transient


  SP_MarketLinkedDepositDeal =
  CustomApplication=Deal Package
  DefinitionClass=SP_MarketLinkedDepositDeal.MarketLinkedDepositDeal
  Description=
  DisplayName=Market Linked Deposit Deal
  Type=Normal


  SP_MarketLinkedDepositIR =
  CustomApplication=Deal Package
  DefinitionClass=SP_MarketLinkedDepositIR.MLDIRDefinition
  Description=
  DisplayName=Market Linked Deposit IR
  Type=Normal


  SP_MarketLinkedDepositRangeAccrualFx =
  CustomApplication=Deal Package
  DefinitionClass=SP_MarketLinkedDepositFxRA.MarketLinkedDepositRangeAccrualFx
  Description=
  DisplayName=Market Linked Deposit RAFx
  Type=Normal


}

decls[FExtensionAttribute] {
}

clx FSingleInstrumentAndTrades [FExtensionAttribute] {
  SpecificGlnoUsed = py("Report_Python_BO", context).SpecificGlnoUsed(object.Trades.AsArray.First) + select(object.Instrument.Currency.Name, 
  "IDR"->"-0-100", 
  default->"-0-200");
}

clx FTradeRow [FExtensionAttribute] {
  SpecificGlnoUsed = py("Report_Python_BO", context).SpecificGlnoUsed(object.Trade) + select(object.Instrument.Currency.Name, 
  "IDR"->"-0-100", 
  default->"-0-200");
}

decls[FExtensionValue] {
}

clx FObject [FExtensionValue] {
  CustomLayout_SP_MLDDealPackageExoticEvents
exoticEvents;
fixingEditer;
...

  CustomLayout_SP_MLDDealPackageGeneral
vbox(;
    vbox{;
        hbox(;
            packageType;
        );
        hbox(;
            name;
            suggestName;
        );
    };
    vbox{;
        vbox[Deposit Data;
            hbox(;
                vbox{;
                    depositCashAmount;
                    trade_premium;
                    leg_legType;
                    leg_fixedRate;
                    hbox(;
                        leg_rollingPeriod;
                        leg_rollingPeriodBase;
                        leg_resets;
                    );
                };
                vbox{;
                    leg_zeroCouponFixedPeriod;
                    leg_floatRateReference;
                    leg_dayCountMethod;
                    deposit_startDate;
                    deposit_endDate;
                };
            );
        ];
    };
    vbox[Range Accrual Data;
        hbox(;
            vbox{;
                domesticCurrency;
                notional2;
                mmld_ceiling;
                mmld_floor;
                mmld_premiumOption;
                discountingType;
                mtmFromFreed;
            };
            vbox{;
                mmld_reference;
                mmld_maxYield;
                mmld_minYield;
                mmld_dayBasis;
                settlementType;
                ExternalId;
                valGroup;
            };
        );
        hbox[Fixing Data;
            vbox{;
                startDate;
                datePeriod;
                fixingCalendar1;
                fixingCalendar2;
                fixingCalendar3;
                expiry;
            };
            vbox{;
                fixingSource;
                instrumentsSettleDays;
                dayMethod;
                settlementCalendar;
                nbrObservationDays;
                fixingsGenerate;
            };
        ];
        hbox(;
            vbox[,domesticPerForeignVBox;
                vbox{;
                    hbox(;
                        spotReference_rateDomesticPerForeign;
                    );
                };
            ];
            vbox[,foreignPerDomesticVBox;
                vbox{;
                    spotReference_rateForeignPerDomestic;
                };
            ];
        );
        hbox[Early Termination Status;
            vbox{;
                terminationStatus;
            };
            vbox{;
                terminationDate;
            };
        ];
    ];
);
...

  CustomLayout_SP_MLDDealPackageTrades
vbox(;
        vbox[;
                hbox(;
                    vbox{;
                        tradeTime;
                        tradeValueDay;
                        tradePortfolio;
                        tradeTrader;
                    };
                    vbox{;
                        
                        tradeAcquirer;
                        tradeCounterParty;
                        tradeStatus;
                        tradesOptKey3;
                        tradesOptKey4;
                        hbox(;
                                fill;
                                tradePayments;
                        );
                    };
                );
        ];
);
...

  CustomLayout_SP_MLDepositDealPackageTrades
vbox(;
        vbox[;
                hbox(;
                    vbox{;
                        tradeTime;
                        tradeValueDay;
                        tradePortfolio;
                        trade_portfolio;
                        tradeTrader;
                        trades_AddInfo_DealerCode;
                        trades_AddInfo_DocumentType;
                        trades_AddInfo_TransactionPurpose;
                    };
                    vbox{;
                        
                        tradeAcquirer;
                        tradeCounterParty;
                        tradeStatus;
                        tradesOptKey1;
                        tradesOptKey2;
                        tradesOptKey3;
                        tradesOptKey4;
                        tradeText1;
                        hbox(;
                                fill;
                                tradePayments;
                        );
                    };
                );
            depositB2B;
            vbox[;
                b2bOptionEnabled;
                hbox(;
                    vbox(;
                        b2bOptionPrice;
                        b2bOptionMargin;
                    );
                    vbox(;
                        b2bOptionPrf;
                        b2bOptionAcq;
                    );
                );
            ];
        ];
);
...

  CustomLayout_SP_MLDepositIRPackageTrades
vbox(;
        vbox[;
                hbox(;
                    vbox{;
                        tradeTime;
                        tradeValueDay;
                        depositPortfolio;
                        swapPortfolio;
                        tradeTrader;
                        trades_AddInfo_DealerCode;
                        trades_AddInfo_DocumentType;
                        trades_AddInfo_TransactionPurpose;
                    };
                    vbox{;
                        
                        tradeAcquirer;
                        tradeCounterParty;
                        tradeStatus;
                        tradesOptKey1;
                        tradesOptKey2;
                        tradesOptKey3;
                        tradesOptKey4;
                        tradeText1;
                        hbox(;
                                fill;
                                tradePayments;
                        );
                    };
                );
                depositB2B;
                swapB2B;
        ];
);
...

  CustomLayout_SP_MLDIRDealPackageGeneral
vbox(;
        vbox{;
                hbox(;
                        packageType;
                );
                hbox(;
                        name;
                        suggestName;
                );
        };
        vbox{;
            vbox[Deposit Data;
                hbox(;
                    vbox{;
                        depositCashAmount;
                        currency;
                        leg_legType;
                        leg_fixedRate;
                        hbox(;
                            leg_rollingPeriod;
                            leg_rollingPeriodBase;
                            leg_resets;
                        );
                    };
                    vbox{;
                        leg_zeroCouponFixedPeriod;
                        leg_floatRateReference;
                        leg_dayCountMethod;
                        deposit_startDate;
                        deposit_endDate;
                    };
                );
            ];
        };
        vbox[Range Accrual Data;
                hbox(;
                        vbox{;
                                discountingType;
                                mmld_ceiling;
                                mmld_floor;
                                mmld_premiumOption;
                                mtmFromFreed;
                        };
                        vbox{;
                                mmld_reference;
                                mmld_maxYield;
                                mmld_minYield;
                                mmld_dayBasis;
                                ExternalId;
                                valGroup;
                        };
                );
                hbox[Fixing Data;
                        vbox{;
                                startDate;
                                datePeriod;
                                fixingCalendar1;
                                fixingCalendar2;
                                fixingCalendar3;
                                expiryDate;
                        };
                        vbox{;
                                dayMethod;
                                settlementCalendar;
                                settlementCalendar2;
                        };
                ];
        ];
);
    
...

  CustomLayout_SP_MLDIRResets
resets;
fixingEditer;
...

  CustomLayout_SP_MLDRAFxDealPackageGeneral
vbox(;
        vbox{;
                hbox(;
                        packageType;
                );
                hbox(;
                        name;
                        suggestName;
                );
                
        };
        vbox[;
                hbox(;
                        vbox{;
                                domesticCurrency;
                                notional2;
                                mmld_ceiling;
                                mmld_floor;
                                mmld_premiumOption;
                                discountingType;
                                mtmFromFreed;
                        };
                        vbox{;
                                mmld_reference;
                                mmld_maxYield;
                                mmld_minYield;
                                mmld_dayBasis;
                                settlementType;
                                ExternalId;
                                valGroup;
                        };
                );
                hbox[Fixing Data;
                        vbox{;
                                startDate;
                                datePeriod;
                                fixingCalendar1;
                                fixingCalendar2;
                                fixingCalendar3;
                                expiry;
                        };
                        vbox{;
                                fixingSource;
                                settleDays;
                                dayMethod;
                                settlementCalendar;
                                nbrObservationDays;
                                fixingsGenerate;
                        };
                        hbox(;
                            vbox[,domesticPerForeignVBox;
                                vbox{;
                                    hbox(;
                                            spotReference_rateDomesticPerForeign;
                                    );
                                };
                            ];
                            vbox[,foreignPerDomesticVBox;
                                vbox{;
                                    spotReference_rateForeignPerDomestic;
                                };
                            ];
                        );
                ];
                hbox[Early Termination Status;
                    vbox{;
                        terminationStatus;
                    };
                    vbox{;
                        terminationDate;
                    };
                ];
        ];
);
    
...

  CustomPanes_SP_MLDDealPackage
CustomLayout_SP_MLDDealPackageGeneral,General;CustomLayout_SP_MLDDealPackageExoticEvents,Date Schedule;CustomLayout_SP_MLDepositDealPackageTrades,Trade
...

  CustomPanes_SP_MLDIRDealPackage
CustomLayout_SP_MLDIRDealPackageGeneral,General;CustomLayout_SP_MLDIRResets, Resets;CustomLayout_SP_MLDepositIRPackageTrades,Trade
...

  CustomPanes_SP_MLDRAFxDealPackage
CustomLayout_SP_MLDRAFxDealPackageGeneral,General;CustomLayout_SP_MLDDealPackageExoticEvents,Date Schedule;CustomLayout_SP_MLDDealPackageTrades,Trade
...

}

decls[FMenuExtension] {
}

clx FFrame [FMenuExtension] {
  SP_MarketLinkedDepositDeal =
  DisplayName=Market Linked Deposit Deal
  Function=SP_MarketLinkedDepositDealPackage.StartMLDDeal
  MenuType=Application
  ParentMenu=Trading/Structured Products
  ProfileComponent=MarketLinkedDepositDeal
  Standard=Yes


  SP_MarketLinkedDepositIr =
  DisplayName=Market Linked Deposit IR
  Function=SP_MarketLinkedDepositDealPackage.StartMLDIR
  MenuType=Application
  ParentMenu=Trading/Structured Products
  ProfileComponent=MarketLinkedDepositIr
  Standard=Yes


  SP_MarketLinkedDepositRangeAccrualFx =
  DisplayName=Market Linked Deposit RAFx
  Function=SP_MarketLinkedDepositDealPackage.StartMLDRangeAccrualFx
  MenuType=Application
  ParentMenu=Trading/Structured Products
  ProfileComponent=MarketLinkedDepositRaFX
  Standard=Yes


}

decls[FNumFormatter] {
}

clx FObject [FNumFormatter] {
  MLDFourDecimal =
  DenominatedValueDateTimeFormatter=
  DigitGrouping=
  DigitGroupingSymbol=
  Epsilon=
  Expression=
  Format=
  Fractions=
  InputScaleFactor=
  InputScaleFactorLimit=
  Inverse=
  MaximumSignificantDigits=
  MinimumSignificantDigits=
  Mnemonic=''=0.0:Input
  NumDecimals=4
  ScaleFactor=
  ShowInf=false
  Tick=
  TruncateTrailingZeros=false
  USTreasuryInput=


  SixDecimalVeryDetailedShowZeroHideNaN =
  DenominatedValueDateTimeFormatter=
  DigitGrouping=
  DigitGroupingSymbol=
  Epsilon=0.0
  Expression=
  Format=
  Fractions=
  InputScaleFactor=
  InputScaleFactorLimit=
  Inverse=
  MaximumSignificantDigits=
  MinimumSignificantDigits=
  Mnemonic='B'=1000000000.0:Input;'G'=1000000000.0:Input;'K'=1000.0:Input;'M'=1000000.0:Input;''=NotANumber:Output
  NumDecimals=6
  ScaleFactor=1.0
  ShowInf=false
  Tick=
  TruncateTrailingZeros=false
  USTreasuryInput=


  SP_MLDFXRate =
  DenominatedValueDateTimeFormatter=
  DigitGrouping=
  DigitGroupingSymbol=
  Epsilon=1e-06
  Expression=x
  Format=
  Fractions=
  InputScaleFactor=
  InputScaleFactorLimit=
  Inverse=abs(x)
  MaximumSignificantDigits=
  MinimumSignificantDigits=
  Mnemonic='B'=1000000000.0:Input;'G'=1000000000.0:Input;'K'=1000.0:Input;'M'=1000000.0:Input;''=NotANumber:Output
  NumDecimals=4
  ScaleFactor=1.0
  ShowInf=false
  Tick=
  TruncateTrailingZeros=false
  USTreasuryInput=


}

decls[FPythonCode] {
}

clx FObject [FPythonCode] {
  CompositeCashFlowComponents
from __future__ import print_function
from __future__ import division
from __future__ import absolute_import

import acm
import FUxCore
from DealPackageDevKit import DealPackageDefinition, DealPackageException, DealPackageUserException, CalcVal, Object, Str, Action, List, Bool, Float, Int, Date, Text, DatePeriod, DealPackageChoiceListSource, CompositeAttributeDefinition, ValGroupChoices, InstrumentPart
from CompositeComponentBase import CompositeBaseComponent
from SP_DealPackageHelper import IsDateTime
from SP_DealPackageHelper import MergeDictionaries as dMerge
from functools import partial


class CashFlowComponent(CompositeBaseComponent):

    # -----------------------------------------------
    # ##### Override of methods from Dev Kit ###### #
    # -----------------------------------------------

    def Attributes(self):

        return {
                    # Slim view
                                               
                    'startDate'     : Object ( objMapping = InstrumentPart(self._instrumentName + '.LegStartDate'),
                                               label = "Start Date",
                                               toolTip = 'Start Date',
                                               onChanged = self.UniqueCallback("@SetEndDateAfterStartDate|RegenerateCashFlows"),
                                               transform = self.UniqueCallback("@TransformPeriodToStartDate")),

                    'endDate'       : Object ( objMapping = InstrumentPart(self._instrumentName + '.LegEndDate'),
                                               label = 'End Date',
                                               toolTip = 'End Date',
                                               onChanged = self.UniqueCallback("@RegenerateCashFlows"),
                                               transform = self.UniqueCallback("@TransformPeriodToEndDate"),
                                               validate = self.UniqueCallback("@ValidateEndDate") ),
                                               
                    'contractSize'  : Object ( objMapping = InstrumentPart(self._instrumentName + '.ContractSize'),
                                               label = 'Contract Size',
                                               onChanged = self.UniqueCallback("@RegenerateCashFlows"),
                                               toolTip = 'Contract Size' ),
                                                                   
                    # Detailed view                    
                    'payCalendar'   : Object ( objMapping = InstrumentPart(self._legName + '.PayCalendar'),
                                               label = 'Calendar',
                                               toolTip = 'Calendar',
                                               onChanged = self.UniqueCallback("@RegenerateCashFlows"),
                                               visible = self.UniqueCallback("@IsShowModeDetail") ),
                    
                    'valuationGroup' : Object ( objMapping = InstrumentPart(self._instrumentName + '.ValuationGrpChlItem'),
                                                label= 'Val Group',
                                                toolTip = 'Valuation Group',
                                                visible = self.UniqueCallback("@IsShowModeDetail"),
                                                choiceListSource = ValGroupChoices() )

                }

    def OnInit(self):
        raise DealPackageError('Use instrument type specific class instead of CashFlowComponent')
    

    # -----------------------------------------------
    # ##### Attribute callbacks that carry out
    # ##### specific tasks
    # -----------------------------------------------

    def VisibleContractSize(self, attrName):
        return False

    def RegenerateCashFlows(self, *rest):
        raise DealPackageException ( 'Component %s does not implement method RegenerateCashFlows' 
                                    % (self.__class__.__name__) )

    def SetEndDateAfterStartDate(self, *rest):
        # If start date is set to a date after end date, adjust the end date
        # to the next business date.
        # Using silent mode to enure that regenerate Cash flow is not called
        # from both start date and end date
        if IsDateTime(self.startDate) and IsDateTime(self.endDate):
            if acm.Time.DateDifference(self.startDate, self.endDate) >= 0:            
                self.SetAttribute('endDate', '1d', silent=True)

    # -----------------------------------------------
    # ##### Attribute callbacks that can be intercepted
    # ##### by the deal package
    # -----------------------------------------------
    
    def TransformPeriodToStartDate(self, attrName, value):
        if acm.Time().PeriodSymbolToDate(value):
            value = self.GetMethod(self._instrumentName)().LegStartDateFromPeriod(value)
        return value

    def TransformPeriodToEndDate(self, attrName, value):
        if acm.Time().PeriodSymbolToDate(value):
            value = self.GetMethod(self._instrumentName)().LegEndDateFromPeriod(value)
        return value

    def ValidateEndDate(self, attrName, value):
        validationStartDate = self.TransformPeriodToStartDate('startDate', self.startDate)
        if acm.Time().DateDifference(validationStartDate, value) >= 0:
            raise DealPackageUserException('End date must be after start date')

class CouponComponent(CashFlowComponent):

    # -----------------------------------------------
    # ##### Override of methods from Dev Kit ###### #
    # -----------------------------------------------
    
    def Attributes(self):

        attributes = super(CouponComponent, self).Attributes()

        attributes['coupon']    = Object ( objMapping = InstrumentPart(self._legName + '.FixedRate'),
                                           label = 'Coupon',
                                           toolTip = 'Coupon',
                                           solverParameter = self.UniqueCallback('@SolverParametersCoupon'),
                                           backgroundColor = '@SolverColor',
                                           onChanged = self.UniqueCallback("@RegenerateCashFlows"),
                                           transform = self.UniqueCallback("@TransformCoupon") )

        return attributes


    def AttributeOverrides(self, overrideAccumulator):

        overrideAccumulator(
                {'startDate' : dict(label = 'Interest Start Date')})

    # -----------------------------------------------
    # ##### On Change Callbacks                #####
    # -----------------------------------------------

    def RegenerateCashFlows(self, *rest):
        self.GetMethod(self._legName)().GenerateCashFlows(self.coupon)

    # -----------------------------------------------
    # ##### Methods intended to be called from #####
    # ##### the Deal package itself            #####
    # -----------------------------------------------
            
    def SetParRate(self):
        if IsDateTime(self.startDate) and IsDateTime(self.endDate) and acm.Time.DateDifference(self.endDate, self.startDate) > 0:
            self.GetMethod(self._legName)().GenerateCashFlows(0)
            insCalc = self.GetMethod(self._instrumentName)().Calculation()
            calcSpace = self.GetMethod('_GetStdCalcSpace')()
            parRate = insCalc.ParRate(calcSpace)
            self.coupon = parRate

    def SolverParametersCoupon(self, attrName, *rest):
        return {'minValue':0.0, 'maxValue':100.0}

    # -----------------------------------------------
    # ##### Other callback methods             #####
    # -----------------------------------------------

    def TransformCoupon(self, attrName, value):
        return self.TransformSolver(attrName, value)


class Deposit(CouponComponent):

    # -----------------------------------------------
    # ##### Override of methods from Dev Kit ###### #
    # -----------------------------------------------
    
    def OnInit(self, depositName, depositLegName, **kwargs):
        self._instrumentName = depositName
        self._legName = depositLegName

    def IsValid(self, exceptionAccumulator, aspect):
        insToValidate = self.GetMethod(self._instrumentName)()
        if insToValidate:

            # Check instrument type:
            if insToValidate.InsType() != 'Deposit':
                exceptionAccumulator(
                        'Instrument type for deposit component must be deposit.')


    # -----------------------------------------------
    # ##### Methods intended to be called from #####
    # ##### the Deal package itself            #####
    # -----------------------------------------------
        
    def CreateInstrument(self):
        ins = acm.DealCapturing().CreateNewInstrument('Deposit')
        ins.Quotation('Clean')
        ins.MtmFromFeed(False)
        ins.FirstFixedLeg().PayOffset('0d')
        return ins
    
class CD(CouponComponent):

    # -----------------------------------------------
    # ##### Override of methods from Dev Kit ###### #
    # -----------------------------------------------

    def OnInit(self, cdName, cdLegName, **kwargs):
        self._instrumentName = cdName
        self._legName = cdLegName

    def IsValid(self, exceptionAccumulator, aspect):

        insToValidate = self.GetMethod(self._instrumentName)()
        if insToValidate:

        # Check instrument type:
            if insToValidate.InsType() != 'CD':
                exceptionAccumulator(
                        'Instrument type for CD component must be CD.')

    # -----------------------------------------------
    # ##### Methods intended to be called from #####
    # ##### the Deal package itself            #####
    # -----------------------------------------------

    def CreateInstrument(self):
        ins = acm.DealCapturing().CreateNewInstrument('CD')
        ins.FirstFixedLeg().RollingPeriod('0d')
        ins.MtmFromFeed(False)
        ins.FirstFixedLeg().PayOffset('0d')
        return ins


class Bond(CouponComponent):

    # -----------------------------------------------
    # ##### Override of methods from Dev Kit ###### #
    # -----------------------------------------------

    def OnInit(self, bondName, bondLegName, **kwargs):
        self._instrumentName = bondName
        self._legName = bondLegName

    def IsValid(self, exceptionAccumulator, aspect):

        insToValidate = self.GetMethod(self._instrumentName)()
        if insToValidate:

        # Check instrument type:
            if insToValidate.InsType() != 'Bond':
                exceptionAccumulator(
                        'Instrument type for bond component must be bond.')

    # -----------------------------------------------
    # ##### Methods intended to be called from #####
    # ##### the Deal package itself            #####
    # -----------------------------------------------

    def CreateInstrument(self):
        ins = acm.DealCapturing().CreateNewInstrument('Bond')
        ins.FirstFixedLeg().RollingPeriod('0d')
        ins.Quotation('Clean')
        ins.MtmFromFeed(False)
        ins.FirstFixedLeg().PayOffset('0d')
        return ins

class RangeAccrualSwap(CashFlowComponent):

    # -----------------------------------------------
    # ##### Override of methods from Dev Kit ###### #
    # -----------------------------------------------

    def Attributes(self):
        return {
                    # Slim view
                                               
                    'startDate'     : Object ( objMapping = InstrumentPart(self._instrumentName + '.LegStartDate'),
                                               label = "Start Date",
                                               toolTip = 'Start Date',
                                               onChanged = self.UniqueCallback("@SetEndDateAfterStartDate|RegenerateCashFlows"),
                                               transform = self.UniqueCallback("@TransformPeriodToStartDate")),

                    'endDate'       : Object ( objMapping = InstrumentPart(self._instrumentName + '.LegEndDate'),
                                               label = 'End Date',
                                               toolTip = 'End Date',
                                               onChanged = self.UniqueCallback("@RegenerateCashFlows"),
                                               transform = self.UniqueCallback("@TransformPeriodToEndDate"),
                                               validate = self.UniqueCallback("@ValidateEndDate") ),
                                               
                    'contractSize'  : Object ( objMapping = InstrumentPart(self._instrumentName + '.ContractSize'),
                                               label = 'Contract Size',
                                               onChanged = self.UniqueCallback("@RegenerateCashFlows"),
                                               toolTip = 'Contract Size' ),
                                                                   
                    # Detailed view                    
                    'fixedPayCalendar'   : Object ( objMapping = InstrumentPart(self._fixedLegName + '.PayCalendar'),
                                               label = 'Calendar',
                                               toolTip = 'Calendar',
                                               onChanged = self.UniqueCallback("@RegenerateCashFlows"),
                                               visible = self.UniqueCallback("@IsShowModeDetail") ),
                    'raPayCalendar'   : Object ( objMapping = InstrumentPart(self._raLegName + '.PayCalendar'),
                                               label = 'Calendar',
                                               toolTip = 'Calendar',
                                               onChanged = self.UniqueCallback("@RegenerateCashFlows"),
                                               visible = self.UniqueCallback("@IsShowModeDetail") ),
                    
                    'valuationGroup' : Object ( objMapping = InstrumentPart(self._instrumentName + '.ValuationGrpChlItem'),
                                                label= 'Val Group',
                                                toolTip = 'Valuation Group',
                                                visible = self.UniqueCallback("@IsShowModeDetail"),
                                                choiceListSource = ValGroupChoices() )

                }

    def OnInit(self, swapName, fixedLegName, raLegName, **kwargs):
        self._instrumentName = swapName
        self._fixedLegName = fixedLegName
        self._raLegName = raLegName

    def IsValid(self, exceptionAccumulator, aspect):
        insToValidate = self.GetMethod(self._instrumentName)()
        if insToValidate:

            # Check instrument type:
            if insToValidate.InsType() != 'Swap':
                exceptionAccumulator(
                        'Instrument type for swap component must be swap.')

    # -----------------------------------------------
    # ##### On Change Callbacks                #####
    # -----------------------------------------------

    def RegenerateCashFlows(self, *rest):
        self.GetMethod(self._fixedLegName)().GenerateCashFlows(0)
        self.GetMethod(self._raLegName)().GenerateCashFlows(0)

    def CreateInstrument(self):
        ins = acm.DealCapturing().CreateNewInstrument('Swap')
        ins.MtmFromFeed(False)
        pay_leg = ins.PayLeg()
        pay_leg.LegType('Range Accrual')
        pay_leg.Digital(True)
        pay_leg.DigitalType('Fixed')
        pay_leg.ResetType('Unweighted')
        pay_leg.ResetPeriod('1d')
        pay_leg.ResetAdjustmentMethod('Preceding')
        pay_leg.ResetDayMethod('Preceding')
        pay_leg.ResetDayOffset(0)

        rec_leg = ins.RecLeg()
        rec_leg.LegType('Fixed')
        return ins

class ZeroBond(CashFlowComponent):

    # -----------------------------------------------
    # ##### Override of methods from Dev Kit ###### #
    # -----------------------------------------------

    def OnInit(self, zeroName, zeroLegName, **kwargs):
        self._instrumentName = zeroName
        self._legName = zeroLegName

    def IsValid(self, exceptionAccumulator, aspect):
        insToValidate = self.GetMethod(self._instrumentName)()
        if insToValidate:

            # Check instrument type:
            if insToValidate.InsType() != 'Zero':
                exceptionAccumulator(
                        'Instrument type for zero bond component must be zero bond.')

    # -----------------------------------------------
    # ##### On Change Callbacks                #####
    # -----------------------------------------------

    def RegenerateCashFlows(self, *rest):
        self.GetMethod(self._legName)().GenerateCashFlows(0)

    # -----------------------------------------------
    # ##### Methods intended to be called from #####
    # ##### the Deal package itself            #####
    # -----------------------------------------------
        
    def CreateInstrument(self):
        ins = acm.DealCapturing().CreateNewInstrument('Zero')
        ins.Quotation('Pct of Nominal')
        ins.MtmFromFeed(False)
        ins.FirstFixedLeg().PayOffset('0d')
        return ins

...

  FValidationMMLDPremium

import acm, ael

PREMIUM_STRUCTURE_TYPE = ['Market Linked Deposit Deal']
PAYMENT_TYPE = 'Premium'

def createPayment(trade, amount, date):
    try:
        ael_date = ael.date(date)
        payment = ael.Payment.new(trade)
        payment.type = 'Premium'
        payment.amount = amount
        payment.curr = trade.curr
        payment.ptynbr = trade.counterparty_ptynbr
        payment.payday = ael_date
        payment.valid_from = ael.date_from_time(trade.time)
        payment.text = 'Auto'
    except Exception as e:
        print('Error while creating premium for trade %i and premium date %s' % (trade.trdnbr, date))

def findToDeletePayments(trade, instrument):
    deal_package_links = ael.DealPackageTrdLink.select(f'trdnbr = {trade.trdnbr}')
    payments = ael.Payment.select(f'trdnbr = {trade.trdnbr}')
    for deal_package_link in deal_package_links:
        deal_package = deal_package_link.deal_package_seqnbr
        if deal_package is None:
            continue
        payments = filter(lambda x: x.type == PAYMENT_TYPE, payments)
        payments = list(payments)
    return payments

def add_to_list(to_delete_payments, transaction_list):
    if to_delete_payments is None:
        return
    for to_delete_payment in to_delete_payments:
        transaction_list.append((to_delete_payment, 'Delete'))

def validate_transaction(transaction_list, *rest):
    today = acm.Time.DateToday()
    for entity, operation in transaction_list:
        if operation == 'Delete':
            continue
        if entity.record_type == 'Trade':
            if entity.status not in ['FO Confirmed', 'Internal']:
                continue
            if entity.original() and entity.original().status in ['FO Confirmed', 'Internal']:
                if entity.status == 'Internal' and entity.mirror_trdnbr: # Bug where one mirror trade comes in with e.original in same status as e
                    if entity.mirror_trdnbr.status == 'Internal':
                        pass
                    else:
                        continue
                else:
                    continue
            if entity.counterparty_ptynbr is None:
                continue
            instrument = entity.insaddr
            if instrument.add_info('StructureType') not in PREMIUM_STRUCTURE_TYPE:
                continue
            if instrument.instype != 'Option':
                continue

            from itertools import groupby
            sortFunc = lambda x: x.PayDate()

            to_delete_payments = findToDeletePayments(entity, instrument)
            if to_delete_payments:
                add_to_list(to_delete_payments, transaction_list)
            premium_percentage = entity.price
            basis = int(instrument.add_info('Sp_MLDDayBasis'))
            notional = float(instrument.add_info('Sp_LeverageNotional'))
            if entity.status == 'Internal':
                group_trade = entity.group_trdnbr
                if group_trade:
                    group_trade_positive = group_trade.quantity >= 0
                    entity_positive = entity.quantity >= 0
                    if group_trade_positive != entity_positive:
                        notional *= -1
            start = instrument.start_day
            end = instrument.exp_day
            freq = instrument.add_info('Sp_RollingPeriod')
            calendars = list()
            a = instrument.add_info('Sp_MLDCal1')
            if a:
                calendars.append(acm.FCalendar[a])
            b = instrument.add_info('Sp_MLDCal2')
            if b:
                calendars.append(acm.FCalendar[b])
            c = instrument.add_info('Sp_MLDCal3')
            if c:
                calendars.append(acm.FCalendar[c])
            method = instrument.add_info('Sp_PayDayMethod')
            periods = acm.DealCapturing().GenerateStripOfOptionDates(start, end, freq, end, method, calendars, False)

            option = acm.FOption[instrument.insaddr]
            events = option.GetExoticEventsOfKind('Price Fixing')
            idx = 0
            for key, group in groupby(sorted(events, key=sortFunc), key=sortFunc):
                try:
                    start, end = periods[idx:idx + 2]
                    idx += 1
                    if acm.Time.DateDifference(today, key) > 0:
                        continue
                    interestDays = acm.Time.DateDifference(end, start)
                    premium_amount = (premium_percentage / 100 * notional * interestDays / basis) * (-1)
                    createPayment(entity, premium_amount, key)
                except Exception as e:
                    print('Cannot generate all Premium Payments for option trade %i' % entity.trdnbr)
                    print(e)
    return transaction_list

...

  MMLD_Payments
import acm
import FBDPGui
from FLogger import FLogger

import PsRvm_AccountingMmldColumn

"""
footprint:
    2023-11-27 richard.milford@fisglobal.com
    update the script to generate period-based (i) MMLD Payout and (ii) premium
    confirmed by Bank Mandiri, that both (i) and (ii) are paid out at the same time. 
    i.e. the script should generarte a value for both of these concurrently and for the same dates (pay date)
    
    Payout Calculation:
    Re-use of PsRvm_AccountingMmldColumn.calculateMmldDailyAccrual(), which calculates the accrued payment per observation date within an observation period.
    
    
"""

logger = FLogger(name=__name__)
log_levl_dict = {'INFO' : 1, 'DEBUG' : 2, 'WARN' : 3, 'ERROR' : 4}

# Tool Tip
tttrades = 'Trades to process.'
tttradeQueryFolder = 'Trade Query Folder to process.'
ttdate = 'Date for the payments to run.'
ttLogMode = 'Defines the amount of logging produced.'
ttLogToCon = 'Whether logging should be done in the Log Console or not.'
ttLogToFile = 'Defines whether logging should be done to file.'
ttLogFile = r'Name of the logfile. Could include the whole path c:\log\...'

query = acm.CreateFASQLQuery(acm.FTrade, 'AND')  # empty query
op = query.AddOpNode('OR')
op.AddAttrNode('Instrument.Name', 'RE_LIKE_NOCASE', None)
op = query.AddOpNode('AND')
op.AddAttrNode('Oid', 'GREATER_EQUAL', None)
op.AddAttrNode('Oid', 'LESS_EQUAL', None)
op = query.AddOpNode('OR')
op.AddAttrNode('Portfolio.Name', 'EQUAL', None)
op = query.AddOpNode('OR')
op.AddAttrNode('DealPackageTradeLinks.DealPackage.InstrumentPackage.DefinitionName','EQUAL', 'SP_MarketLinkedDepositRangeAccrualFx')
op.AddAttrNode('DealPackageTradeLinks.DealPackage.InstrumentPackage.DefinitionName','EQUAL', 'SP_MarketLinkedDepositDeal')

trade_query_folders = acm.FStoredASQLQuery.Select('subType = FTrade')
query_names = [query_folder.Name() for query_folder in trade_query_folders]

ael_variables = FBDPGui.DefaultVariables(
    # Variable     Display                          Type           Candidate  Default  Mandatory   Description Input Enabled
    # name         name                                            values                    Multiple          hook
    ('trades', 'MMLD Trades', 'FTrade', None, query, False, True, tttrades),
    ('tradeQueries', 'MMLD Trade Queries', 'FStoredASQLQuery', query_names, None, False, True, tttradeQueryFolder),
    ('reportDate', 'Process Date', 'string', None, acm.Time.DateToday(), True, False, ttdate),
    ('Logmode', 'Log mode_Logging', 'string', ['INFO','DEBUG','WARN','ERROR'], 'INFO', False, False, ttLogMode),
    ('LogToConsole', 'Log to console_Logging', 'int', [1, 0], 1, False, False, ttLogToCon),
    ('LogToFile', 'Log to file_Logging', 'int', [1 ,0], 0, False, False, ttLogToFile),
    ('Logfile', 'Log file_Logging', 'string', None, __name__ + '.log', False, False, ttLogFile),)


def getValidDate(newDate):
    period = acm.Time().PeriodSymbolToDatePeriod(newDate)
    if period:
        newDate = acm.Time.PeriodSymbolToDate(period)
    return newDate
    

def ProcessPayments(params):
    trades = params['trades']
    for query_folder in params['tradeQueries']:
        trades.AddAll(query_folder.Query().Select())
    if not trades:
        logger.LOG('No trades to process')
        
    report_date = getValidDate(params['reportDate'])
    for trade in trades:
        logger.LOG('Processing trade %i' % trade.Oid())
        instrument = trade.Instrument()
        
        if instrument.InsType() != 'Option':
            logger.LOG('Trade %i is not an option' % trade.Oid())
            continue
        events = instrument.GetExoticEventsOfKind('Price Fixing')
        if not events:
            logger.LOG('Instrument "%s" has no MLD Expiry Dates' % instrument.Name())
            continue
        events_report_date = [event for event in events if acm.Time.DateDifference(event.PayDate(), report_date) == 0]
        if len(events_report_date) == 0:
            logger.LOG('Report date %s is not a payment date for trade %i.' % (report_date, trade.Oid()))
            continue

        try:
            for event in instrument.ExerciseEvents():
                if acm.Time.DateDifference(report_date,event.SettlementDate()) == 0:
                    periodEndDate = event.EndDate()
                    logger.DLOG('Instrument "%s" calling calculateMmldDailyAccrual with periodEndDate %s' %(instrument.Name(),periodEndDate))
                    mld_amount = PsRvm_AccountingMmldColumn.calculateMmldDailyAccrual(instrument,periodEndDate,periodEndDate)
                    
        except Exception as e:
            mld_amount = 0
            logger.ELOG('Payout amount could not be calculated for instrument %s trade %s.' %(instrument.Name(),trade.Oid()))
            logger.ELOG(str(e))
    
        try:                    
            for event in instrument.ExerciseEvents():
                if acm.Time.DateDifference(report_date,event.SettlementDate()) == 0:
                    periodEndDate = event.EndDate()
                    
                    premium_percentage = instrument.AdditionalInfo().Sp_MLDPremiumOption()
                    notional = instrument.AdditionalInfo().Sp_LeverageNotional()
                    basis = instrument.AdditionalInfo().Sp_MLDDayBasis()
                    
                    logger.DLOG('Instrument "%s" calling PsRvm_AccountingMmldColumn.getCurrentPayPeriodDaysInfo with periodEndDate %s' %(instrument.Name(),periodEndDate))
                    currentPeriodNoCalDays = PsRvm_AccountingMmldColumn.getCurrentPayPeriodDaysInfo(instrument,periodEndDate)[3]

                    premium_amount = (premium_percentage / 100 * notional * currentPeriodNoCalDays/basis) *(-1)
        except Exception as e:
            premium_amount = 0
            logger.ELOG('Premium amount could not be calculated for instrument %s trade %s.' %(instrument.Name(),trade.Oid()))
            logger.ELOG(str(e))
            
        payments = trade.Payments()
        to_delete = acm.FArray()
        for payment in payments:
            if acm.Time.DateDifference(payment.PayDay(), report_date) == 0:
                if payment.Type() in ('MMLD Payment', 'Premium') and payment.Text() == 'Auto':
                    to_delete.Add(payment)

        new_payments = acm.FArray()

        # MMLD Payment
        if acm.Math.AlmostZero(mld_amount, 1e-2):
            logger.LOG('MMLD Payment amount is zero for trade %i.' % trade.Oid())
        else:
            payment = acm.FPayment()
            payment.Type('MMLD Payment')
            payment.Party(trade.Counterparty())
            payment.Currency(trade.Currency())
            payment.PayDay(report_date)
            payment.ValidFrom(report_date)
            payment.Amount(mld_amount)
            payment.Trade(trade)
            payment.Text('Auto')
            new_payments.Add(payment)

        # Premium Payment
        if acm.Math.AlmostZero(premium_amount, 1e-2):
            logger.LOG('Premium amount is zero for trade %i.' % trade.Oid())
        else:
            payment = acm.FPayment()
            payment.Type('Premium')
            payment.Party(trade.Counterparty())
            payment.Currency(trade.Currency())
            payment.PayDay(report_date)
            payment.ValidFrom(report_date)
            payment.Amount(premium_amount)
            payment.Trade(trade)
            payment.Text('Auto')
            new_payments.Add(payment)
        if new_payments:
            acm.BeginTransaction()
            try:
                new_payments.Commit()
                to_delete.Delete()
                logger.LOG('Payments created for trade %i.' % trade.Oid())
                acm.CommitTransaction()
            except Exception as e:
                acm.AbortTransaction()
                logger.ELOG('Could not create payments for trade %i.' % trade.Oid())
                logger.ELOG(str(e))
        else:
            logger.LOG('No payments created for trade %i.' % trade.Oid())
    logger.LOG('Completed payment creation for report date: %s' % report_date)


def ael_main(params):
    if params['LogToFile'] and params['Logfile']:
        logger.Reinitialize(log_levl_dict[params['Logmode']], None, None, params['LogToConsole'], True, params['Logfile'], None, None, None)
    else:
        logger.Reinitialize(log_levl_dict[params['Logmode']], None, None, params['LogToConsole'], True, None, None, None, None)
    logger.LOG('Initialising MMLD Payments process')
    ProcessPayments(params)

...

  SP_MarketLinkedDeposit

from __future__ import division
from __future__ import absolute_import

import acm
import math, inspect, string , types
from math import isnan

try:
    from StructuredProductsCommonAddInfo import SP_CommonAddInfoDealPackageDefinitionWithPreDeal
except ImportError:
    try:
        from StructureProductsPreDealUtils import SP_CommonAddInfoDealPackageDefinitionWithPreDeal
    except ImportError:
        from DealPackageDevKit import DealPackageDefinition as SP_CommonAddInfoDealPackageDefinitionWithPreDeal

try:
    from StructuredProductsCommonAddInfo import CommonTradeDefinition
except ImportError:
    from CompositeAttributesLib import TradeDefinition as CommonTradeDefinition

from DealPackageDevKit import DealPackageUserException, Object, InstrumentPart, TradeStatusChoices, PortfolioChoices, AcquirerChoices, CounterpartyChoices
from CompositeAttributesLib import PaymentsDialog

class MLDBaseDefinition(SP_CommonAddInfoDealPackageDefinitionWithPreDeal):
    #-----------------------------
    # Traits to handle fixing dates
    #-----------------------------
    def AttributeOverrides(self, overrideAccumulator):
        overrideAccumulator({
        })

    #-----------------------------
    # Date period logic
    #-----------------------------
    def TradeDayFromPeriod(self, startDate, period):
        tradeDay = acm.Time.DateAdjustPeriod(startDate, period)
        if self.currency and self.currency.Calendar():
            tradeDay = self.currency.Calendar().ModifyDate(None, None, tradeDay)
        return tradeDay

    def FirstRelevantDayOfMonth(self, value):
        return acm.Time.FirstDayOfMonth(value)

    #-----------------------------
    # On Selection Changed callacks
    #-----------------------------
    def RegisterUpdatedAttribute(self, attrName, *args):
        raise NotImplementedError('Method RegisterUpdatedAttribute not implemented')

    #-----------------------------------------
    # Formatters
    #-----------------------------------------
    def VisibleIfNotCountLoss(self, traitName):
        # For now always true
        # Change if count feature is implemented on other strucutures
        return True

    def VisibleTerminationStatus(self, traitName):
        return (self.IsShowModeDetail() or self.terminationStatus != 'None')

    #-----------------------------------------
    # Validation callbacks
    #-----------------------------------------
    def ValidateDatePeriod(self, attrName, value, *rest):
        if not acm.Time().PeriodSymbolToDate(value):
            raise DealPackageUserException('"%s" is not a valid date period' % value)

    #-------------------------------------------------
    # Other methods to be overridden by lower classes
    #-------------------------------------------------
    def LabelReplaceWithQuotation(self, traitName):
        label = self.GetAttributeMetaData(traitName, '_labelText')()
        if label:
            if label.find('Quotation') > 0:
                if not self.notionalQuotation:
                    return label.split('(')[0].strip()
                quotationName = self.notionalQuotation.Name().replace('Per ', '')
                label = label.replace('Quotation', quotationName)
        return label

    #-----------------------------------------
    # Other methods
    #-----------------------------------------
    def IsB2B(self, attrName):
        return self.b2bEnabled

    def IsB2BorDetail(self, attrName):
        return self.IsB2B(attrName) or self.IsShowModeDetail()

    #-----------------------------------------
    # Interface override
    #-----------------------------------------
    def CustomPanes(self):
        raise NotImplementedError('Method CustomPanes not implemented')

    def OnSave(self, saveConfig):
        ret = super().OnSave(saveConfig)
        return ret

    def OnInit(self):
        self._formatterTarget = None
        self._standardCalcSpaceCollection = None
        self._generateAttributeUpdated = False
        self.RegisterCallbackOnAttributeChanged(self.RegisterUpdatedAttribute)

    def AssemblePackage(self):
        raise NotImplementedError('Method AssemblePackage not implemented')

    @classmethod 
    def SetUp(cls, definitionSetUp):
        import SP_MarketLinkedDeposit_Setup
        SP_MarketLinkedDeposit_Setup.SetupMLD(definitionSetUp)




...

  SP_MarketLinkedDeposit_Setup
from __future__ import print_function
from __future__ import division
from __future__ import absolute_import
import acm

#----------------------
# MLD Setup
#----------------------
#valuationGroupNameMLD = 'Vanna Volga'
mappingContext = 'Global'

add_info_specs = [['Instrument', 'sp_LeverageNotional', 'Double', 'Leveraged Notional', 'Standard', ['Option'], None, False],
                 ['Instrument', 'sp_RollingPeriod', 'String', 'Frequency of date schedule', 'Standard', ['Option'], None, False],
                 ['Instrument', 'sp_PayDayMethod', 'BusinessDayMethod', 'Business Day Method for calculating delivery dates', 'Enum', ['Option'], None, False],
                 ['Instrument', 'StructureType', 'ChoiceList', 'StructureType', 'RecordRef', [], None, False],
                 ['Instrument', 'sp_MLDCeiling', 'Double', 'MMLD Ceiling', 'Standard', ['Option'], None, False],
                 ['Instrument', 'sp_MLDFloor', 'Double', 'MMLD Floor', 'Standard', ['Option'], None, False],
                 ['Instrument', 'sp_MLDPremiumOption', 'Double', 'MMLD Premium Option', 'Standard', ['Option'], None, False],
                 ['Instrument', 'sp_MLDReference', 'CurrencyPair', 'MMLD Reference', 'RecordRef', ['Option'], None, False],
                 ['Instrument', 'sp_MLDMaxYield', 'Double', 'MMLD Premium Option', 'Standard', ['Option'], None, False],
                 ['Instrument', 'sp_MLDMinYield', 'Double', 'MMLD Premium Option', 'Standard', ['Option'], None, False],
                 ['Instrument', 'sp_MLDDayBasis', 'Integer', 'MMLD Premium Option', 'Standard', ['Option'], None, False],
                 ['Instrument', 'sp_MLDCal1', 'Calendar', 'MMLD Calendar1', 'RecordRef', ['Option'], None, False],
                 ['Instrument', 'sp_MLDCal2', 'Calendar', 'MMLD Calendar2', 'RecordRef', ['Option'], None, False],
                 ['Instrument', 'sp_MLDCal3', 'Calendar', 'MMLD Calendar3', 'RecordRef', ['Option'], None, False],
                 ['DealPackage', 'sp_ExternalId', 'String', 'External Identifier', 'Standard', [], None, False]]

choice_list_specs = [('StructureType', 'Market Linked Deposit RAFx', 'MarketLinkedDeposit IR', 'Market Linked Deposit Deal')]


def SetupMLD(definitionSetUp):
    contextName = mappingContext
    if not (contextName and acm.FContext[contextName]):
        raise RuntimeError('No valid context for mappings specified in MLD parameters (FParameters)')
    
    from DealPackageSetUp import AddInfoSetUp, ChoiceListSetUp, ContextLinkSetUp, CustomMethodSetUp

    for choiceList in choice_list_specs:
        choiceListSetupObject = ChoiceListSetUp( list   = choiceList[0],
                                                 entry  = choiceList[1],
                                                 descr  = choiceList[2]
                                               )
        definitionSetUp.AddSetupItem( choiceListSetupObject )

    for addinfo in add_info_specs:
        addInfoSetupObject = AddInfoSetUp(  recordType      = addinfo[0],
                                            fieldName       = addinfo[1],
                                            dataType        = addinfo[2],
                                            description     = addinfo[3],
                                            dataTypeGroup   = addinfo[4],
                                            subTypes        = addinfo[5],
                                            defaultValue    = addinfo[6],
                                            mandatory       = addinfo[7]
                                        )
        definitionSetUp.AddSetupItem( addInfoSetupObject )
        
    '''
    for contextLink in context_links:
        contextLinkSetUpObject = ContextLinkSetUp(  context     = contextName, 
                                                    type        = contextLink[0], 
                                                    name        = contextLink[1], 
                                                    mappingType = contextLink[2], 
                                                    chlItem     = contextLink[3]
                                                 )
        definitionSetUp.AddSetupItem( contextLinkSetUpObject )
    '''

...

  SP_MarketLinkedDeposit_Utils

from __future__ import print_function
from __future__ import division
from __future__ import absolute_import
from builtins import next
from FFixPerform import UsedPrice

from builtins import object
import acm, ael, math
from CompositeAttributeDevKit import CompositeAttributeDefinition
from DealPackageDevKit import ReturnDomainDecorator, Str, DealPackageUserException
from SP_BusinessCalculations import GetHistoricalFxRate, GeneratePeriodEndDates, GenerateExpiryTableDates, AdjustBankingDaysFromMultiCalendars

TargetAdjustmentTwoWayEnumMapping = {0 : 'No Adjustment',   'No Adjustment'   : 0,
                                     1 : 'Adjust Strike',   'Adjust Strike'   : 1,
                                     2 : 'Adjust Notional', 'Adjust Notional' : 2}



def BuySellMappingDictionary():
    return {'FromOptionType':{'Foreign' :{False:"SELL", True:"BUY"},
                              'Domestic':{False:"BUY", True:"SELL"}},
            'ToOptionType'  :{'Foreign' :{"SELL":False, "BUY":True},
                              'Domestic':{"SELL":True, "BUY":False}}}
                              
                              
def BuySellMappingFromOptionTypeDefault(direction):
    return 'SELL' if direction == 'Foreign' else 'BUY'

def BuySellMapping(instrument, direction, value = 'NoValue'):
    if value == 'NoValue':
        return BuySellMappingDictionary()['FromOptionType'][direction].get(instrument.OptionTypeIsCall(), BuySellMappingFromOptionTypeDefault(direction))
    else:
        optionType = BuySellMappingDictionary()['ToOptionType'][direction].get(value, False)
        instrument.SuggestOptionType(optionType)
    
    
'''
class SelectPackageType(CompositeAttributeDefinition):
    
    def OnInit(self, label, choiceListSource, definitionPrefix):
        self._label = label
        self._choiceListSource = choiceListSource
        self._currentlyOpeningen = None
        self._definitionPrefix = definitionPrefix
    
    def Attributes(self):
        return { 'packageType' : Str( label=self._label,
                                      objMapping=self.UniqueCallback('PackageType'),
                                      choiceListSource=self._choiceListSource)
               }
    
    @ReturnDomainDecorator('string')
    def PackageType(self, value = '*Reading*'):
        if value == '*Reading*':
            return self.TrimPrefix(self.Owner().DealPackage().DefinitionDisplayName())
        else:
            definitionDisplayName = self.AddPrefixToDefinition(value)
            self._currentlyOpeningen = definitionDisplayName
            obj = acm.DealPackage.New(definitionDisplayName)
            self.OpenObject(obj)

    def TrimPrefix(self, displayName):
        nameNoPrefix = displayName.replace(self._definitionPrefix, '')
        nameNoSpace = nameNoPrefix.strip()
        return nameNoSpace

    def AddPrefixToDefinition(self, selectedDefinition):
        definitionName = '%s%s' % (self._definitionPrefix, selectedDefinition)
        return definitionName

    def OpenObject(self, obj):
        uxCallbacks = self.Owner().GetAttribute('uxCallbacks')
        if uxCallbacks:
            openCb = uxCallbacks.At('open')
            if openCb:
                acm.AsynchronousCall(openCb, [obj, self.OnOpenFail])

    def OnOpenFail(self):
        print ('Failed to open package of type "%s"'%self._currentlyOpeningen)
        
    def GetLayout(self):
        return self.UniqueLayout(""" 
            vbox(;
                packageType;
            );
            """)
'''


def CalculateAverageFixing(averagePriceEvents, roundingSpec = None):
    def GetRounding(roundingSpec, attr):
        r = None
        rs = roundingSpec
        if rs and type(rs) == type(acm.FRoundingSpec()):
            r = next((r for r in rs.Roundings() if r.Attribute() == attr), None)
        return r
    
    avg = -1.00
    c1 = all(i.EventValue() > 0.0 for i in averagePriceEvents)

    if not c1:
        str = 'Missing daily fixings in period.'
        raise DealPackageUserException(str)
        
    ev = [e.EventValue() for e in averagePriceEvents]
    avg = sum(ev) / float(len(ev))
    
    round = GetRounding(roundingSpec, 'Settled Price')
    Round = acm.GetFunction('round', 3)
    if round:
        avg = Round(avg, round.Decimals(), round.Type())
    else:
        avg = Round(avg, 3, 'Normal')
        
    return avg


def ExpiryPeriodToDate(ins, periodOrDate, startDate = acm.Time.DateToday()):
    # Note: ExpiryDateFromPeriod will create a pop up if called with
    #       a period that ends on a non banking day.
    #       In order to avoid pop-up, call this method with an instrment decorator
    #       that has AskAdjustToFollowingBusinessDay set to False
    value = periodOrDate
    if acm.Time.PeriodSymbolToDate(periodOrDate):
        if ins.UnderlyingType() == 'Curr':
            if ins.ForeignCurrency() and ins.DomesticCurrency():
                ccyPair = ins.ForeignCurrency().CurrencyPair(ins.DomesticCurrency())
                returnDate = ccyPair.ExpiryDate(startDate, periodOrDate)
            else:
                returnDate = ins.ExpiryDateFromPeriod(periodOrDate)
                if ins.ForeignCurrency():
                    returnDate = ins.ForeignCurrency().Calendar().ModifyDate(None, None, returnDate)
                elif ins.DomesticCurrency():
                    returnDate = ins.DomesticCurrency().Calendar().ModifyDate(None, None, returnDate)
            returnDate = ins.SpotDate(returnDate)
            return returnDate
        else:
            returnDate = ins.ExpiryDateFromPeriod(periodOrDate)
            if ins.Underlying() and ins.Underlying().SettlementCalendar():
                returnDate = ins.Underlying().SettlementCalendar().ModifyDate(None, None, returnDate)
            elif ins.Currency() and ins.Currency().Calendar():
                returnDate = ins.Currency().Calendar().ModifyDate(None, None, returnDate)
            returnDate = ins.SpotDate(returnDate)
            return returnDate
    return value

def TransformUsingDecorator(obj, value, inputField, outputField = None):
    tempObjDecorator = acm.FBusinessLogicDecorator.WrapObject(obj.StorageNew())
    if hasattr(tempObjDecorator, inputField):
        getattr(tempObjDecorator, inputField)(value)
        outputField = inputField if outputField is None else outputField
        transformedValue = getattr(tempObjDecorator, outputField)()
        return transformedValue
    return value

def GetInverseRate(value):
    if value == 0.0 or value is None:
        return 0.0
    return 1.0 / value

def GetValueForeignPerDomestic(ins, storedValue):
    if ins.StrikeQuotation() is None or ins.StrikeQuotation().Name() != 'Per Unit Inverse':
        return GetInverseRate(storedValue)
    return storedValue

def GetValueDomesticPerForeign(ins, storedValue):
    if ins.StrikeQuotation() is not None and ins.StrikeQuotation().Name() == 'Per Unit Inverse':
        return GetInverseRate(storedValue)
    return storedValue

def FixingToUseForAccumulation(ee, inverted):
    if inverted and ee.ComponentInstrument() and ee.ComponentInstrument().InsType() == 'Curr':
        return -GetInverseRate(ee.EventValue())
    else:
        return ee.EventValue()


def AccumulateValues(values, maxValue, adjustToMax, barrierValues = []):
    def Accumulate(val, next, max, adjust):
        if (val < max) or (max == 0.0):
            val += next
            if max and val > max and adjust:
                val = max
        return val

    accumulated = []
    
    for v in values:
        accumulated.append(Accumulate(accumulated[-1] if accumulated else 0, v, maxValue, adjustToMax))
    return accumulated




def GetAllMLDProductTypes():
    subTypes = []
    subTypes.append('Market Linked Deposit RAFx')
    subTypes.append('Market Linked Deposit Deal')
    subTypes.append('Market Linked Deposit IR')
    return subTypes

def MLDExpiryEvents(ins):
    return ins.GetExoticEventsOfKind('Price Fixing')

def MLDExpiryEventsSortedByDate(ins):
    return MLDExpiryEvents(ins).SortByProperty('Date')

def MLDExpiryEvent(ins, date):
    mldExpiries = MLDExpiryEvents(ins)
    for mldExpiry in mldExpiries:
        if mldExpiry.Date() == date:
            return mldExpiry
    return None

def MLDExpiryEventPerPayDate(ins, date):
    mldExpiries = MLDExpiryEvents(ins)
    for mldExpiry in mldExpiries:
        if mldExpiry.EndDate() == date:
            return mldExpiry
    return None

def MLDExpiryEventsIncludeHistorical(instrument, dateToday, includeHistorical):
    events = []
    for event in MLDExpiryEvents(instrument):
        if (acm.Time.DateDifference(event.Date(), dateToday) == 0 or (includeHistorical and acm.Time.DateDifference(event.Date(), dateToday) < 0)):
            if event.EventValue() == -1.0:
                events.append(event)
    return events

def GetNumberOfPaymentPeriods(instrument):
    excEvents = instrument.ExerciseEvents()
    numberOfPeriods = 0
    if excEvents is not None: 
        settlementDates = set([x.SettlementDate() for x in excEvents])
        if settlementDates: 
            numberOfPeriods = len(settlementDates)
   
    return numberOfPeriods

#------------------------------------
# Fixing the FX rate
#------------------------------------
def FixFxRateCalculation(insDecorator, event, instrumentPair):
    #foreign = insDecorator.ForeignCurrency() if instrumentPair.IsKindOf('FCurrencyPair') else insDecorator.ForeignInstrument()
    #domestic = insDecorator.DomesticCurrency()
    return GetHistoricalFxRate(instrumentPair.Currency1(), instrumentPair.Currency2(), event.Date())

# ----------------------------------------------------------------
# Exotic fixings hook referenced from Custom Instrument Definition - FSQLDataMaint
# ----------------------------------------------------------------
def MLDExoticFixingsHook(instrument, dateToday, updateHistorical, updateResult):
    return ['Price Fixing']


def MLDExpiryEventsIncludeHistorical(instrument, dateToday, includeHistorical):
    events = []
    for event in MLDExpiryEvents(instrument):
        if (acm.Time.DateDifference(event.Date(), dateToday) == 0 or (includeHistorical and acm.Time.DateDifference(event.Date(), dateToday) < 0)):
            if event.EventValue() == -1.0:
                events.append(event)
    return events
    
def MtMPriceFromFixingSource(exoticEvent, currency = None):
    fixingSource = None
    if exoticEvent and exoticEvent.Instrument():
        ins = exoticEvent.Instrument()
        fixingSource = ins.FixingSource()
        currPair = ins.ValuationUnderlying().CurrencyPair()
        price = UsedPrice(currPair.Currency1(), exoticEvent.Date(), exoticEvent.Date(), currPair.Currency2(), fixingSource, False)
        #print(f"price from MtMPriceFromFixingSource = {price}")
        if (price is None) or (math.isnan(price)):
            return None, False
        return price, True
        
    return None, False
    

def MLDRAFxExoticFixingsHook(instrument, dateToday, updateHistorical, updateResult):
    # Work-around: Class and method definitions below are redundant with FSEQDataMaint. 
    # However, importing FSEQDataMaint cause performance penalty (due to 
    # Selects being assigned to globals)
    class FExoticEventUpdateResult(object):
        def __init__(self):
            self.nHistoricalSuccess = 0
            self.nHistoricalFailed = 0

        def addResult(self, anotherResult):
            self.nHistoricalSuccess += anotherResult.nHistoricalSuccess
            self.nHistoricalFailed += anotherResult.nHistoricalFailed

        def hasFailedUpdates(self):
            return (self.nHistoricalFailed > 0)

        def logResult(self):
            ael.log_all("Historical updates performed: " + str(self.nHistoricalSuccess))
            ael.log_all("Historical updates failed:    " + str(self.nHistoricalFailed))
            
    def LogEventWritten(derivative, underlying, updatedEvent, oldValue, newValue):
        ael.log_all("\nInstrument:    " + derivative.Name())
        ael.log_all("Underlying:    " + updatedEvent.ComponentInstrument().Name())
        ael.log_all("Event date:    " + str(updatedEvent.Date()))
        ael.log_all("Old Value:     " + str(oldValue))
        ael.log_all("New Value:     " + str(newValue))
        ael.log_all("Event type:    " + str(updatedEvent.Type()))
        ael.log_all("---------------------------------------")
            
    def UpdateExoticEventValue(exoticEvent, eventValue):
        oldValue = exoticEvent.EventValue()
        eClone = exoticEvent.Clone()
        eClone.EventValue = eventValue
        exoticEvent.Apply(eClone)
        try:
            exoticEvent.Commit()
            LogEventWritten(exoticEvent.Instrument(), exoticEvent.Instrument().Underlying(), exoticEvent, oldValue, eventValue)
        except Exception as e:
            ael.log_all("Could not update Exotic Event Value, due to: %s" % str(e))
                
    totalFixingResult = FExoticEventUpdateResult()
    eventsToProcess = MLDExpiryEventsIncludeHistorical(instrument, dateToday, updateHistorical)
    for event in eventsToProcess:
        eventUpdateResult = FExoticEventUpdateResult()
        try:
            mtmPrice, handled = MtMPriceFromFixingSource(event)
            if mtmPrice is not None:
                UpdateExoticEventValue(event, mtmPrice)
                eventUpdateResult.nHistoricalSuccess = 1
            else:
                fixingSource = event.Instrument().FixingSource()
                if fixingSource:
                    msg = "Failed to retrieve MtM Price form fixing source {} for exotic event with Oid: {}".format(fixingSource.Name(), event.Oid())
                else:
                    msg = "Failed to retrieve MtM Price for exotic event with Oid: {}".format(event.Oid())
                ael.log(msg)

        except Exception as e:
            eventUpdateResult.nHistoricalFailed = 1
            ael.log_all(instrument.Name() +  
                    ": ERROR: " + str(e) + \
                    " (period ending %s)" % str(event.Date()))
        totalFixingResult.addResult(eventUpdateResult)
    if totalFixingResult.hasFailedUpdates():
        ael.log_all("\n" + instrument.Name() + 
            ": Failed to update exotic events for instrument.")
        totalFixingResult.logResult()
        ael.log_all("---------------------------------------")
    updateResult.addResult(totalFixingResult)
    return []


# ----------------------------------------------------------------
# End - Exotic fixings hook referenced from Custom Instrument Definition - FSQLDataMaint
# ----------------------------------------------------------------


#----------------------
# General help methods
#----------------------
def GetPaymentsOfKinds(trade, kinds):
    kindPayments = acm.FArray()
    allPayments = trade.Payments()
    for payment in allPayments:
        if payment.Type() in kinds:
            kindPayments.Add(payment)
    return kindPayments

def GetPaymentsOfKind(trade, kind):
    kinds = acm.FArray()
    kinds.Add(kind)
    return GetPaymentsOfKinds(trade, kinds)

def TargetAdjustmentTranslation(targetAdjustmentKey):
    if targetAdjustmentKey not in TargetAdjustmentTwoWayEnumMapping:
        raise RuntimeError('%s is not a valid Target Adjustment value' % str(targetAdjustmentKey))
    return TargetAdjustmentTwoWayEnumMapping[targetAdjustmentKey]

#-------------------------------------
# Custom Methods (Exotic Events)
#-------------------------------------

def MLDFixingDomesticPerForeign(ee):
    return ee.EventValue()
    
def PayDate(ee):
    evtDate = ee.Date()
    value=None
    excEvts = [x for x in ee.Instrument().ExerciseEvents() if ( x.StartDate() <= evtDate) and (x.EndDate() >= evtDate)]
    if excEvts and (len(excEvts) > 0 ):
        excEvt = excEvts[0]
        if(value is None) :
            return excEvt.SettlementDate()
        else:
            excEvt.SettlementDate(value)
    return None

def SetPayDate(ee, value=None):
    if(value is not None) :
        evtDate = ee.Date()
        #value=None
        excEvts = [x for x in ee.Instrument().ExerciseEvents() if ( x.StartDate() <= evtDate) and (x.EndDate() >= evtDate)]
        if excEvts and (len(excEvts) > 0 ):
            excEvt = excEvts[0]
            excEvt.SettlementDate(value)

def MLDEndDate(ee, value=None):
    evtDate = ee.Date()
    #value=None
    excEvts = [x for x in ee.Instrument().ExerciseEvents() if ( x.StartDate() <= evtDate) and (x.EndDate() >= evtDate)]
    if excEvts and (len(excEvts) > 0 ):
        excEvt = excEvts[0]
        if(value is None) :
            return excEvt.SettlementDate()
        else:
            excEvt.SettlementDate(value)
    return value

def MLDFixing(ee):
    return ee.EventValue()

def MLDAmount(ee):
    return 0.0

def MLDAmountInOut(ee):
    if ( ee.EventValue() != -1) :
        if( ee.EventValue() >= ee.Instrument().AdditionalInfo().Sp_MLDFloor() ) and ( ee.EventValue() <= ee.Instrument().AdditionalInfo().Sp_MLDCeiling() ):
            return "In"
        else:
            return "Out"
    else:
        return ""
    

# -------------------------------
# Default values
# -------------------------------
def DefaultSheetDefaultColumns():
    return ['Price Theor', 
            'Portfolio Theoretical Value', 
            'Portfolio Underlying Price', 
            'Portfolio Underlying Forward Price', 
            'Portfolio Volatility', 
            'Portfolio Carry Cost', 
            'Instrument Delta']


#----------------------
# Custom Functions
#----------------------


def TargetAdjustmentToEnum(targetAdjustment):
    return TargetAdjustmentTranslation(targetAdjustment)

def TargetAdjustmentFromEnum(targetAdjustment):
    return TargetAdjustmentTranslation(targetAdjustment)
    
def GenerateMLDPeriodEndDates(startDate, endDate, method, rolling, calendars, settleDays, settleCalendars, **rest):
    return GeneratePeriodEndDates(startDate, endDate, method, rolling, calendars, settleDays, settleCalendars)


def GenerateMLDExpiryTable(fixingParams):
    
        # 1) verify parameters or throw exception
        #self._VerifyExpiryTableParameters(**fixingParams)

        # 2) Generate dates
        #print(fixingParams)
        periodEndDates  = GenerateMLDPeriodEndDates( **fixingParams )
        '''
        print(f"period end dates : **************")
        for pEndDate in periodEndDates:
            print(pEndDate)
        print(f"*********************************")
        '''
                                                
        expiryTableData = GenerateExpiryTableDates( fixingParams['startDate'],
                                                    fixingParams['calendars'] ,
                                                    periodEndDates,
                                                    fixingParams['frequency'])
        
        
        # 3) If new dates are different from existing date, update exercise events

        #allExerciseEvents = self._Accumulator().ExerciseEvents()

        #allExerciseEvents.Unsimulate()
        
        #for observation in expiryTableData:
            #CreateExerciseEvent(observation)
    
        # 5) generate price fixing events
        #self._UpdatePriceFixingEvents()
        return (expiryTableData, periodEndDates)
    

...

  SP_MarketLinkedDepositBase

import acm
import math, inspect, string , types
from math import isnan

try:
    from StructuredProductsCommonAddInfo import SP_CommonAddInfoDealPackageDefinitionWithPreDeal
except ImportError:
    try:
        from StructureProductsPreDealUtils import SP_CommonAddInfoDealPackageDefinitionWithPreDeal
    except ImportError:
        from DealPackageDevKit import DealPackageDefinition as SP_CommonAddInfoDealPackageDefinitionWithPreDeal

from DealPackageDevKit import DealPackageUserException, Object, InstrumentPart, TradeStatusChoices, PortfolioChoices, AcquirerChoices, CounterpartyChoices
from CompositeAttributesLib import PaymentsDialog

from SP_TrfUtils import SelectPackageType


class MarketLinkedDefinitionBase(SP_CommonAddInfoDealPackageDefinitionWithPreDeal):

    #-----------------------------
    # Visible Traits
    #-----------------------------
    packageType = SelectPackageType(label = 'Type',
                                choiceListSource = GetAllMLDProductTypes(),
                                definitionPrefix = '')

    name = Object(objMapping = InstrumentPart('DealPackage.InstrumentPackage.Name'),
                                label = 'Name',
                                toolTip = 'Name of Instrument Package' )
    
    suggestName = Action(label='Suggest',
                                action = '@SuggestNameAction',
                                toolTip = 'Suggest a name for the instrument/instrument package',
                                visible = True,
                                width = 2000,
                                maxWidth = 2000 )


    #-----------------------------------------
    # Interface override
    #-----------------------------------------
    def CreateSuggestedSecurityId(self):
        raise NotImplementedError('Method RegisterUpdatedAttribute not implemented')

    def SuggestNameAction(self, *args):
        self.name = self.CreateSuggestedSecurityId()

    @classmethod 
    def SetUp(cls, definitionSetUp):
        import SP_MarketLinkedDeposit_Setup
        SP_MarketLinkedDeposit_Setup.SetupMLD(definitionSetUp)

...

  SP_MarketLinkedDepositDeal

from __future__ import division
from __future__ import absolute_import

import acm
from DealPackageDevKit import DealPackageUserException, Object, InstrumentPart, PortfolioChoices, AcquirerChoices, Settings, TradeActions, DealPackageChoiceListSource
from SP_MMLDCloseCommand import MMLDCloseCommand as CloseCommand
from DealPackageUtil import UnDecorate
from ChoicesExprCommon import listChoicesWithEmpty

from CompositeTradeComponents import TradeInput
from SP_MarketLinkedDepositFxRA import MLDFxRABaseDefinition
from SP_CustomTradeActions import TrfExerciseAction

from CompositeLegDefinition import LegDefinition
from CompositeTradeDefinition import TradeDefinition
from CompositeCashFlowComponents import Deposit
from CompositeTradeComponents import TradeB2B

from StructureProductsPreDealUtils import findShell
from ComplianceCheckProgressDialog import ComplianceCheckProgressDialog

try:
    from StructuredProductsCommonAddInfo import CommonTradeDefinition
except ImportError:
    from CompositeAttributesLib import TradeDefinition as CommonTradeDefinition

class MarketLinkedDepositDealTrades(TradeInput):
    
    _quantityMapping = 'DepositTrades.Quantity'
    
    _buySellLabels = ['Deposit', 'Loan', '-']
    _buySellChoiceListWidth = 10


@Settings(ShowGraphInitially=False,
          GraphApplicable=False)
@TradeActions(exercise = TrfExerciseAction(), close = CloseCommand(statusAttr='trades_status', nominal='depositCashAmount'))
class MarketLinkedDepositDeal(MLDFxRABaseDefinition):
    #-----------------------------
    # Deposit data
    #-----------------------------                                                                     
    
    optionOid = Object(objMapping = InstrumentPart('Option.Oid'),
                            label = 'Oid',
                            visible=True)

    depositOid = Object(objMapping = InstrumentPart('Deposit.Oid'),
                            label = 'Oid',
                            visible=True)

    deposit = Deposit(depositName = 'Deposit',
                            depositLegName = 'DepositLeg' )

    leg = LegDefinition( leg='DepositLeg', trade='DepositTrade' )

    trades = CommonTradeDefinition(trade = 'DepositTrade')

    trade = TradeDefinition(trade='DepositTrade')

    tradeText1 = Object(objMapping = 'Trades.Text1',
                            label = 'Free Text')

    tradesOptKey1 = Object(objMapping = 'Trades.OptKey1',
                        choiceListSource = listChoicesWithEmpty('Branch'),
                        label = 'Branch')

    tradesOptKey2 = Object(objMapping = 'Trades.OptKey2',
                        choiceListSource = listChoicesWithEmpty('Interface'),
                        label = 'Interface')

    tradesOptKey3 = Object(objMapping = 'Trades.OptKey3',
                        choiceListSource = listChoicesWithEmpty('Product Type'),
                        label = 'Product Type')

    tradesOptKey4 = Object(objMapping = 'Trades.OptKey4',
                        choiceListSource = listChoicesWithEmpty('Category'),
                        label = 'Category')

    tradePortfolio = Object(objMapping = InstrumentPart('TradeOption.Portfolio'),
                            choiceListSource = PortfolioChoices(),
                            label = 'Portfolio Option')

    depositCashAmount = Object(objMapping = 'DepositCashAmount',
                        label = 'Cash Amount',
                        formatter = 'NumDefault')

    depositTradeCurrency = Object(objMapping = 'DepositTrade.Currency',
                        visible = False,
                        defaultValue = 'USD')

    instrumentsSettleDays = Object(objMapping = 'SettleDays',
                        label = 'Settle Days')

    mmld_premiumOption = Object(label='Premium Option(% p.a.)',
                            objMapping = 'PremiumOption',
                            formatter = 'MLDFourDecimal',
                            validate = '@ValidateRates',
                            visible = True)

    #--------------------------
    # Deposit B2B parameters
    #--------------------------

    depositB2B  = TradeB2B(uiLabel = 'Deposit',
                            b2bTradeParamsName = 'DepositB2BParams')

    depositB2BPrice = Object(visible = False,
                            objMapping = 'DepositB2BParams.TraderPrice')

    depositB2BAcq = Object(visible = False,
                            objMapping = 'DepositB2BParams.TraderAcquirer')

    depositB2BPort = Object(visible = False,
                            objMapping = 'DepositB2BParams.TraderPortfolio')

    b2bDepositEnabled = Object(defaultValue = False,
                            label = 'Deposit B2B Cover',
                            objMapping = 'DepositB2BParams.SalesCoverEnabled',
                            visible = True)

    #--------------------------
    # Option B2B parameters
    #--------------------------

    b2bOptionEnabled = Object(defaultValue = False,
                                  label = 'Option B2B Cover',
                                  objMapping = 'OptionB2BParams.SalesCoverEnabled',
                                  visible = True)

    b2bOptionMargin = Object(label='Margin',
                                objMapping='OptionMargin',
                                formatter='FullPrecision',
                                enabled='@IsB2BOption')
                            
    b2bOptionPrice = Object(defaultValue=0.0,
                                label='Trader Price',
                                objMapping='OptionPrice',
                                formatter='FullPrecision',
                                enabled='@IsB2BOption')
                            
    b2bOptionPrf = Object(label='Trader Portfolio',
                                objMapping='OptionB2BParams.TraderPortfolio',
                                choiceListSource=PortfolioChoices(),
                                enabled='@IsB2BOption',
                                onChanged='@SetChanged')
             
    b2bOptionAcq = Object(label='Trader Acquirer',
                                objMapping='OptionB2BParams.TraderAcquirer',
                                choiceListSource=AcquirerChoices(),
                                enabled='@IsB2BOption',
                                onChanged='@SetChanged')


    
    tradeQuantity = Object(objMapping = 'TradesOption.Quantity')

    def ChangeDepositCurrency(self, attrName, old_currency, new_currency, *rest):
        self.Option().Currency(new_currency)
        self.DepositTrade().Currency(new_currency)
        self.TradeOption().Currency(new_currency)
        calendar = new_currency.Calendar()
        self.Option().SettlementCalendar(calendar)
        self.UpdateCurrencyPairChoices(attrName)

    def AttributeOverrides(self, overrideAccumulator):
        overrideAccumulator({
            'productType': dict(defaultValue='Market Linked Deposit Deal'),
            'deposit_startDate': dict(label='Effective Date'),
            'deposit_endDate': dict(label='Maturity Date'),
            'leg_rollingPeriodBase': dict(label=''),
            'trade_portfolio': dict(label='Portfolio Deposit'),
            'mmld_premiumOption': dict(defaultValue=0.04),
            'domesticCurrency': dict(objMapping = 'Deposit.Currency|Option.DomesticCurrency', onChanged = '@ChangeDepositCurrency', defaultValue = 'USD'),
            'tradesOptKey3': dict(defaultValue = 'SP', editable = False),
            'tradesOptKey4': dict(defaultValue = 'MMLD', editable = False),
            'instrumentsSettleDays': dict (defaultValue = self.Option().PayDayOffset()),
            'settlementCalendar': dict(objMapping = 'Option.SettlementCalendar|DepositLeg.PayCalendar'),
            'leg_fixedRate': dict(objMapping = 'DepositLeg.FixedRate', validate = '@ValidateRates'),
            'deposit_freetext': dict(objMapping = 'Text1'),
            'depositTradeCurrency': dict(defaultValue = 'USD'),
        })

    def ValidateRates(self, attrName, value, *args):
        if str(attrName) == 'mmld_premiumOption':
            mmld_premiumOption = float(value)
            leg_fixedRate = self.DepositLeg().FixedRate()
        else:
            mmld_premiumOption = self.Option().AdditionalInfo().Sp_MLDPremiumOption()
            leg_fixedRate = value
        if mmld_premiumOption > leg_fixedRate:
            raise DealPackageUserException ('Deposit Fixed Rate (%.3f) must be a number greater than Option Premium (%.3f).' % (leg_fixedRate, mmld_premiumOption))

    def IsShowModeInstrumentDetail(self, *args):
        return True

    def DepositBase(self):
        return self.Deposit().DecoratedObject()

    def Deposit(self):
        return self.DealPackage().InstrumentAt('Trade')
        
    def DepositLeg(self):
        return self.Deposit().FirstEditLeg()
    
    def DepositTrade(self):
        return self.DealPackage().TradeAt('Trade')
    
    def TradesDeposit(self):
        return self.Deposit().Trades()
        
    def Trade(self):
        return self.DealPackage().TradeAt('Trade')
        
    def TradesOption(self):
        return self.Option().Trades()
        
    def TradeOption(self):
        return self.DealPackage().TradeAt('Option')

    def SettleDays(self, value = 'Reading'):
        if value == 'Reading':
            return self.Option().PayDayOffset()
        self.DepositLeg().PayOffset(f'{value}d')
        self.Option().PayDayOffset(value)

    def DepositCashAmount(self, value = 'Reading'):
        if value == 'Reading':
            return self.DepositTrade().CashAmount()
        self.DepositTrade().CashAmount(value)
        self.Deposit().PerformRegenerateAllCashFlows()

    def DepositB2B(self):
        return self.B2BTradeParamsAt('Trade')

    def DepositB2BParams(self):
        return self.B2BTradeParamsAt('Trade')

    def OptionB2BParams(self):
        return self.B2BTradeParamsAt('Option')

    def IsB2BDeposit(self, attrName):
        return self.b2bDepositEnabled

    def IsB2BOption(self, attrName):
        return self.b2bOptionEnabled

    def LeadTrade(self):
        return self.TradeAt('Option')

    def OnSave(self, saveConfig):
        super().OnSave(saveConfig)
        trade = self.Trade().DecoratedObject().Originator()
        if trade.Status() in ('Reserved', 'Limit Check'):
            shell = findShell(self.DealPackage().DecoratedObject().Originator())
            dial =  ComplianceCheckProgressDialog(trade)
            acm.UXDialogs.ShowCustomDialog(shell, dial.CreateLayout(), dial)
 
    def AssemblePackage(self):
        ins = acm.DealCapturing().CreateNewInstrument('MarketLinkedDepositDeal')
        trade = acm.DealCapturing().CreateNewTrade(ins)
        self.DealPackage().AddTrade(trade, 'Option')
                
        _deposit = self.deposit.CreateInstrument()
        tradeDeposit = acm.DealCapturing().CreateNewTrade(_deposit)
        self.DealPackage().AddTrade(tradeDeposit, 'Trade')

    def CustomPanes(self):
        return self.GetCustomPanesFromExtValue('CustomPanes_SP_MLDDealPackage')

    def PremiumOption(self, value = 'Reading'):
        if value == 'Reading':
            return self.OptionTrade().Price()
        value = float(value)
        self.OptionTrade().Price(value)
        self.Option().AdditionalInfo().Sp_MLDPremiumOption(value)

    def OptionMargin(self, value = 'Reading'):
        if value == 'Reading':
            return self.OptionTrade().Price() - self.OptionB2BParams().TraderPrice()
        value = float(value)
        new_trader_price = self.OptionTrade().Price() - value
        b2b = self.OptionB2BParams().DecoratedObject()
        b2b.TraderPrice(new_trader_price)
        self.SetChanged()

    def OptionPrice(self, value = 'Reading'):
        if value == 'Reading':
            return self.OptionB2BParams().TraderPrice()
        value = float(value)
        margin = value - self.OptionTrade().Price()
        b2b = self.OptionB2BParams().DecoratedObject()
        b2b.TraderPrice(value)
        self.SetChanged()

    def SetChanged(self, *args, **kwargs):
        self.DealPackage().Touch()
        self.DealPackage().Changed()

...

  SP_MarketLinkedDepositDealPackage

import acm

    
def StartMLDRangeAccrualFx(eii):
    acm.UX().SessionManager().StartApplication('Deal Package', 'SP_MarketLinkedDepositRangeAccrualFx')    

def StartMLDDeal(eii):
    acm.UX().SessionManager().StartApplication('Deal Package', 'SP_MarketLinkedDepositDeal')    

def StartMLDIR(eii):
    acm.UX().SessionManager().StartApplication('Deal Package', 'SP_MarketLinkedDepositIR')



def OnDoubleClick(eii):
    sheet = eii.Parameter( "sheet" )
    rows = sheet.Selection().SelectedRowObjects()
    if rows and rows[0].IsKindOf(acm.FExoticEvent):
        dpLinks = rows[0].Instrument().DealPackageInstrumentLinks()
        if dpLinks:
            ip = dpLinks.First().InstrumentPackage()
            dps = ip.DealPackages()
            entity = dps.First() if dps else ip
            acm.StartApplication('Deal Package', entity)


...

  SP_MarketLinkedDepositFxRA

from __future__ import division
from __future__ import absolute_import
from math import isnan

import acm
from DealPackageDevKit import DealPackageUserException, Box, Object, InstrumentPart, Action, ReturnDomainDecorator, Settings, TradeActions, \
     DealPackageChoiceListSource, TradeStatusChoices, PortfolioChoices, AcquirerChoices, CounterpartyChoices, CloseCommand
from DealPackageUtil import UnDecorate
from SP_MarketLinkedDepositOption import MLDOption
from SP_MarketLinkedDeposit import MLDBaseDefinition
from SP_TrfUtils import SelectPackageType
from SP_MarketLinkedDeposit_Utils import GetAllMLDProductTypes, ExpiryPeriodToDate
from SP_DealPackageHelper import DayMethodOnlyFollowingPreceding
from SP_CustomTradeActions import TrfExerciseAction
from CompositeTradeDefinition import TradeDefinition
from CompositeAttributesLib import BuySell, PaymentsDialog
from SP_MLDCompositeAttributes import MLDFxRateComposite, MLDFxFixingEditerComposite
from SP_BusinessCalculations import BankingDayPeriodToDateFromStartDate, GetPairCalendars
from SP_MLDCalculations import CalculateDailyAccrualReturn
import ChoicesExprInstrument

class CommonTradeDefinition(TradeDefinition):

    def CommonAttributes(self):
        return ['counterparty', 'yourRef', 'valueDay', 'acquireDay', 'trader', 'settleCategoryChlItem', 'status', 'tradeTime', 'optKey3', 'optKey4']
        
    def Attributes(self):
        allAttributes = super().Attributes()
        attributes = {}
        for attr in self.CommonAttributes():
            attributes[attr] = allAttributes[attr]
        return attributes
        
    def AttributeOverrides(self, overrideAccumulator):
        for attr in self.CommonAttributes():
            overrideAccumulator({attr: dict(onChanged=self.UniqueCallback('@Synchronize'))})
            
    def Synchronize(self, *args):
        for trade in self.Owner().Trades():
            if trade != self.Trade():
                trade = UnDecorate(trade)
                for attr in self.CommonAttributes():
                    attr = attr[:1].upper() + attr[1:]
                    value = getattr(self.Trade(), attr)()
                    setattr(trade, attr, value)

@TradeActions(close = CloseCommand(statusAttr='trades_status', nominal='notional1'))
class MLDFxRABaseDefinition(MLDOption):
    foreignPerDomesticVBox = Box( label='@LabelCurrBox', visible=False)
    domesticPerForeignVBox = Box( label='@LabelCurrBox', visible=False)

    _buySellLabels = ['Deposit', 'Loan', '-']
    _buySellChoiceListWidth = 10

    #-----------------------------
    # Visible Traits
    #-----------------------------

    packageType = SelectPackageType(label = 'Type',
                                choiceListSource = GetAllMLDProductTypes(),
                                definitionPrefix = '')

    name = Object(objMapping = InstrumentPart('DealPackage.InstrumentPackage.Name'),
                                label = 'Name',
                                toolTip = 'Name of Instrument Package' )
    
    suggestName = Action(label='Suggest',
                                action = '@SuggestNameAction',
                                toolTip = 'Suggest a name for the instrument/instrument package',
                                visible = True,
                                width = 2000,
                                maxWidth = 2000 )

    domesticCurrency = Object(objMapping = InstrumentPart('Option.DomesticCurrency'),
                                label = 'Notional Currency',
                                choiceListSource = acm.FCurrency.Instances(),
                                onChanged = '@UpdateCurrencyPairChoices',
                                toolTip = 'Notional Currency' )
        
    foreignCurrency = Object(objMapping = InstrumentPart('Option.ForeignCurrency'),
                                visible = False,
                                toolTip = 'Notional Currency' )

    notional1 = Object(objMapping = InstrumentPart('Option.ContractSizeInQuotation'),
                                label = 'Contr Size',
                                visible = False)

    notional2 = BuySell(objMapping = 'Notional2',
                                label = 'Notional Amount',
                                buySellLabels = ['B', 'S', '-'],
                                choiceListWidth = 10)

    ExternalId = Object(label='External Id',
                                visible = True,
                                objMapping = 'PackageExternalId')

    discountingType = Object(label = 'Disc Type',
                                choiceListSource = acm.GetDomain('FChoiceList(''''DiscType'''')').Instances(),
                                objMapping = InstrumentPart('Option.DiscountingType'),
                                visible = True
                                )
    
    valGroup = Object(label = 'Val Group',
                                objMapping = InstrumentPart('Option.ValuationGrpChlItem'),
                                choiceListSource = acm.GetDomain('FChoiceList(''''ValGroup'''')').Instances(),
                                visible = True)
    
    mmld_ceiling = Object(label = 'Ceiling',
                                formatter = 'MLDFourDecimal',
                                visible = True,
                                defaultValue = 0.0,
                                objMapping = 'Ceiling')

    mmld_floor = Object(label = 'Floor',
                                formatter = 'MLDFourDecimal',
                                visible = True,
                                defaultValue = 0.0,
                                objMapping = 'Floor')
    
    mmld_premiumOption = Object(label = 'Premium Option(% p.a.)',
                                formatter = 'MLDFourDecimal',
                                visible = True,
                                objMapping = InstrumentPart('Option.AdditionalInfo.Sp_MLDPremiumOption'))   
    
    mmld_reference = Object(label = 'Reference',
                                recreateCalcSpaceOnChange = True,
                                visible = True,
                                onChanged = '@UpdateForeignCurrency',
                                objMapping = InstrumentPart('Option.AdditionalInfo.Sp_MLDReference'))
    
    mmld_maxYield = Object(label = 'Max Yield/Return(% p.a.)',
                                formatter = 'MLDFourDecimal',
                                visible = True,
                                objMapping = InstrumentPart('Option.AdditionalInfo.Sp_MLDMaxYield'))
    
    mmld_minYield = Object(label = 'Min Yield/Return(% p.a.)',
                                formatter = 'MLDFourDecimal',
                                visible = True,
                                objMapping = InstrumentPart('Option.AdditionalInfo.Sp_MLDMinYield'))
    
    mmld_dayBasis = Object(label='Day Basis',
                                choiceListSource = [360, 365],
                                visible = True,
                                objMapping = InstrumentPart('Option.AdditionalInfo.Sp_MLDDayBasis'),
                                defaultValue = 365)
                                 
    mtmFromFreed = Object(objMapping = InstrumentPart('Option.MtmFromFeed'),
                                label = 'MTM From Feed' )
   
    startDate = Object(objMapping = InstrumentPart('StartDate'),
                                label = 'Option Start',
                                toolTip = 'Option Start Date',
                                validate = '@ValidateDate',
                                transform = '@ExpiryPeriodToDate' )
    
    datePeriod = Object(objMapping = InstrumentPart('Option.AdditionalInfo.Sp_RollingPeriod'),
                                validate = '@ValidateDatePeriod',
                                visible = '@VisibleIfNotAsian',
                                label = 'Rolling Period' )
    
    fixingCalendar1 = Object(label = 'Calendar1',
                                objMapping = InstrumentPart('Option.AdditionalInfo.Sp_MLDCal1'))
    
    fixingCalendar2 = Object(label = 'Calendar2',
                                objMapping = InstrumentPart('Option.AdditionalInfo.Sp_MLDCal2'))
    
    fixingCalendar3 = Object(label = 'Calendar3',
                                objMapping = InstrumentPart('Option.AdditionalInfo.Sp_MLDCal3'))
    
    settlementCalendar = Object(objMapping = InstrumentPart('Option.SettlementCalendar'),
                                label = 'Payment Calendar' )
    
    expiry = Object(objMapping = InstrumentPart('Expiry'),
                                label = 'Option End',
                                toolTip = 'Final Fixing Date',
                                validate = '@ValidateDate',
                                transform = '@ExpiryPeriodToDate'  )
    
    fixingSource = Object(objMapping = InstrumentPart('Option.FixingSource'),
                                label = 'Fixing Source' )
    
    nbrObservationDays = Object(objMapping = InstrumentPart('NumberOfObservationDays'),
                                label = 'Observation Days', enabled=False)
    
    dayMethod = Object(objMapping = InstrumentPart('Option.AdditionalInfo.Sp_PayDayMethod'),
                                choiceListSource = DayMethodOnlyFollowingPreceding(),
                                label = 'Day Convention' )
    
    spotReference = MLDFxRateComposite(rateDomPerFor = 'ReferencePriceDomPerFor', 
                               rateForPerDom = 'ReferencePriceForPerDom')

    trades = CommonTradeDefinition(trade = 'LeadTrade')

    #-----------------------------
    # Traits to handle fixing dates
    #-----------------------------
    fixingEditer = MLDFxFixingEditerComposite(instrument='Option')

    #-----------------------------
    # Non visible traits
    #-----------------------------
    baseType = Object(objMapping = InstrumentPart('Option.Exotic.BaseType'))

    strikeQuotation = Object(objMapping = InstrumentPart('Option.StrikeQuotation'))

    flipBuySell = Action(action = '@FlipBuySell')
    
    instrumentPair = Object(objMapping = InstrumentPart('InstrumentPair'),
                                    visible = False)

    def AttributeOverrides(self, overrideAccumulator):
        overrideAccumulator({
            'productType':                              dict(objMapping = InstrumentPart('Option.AdditionalInfo.StructureType')),
            'settlementCalendar':                       dict(defaultValue='Jakarta'),
            'settlementCalendar':                       dict(defaultValue='Jakarta'),
            'dayMethod':                                dict(defaultValue='Mod. Following'),
            'datePeriod':                               dict(defaultValue='1M'),
            'startDate':                                dict(defaultValue='0D'),
            'expiry':                                   dict(defaultValue='2Y'),
            'notional1':                                dict(defaultValue=1),
            'notional2_value':                          dict(defaultValue=1000000),
            'foreignCurrency':                          dict(visible = False, defaultValue='HKD'),
            'domesticCurrency':                         dict(defaultValue='USD'),
            'settlementType':                           dict(defaultValue='Cash', visible=False),
            'fixingSource' :                            dict(toolTip = 'Expiry Cutoff',
                                                        choiceListSource = ChoicesExprInstrument.getFixingSources(True)),
            'tradeCurrency':                            dict(onChanged = '@OnChangedTradeCurrency'),
            'baseType':                                 dict(defaultValue='Range Accrual', visible=False),

            'spotReference_rateForeignPerDomestic':     dict(label = 'Spot Ref', visible=False),
            'spotReference_rateDomesticPerForeign':     dict(label = 'Spot Ref', visible=False),
            

            'fixingEditer_fixingValue_rateDomesticPerForeign': dict(label='@LabelReplaceWithCurrency',
                                                       _labelText = 'Fixing (Domestic per Foreign)'),
            'fixingEditer_fixingValue_rateForeignPerDomestic': dict(label='@LabelReplaceWithCurrency',
                                                       _labelText = 'Fixing (Foreign per Domestic)', visible=False),
            'tradeNotional1_buySell':                   dict(label = '@LabelReplaceWithCurrency',
                                                       _labelText = 'Notional 1 (Foreign)'),
            'tradeNotional2_buySell':                   dict(label = '@LabelReplaceWithCurrency',
                                                       _labelText = 'Notional 2 (Foreign)'),

            'contractSize':                             dict(defaultValue= 1),
             
            'mmld_reference' :                          dict(defaultValue= 'USD/HKD',
                                                        choiceListSource = '@ChoicesCurrencyPairs'),
            'mmld_maxYield' :                           dict(defaultValue= 0.7),
            'mmld_minYield' :                           dict(defaultValue= 0),
            'mmld_premiumOption' :                      dict(defaultValue= 0.4),
            'ExternalId' :                              dict(defaultValue= ''),
            'dayMethod':                                dict(defaultValue = 'Mod. Following'),
            'tradesOptKey3':                            dict(defaultValue = 'SP'),
            'tradesOptKey4':                            dict(defaultValue = 'MLDR'),
            })

    #-----------------------------------------
    # Access components
    #-----------------------------------------
    def OptionNoDecorator(self):
        return self.Option().DecoratedObject()

    def OptionNoQuestionGui(self):
        option = self.OptionNoDecorator()
        gui = acm.FBusinessLogicGUIDefault()
        gui.AskAdjustToFollowingBusinessDay(False)
        return acm.FBusinessLogicDecorator.WrapObject(option, gui)

    def OptionTrade(self):
        return self.DealPackage().TradeAt('Option')
    
    def LeadTrade(self):
        return self.OptionTrade()

    def SetInstrumentFields(self):
        self.Option().ProductTypeChlItem(self.tradesOptKey3)
        self.Option().CategoryChlItem(self.tradesOptKey4)

    #-----------------------------
    # Object Mappings
    #-----------------------------
    def TradeNotional(self, value, scaleFactor):
        if value == 'NoValue':
            if scaleFactor:
                return scaleFactor * self.OptionTrade().Quantity()
            return 0.0
        if scaleFactor:
            self.OptionTrade().Quantity(value / scaleFactor)

    @ReturnDomainDecorator('float')
    def TradeNotional1(self, value = 'NoValue'):
        return self.TradeNotional(value, self.notional1)

    @ReturnDomainDecorator('float')
    def TradeNotional2(self, value = 'NoValue'):
        return self.TradeNotional(value, self.notional2)

    def DomesticCurrencyCalendar(self, *args):
        return self.domesticCurrency.Calendar() if self.domesticCurrency else None

    def Ceiling(self, value = 'Reading'):
        if value == 'Reading':
            return self.Option().AdditionalInfo().Sp_MLDCeiling()
        else:
            self.Option().AdditionalInfo().Sp_MLDCeiling(value)
            
            if self.domesticCurrency != self.mmld_reference.Currency1():
                self.Option().Exotic().RangeAccrualCapDomesticPerForeign(value)
                #print (f" set domesti per foreign Ceiling : {value}")
            else:
                fval = float(value)
                if fval != 0.0:
                    self.Option().Exotic().RangeAccrualFloorDomesticPerForeign(1.0/fval)
                else:
                    self.Option().Exotic().RangeAccrualFloorDomesticPerForeign(0.0)
                #print (f" set domesti per foreign floor : {value}")
            

    def Floor(self, value = 'Reading'):
        if value == 'Reading':
            return self.Option().AdditionalInfo().Sp_MLDFloor()
        else:
            self.Option().AdditionalInfo().Sp_MLDFloor(value)
            
            if self.domesticCurrency != self.mmld_reference.Currency1():
                self.Option().Exotic().RangeAccrualFloorDomesticPerForeign(value)
                #print (f" set domesti per foreign Floor : {value}")
            else:
                fval = float(value)
                if fval != 0.0:
                    self.Option().Exotic().RangeAccrualCapDomesticPerForeign(1.0/fval)
                else:
                    self.Option().Exotic().RangeAccrualCapDomesticPerForeign(0.0)
                #print (f" set domesti per foreign cap : {fval}")
            

    def Notional2(self, value = 'Reading'):
        if value == 'Reading':
            return self.Option().AdditionalInfo().Sp_LeverageNotional()
        self.Option().AdditionalInfo().Sp_LeverageNotional(value)

    @ReturnDomainDecorator('string')
    def PackageExternalId(self, value='Reading'):
        if value == 'Reading':
            return self.DealPackage().AdditionalInfo().Sp_ExternalId()
        self.DealPackage().AdditionalInfo().Sp_ExternalId(value)
        for t in self.Trades():
            t.Text2(value)

    #-----------------------------------------
    # Interface override
    #-----------------------------------------
    def Refresh(self):
        self.SetQuotationPerContract()

    def OnNew(self):
        # Non visible traits
        if self.InstrumentPackage().IsInfant():
            self.baseType = 'Range Accrual'
        super().OnNew()
        self.tradeValueDay = '0d'
        # Make sure that quotation has not been changed
        # Keep this last in OnNew as several Option Decorator
        # fields will reset quotation based on underlying quotation
        self.SetQuotationPerContract()

    def DayCountMethods(self, *rest):
        return [e for e in acm.FEnumeration['enum(DaycountMethod)'].Enumerators()]

    #-----------------------------
    # Action Callbacks
    #-----------------------------
    def FlipBuySell(self, attrName = None, *rest):
        self.Option().FxoChangeCallPut()

    #-----------------------------
    # On Changed
    #-----------------------------
    def OnChangedTradeCurrency(self, traitName, oldValue, newValue, *rest):
        if newValue and (newValue != oldValue):
            self.Option().Currency(newValue)

    #-----------------------------------------
    # Attribute Validation
    #-----------------------------------------
    def ValidateDate(self, attrName, value, *args):
        if not value:
            label = self.GetAttributeMetaData(attrName, 'label')()
            str = 'Expected a %s' % label
            raise DealPackageUserException(str)   

    def TradeDayAndTimeFromPeriod(self, attrName, newDate, *rest):
        dateTime = newDate
        if acm.Time().PeriodSymbolToDate(newDate):
            startTime = acm.Time().TimeNow()
            startDate = acm.Time().DateNow()
            currentTime = acm.Time.DateTimeToTime(startTime) - acm.Time.DateTimeToTime(startDate)
            date = self.TradeDayFromPeriod(startDate, newDate)
            dateTime = acm.Time.DateTimeFromTime(acm.Time.DateTimeToTime(date) + currentTime)
        return dateTime 

    #-----------------------------------------
    # Other methods
    #-----------------------------------------
    def SetQuotationPerContract(self, *rest):
        self.quotation = 'Per Contract'

    def TradeDayFromPeriod(self, startDate, period):
        nonAdjustedDate = acm.Time.DateAdjustPeriod(startDate, period)
        date = AdjustBankingDaysFromMultiCalendars(nonAdjustedDate, 0, GetPairCalendars(self.instrumentPair))
        return date

    def BankingDayPeriodToDateFromTradeTimePlusSpot(self, attrName, newDate, *rest):
        date = newDate
        if acm.Time().PeriodSymbolToDate(newDate):
            tradeDate = acm.Time.AsDate(self.tradeTime)
            insPair = self.instrumentPair
            tradeDatePlusSpot = insPair.SpotDate(tradeDate)
            return BankingDayPeriodToDateFromStartDate(GetPairCalendars(self.instrumentPair), tradeDatePlusSpot, newDate)
        return date

    #-----------------------------
    # Object Mappings
    #-----------------------------
    @ReturnDomainDecorator('FCurrencyPair')
    def InstrumentPair(self, *rest):
        return self.OptionTrade().CurrencyPair()

    #-----------------------------
    # Protected methods
    #-----------------------------
    def GetExpiryCalendars(self):
        expiryCalendars =[]
        if self.Option().AdditionalInfo().Sp_MLDCal1() is not None:
            expiryCalendars.append(self.Option().AdditionalInfo().Sp_MLDCal1())
        if self.Option().AdditionalInfo().Sp_MLDCal2() is not None:
            expiryCalendars.append(self.Option().AdditionalInfo().Sp_MLDCal2())
        if self.Option().AdditionalInfo().Sp_MLDCal3() is not None:
            expiryCalendars.append(self.Option().AdditionalInfo().Sp_MLDCal3())
        return expiryCalendars
    
    def _GetSettleCalendar(self):
        return self.Option().SettlementCalendar()

    def _GetCurrencyCalendars(self):
        if self.Option().ForeignCurrency() is not None:
            return [self.Option().ForeignCurrency().Calendar()]
        return []

    def GetSettlementCalendars(self):
        if (self._GetSettleCalendar() is None or self._GetSettleCalendar() == '') and self._GetCurrencyCalendars():
            return self._GetCurrencyCalendars()
        return [self._GetSettleCalendar()]
    
    def ExerciseAmount(self, date):
        return CalculateTRFSettlementAmounts(self.OptionTrade(), date)

    def ExerciseObjects(self, amount, event, date, openPart):
        if self.settlementType == 'Cash':
            if abs(amount) > epsilon:
                return AddExerciseCashPayment(self.OptionTrade(), event, amount * openPart, event.EndDate(), self.domesticCurrency if self.settleInCurr2 is True else self.foreignCurrency)
            raise DealPackageUserException('Exercise amount is 0, no exercise payment booked.')
        else:
            if abs(amount[0]) > epsilon and abs(amount[1]) > epsilon:
                amount1 = acm.DenominatedValue(amount[0] * openPart, self.foreignCurrency, date)
                amount2 = acm.DenominatedValue(amount[1] * openPart, self.domesticCurrency, date)
                return CreatePhysicalDeliveryFxSpotExerciseTrade(self.OptionTrade(), amount1, amount2, event.EndDate(), self.OptionB2B())
            raise DealPackageUserException('Exercise amount is 0, no exercise trade booked.')
        return []
  
    def GetFixingParams(self):
        if not (self.foreignCurrency and self.domesticCurrency):
            DealPackageUserException(
                'Cannot generate date periods without currencies set'
            )
        currPair = self.instrumentPair
        return{
                'startDate'             : self.startDate,
                'endDate'               : self.expiry,
                'method'                : self.dayMethod,
                'rolling'               : self.datePeriod,
                'calendars'             : self.GetExpiryCalendars(),
                'settleDays'            : self.settleDays,
                'settleCalendars'       : self.GetSettlementCalendars(),             
                'instrumentPair'        : currPair,
                'nbrOfPeriods'          : self.GetNumberOfPeriods(),
                'frequency'             : 'Daily'
                }

    def GeneratePeriodDates(self):
        return GenerateFXPeriodDates(**self.GetFixingParams())

    def RegisterUpdatedAttribute(self, attrName, *args):
        if attrName in ('domesticCurrency', 'foreignCurrency', 'startDate', 'datePeriod', 'expiry',
                        'dayMethod', 'nbrOfPeriods', 'mmld_reference', 'mmld_dayBasis', 'fixingCalendar1', 
                        'fixingCalendar2', 'fixingCalendar3', 'settlementCalendar', 'settleDays'):
            self._generateAttributeUpdated = True

    #-----------------------------
    # Enabled Callbacks
    #-----------------------------
    def FieldsSetToGenerate(self):
        return (self.startDate and self.datePeriod and self.expiry and self.dayMethod  and self.foreignCurrency and self.domesticCurrency and
                self.mmld_reference and self.mmld_dayBasis and self.fixingCalendar1 and self.settlementCalendar and (self.settleDays is not None) )

    #-----------------------------
    # Columns callbacks
    #-----------------------------
    def ColumnsExoticEvents(self, traitName):
        return [
                {'methodChain': 'Date', 'label':'Fixing Date', 'formatter':'DateOnly'},
                {'methodChain': 'PayDate', 'label':'Pay Date', 'formatter':'DateOnly'},
                {'methodChain': 'MLDFixing', 'label':'Fixing', 'formatter':'FXRate'},
                {'methodChain': 'MLDAmountInOut', 'label':'In/Out'}      
                ]

    #-----------------------------------------
    # Choice List values
    #-----------------------------------------
    def ChoicesCurrencyPairs(self, traitName):
        self.UpdateCurrencyPairChoices(traitName)
        return self._MMLDCurrencyPairChoices.Source()
    
    def UpdateCurrencyPairChoices(self, traitName, *args):
        domesticCurrency = self.Option().DomesticCurrency()
        self.OptionTrade().Currency(domesticCurrency)
        currPairs = None
        if (domesticCurrency is not None):
            self._MMLDCurrencyPairChoices.Clear()
            currencyPairs = acm.FCurrencyPair.Select('')
            currPairs =[currpair for currpair in currencyPairs if domesticCurrency.Name() in currpair.Name()]
            self._MMLDCurrencyPairChoices.AddAll(currPairs)
        if currPairs and len(args) > 0:
            self.Option().AdditionalInfo().Sp_MLDReference(currPairs[0])
    
    def UpdateForeignCurrency(self, traitName, *args):
        self.UpdateCurrencyPairChoices(traitName)
        if self.mmld_reference is not None:
            if self.Option().DomesticCurrency() == self.mmld_reference.Currency1():
                self.Option().StrikeQuotation('Per Unit Inverse')
                self.Option().ForeignCurrency(self.mmld_reference.Currency2())
            elif self.Option().DomesticCurrency() == self.mmld_reference.Currency2():
                self.Option().ForeignCurrency(self.mmld_reference.Currency1())
                self.Option().StrikeQuotation('Per Unit')

    #-----------------------------------------
    # Define Labels
    #-----------------------------------------   
    def LabelReplaceWithCurrency(self, traitName):
        label = self.GetAttributeMetaData(traitName, '_labelText')()
        if label:
            if label.find('Foreign') > 0:
                if not self.foreignCurrency:
                    return label.split('(')[0].strip()
                label = label.replace('Foreign', self.foreignCurrency.Name())

            if label.find('Domestic') > 0:
                if not self.domesticCurrency:
                     return label.split('(')[0].strip()
                label = label.replace('Domestic', self.domesticCurrency.Name())
        return label

    def LabelCurrBox(self, traitName):
        foreign  = self.foreignCurrency.Name() if self.foreignCurrency else 'Foreign'
        domestic = self.domesticCurrency.Name() if self.domesticCurrency else 'Domestic'
        if traitName.startswith('foreign'):
            label = '%s per %s' % (foreign, domestic)
        else:
            label = '%s per %s' % (domestic, foreign)
        return label

    #-----------------------------------------
    # FX Rate values
    #-----------------------------------------
    def TriggerFlipOfStorageDirection(self, direction):
        # Tigger decorator driven updates if the storage direction is updated using a non standard field
        self.GetAttribute('strike_store%s' % direction)()

    def SetNonStandardDomesticPerForeign(self, value, setMethod):
        self.SetNonStandardRate(value, setMethod, 'DomesticPerForeign')

    def SetNonStandardForeignPerDomestic(self, value, setMethod):
        self.SetNonStandardRate(value, setMethod, 'ForeignPerDomestic')

    def SetNonStandardRate(self, value, setMethod, direction):
        value = TransformUsingDecorator(self.Option(), value, 'Strike%s' % direction)
        # Trigger the decorator flip ahead of setting the value
        self.TriggerFlipOfStorageDirection(direction)
        setMethod(value)

    def GetNonStandardDomesticPerForeign(self, value):
        return value
    
    def GetNonStandardForeignPerDomestic(self, value):
        return value

    #-----------------------------
    # Trade data
    #-----------------------------

    tradeTime = Object( objMapping = 'Trades.TradeTime',
                                label = 'Trade Time',
                                transform = '@TradeDayAndTimeFromPeriod')
    
    tradeStatus = Object(objMapping = 'Trades.Status',
                                choiceListSource = TradeStatusChoices(),
                                label = 'Trade Status')
    
    tradeValueDay = Object(objMapping = 'Trades.ValueDay',
                                label = 'Value Day',
                                defaultValue='0d',
                                transform = '@BankingDayPeriodToDateFromTradeTimePlusSpot')
    
    tradeTrader = Object(objMapping = 'Trades.Trader',
                                choiceListSource = acm.FUser.Instances(),
                                label = 'Trader')

    tradePortfolio = Object(objMapping = 'Trades.Portfolio',
                                choiceListSource = PortfolioChoices(),
                                label = 'Portfolio')
       
    tradeAcquirer = Object(objMapping = 'Trades.Acquirer',
                                choiceListSource = AcquirerChoices(),
                                label = 'Acquirer')
    
    tradeCounterParty = Object(objMapping = 'Trades.Counterparty',
                                choiceListSource = CounterpartyChoices(),
                                label = 'Counterparty')
    
    tradePayments = PaymentsDialog(trade = 'LeadTrade')

    # Non visible trade traits, used for exercise
    tradeType = Object( objMapping = 'Trades.Type' )
    tradeQuantity = Object( objMapping = 'Trades.Quantity')

    #-----------------------------------------
    # Other methods
    #-----------------------------------------
    def GetExoticEventReference(self):
        return self.foreignCurrency

    # Spot reference methods
    def ReferencePriceDomPerFor(self, *args):
        ref = args[0] if args else self.OptionTrade().ReferencePrice()
        #ref = ref if self.strikeQuotation.Name() == 'Per Unit' else GetInverseRate(ref)
        if args:
            if not isnan (ref):
                self.OptionTrade().ReferencePrice(ref)
        else:
            return ref

    def ReferencePriceForPerDom(self, *args):
        ref = args[0] if args else self.OptionTrade().ReferencePrice()
        if args:
            if not isnan(ref):
                self.OptionTrade().ReferencePrice(ref)
        else:
            return ref

    def InvertSpotReference(self, attrName, *rest):
        self.spotReference_rateForeignPerDomestic = GetInverseRate(self.spotReference_rateForeignPerDomestic)

    def UpdateSpotReference(self, *args):
        foreign = self.Option().ForeignCurrency()
        domestic = self.Option().DomesticCurrency()
        if (foreign is not None) and (domestic is not None):
            if domestic == foreign:
                if foreign.Name() == 'USD':
                    foreign = acm.FCurrency['IDR']
                else:
                    foreign = acm.FCurrency['USD']
            ccyPair = domestic.CurrencyPair(foreign, True)
            isInvert = foreign == ccyPair.Currency1()
            spotPrice = ccyPair.SpotPrice(self.OptionTrade().ValueDay(), isInvert)
            #Default strike multiplier value 1.5% up / down 
            strikeMultiplier = 0.015
            #Spot rate below is as domestic per foreign
            self.spotReference_rateForeignPerDomestic = spotPrice

    def CreateSuggestedSecurityId(self):
        base_name = self.Option().SuggestName()

    def SuggestNameAction(self, *args):
        self.name = self.CreateSuggestedSecurityId()

    def SetOptionName(self, *args):
        self.Option().Name(self.CreateSuggestedSecurityId())

    def SuggestName(self):
        name = self.CreateSuggestedSecurityId()
        self.Option().Name(name)
        return name
    
    def SetTradeNominal(self):
        try:
            mldNotional = self.Option().AdditionalInfo().Sp_LeverageNotional()
            observationDays = self.NumberOfObservationDays()
            maxYield = self.mmld_maxYield/100
            quantity = CalculateDailyAccrualReturn(self.startDate, self.expiry, maxYield , mldNotional, self.mmld_dayBasis , observationDays)
            quantity = -quantity if self.OptionTrade().Type() == 'Closing' else quantity
            self.OptionTrade().Quantity(quantity)
        except Exception as e:
            raise DealPackageUserException(f'Unable to create deal package : failed to calculated DailyAccrualReturn, Please check the MLD parameters. Error : {e}')

    #-----------------------------------------
    # Interface override
    #-----------------------------------------
    def CustomPanes(self):
        return self.GetCustomPanesFromExtValue('CustomPanes_SP_MLDRAFxDealPackage')

    def OnInit(self):
        self._foreignCurrencyChoices = DealPackageChoiceListSource()
        self._domesticCurrencyChoices = DealPackageChoiceListSource()
        self._MMLDCurrencyPairChoices = DealPackageChoiceListSource()
        self._generateAttributeUpdated = False
        self.RegisterCallbackOnAttributeChanged(self.UpdateSpotReference, ('mmld_reference','domesticCurrency'))
        super().OnInit()

    def OnNew(self):
        if self.InstrumentPackage().IsInfant():
            # Non visible traits
            self.exoticType = 'Other'
            #self.GenerateMLDExpiryEvents()
            #self.GenerateAverageDates()
        self.UpdateSpotReference()
    
    def OnSave(self, saveConfig):
        if not self.name:
            self.SetOptionName()
        else:
            self.Option().Name(self.name)
        self.SetTradeNominal()
        self.SetInstrumentFields()
        super().OnSave(saveConfig)

    def AssemblePackage(self):
        ins = acm.DealCapturing().CreateNewInstrument('MarketLinkedDepositRangeAccrualFx')
        trade = acm.DealCapturing().CreateNewTrade(ins)
        self.DealPackage().AddTrade(trade, 'Option')

@Settings(ShowGraphInitially=False,
          GraphApplicable=False)
@TradeActions( exercise = TrfExerciseAction())
class MarketLinkedDepositRangeAccrualFx(MLDFxRABaseDefinition):
    def AttributeOverrides(self, overrideAccumulator):
        overrideAccumulator({
            'productType': dict(objMapping = InstrumentPart('Option.AdditionalInfo.StructureType'), defaultValue = 'Market Linked Deposit RAFx')
        })




...

  SP_MarketLinkedDepositIR
import traceback
import acm

try:
    from StructuredProductsCommonAddInfo import SP_CommonAddInfoDealPackageDefinitionWithPreDeal
    from StructuredProductsCommonAddInfo import CommonTradeDefinition
except ImportError:
    from CompositeAttributesLib import TradeDefinition as CommonTradeDefinition
    try:
        from StructureProductsPreDealUtils import SP_CommonAddInfoDealPackageDefinitionWithPreDeal
    except ImportError:
        from DealPackageDevKit import DealPackageDefinition as SP_CommonAddInfoDealPackageDefinitionWithPreDeal

from DealPackageDevKit import DealPackageUserException, Settings, ReturnDomainDecorator, InstrumentPart, Object, Action, TradeStatusChoices, PortfolioChoices, \
                              AcquirerChoices, CounterpartyChoices, TradeActions
from SP_MMLDCloseCommand import MMLDIRCloseCommand as CloseCommand
from DealPackageUtil import UnDecorate
from ChoicesExprCommon import listChoicesWithEmpty

from CompositeLegDefinition import LegDefinition
from CompositeTradeDefinition import TradeDefinition
from CompositeAttributesLib import PaymentsDialog
from CompositeTradeComponents import TradeB2B
from CompositeCashFlowComponents import RangeAccrualSwap, Deposit

from SP_BusinessCalculations import BankingDayPeriodToDateFromStartDate
from SP_TrfUtils import SelectPackageType
from SP_DealPackageHelper import DayMethodOnlyFollowingPreceding
from SP_MarketLinkedDeposit_Utils import GetAllMLDProductTypes, ExpiryPeriodToDate
from SP_MLDCompositeAttributes import MLDIRFixingEditerComposite

@Settings(ShowGraphInitially=False,
          GraphApplicable=False)
@TradeActions(close = CloseCommand(statusAttr='trades_status', nominal='depositCashAmount'))
class MLDIRDefinition(SP_CommonAddInfoDealPackageDefinitionWithPreDeal):
    #-----------------------------
    # Visible Traits
    #-----------------------------

    packageType = SelectPackageType(label='Type',
                        choiceListSource=GetAllMLDProductTypes(),
                        definitionPrefix = '')

    ExternalId = Object(label='External Id',
                        objMapping='PackageExternalId',
                        visible = True)

    discountingType = Object(label='Disc Type',
                        choiceListSource=acm.GetDomain('FChoiceList(''''DiscType'''')').Instances(),
                        objMapping=InstrumentPart('SwapInstrument.DiscountingType'),
                        visible=True)
    
    valGroup = Object(label='Val Group',
                        choiceListSource=acm.GetDomain('FChoiceList(''''ValGroup'''')').Instances(),
                        objMapping=InstrumentPart('SwapInstrument.ValuationGrpChlItem'),
                        visible=True)
    
    mmld_reference = Object(label='Reference',
                        recreateCalcSpaceOnChange=True, 
                        choiceListSource = '@RateIndices',
                        objMapping = InstrumentPart('SwapInstrument.AdditionalInfo.Sp_MLDIRReference|SwapInstrument.PayLeg.FloatRateReference'),
                        defaultValue= 'IDR/JIBOR/1M',
                        visible = True)

    mmld_maxYield = Object(label='Max Yield/Return(% p.a.)',
                        objMapping = InstrumentPart('SwapInstrument.PayLeg.FixedPrice|SwapInstrument.AdditionalInfo.Sp_MLDMaxYield'),
                        formatter = 'MLDFourDecimal',
                        defaultValue= 0.07,
                        visible = True)
    
    mmld_minYield = Object(label='Min Yield/Return(% p.a.)',
                        objMapping = InstrumentPart('SwapInstrument.AdditionalInfo.Sp_MLDMinYield'),
                        formatter = 'MLDFourDecimal',
                        defaultValue= 0.04,
                        visible = True)

    mmld_dayBasis = Object(label='Day Basis',
                        choiceListSource = [360, 365],
                        visible = True,
                        defaultValue = 360,
                        onChanged = '@DayBasisChanged',
                        objMapping = InstrumentPart('SwapInstrument.AdditionalInfo.Sp_MLDDayBasis'))

    mmld_ceiling = Object(label='Ceiling',
                        objMapping = InstrumentPart('SwapInstrument.PayLeg.Strike|SwapInstrument.AdditionalInfo.Sp_MLDCeiling'),
                        formatter = 'MLDFourDecimal',
                        defaultValue = 0.7,
                        visible = True)

    mmld_floor = Object(label='Floor',
                        objMapping = InstrumentPart('SwapInstrument.PayLeg.Strike2|SwapInstrument.AdditionalInfo.Sp_MLDFloor'),
                        formatter = 'MLDFourDecimal',
                        defaultValue = 0.4,
                        visible = True)
    
    mmld_premiumOption = Object(label='Premium Option(% p.a.)',
                            objMapping = 'PremiumOption',
                            formatter = 'MLDFourDecimal',
                            defaultValue = 0.04,
                            visible = True)

    mtmFromFreed = Object(label = 'MTM From Feed',
                        objMapping = InstrumentPart('SwapInstrument.MtmFromFeed'))
   
    startDate = Object(label = 'Swap Start',
                        objMapping = InstrumentPart('StartDate'),
                        toolTip = 'Swap Start Date',
                        validate = '@ValidateDate',
                        transform = '@ExpiryPeriodToDate')
    
    datePeriod = Object(label = 'Rolling Period',
                        objMapping = 'RollingPeriod',
                        validate = '@ValidateDatePeriod',
                        defaultValue = '0d')
    
    fixingCalendar1 = Object(label='Calendar1',
                        objMapping=InstrumentPart('SwapInstrument.PayLeg.ResetCalendar|SwapInstrument.RecLeg.ResetCalendar|SwapInstrument.AdditionalInfo.Sp_MLDCal1'),
                        defaultValue = 'Jakarta')
    
    fixingCalendar2 = Object(label='Calendar2',
                        objMapping=InstrumentPart('SwapInstrument.PayLeg.Reset2Calendar|SwapInstrument.RecLeg.Reset2Calendar|SwapInstrument.AdditionalInfo.Sp_MLDCal2'))
    
    fixingCalendar3 = Object(label='Calendar3',
                        objMapping=InstrumentPart('SwapInstrument.PayLeg.Reset3Calendar|SwapInstrument.RecLeg.Reset3Calendar|SwapInstrument.AdditionalInfo.Sp_MLDCal3'))

    settlementCalendar = Object(label = 'Payment Calendar',
                            objMapping = InstrumentPart('SwapInstrument.PayLeg.PayCalendar|SwapInstrument.RecLeg.PayCalendar'))

    settlementCalendar2 = Object(label = 'Payment Calendar2',
                            objMapping = InstrumentPart('SwapInstrument.PayLeg.Pay2Calendar|SwapInstrument.RecLeg.Pay2Calendar'))
    
    expiryDate = Object(objMapping = 'SwapExpiryDate',
                        label = 'Swap End',
                        editable = False)
    
    dayMethod = Object(objMapping = InstrumentPart('SwapInstrument.AdditionalInfo.Sp_PayDayMethod'),
                        choiceListSource = DayMethodOnlyFollowingPreceding(),
                        label = 'Day Convention')

    resets = Object(objMapping = 'SwapResets',
                                columns = '@ColumnsResets',
                                label = 'Reset Table',
                                addNewItem = ['First', 'Sorted'],
                                sortIndexCallback = '@SortResets',
                                onSelectionChanged = '@SelectionResets',
                                dialog = None,
                                toolTip = 'Reset Table' )

    fixingEditer = MLDIRFixingEditerComposite(instrument = 'SwapInstrument')

    #-----------------------------
    # Deposit data
    #-----------------------------                                                                     
    
    deposit = Deposit(depositName = 'DepositInstrument',
                        depositLegName = 'DepositLeg')

    trades = CommonTradeDefinition(trade = 'DepositTrade')

    trade = TradeDefinition(trade = 'DepositTrade')

    leg = LegDefinition(leg = 'DepositLeg', trade = 'DepositTrade')

    currency = Object(label = 'Currency',
                        objMapping = InstrumentPart('DepositInstrument.Currency|SwapInstrument.Currency'),
                        onChanged = '@CurrencyChanged',
                        defaultValue = 'IDR')

    tradeText1 = Object(objMapping = 'Trades.Text1',
                        label = 'Free Text')

    depositCashAmount = Object(objMapping = 'DepositCashAmount',
                        label = 'Cash Amount',
                        formatter = 'NumDefault')

    tradesOptKey1 = Object(objMapping = 'Trades.OptKey1',
                        choiceListSource = listChoicesWithEmpty('Branch'),
                        label = 'Branch')

    tradesOptKey2 = Object(objMapping = 'Trades.OptKey2',
                        choiceListSource = listChoicesWithEmpty('Interface'),
                        label = 'Interface')

    tradesOptKey3 = Object(objMapping = 'Trades.OptKey3',
                        choiceListSource = listChoicesWithEmpty('Product Type'),
                        label = 'Product Type')

    tradesOptKey4 = Object(objMapping = 'Trades.OptKey4',
                        choiceListSource = listChoicesWithEmpty('Category'),
                        label = 'Category')

    #--------------------------
    # Deposit B2B parameters
    #--------------------------

    depositB2B = TradeB2B(uiLabel = 'Deposit',
                            b2bTradeParamsName = 'DepositB2BParams')

    depositB2BPrice = Object(visible = False,
                            objMapping = 'DepositB2BParams.TraderPrice')

    depositB2BAcq = Object(visible = False,
                            objMapping = 'DepositB2BParams.TraderAcquirer')

    depositB2BPort = Object(visible = False,
                            objMapping = 'DepositB2BParams.TraderPortfolio')

    b2bDepositEnabled = Object(defaultValue = False,
                            label = 'Deposit B2B Cover',
                            objMapping = 'DepositB2BParams.SalesCoverEnabled',
                            visible = True)

    #--------------------------
    # Swap B2B parameters
    #--------------------------

    swapB2B = TradeB2B(uiLabel = 'Swap',
                            b2bTradeParamsName = 'SwapB2BParams')

    swapB2BPrice = Object(visible = False,
                            objMapping = 'SwapB2BParams.TraderPrice')

    swapB2BAcq = Object(visible = False,
                            objMapping = 'SwapB2BParams.TraderAcquirer')

    swapB2BPort = Object(visible = False,
                            objMapping = 'SwapB2BParams.TraderPortfolio')

    b2bSwapEnabled  = Object(defaultValue = False,
                            label = 'Swap B2B Cover',
                            objMapping = 'SwapB2BParams.SalesCoverEnabled',
                            visible = True)

    #-----------------------------
    # Access methods
    #-----------------------------
    name = Object(objMapping = InstrumentPart('DealPackage.InstrumentPackage.Name'),
                            label = 'Name',
                            toolTip = 'Name of Instrument Package')

    suggestName = Action(label='Suggest', action = '@SuggestNameAction',
                            toolTip = 'Suggest a name for the instrument/instrument package',
                            visible = True,
                            width = 2000,
                            maxWidth = 2000 )

    tradeTime = Object(objMapping = 'Trades.TradeTime',
                            label = 'Trade Time')
    
    tradeStatus = Object(objMapping = 'Trades.Status',
                            choiceListSource = TradeStatusChoices(),
                            label = 'Trade Status')
    
    tradeValueDay = Object(objMapping = 'Trades.ValueDay',
                            label = 'Value Day',
                            defaultValue = '0d',
                            transform = '@BankingDayPeriodToDateFromTradeTimePlusSpot')
    
    tradeTrader = Object(objMapping = 'Trades.Trader',
                            choiceListSource = acm.FUser.Instances(),
                            label = 'Trader')

    depositPortfolio = Object(objMapping = 'DepositTrade.Portfolio',
                            choiceListSource = PortfolioChoices(),
                            label = 'Deposit Portfolio')

    swapPortfolio = Object(objMapping = 'SwapTrade.Portfolio',
                            choiceListSource = PortfolioChoices(),
                            label = 'Swap Portfolio')
       
    tradeAcquirer = Object(objMapping = 'Trades.Acquirer',
                            choiceListSource = AcquirerChoices(),
                            label = 'Acquirer')
    
    tradeCounterParty = Object(objMapping = 'Trades.Counterparty',
                            choiceListSource = CounterpartyChoices(),
                            label = 'Counterparty')

    tradePayments = PaymentsDialog(trade = 'LeadTrade')

    def AttributeOverrides(self, overrideAccumulator):
        overrideAccumulator({
            'deposit_startDate': dict(label = 'Start Date', onChanged = '@StartDateChange'),
            'startDate': dict(onChanged = '@StartDateChange'),
            'deposit_endDate': dict(label = 'End Date', onChanged = '@EndDateChange'),
            'tradesOptKey3': dict(defaultValue = 'SP'),
            'tradesOptKey4': dict(defaultValue = 'MLDR'),
            'expiryDate': dict(defaultValue = self.ExpiryDate()),
            'fixingEditer_fixingValue': dict(label = 'Rate'),
            'swapB2B_b2bMargin': dict(onChanged = '@B2BSwapCoverMarginChanged'),
        })

    def AssemblePackage(self):
        ins = acm.DealCapturing().CreateNewInstrument('MarketLinkedDepositIR')
        trade = acm.DealCapturing().CreateNewTrade(ins)
        self.DealPackage().AddTrade(trade, 'Trade')

        swap = RangeAccrualSwap('RangeSwap', 'FixedLeg', 'RALeg').CreateInstrument()
        swap_trade = acm.DealCapturing().CreateNewTrade(swap)
        self.DealPackage().AddTrade(swap_trade, 'SwapTrade')
        

    def SuggestNameAction(self, *rest):
        return 'Name'

    def RateIndices(self, *rest):
        return acm.FRateIndex.Select('generic = true')

    def DayCountMethods(self, *rest):
        return [e for e in acm.FEnumeration['enum(DaycountMethod)'].Enumerators()]

    @ReturnDomainDecorator('FIndexedCollection(FReset)')
    def SwapResets(self, *rest):
        resets = self.SwapInstrument().PayLeg().Resets()
        resets = [reset for reset in resets if reset.CashFlow().NominalFactor() > 0]
        return acm.FArray().AddAll(resets)

    #-----------------------------
    # Column Callbacks
    #-----------------------------

    def ColumnsResets(self, traitName):
        return [
                {'methodChain': 'Day', 'label':'Fixing Date', 'formatter':'DateOnly'},
                {'methodChain': 'CashFlow.PayDate', 'label':'Pay Date', 'formatter':'DateOnly'},
                {'methodChain': 'FixFixingValue', 'label':'Fixing', 'formatter': 'InitialFixing'},
                ]

    #-----------------------------
    # On Changed
    #-----------------------------

    def SortResets(self, attrName, columnNbr, value, formatter, obj):
        if columnNbr < 0:
            return acm.Time.DateTimeToTime(obj.Day())
        if columnNbr in (0, 1):
            return acm.Time.DateTimeToTime(value)
        return value

    def SelectionResets(self, traitName, rowObject):
        self.fixingEditer.OnSelectionChanged(rowObject)

    def DayCountMethodChanged(self, attrName, old_value, new_value, *rest):
        self.SwapInstrument().PayLeg().DayCountMethod(new_value)
        self.SwapInstrument().RecLeg().DayCountMethod(new_value)
        self.SwapInstrument().PerformRegenerateAllCashFlows()

    def StartDateChange(self, attrName, old_value, new_value, *rest):
        if attrName == 'deposit_startDate':
            self.SwapNoDecorator().StartDate(new_value)
            self.SwapInstrument().RecLeg().StartDate(new_value)
            self.SwapInstrument().PayLeg().StartDate(new_value)
            self.SwapInstrument().PerformRegenerateAllCashFlows()
        else:
            self.DepositInstrument().StartDate(new_value)
            self.DepositInstrument().FirstLeg().StartDate(new_value)
            self.DepositInstrument().PerformRegenerateAllCashFlows()

    def EndDateChange(self, attrName, old_value, new_value, *rest):
        self.SwapNoDecorator().ExpiryDate(new_value)
        self.SwapInstrument().RecLeg().EndDate(new_value)
        self.SwapInstrument().PayLeg().EndDate(new_value)
        self.SwapInstrument().PerformRegenerateAllCashFlows()
    
    def B2BSwapCoverMarginChanged(self, attrName, oldValue, newValue, *rest):
        rate = self.SwapInstrument().RecLeg().FixedRate()
        self.SwapInstrument().AdditionalInfo().Sp_MLDPremiumOption(rate)

    def CurrencyChanged(self, attrName, old_value, new_value, *rest):
        self.SwapInstrument().Currency(new_value)
        self.SwapTrade().Currency(new_value)
        self.DepositInstrument().Currency(new_value)
        self.DepositTrade().Currency(new_value)
        
        currency_calendar = new_value.Calendar()
        self.SwapInstrument().PayLeg().ResetCalendar(currency_calendar)
        self.SwapInstrument().RecLeg().ResetCalendar(currency_calendar)
        self.SwapInstrument().AdditionalInfo().Sp_MLDCal1(currency_calendar)
        
        rate_indices = self.RateIndices()
        rate_indices = [index for index in rate_indices if index.Currency().Name() == new_value.Name()]

        self.SwapInstrument().AdditionalInfo().Sp_MLDIRReference(rate_indices[0] or None)
        self.SwapInstrument().PayLeg().FloatRateReference(rate_indices[0] or None)

    def DayBasisChanged(self, attrName, old_value, new_value, *rest):
        if new_value == 360:
            method = 'Act/360'
        elif new_value == 365:
            method = 'Act/365'
        else:
            method = 'Act/360'
        self.SwapInstrument().PayLeg().DayCountMethod(method)
        self.SwapInstrument().RecLeg().DayCountMethod(method)
        self.SwapInstrument().PerformRegenerateAllCashFlows()

    def IsShowModeInstrumentDetail(self, *args):
        return True

    def DepositB2B(self):
        return self.B2BTradeParamsAt('Trade')

    def DepositB2BParams(self):
        return self.B2BTradeParamsAt('Trade')

    def SwapB2BParams(self):
        return self.B2BTradeParamsAt('SwapTrade')

    def IsB2BDeposit(self, attrName):
        return self.b2bDepositEnabled

    def IsB2BSwap(self, attrName):
        return self.b2bSwapEnabled

    def LeadTrade(self, *rest):
        return self.DealPackage().TradeAt('SwapTrade')

    def DepositTrade(self, *rest):
        return self.DealPackage().TradeAt('Trade')

    def Trade(self, *args):
        return self.DepositTrade()

    def SwapTrade(self, *rest):
        ra_swap_trade = self.DealPackage().TradeAt('SwapTrade')
        ra_leg = ra_swap_trade.Instrument().PayLeg()
        ra_leg.RollingPeriod(ra_swap_trade.Instrument().AdditionalInfo().Sp_RollingPeriod())
        ra_leg.ResetAdjustmentMethod('Preceding')
        ra_leg.ResetDayMethod('Preceding')
        ra_leg.ResetDayOffset(0)
        return ra_swap_trade

    def Trades(self, *rest):
        return self.DealPackage().Trades()

    def DepositInstrument(self, *rest):
        return self.DealPackage().InstrumentAt('Trade')

    def SwapInstrument(self, *rest):
        return self.DealPackage().InstrumentAt('SwapTrade')

    def SwapNoDecorator(self):
        return self.SwapInstrument().DecoratedObject()

    def SwapNoQuestionGui(self):
        swap = self.SwapNoDecorator()
        gui = acm.FBusinessLogicGUIDefault()
        gui.AskAdjustToFollowingBusinessDay(False)
        return acm.FBusinessLogicDecorator.WrapObject(swap, gui)

    def StartDate(self, *rest):
        return self.DepositInstrument().StartDate()
        
    def ExpiryDate(self, *rest):
        return self.DepositInstrument().ExpiryDate()

    def DepositLeg(self):
        return self.DepositInstrument().FirstEditLeg()

    def SwapExpiryDate(self, value = 'Reading'):
        try:
            if value == 'Reading':
                return self.SwapInstrument().EndDate()
            value = acm.Time.AsDate(value)
            self.SwapInstrument().ExpiryDate(value)
            self.SwapInstrument().RecLeg().EndDate(value)
            self.SwapInstrument().PayLeg().EndDate(value)
            self.SwapInstrument().PerformRegenerateAllCashFlows()
        except Exception as e:
            print(str(e))

    def DepositEndDate(self, value = 'Reading'):
        if value == 'Reading':
            return self.DepositInstrument().ExpiryDateOnly()
        value = acm.Time.AsDate(value)
        self.DepositInstrument().ExpiryDate(value)
        self.DepositInstrument().FirstLeg().EndDate(value)
        self.DepositInstrument().PerformRegenerateAllCashFlows()

        self.SwapInstrument().ExpiryDate(value)
        self.SwapInstrument().RecLeg().EndDate(value)
        self.SwapInstrument().PayLeg().EndDate(value)
        self.SwapInstrument().PerformRegenerateAllCashFlows()

    def DepositCashAmount(self, value = 'Reading'):
        if value == 'Reading':
            return self.DepositTrade().CashAmount()
        try:
            value = float(value)
        except Exception as e:
            print('Cannot convert %s to float' % value)
            print(str(e))
            return

        self.DepositTrade().CashAmount(value)
        self.DepositInstrument().PerformRegenerateAllCashFlows()
        self.SwapInstrument().NominalAmount(value)
        self.SwapInstrument().PerformRegenerateAllCashFlows()

    @ReturnDomainDecorator('string')
    def PackageExternalId(self, value = 'Reading'):
        if value == 'Reading':
            return self.DealPackage().AdditionalInfo().Sp_ExternalId()
        self.DealPackage().AdditionalInfo().Sp_ExternalId(value)
        for t in self.Trades():
            t.Text2(value)

    def RollingPeriod(self, value = 'Reading'):
        if value == 'Reading':
            return self.SwapInstrument().AdditionalInfo().Sp_RollingPeriod()
        swap = self.SwapInstrument()
        swap.AdditionalInfo().Sp_RollingPeriod(value)
        swap.PayLeg().RollingPeriod(value)
        swap.RecLeg().RollingPeriod(value)
        swap.PerformRegenerateAllCashFlows()

    def PremiumOption(self, value = 'Reading'):
        if value == 'Reading':
            return self.SwapInstrument().RecLeg().FixedRate()
        self.SwapInstrument().RecLeg().FixedRate(value)
        self.SwapInstrument().RecLeg().GenerateCashFlowsFromDate(acm.Time.DateToday())
        self.SwapInstrument().AdditionalInfo().Sp_MLDPremiumOption(value)

    def CustomPanes(self):
        return self.GetCustomPanesFromExtValue('CustomPanes_SP_MLDIRDealPackage')

    def BankingDayPeriodToDateFromTradeTimePlusSpot(self, attrName, newDate, *rest):
        date = newDate
        if acm.Time().PeriodSymbolToDate(newDate):
            tradeDate = acm.Time.AsDate(self.tradeTime)
            ins = self.DepositInstrument()
            tradeDatePlusSpot = ins.SpotDate(tradeDate)
            return BankingDayPeriodToDateFromStartDate(self.DepositTrade().Currency().Calendar(), tradeDatePlusSpot, newDate)
        return date

    def ValidateDate(self, attrName, value, *args):
        if not value:
            label = self.GetAttributeMetaData(attrName, 'label')()
            str = 'Expected a %s' % label
            raise DealPackageUserException(str)

    def ValidateDatePeriod(self, attrName, value, *rest):
        if not acm.Time().PeriodSymbolToDate(value):
            raise DealPackageUserException('"%s" is not a valid date period' % value)

    def ExpiryPeriodToDate(self, traitName, value):
        return ExpiryPeriodToDate(self.SwapNoQuestionGui(), value)


    def SetInstrumentFields(self):
        self.DepositInstrument().ProductTypeChlItem(self.tradesOptKey3)
        self.DepositInstrument().CategoryChlItem(self.tradesOptKey4)
        self.SwapInstrument().ProductTypeChlItem(self.tradesOptKey3)
        self.SwapInstrument().CategoryChlItem(self.tradesOptKey4)

    def OnSave(self, saveConfig):
        self.SetInstrumentFields()
        super().OnSave(saveConfig)

...

  SP_MarketLinkedDepositOption

from __future__ import division
from __future__ import absolute_import
from itertools import groupby

import acm

from DealPackageDevKit import DealPackageUserException, Object, Action, PortfolioChoices, AcquirerChoices, ReturnDomainDecorator, InstrumentPart
from SP_DealPackageHelper import SettlementTypeChoices
from SP_ExerciseUtils import CalculateOpenPart, IsExercised

from SP_MarketLinkedDeposit_Utils import GenerateMLDExpiryTable, MLDExpiryEvent, ExpiryPeriodToDate, GetNumberOfPaymentPeriods
from SP_MarketLinkedDeposit import MLDBaseDefinition

class MLDOption(MLDBaseDefinition):
    productType         = Object(   objMapping = InstrumentPart('Option.AdditionalInfo.StructureType'))

    averageMethodType = Object(objMapping = InstrumentPart('Option.Exotic.AverageMethodType'),
                                defaultValue = 'None',
                                visible = False)

    averagePriceType = Object(objMapping = InstrumentPart('Option.Exotic.AveragePriceType'),
                                defaultValue = 'None',
                                visible = False)

    averageStrikeType = Object(objMapping = InstrumentPart('Option.Exotic.AverageStrikeType'),
                                defaultValue = 'None',
                                visible = False)

    settlementType = Object(objMapping = InstrumentPart('Option.SettlementType'),
                                choiceListSource = '@ChoicesSettlementType',
                                label = 'Settlement')

    settleDays = Object(objMapping = InstrumentPart('Option.PayDayOffset'),
                               label = 'Settle Days',
                               visible = True,
                               toolTip = 'Number of banking days between each period end date and the corresponding settlment date')

    terminationStatus = Object(objMapping = InstrumentPart('Option.Exotic.BarrierCrossedStatus'),
                                recreateCalcSpaceOnChange = True,
                                label = 'Termination Status',
                                visible = '@VisibleTerminationStatus')

    terminationDate = Object(objMapping = InstrumentPart('Option.Exotic.BarrierCrossDate'),
                                recreateCalcSpaceOnChange=True,
                                label = 'Termination Date',
                                visible = '@VisibleTerminationStatus')

    #-----------------------------
    # Trait building up the expiry table
    #-----------------------------
    fixingsGenerate = Action(label = 'Generate',
                                enabled = '@EnabledFixingsGenerate',
                                action = '@ActionFixingsGenerate')

    exoticEvents = Object(objMapping = 'MLDExpiryEvents',
                                columns = '@ColumnsExoticEvents',
                                label = 'Expiry Table',
                                addNewItem = ['First', 'Sorted'],
                                sortIndexCallback = '@SortMLDExpiryEvents',
                                onSelectionChanged = '@SelectionExoticEvents',
                                dialog = None,
                                toolTip = 'Expiry Table' )

    #--------------------------
    # B2B parameters
    #--------------------------
    b2bEnabled = Object(defaultValue = False,
                                label = 'B2B Cover',
                                objMapping = 'OptionB2B.SalesCoverEnabled',
                                visible = True)

    b2bMargin = Object(defaultValue = 0.0,
                                label = 'Sales Spread',
                                objMapping = 'OptionB2B.SalesMargin',
                                formatter = 'FullPrecision',
                                enabled = '@IsB2B',
                                visible = True)

    b2bPrice = Object(defaultValue = 0.0,
                                label = 'Trader Price',
                                objMapping = 'OptionB2B.TraderPrice',
                                formatter = 'FullPrecision',
                                enabled = '@IsB2B',
                                visible = True)

    b2bPortfolio = Object(label='Trader Portfolio',
                                objMapping = 'OptionB2B.TraderPortfolio',
                                choiceListSource = PortfolioChoices(),
                                enabled = '@IsB2B',
                                visible = True)
             
    b2bAcquirer = Object(label='Trader Acquirer',
                                objMapping = 'OptionB2B.TraderAcquirer',
                                choiceListSource = AcquirerChoices(),
                                enabled = '@IsB2B',
                                visible = True)

    #-----------------------------
    # Non visible traits
    #-----------------------------
    quotation = Object(objMapping = InstrumentPart('Option.Quotation'))
    
    exoticType = Object(objMapping = InstrumentPart('Option.ExoticType'))
    
    isCallOption = Object(objMapping = InstrumentPart('Option.IsCallOption'),
                                visible = False )

    notionalQuotation = Object(objMapping = InstrumentPart('Option.Underlying.Quotation'),
                                visible = False)

    #-----------------------------
    # Traits to handle fixing dates
    #-----------------------------
    exercise = Action (action = '@Exercise')

    def AttributeOverrides(self, overrideAccumulator):
        overrideAccumulator({
        })

    def AddExoticEvent(self, type, date, settlementDate, endDate, value, valueSecond, componentInstrument):
        ee = acm.FExoticEvent()
        ee.Instrument(self.Option().Instrument())
        ee.ComponentInstrument(componentInstrument)
        ee.Type(type)
        ee.Date(date)
        ee.EventValue(value)
        ee.EventValueSecond(valueSecond)
        self.Option().ExoticEvents().Add(ee)
        ee.RegisterInStorage()

    def GetExoticEventReference(self):
        raise NotImplementedError('Method GetExoticEventReference not implemented')

    def DeleteExoticEventsOfType(self, eeType):
        existingEvents = [event for event in self.Option().GetExoticEventsOfKind(eeType)]
        for ee in existingEvents:
            ee.Unsimulate()

    def DeleteMLDExpiryEvents(self):
        self.DeleteExoticEventsOfType('Price Fixing')

    def DeleteAveragePriceDates(self):
        self.DeleteExoticEventsOfType('Average price')

    #-----------------------------
    # Methods to override
    #-----------------------------
    # Return value is for instrument (not for trade), i.e. for trade quantity 1
    def ExerciseAmount(self, date):
        raise NotImplementedError('Method ExerciseAmount not implemented')

    def ExerciseObjects(self, date, *rest):
        raise NotImplementedError('Method ExerciseObjects not implemented')

    def GeneratePeriodDates(self):
        raise NotImplementedError('Method GeneratePeriodDates not implemented')

    def GetFixingParams(self):
        raise NotImplementedError('Method GeneratePeriodDates not implemented')

    def FieldsSetToGenerate(self):
        raise NotImplementedError('Method FieldsSetToGenerate not implemented')

    #-----------------------------
    # Exercise Events
    #-----------------------------

    def _CreateExerciseEvent(self, startDate, EndDate, SettlementDate):
        #need to use strikeDomesticPerForeign
        ee = acm.FExerciseEvent()
        ee.Date(EndDate)
        ee.StartDate(startDate)
        ee.SettlementDate(SettlementDate)
        ee.EndDate(EndDate)
        ee.NoticeDate(EndDate)
        ee.Strike(-1)
        ee.Type('UserDefined')
        ee.Instrument(self.Option())
        self.Option().ExerciseEvents().Add(ee)
        ee.RegisterInStorage()

    def GenerateMLDExpiryEvents(self, dates = None):
        if dates is None:
            ExpiryDates, periodEndDates = GenerateMLDExpiryTable(self.GetFixingParams())

        allExerciseEvents = self.Option().ExerciseEvents()
        allExerciseEvents.Unsimulate()
        for enddate in periodEndDates:
            observationDays = [x for x in ExpiryDates if x.At('endDate') == enddate.At('endDate')]
            startDate = None
            for obsDay in observationDays:
                observationDate = obsDay.At('observationDate')

                if(acm.Time.DateDifference(self.expiry, observationDate) >= 0):
                    self.AddExoticEvent('Price Fixing', observationDate, obsDay.At('settlementDate'), obsDay.At('endDate'), -1, -1, self.GetExoticEventReference())
                if startDate is None :
                    startDate = observationDate
                elif startDate > observationDate:
                    startDate = observationDate
            self._CreateExerciseEvent(startDate, enddate.At('endDate'), enddate.At('settlementDate'))

        self._generateAttributeUpdated = False

    def GetNumberOfPeriods(self):
        return GetNumberOfPaymentPeriods(self.Option().Instrument())

    @ReturnDomainDecorator('int')
    def NumberOfObservationDays(self, value = 'NoValue'):
        return self.GetNumberOfObservationDays()

    def GetNumberOfObservationDays(self):
        mldExpEvents = self.Option().GetExoticEventsOfKind('Price Fixing')
        if mldExpEvents is not None :
            return mldExpEvents.Size()
        return 0

    def SortMLDExpiryEvents(self, attrName, columnNbr, value, formatter, obj):
        if columnNbr < 0:
            return acm.Time.DateTimeToTime(obj.Date())
        if columnNbr in (0, 1):
            return acm.Time.DateTimeToTime(value)
        return value

    #-----------------------------
    # Object Mappings
    #-----------------------------
    @ReturnDomainDecorator('date')
    def ExpiryDate(self, value = 'NoVal'):
        if value == 'NoVal':
            return self.OptionNoQuestionGui().ExpiryDate()
        self.OptionNoQuestionGui().ExpiryDate(value)

    @ReturnDomainDecorator('date')
    def StartDate(self, value = 'NoVal'):
        if value == 'NoVal':
            return self.Option().StartDate()
        self.Option().StartDate(value)
    
    @ReturnDomainDecorator('date')
    def Expiry(self, value='NoVal'):
        if value == 'NoVal':
            return self.Option().FxoExpiryDate()
        self.Option().FxoExpiryDate(value)

    #-----------------------------
    # Date period logic
    #-----------------------------
    def ExpiryPeriodToDate(self, traitName, value):
        return ExpiryPeriodToDate(self.OptionNoQuestionGui(), value)

    #-----------------------------
    # Enabled Callbacks
    #-----------------------------
    def FieldsUpdatedToGenerate(self):
        return self._generateAttributeUpdated

    def EnabledFixingsGenerate(self, traitName):
        return (self.FieldsSetToGenerate() and
                self.FieldsUpdatedToGenerate() and
                (not self.IsFirstFixingDateFixed()))

    #-----------------------------
    # Action Callbacks
    #-----------------------------
    def ActionFixingsGenerate(self, traitName):
        self.DeleteMLDExpiryEvents()
        self.GenerateMLDExpiryEvents()

    #-----------------------------
    # Columns callbacks
    #-----------------------------
    def ColumnsExoticEvents(self, traitName):
        raise NotImplementedError('Method ColumnsExoticEvents not implemented')

    #-----------------------------
    # On Selection Changed callacks
    #-----------------------------
    def SelectionExoticEvents(self, traitName, rowObject):
        self.fixingEditer.OnSelectionChanged(rowObject)

    def RegisterUpdatedAttribute(self, attrName, *args):
        raise NotImplementedError('Method RegisterUpdatedAttribute not implemented')

    #-----------------------------------------
    # Formatters
    #-----------------------------------------
    def VisibleIfNotAsian(self, attrName):
        return True

    #-----------------------------------------
    # Action callbacks
    #-----------------------------------------
    def Exercise(self, attrName, *rest):
        def CheckAllFixingsDone(event):
            for ee in self.exoticEvents:
                if (acm.Time.DateDifference(ee.Date(), event.Date()) < 0 
                        and ee.EventValue() < epsilon):
                    raise DealPackageUserException('No fixing value for %s' % ee.Date())
            return True

        exerciseObjects = []
        closingPackage = None
        date = rest[0] if len(rest) > 0 else acm.Time().DateToday()
        event = MLDExpiryEvent(self.Option(), date)
        if event:
            openPart = self.tradeQuantity * CalculateOpenPart(self.OptionTrade(), date = event.Date(), tradeType = 'tradeType', status = 'tradeStatus', quantity = 'tradeQuantity', valueDay = 'tradeValueDay', tradeTime = 'tradeTime')
            if abs(openPart) > epsilon:
                if not IsExercised(self.OptionTrade(), event):
                    CheckAllFixingsDone(event)
                    amount = self.ExerciseAmount(date)
                    exerciseObjects = self.ExerciseObjects(amount, event, date, openPart)
                else:
                    raise DealPackageUserException('Trade has already been exercised for %s' % date)
            else:
                raise DealPackageUserException('Position is 0 for %s' % date)
        return exerciseObjects, closingPackage

    #-----------------------------------------
    # Choice List values
    #-----------------------------------------
    def ChoicesSettlementType(self, attrName, *rest):
        return SettlementTypeChoices(self.Option())

    #-----------------------------------------
    # Access components
    #-----------------------------------------
    def Option(self):
        return self.DealPackage().InstrumentAt('Option')

    def OptionB2B(self):
        return self.B2BTradeParamsAt('Option')

    def OptionNoDecorator(self):
        return self.Option().DecoratedObject()

    def OptionNoQuestionGui(self):
        option = self.OptionNoDecorator()
        gui = acm.FBusinessLogicGUIDefault()
        gui.AskAdjustToFollowingBusinessDay(False)
        return acm.FBusinessLogicDecorator.WrapObject(option, gui)

    def OptionTrade(self):
        return self.DealPackage().TradeAt('Option')
    
    def LeadTrade(self):
        return self.OptionTrade()
    #-----------------------------------------
    # Other methods
    #-----------------------------------------
    @ReturnDomainDecorator('FIndexedCollection(FExoticEvent)')
    def MLDExpiryEvents(self, *rest):
        return self.Option().GetExoticEventsOfKind('Price Fixing')

    @ReturnDomainDecorator('FArray(FExoticEvent)')
    def AveragePriceEvents(self, *rest):
        allEvents = self.Option().GetExoticEventsOfKind('Average price').AsArray()
        if self.fixingEditer.GetFixingEventSelected() is None:
            return acm.FArray()
        specificEvents = acm.FArray()
        selectedDateAsYMD = acm.Time.DateToYMD(self.fixingEditer.GetFixingEventSelected().Date())
        for event in allEvents:
            eventDateAsYMD = acm.Time.DateToYMD(event.Date())
            if (eventDateAsYMD[0] == selectedDateAsYMD[0] and
                eventDateAsYMD[1] == selectedDateAsYMD[1]):
                specificEvents.Add(event)
        return specificEvents

    def IsFirstFixingDateFixed(self):
        if self.exoticEvents and len(self.exoticEvents) > 0:
            return (self.exoticEvents[0].Date() < acm.Time.DateNow() and \
                   (self.exoticEvents[0].EventValue() > 0.0 or \
                    self.exoticEvents[0].EventValueSecond() > 0.0 ))
        return False

    #-----------------------------------------
    # Interface override
    #-----------------------------------------
    def CustomPanes(self):
        raise NotImplementedError('Method CustomPanes not implemented')

    def OnSave(self, saveConfig):
        self.Option().OptionType('Call')
        super().OnSave(saveConfig)

    def IsValid(self, exceptionAccumulator, aspect):
        if self.FieldsUpdatedToGenerate():
            exceptionAccumulator('Fields affecting date periods have been updated, date periods must be re-generated in order to save')

    def OnInit(self):
        super().OnInit()

    def AssemblePackage(self):
        raise NotImplementedError('Method AssemblePackage not implemented')

    @classmethod 
    def SetUp(cls, definitionSetUp):
        super().SetUp(definitionSetUp)




...

  SP_MLDCalculations
"""----------------------------------------------------------------------------     
FOOTPRINT
    [2024 05 10] richard.milford@fisglobal.com
    As per TCSTCSPBDT-430601, adjust CalculateDailyAccrualReturn noOfDay from "acm.Time().DateDifference( optEndDate, optStartDate) + 1"
    to "noOfDay = acm.Time().DateDifference( optEndDate, optStartDate)".
    NOTE that this logic aligns to the logic within Accounting.PsRvm_AccountingMmldColumn
----------------------------------------------------------------------------"""

from __future__ import division

import acm

import operator
from SP_TrfExerciseCalculations import  BaseSettlementParameters, CalculateCashAmount, GetFixingValue

greater = operator.gt
greaterOrEqual = operator.ge
epsilon = 0.000001
   

def CalculateDailyAccrualReturn(optStartDate, optEndDate, maxReturn, mldNotional, dayBasis, observationDays):
    dailyAccrualReturn = 0
    noOfDay = acm.Time().DateDifference( optEndDate, optStartDate) 
    maxTotalReturn = (noOfDay * maxReturn * mldNotional) / dayBasis
    if (observationDays is not None) and (observationDays!=0 ):
        dailyAccrualReturn = maxTotalReturn/observationDays
    return dailyAccrualReturn
    


'''
def CashSettlementParameters(instrument, date):
    params = BaseSettlementParameters(instrument, date)
    #params['settleInDomesticCurrency'] = instrument.AdditionalInfo().Sp_SettleInCurr2()
    rateDirection = params['rateDirection']
    rateDecimals = 6
    fixing = round(GetFixingValue(instrument, date, rateDirection), rateDecimals)
    strike = round(instrument.StrikePrice(), rateDecimals)
    barrier = round(instrument.Barrier(), rateDecimals)
    params['fixing']=fixing
    params['strike']=strike
    params['barrierLevel']=barrier
    return params


def CustomCalculateCashAmount(instrument, date):
    if instrument.AdditionalInfo().StructureType() == 'Market Linked Deposit RAFx':
        return CalculateCashAmount(**CashSettlementParameters(instrument, date))
    else:
        raise RuntimeError('MLD settlement calculations only implemented for Market Linked Deposit (Range Accrual FX)')

        
def CalculateSettlementAmounts(trade, date):
    instrument = trade.Instrument()
    if instrument.SettlementType() == 'Cash':
        return CustomCalculateCashAmount(instrument, date)
    else:
        return None
'''

...

  SP_MLDCompositeAttributes
from __future__ import print_function
from __future__ import division
from __future__ import absolute_import


from builtins import range
from FFixPerform import UsedPrice
import acm
from DealPackageDevKit import CompositeAttributeDefinition, Object, Action, InstrumentPart, ReturnDomainDecorator, Date, DealPackageUserException, Float, Str
from SP_DealPackageHelper import GetCurrencyPairPointsDomesticPerForeign, GetCurrencyPairPointsForeignPerDomestic, StringValueIsInteger
from SP_BusinessCalculations import AdjustBankingDaysFromMultiCalendars, BankingDayPeriodToDateFromStartDate, GetPairCalendars
from SP_MarketLinkedDeposit_Utils import MLDExpiryEvent, MLDExpiryEventPerPayDate, FixFxRateCalculation, GetInverseRate, CalculateAverageFixing, MtMPriceFromFixingSource

#InstrumentPart,


class MLDFxRateComposite(CompositeAttributeDefinition):

    def Attributes(self):
        
        return {

                'rateDomesticPerForeign' :    Object( objMapping = InstrumentPart(self.UniqueCallback('ObjectMappingDomesticPerForeign')),
                                                      formatter = self.UniqueCallback('@FormatFXDomesticPerForeign')),
                
                'rateForeignPerDomestic' :    Object( objMapping = InstrumentPart(self.UniqueCallback('ObjectMappingForeignPerDomestic')),
                                                      formatter = self.UniqueCallback('@FormatFXForeignPerDomestic')),
                
                'storeDomesticPerForeign' :   Action( action = self.UniqueCallback('@SetStorageDomesticPerForeign')),

                'storeForeignPerDomestic' :   Action( action = self.UniqueCallback('@SetStorageForeignPerDomestic')),
                
                'reEvaluateObjectMappings' :  Action( action = self.UniqueCallback('@ReEvaluateObjectMappings')),
                
                'foreignFormatter' :          Str   ( defaultValue = 'foreignCurrency'),
                
                'domesticFormatter' :         Str   ( defaultValue = 'domesticCurrency'),
                
                'instrumentPairAttribute' :   Str   ( defaultValue = 'instrumentPair')
                }
                          
    def OnInit(self, rateDomPerFor, rateForPerDom):
        self._rateDomPerFor = rateDomPerFor
        self._rateForPerDom = rateForPerDom
        self._formatterFxDomesticPerForeign = None
        self._formatterFxForeignPerDomestic = None

    def ReadMapping(self, mapping):
        parts = mapping.split('.')
        value = self.GetMethod(parts[0])()
        for part in range(1, len(parts)):
            value = getattr(value, parts[part])()
        return value
    
    def WriteMapping(self, mapping, value):
        parts = mapping.split('.')
        writeMethod = self.GetMethod(parts[0])
        for part in range(1,len(parts)):
            writeMethod = getattr(writeMethod(), parts[part])
        writeMethod(value)

    def ObjectMappingRates(self, mapping, value = 'NoValue'):
        if value == 'NoValue':
            return self.ReadMapping(mapping)
        else:
            self.WriteMapping(mapping, value)
            self.GetAttribute('reEvaluateObjectMappings')()

    @ReturnDomainDecorator('double')
    def ObjectMappingDomesticPerForeign(self, value = 'NoValue'):
        return self.ObjectMappingRates(self._rateDomPerFor, value)

    @ReturnDomainDecorator('double')
    def ObjectMappingForeignPerDomestic(self, value = 'NoValue'):
        return self.ObjectMappingRates(self._rateForPerDom, value)

    # Action to trigger re-draw of UI
    def ReEvaluateObjectMappings(self, *rest):
        pass

    def SetStorageDomesticPerForeign(self, attrName, *rest):
        silent = rest[0] if len(rest) > 0 else False
        self.SetStorageDirection('rateDomesticPerForeign', silent)
    
    def SetStorageForeignPerDomestic(self, attrName, *rest):
        silent = rest[0] if len(rest) > 0 else False
        self.SetStorageDirection('rateForeignPerDomestic', silent)
    
    def SetStorageDirection(self, attrName, silent):
        storageAttr = attrName.replace('store', 'rate')
        currentValue = self.GetAttribute(storageAttr)
        self.SetAttribute(storageAttr, currentValue + 0.00000001, silent)
        self.SetAttribute(storageAttr, currentValue, silent)

    def FormatFXDomesticPerForeign(self, traitName):
        if not self._formatterFxDomesticPerForeign:
            self._formatterFxDomesticPerForeign = acm.Get('formats/SP_MLDFXRate').Clone()
        numDecimals = GetCurrencyPairPointsDomesticPerForeign(self.Owner().GetAttribute(self.foreignFormatter),
                                                              self.Owner().GetAttribute(self.domesticFormatter),
                                                              self.Owner().GetAttribute(self.instrumentPairAttribute))
        self._formatterFxDomesticPerForeign.NumDecimals(numDecimals)
        return self._formatterFxDomesticPerForeign
    
    def FormatFXForeignPerDomestic(self, traitName):
        if not self._formatterFxForeignPerDomestic:
            self._formatterFxForeignPerDomestic = acm.Get('formats/SP_MLDFXRate').Clone()
        numDecimals = GetCurrencyPairPointsForeignPerDomestic(self.Owner().GetAttribute(self.foreignFormatter),
                                                              self.Owner().GetAttribute(self.domesticFormatter),
                                                              self.Owner().GetAttribute(self.instrumentPairAttribute))
        self._formatterFxForeignPerDomestic.NumDecimals(numDecimals)
        return self._formatterFxForeignPerDomestic


class MLDFixingEditerComposite(CompositeAttributeDefinition):

    #-----------------------------
    # Interface Overrides
    #-----------------------------
    def Attributes(self):
        attr = {
            # vvv Fields vvv
            'fixingDate' : Date(
                label = 'Fixing Date',
                enabled = self.UniqueCallback('@EnabledFixingDate'),
                validate = self.UniqueCallback('@ValidateFixingDate'),
                transform = self.UniqueCallback('@TransformFixingDate')),
            'payDate' : Date(
                label = 'Pay Date',
                visible = self.UniqueCallback('@VisiblePayDate'),
                validate = self.UniqueCallback('@ValidatePayDate'),
                transform = self.UniqueCallback('@TransformPayDate')),
            'fixingValue' : self.FixingValueAttr(),
            # vvv Buttons vvv
            'fixingAdd' : Action(
                label = 'Add',
                visible = self.UniqueCallback('@VisibleFixingAdd'),
                enabled = self.UniqueCallback('@EnabledFixingAdd'),
                action = self.UniqueCallback('@ActionFixingAdd')),
            'fixingUpdate' : Action(
                label = 'Update',
                enabled = self.UniqueCallback('@EnabledFixingUpdate'),
                action = self.UniqueCallback('@ActionFixingUpdate')),
            'fixingRemove' : Action(
                label = 'Delete',
                visible = self.UniqueCallback('@VisibleFixingRemove'),
                enabled = self.UniqueCallback('@EnabledFixingRemove'),
                action = self.UniqueCallback('@ActionFixingRemove')),
            'fixingFixRate' : Action(
                label = 'Suggest Fixing',
                enabled = self.UniqueCallback('@EnabledFixRate'),
                action = self.UniqueCallback('@ActionFixRate'))
        }
        return attr

    def OnInit(self, instrument):
        self._instrument = instrument
        self._fixingValue = 0.0
        self._fixingEventSelected = None

    def GetLayout(self):
        raise NotImplementedError('GetLayout not implemented')
        
    #-----------------------------
    # Protected Access Methods
    #-----------------------------
    def Instrument(self):
        return self.GetMethod(self._instrument)()
        
    def FixingValueAttr(self):
        attr = Object(
            objMapping = self.UniqueCallback('FixingValue'))
        return attr
            
    def GetFixingEventSelected(self, value = 'NoValue'):
        if value == 'NoValue':
            return self._fixingEventSelected
        else:
            self._fixingEventSelected = value
    
    @ReturnDomainDecorator('double')      
    def FixingValue(self, value = 'NoValue'):
        if value == 'NoValue':
            return self._fixingValue
        else:
            self._fixingValue = value
        
    #-----------------------------
    #  Public Access Callbacks
    #-----------------------------
    def OnSelectionChanged(self, rowObj):
        if rowObj:
            self._fixingEventSelected = rowObj
            self._fixingValue = rowObj.EventValue()
            self.fixingDate = rowObj.Date()
            self.payDate = rowObj.PayDate() 
        else:
            self.ResetState()
            
    def ResetState(self):
        self._fixingEventSelected = None
        self._fixingValue = 0.0
        self.fixingDate = None
        self.payDate = None
        
    #-----------------------------
    # Visible Callbacks
    #-----------------------------  
    def VisiblePayDate(self, traitName):
        return True

    def VisibleFixingAdd(self, traitName):
        return True
    
    def VisibleFixingRemove(self, traitName):
        return True
        
    #-----------------------------
    # Enabled Callbacks
    #-----------------------------
    def EnabledFixingDate(self, traitName):
        return True
        
    def EnabledFixingAdd(self, traitName):
        enable = False
        '''
        tee = MLDExpiryEvent(self.Instrument(), self.fixingDate)
        teeppd = MLDExpiryEventPerPayDate(self.Instrument(), self.payDate)
        if (self.fixingDate and self.payDate and not (tee or teeppd)):
        #if (self.fixingDate and not (tee)):
            enable = True
        '''
        return enable
        
    def EnabledFixingUpdate(self, traitName):
        enable = False
        row = self._fixingEventSelected 
        if row:
            edited = (row.Date() != self.fixingDate 
                or row.PayDate() != self.payDate 
                or row.EventValue() != self._fixingValue)
            if edited:
                enable = True
        return enable

    def EnabledFixingRemove(self, traitName):
        enable = (self._fixingEventSelected != None)
        return enable
        
    def EnabledFixRate(self, traitName):
        enable = False
        row = self._fixingEventSelected
        if row:
            rd = row.Date()
            today = acm.Time.DateToday()
            if acm.Time.DateDifference(rd, today) <= 0:
                enable = True
        return enable

    #-----------------------------
    # Validate Callbacks
    #-----------------------------
    def ValidateFixingDate(self, traitName, newDate):
        row = self._fixingEventSelected
        if row and not newDate:
            Md = self.GetMethod('GetAttributeMetaData')
            label = Md(traitName, 'label')()
            str = 'Expected a %s' % label
            raise DealPackageUserException(str)    
       
    def ValidatePayDate(self, traitName, newDate):
        row = self._fixingEventSelected
        if row and not newDate:
            Md = self.GetMethod('GetAttributeMetaData')
            label = Md(traitName, 'label')()
            str = 'Expected a %s' % label
            raise DealPackageUserException(str) 

        
    #-----------------------------
    # Action Callbacks
    #-----------------------------
    def ActionFixingAdd(self, traitName):
        raise NotImplementedError('ActionFixingAdd not implemented')
                
    def ActionFixingUpdate(self, traitName):
        row = self._fixingEventSelected
        if row:
            fvExist = (self._fixingValue and self._fixingValue > 0.0) 
            ev = self._fixingValue if fvExist else -1.0
            row.EventValue(ev)
            row.Date(self.fixingDate)
            row.SetPayDate(self.payDate)
            
    def ActionFixingRemove(self, traitName):
        row = self._fixingEventSelected
        if row:
            row.Unsimulate()
            
    def ActionFixRate(self, traitName):
        raise NotImplementedError('ActionFixRate not implemented')

    #-----------------------------
    # Transform Callbacks
    #-----------------------------
    def TransformFixingDate(self, attrName, newDate, *rest):
        date = newDate
        if date:
            if acm.Time.PeriodSymbolToDate(date):
                dateNow = acm.Time().DateNow()
                nonAdjustedDate = acm.Time.DateAdjustPeriod(dateNow, newDate)
                date = AdjustBankingDaysFromMultiCalendars(
                    nonAdjustedDate, 0, self.GetBankingDateAdjustCalendars())
        return date
    
    
    def TransformPayDate(self, attrName, newDate, *rest):
        date = newDate
        if acm.Time().PeriodSymbolToDate(newDate):
            if acm.Time.IsValidDateTime(self.fixingDate):
                date = BankingDayPeriodToDateFromStartDate(
                    self.GetBankingDateAdjustCalendars(), 
                    self.fixingDate, 
                    newDate, 
                    self.Instrument().SettlementCalendar())
            else:
                raise DealPackageUserException(
                    'Cannot enter pay date as a period '
                    'without a valid fixing date')
        return date
    

    def GetBankingDateAdjustCalendars(self):
        raise NotImplementedError('GetBankingDateAdjustCalendars not implemented')

class MLDIRFixingEditerComposite(MLDFixingEditerComposite):

    def OnSelectionChanged(self, rowObj):
        if rowObj:
            self._fixingEventSelected = rowObj
            self._fixingValue = rowObj.FixFixingValue() if acm.Math.IsFinite(rowObj.FixFixingValue()) else 0
            self.fixingDate = rowObj.Day()
            self.payDate = rowObj.CashFlow().PayDate() 
        else:
            self.ResetState()

    def GetLayout(self):
        str = ( 
        '''
            vbox[Fixing;
                hbox(;
                    fixingDate;
                    payDate;
                );
                fixingValue;
                hbox(;
                    fixingUpdate;
                    fixingFixRate;
                );
            ];
        ''')
        layout = self.UniqueLayout(str)
        return layout

    def EnabledFixingUpdate(self, traitName):
        enable = False
        row = self._fixingEventSelected 
        if row:
            fixing_value = row.FixFixingValue() if acm.Math.IsFinite(row.FixFixingValue()) else 0
            edited = (row.Day() != self.fixingDate 
                or row.CashFlow().PayDate() != self.payDate 
                or fixing_value != self._fixingValue)
            if edited:
                enable = True
        return enable

    def EnabledFixingRemove(self, traitName):
        return self._fixingEventSelected is not None

    def EnabledFixRate(self, traitName):
        enable = False
        row = self._fixingEventSelected
        if row:
            rd = row.Day()
            today = acm.Time.DateToday()
            if acm.Time.DateDifference(rd, today) <= 0:
                enable = True
        return enable

    @staticmethod
    def _MatchedReset(reset):
        resets = reset.Leg().Resets()
        resets = [i_reset for i_reset in resets if i_reset.CashFlow().NominalFactor() < 0 and acm.Time.DateDifference(i_reset.Day(), reset.Day()) == 0]
        if len(resets) == 1:
            return resets[0]
        return None

    def ActionFixingUpdate(self, traitName):
        row = self._fixingEventSelected
        if row:
            fvExist = (self._fixingValue and self._fixingValue > 0.0) 
            ev = self._fixingValue if fvExist else -1.0
            row.FixFixingValue(ev)
            matched = self._MatchedReset(row)
            if matched is not None:
                matched.FixFixingValue(ev)

    def ActionFixRate(self, traitName):
        row = self._fixingEventSelected 
        threshold = 1e-6
        if row and row.Day() <= acm.Time.DateToday():
            try:
                reset = self._fixingEventSelected
                if reset.FixFixingValue() <= threshold:
                    instrument = reset.Instrument()
                    leg = reset.Leg()
                    price = UsedPrice(leg.FixingInstrument(), reset.Day(), reset.Day(), instrument.Currency(), 'EOD_MtM', False)
                    self.fixingValue = price
            except RuntimeError as e:
                raise DealPackageUserException(str(e))

class MLDFxFixingEditerComposite(MLDFixingEditerComposite):

    class FxFixingValue(MLDFxRateComposite):
        @ReturnDomainDecorator('double')
        def ObjectMappingDomesticPerForeign(self, value = 'NoValue'):
            return self.GetMethod(self._rateDomPerFor)(value)

        @ReturnDomainDecorator('double')
        def ObjectMappingForeignPerDomestic(self, value = 'NoValue'):
            return self.GetMethod(self._rateForPerDom)(value)

    def InstrumentPair(self):
        return self.Owner().GetAttribute(self.fixingValue_instrumentPairAttribute)

    def GetBankingDateAdjustCalendars(self):
        return GetPairCalendars(self.InstrumentPair())
    
    #-----------------------------
    # Interface Overrides
    #-----------------------------

    def GetLayout(self):
        str = ( 
        '''
            vbox[Fixing;
                hbox(;
                    fixingDate;
                    payDate;
                );
                hbox(;   
                    fixingValue_rateDomesticPerForeign;
                    fixingValue_rateForeignPerDomestic;
                );
                hbox(;
                    fixingAdd;
                    fixingUpdate;
                    fixingRemove;
                    fixingFixRate;
                );
            ];
        ''')
        layout = self.UniqueLayout(str)
        return layout
        
    #-----------------------------
    # Protected Access Methods
    #-----------------------------    
    def FixingValueAttr(self):
        attr = self.FxFixingValue( 
                rateDomPerFor = self.UniqueCallback('FixingValue'),
                rateForPerDom = self.UniqueCallback('FixingValueInvRate'))
        return attr
        
    @ReturnDomainDecorator('double')
    def FixingValueInvRate(self, value = 'NoValue'):
        if value == 'NoValue':
            return GetInverseRate(self.FixingValue())
        else:
            self.FixingValue(GetInverseRate(value))
    
    #-----------------------------
    # Action Callbacks
    #-----------------------------
    def ActionFixingAdd(self, traitName):
        tee = MLDExpiryEvent(self.Instrument(), self.fixingDate)
        #teeppd = MLDExpiryEventPerPayDate(self.Instrument(), self.payDate)
        #if (self.fixingDate and self.payDate and not (tee or teeppd)):
        if (self.fixingDate and not (tee)):
            AddEe = self.GetMethod('AddExoticEvent')
            AddEe('Price Fixing', self.fixingDate, 
                None, self._fixingValue, -1,
                self.Owner().GetExoticEventReference())
        
    def ActionFixRate(self, traitName):
        row = self._fixingEventSelected 
        threshold = 1e-6
        if row and row.Date() <= acm.Time.DateToday():
            try:
                instrumentPair = self.InstrumentPair()
                reset = self._fixingEventSelected 
                if reset.EventValue() <= threshold:
                    compIns = reset.ComponentInstrument()
                    if compIns.IsKindOf(acm.FCurrency):
                        currPair = reset.Instrument().ValuationUnderlying().CurrencyPair()
                        price = UsedPrice(currPair.Currency1(), reset.Date(), reset.Date(), currPair.Currency2(), reset.Instrument().FixingSource(), False)
                    else:
                        price = UsedPrice(compIns, reset.Date(), reset.Date(), reset.Instrument().Currency(), reset.Instrument().FixingSource(), False)
                #fxRate = FixFxRateCalculation(self.Instrument(), row, instrumentPair)
                self.fixingValue_rateDomesticPerForeign = price
            except RuntimeError as e:
                raise DealPackageUserException(str(e))
                
                
class MLDFxDepositComposite(CompositeAttributeDefinition):

    def Attributes(self):
        
        return {

                'rateDomesticPerForeign' :    Object( objMapping = InstrumentPart(self.UniqueCallback('ObjectMappingDomesticPerForeign')),
                                                      formatter = self.UniqueCallback('@FormatFXDomesticPerForeign')),
                
                'rateForeignPerDomestic' :    Object( objMapping = InstrumentPart(self.UniqueCallback('ObjectMappingForeignPerDomestic')),
                                                      formatter = self.UniqueCallback('@FormatFXForeignPerDomestic')),
                
                'storeDomesticPerForeign' :   Action( action = self.UniqueCallback('@SetStorageDomesticPerForeign')),

                'storeForeignPerDomestic' :   Action( action = self.UniqueCallback('@SetStorageForeignPerDomestic')),
                
                'reEvaluateObjectMappings' :  Action( action = self.UniqueCallback('@ReEvaluateObjectMappings')),
                
                'foreignFormatter' :          Str   ( defaultValue = 'foreignCurrency'),
                
                'domesticFormatter' :         Str   ( defaultValue = 'domesticCurrency'),
                
                'instrumentPairAttribute' :   Str   ( defaultValue = 'instrumentPair')
                }
                          
    def OnInit(self, rateDomPerFor, rateForPerDom):
        self._rateDomPerFor = rateDomPerFor
        self._rateForPerDom = rateForPerDom
        self._formatterFxDomesticPerForeign = None
        self._formatterFxForeignPerDomestic = None

    def ReadMapping(self, mapping):
        parts = mapping.split('.')
        value = self.GetMethod(parts[0])()
        for part in range(1, len(parts)):
            value = getattr(value, parts[part])()
        return value
    
    def WriteMapping(self, mapping, value):
        parts = mapping.split('.')
        writeMethod = self.GetMethod(parts[0])
        for part in range(1,len(parts)):
            writeMethod = getattr(writeMethod(), parts[part])
        writeMethod(value)

    def ObjectMappingRates(self, mapping, value = 'NoValue'):
        if value == 'NoValue':
            return self.ReadMapping(mapping)
        else:
            self.WriteMapping(mapping, value)
            self.GetAttribute('reEvaluateObjectMappings')()

    @ReturnDomainDecorator('double')
    def ObjectMappingDomesticPerForeign(self, value = 'NoValue'):
        return self.ObjectMappingRates(self._rateDomPerFor, value)

    @ReturnDomainDecorator('double')
    def ObjectMappingForeignPerDomestic(self, value = 'NoValue'):
        return self.ObjectMappingRates(self._rateForPerDom, value)

    # Action to trigger re-draw of UI
    def ReEvaluateObjectMappings(self, *rest):
        pass

    def SetStorageDomesticPerForeign(self, attrName, *rest):
        silent = rest[0] if len(rest) > 0 else False
        self.SetStorageDirection('rateDomesticPerForeign', silent)
    
    def SetStorageForeignPerDomestic(self, attrName, *rest):
        silent = rest[0] if len(rest) > 0 else False
        self.SetStorageDirection('rateForeignPerDomestic', silent)
    
    def SetStorageDirection(self, attrName, silent):
        storageAttr = attrName.replace('store', 'rate')
        currentValue = self.GetAttribute(storageAttr)
        self.SetAttribute(storageAttr, currentValue + 0.00000001, silent)
        self.SetAttribute(storageAttr, currentValue, silent)

    def FormatFXDomesticPerForeign(self, traitName):
        if not self._formatterFxDomesticPerForeign:
            self._formatterFxDomesticPerForeign = acm.Get('formats/SP_MLDFXRate').Clone()
        numDecimals = GetCurrencyPairPointsDomesticPerForeign(self.Owner().GetAttribute(self.foreignFormatter),
                                                              self.Owner().GetAttribute(self.domesticFormatter),
                                                              self.Owner().GetAttribute(self.instrumentPairAttribute))
        self._formatterFxDomesticPerForeign.NumDecimals(numDecimals)
        return self._formatterFxDomesticPerForeign
    
    def FormatFXForeignPerDomestic(self, traitName):
        if not self._formatterFxForeignPerDomestic:
            self._formatterFxForeignPerDomestic = acm.Get('formats/SP_MLDFXRate').Clone()
        numDecimals = GetCurrencyPairPointsForeignPerDomestic(self.Owner().GetAttribute(self.foreignFormatter),
                                                              self.Owner().GetAttribute(self.domesticFormatter),
                                                              self.Owner().GetAttribute(self.instrumentPairAttribute))
        self._formatterFxForeignPerDomestic.NumDecimals(numDecimals)
        return self._formatterFxForeignPerDomestic
        
        
        

...

  SP_MMLDCloseCommand
import acm

from DealPackageDevKit import CloseCommand
from DealPackageTradeActionCommands import AsFArray
from SP_CommonCloseCommand import SP_TradeActionClose, SetCloseAttribute

class MMLDCloseCommand(CloseCommand):
    def Invoke(self, *args):
        newDp = acm.DealPackage.NewAsDecorator('MMLDTradeActionClose', self.DealPackage().GUI(), self.KeyWordArguments())
        return AsFArray(newDp)

class MMLDTradeActionClose(SP_TradeActionClose):
    def SetB2BFields(self, origDp, close):
        # Set B2B fields on closing DP
        if origDp.GetAttribute('b2bDepositEnabled') is True:
            close.SetAttribute('b2bDepositEnabled', True)
            for attrName in ['depositB2BPrice', 'depositB2BAcq', 'depositB2BPort']:
                SetCloseAttribute(origDp, close, attrName)
        if origDp.GetAttribute('b2bOptionEnabled') is True:
            close.SetAttribute('b2bOptionEnabled', True)
            for attrName in ['b2bOptionPrice', 'b2bOptionAcq', 'b2bOptionPrf']:
                SetCloseAttribute(origDp, close, attrName)

class MMLDIRCloseCommand(CloseCommand):
    def Invoke(self, *args):
        newDp = acm.DealPackage.NewAsDecorator('MMLDIRTradeActionClose', self.DealPackage().GUI(), self.KeyWordArguments())
        return AsFArray(newDp)

class MMLDIRTradeActionClose(SP_TradeActionClose):
    def SetB2BFields(self, origDp, close):
        # Set B2B fields on closing DP
        if origDp.GetAttribute('b2bDepositEnabled') is True:
            close.SetAttribute('b2bDepositEnabled', True)
            for attrName in ['depositB2BPrice', 'depositB2BAcq', 'depositB2BPort']:
                SetCloseAttribute(origDp, close, attrName)
        if origDp.GetAttribute('b2bSwapEnabled') is True:
            close.SetAttribute('b2bSwapEnabled', True)
            for attrName in ['swapB2BPrice', 'swapB2BAcq', 'swapB2BPort']:
                SetCloseAttribute(origDp, close, attrName)

...

  TraitBasedDealPackage
from builtins import object
from builtins import filter

import acm
import TraitBase
import inspect
from TraitBase import IsFObject, TraitBase, Date, DatePeriod, Str, Object, Float, Bool, Box, Int, CalcVal, List, Grid, Sheet, Set, Action, Text, Label, Link, DelegateAttribute, DelegateDealPackage
from DealPackageCalculations import DealPackageCalculations
from TraitDomainAndValueValidator import TraitDomainAndValueValidator
from DealPackageUtil import DealPackageException, IsFObject, IsPublicTrait, StringKeyOrVal, FormatException, ObjMappingSplitter, MergeMetaDataStrings, IsCallable
from TraitUtil import AttributeException, ThrowOrAccumulate
from CompositeAttributeBase import CompositeAttributeBase
from AttributeMetaDataFactory import ValidAttributeMetaDataKeys, MetaDataMergePossible
from traitlets import getmembers, TraitType
from CompositeAttributeBase import CompositeAttributeBase
from collections import OrderedDict
import copy

class NotImplemented(object):
    pass
    
NOT_IMPLEMENTED = NotImplemented()

def Delegate(*args, **kwargs):
    if 'attributeMapping' in kwargs and len(kwargs['attributeMapping'].split('.')) == 1:
        return DelegateDealPackage(*args, **kwargs)
    else:
        return DelegateAttribute(*args, **kwargs)
    
class ValidationExceptionAccumulator(object):
    def __init__(self):
        self._errors = []
    def __call__(self, error):
        self.ValidationError(error)
    def ValidationError(self, error):
        self._errors.append(error)
    def ValidationResult(self):
        return self._errors if len(self._errors) > 0 else True

class MuteParentDealPackageDelegateUpdates(object):
    def __init__(self, dealPackageBase):
        self._dealPackageBase = dealPackageBase
        self._prev = self._dealPackageBase._muteParentNotifications
    def __enter__(self):
        self._dealPackageBase._muteParentNotifications = True
    def __exit__(self, type, value, traceback):
        self._dealPackageBase._muteParentNotifications = self._prev

class MuteParentDealPackageDelegateUpdatesOnCopyAndOpen(object):
    def __init__(self, dealPackageBase):
        self._dealPackageBase = dealPackageBase
        self._prev = self._dealPackageBase._muteParentNotificationsOnCopyAndOpen
    def __enter__(self):
        self._dealPackageBase._muteParentNotificationsOnCopyAndOpen = True
    def __exit__(self, type, value, traceback):
        self._dealPackageBase._muteParentNotificationsOnCopyAndOpen = self._prev

class MuteNotificationsWithSafeExit(object):
    def __init__(self, dealPackageBase):
        self._dealPackageBase = dealPackageBase
        self._prev = self._dealPackageBase._muteNotifications
    def __enter__(self):
        self._dealPackageBase._muteNotifications = True
    def __exit__(self, type, value, traceback):
        self._dealPackageBase._muteNotifications = self._prev
 
class RegisterAllObjMappingsOnNewWithSafeExit(object):
    def __init__(self, dealPackageBase, newFromInstrumentPackage):
        self._dealPackageBase = dealPackageBase
        self._newFromInstrumentPackage = newFromInstrumentPackage
        self._prev = self._dealPackageBase._registeringAllObjMappingsOnNew
    def __enter__(self):
        self._dealPackageBase._registeringAllObjMappingsOnNew = True
    def __exit__(self, type, value, traceback):
        if type: return False # re-raise exception
        
        self._dealPackageBase._registeringAllObjMappingsOnNew = self._prev
        self._dealPackageBase._RegisterAllCalculations()
        self._dealPackageBase._RegisterAllObjectMappingDefaultValues(self._newFromInstrumentPackage)
        self._dealPackageBase._RegisterAllCalcValSolverDefaultValues()
        self._dealPackageBase.DealPackage().Refresh()
   
class ApplyTraitChangeAndCallObjMappingSetMethodWithSafeExit(object):
    def __init__(self, dealPackageBase):
        self._dealPackageBase = dealPackageBase
        self._prev = self._dealPackageBase._applyTraitChangeAndCallObjMappingSetMethod
    def __enter__(self):
        self._dealPackageBase._applyTraitChangeAndCallObjMappingSetMethod = False
    def __exit__(self, type, value, traceback):
        self._dealPackageBase._applyTraitChangeAndCallObjMappingSetMethod = self._prev
        
class SetSolverParametersWithSafeExit(object):
    def __init__(self, dealPackageBase, topValue = None, parameter = None, value = None):
        self._dealPackageBase = dealPackageBase
        self._solverTopValue = dealPackageBase.solverTopValue
        self._solverParameter = dealPackageBase.solverParameter
        self._solverValue = dealPackageBase.solverValue
        self._topValue = topValue
        self._parameter = parameter
        self._value = value
    def __enter__(self):
        with MuteNotificationsWithSafeExit(self._dealPackageBase):
            if self._topValue:
                self._dealPackageBase.solverTopValue = self._topValue
            if self._parameter:
                self._dealPackageBase.solverParameter = self._parameter
            if self._value is not None:
                self._dealPackageBase.solverValue = self._value
    def __exit__(self, type, value, traceback):
        with MuteNotificationsWithSafeExit(self._dealPackageBase):
            self._dealPackageBase.solverTopValue = self._solverTopValue
            self._dealPackageBase.solverParameter = self._solverParameter
            self._dealPackageBase.solverValue = self._solverValue
     
class TraitBasedDealPackage(TraitBase):
    
    ONCHANGED_MODE = 1
    
    autoRefreshCalc =              Bool(   noDealPackageRefreshOnChange=True )
    refreshCalcCounter =           Int(    onChanged='@_OnRefreshCalcCounterChanged' ) # Apply refresh when changed
    
    def __init__(self, dealPackage):
        TraitBase.__init__(self)
        self._dealPackage = dealPackage
        self.on_obj_mapping_trait_change(self.__OnObjectMappingTraitChange)
        self.on_trait_change(self.__OnAnyTraitChange)
        self._validator = TraitDomainAndValueValidator(self)
        self._dealPackageCalculations = None
        self._calculationsRegistered = False
        self._isSolverDealPackage = False
        self._privateCalculations = False
        self._muteParentNotifications = False
        self._muteParentNotificationsOnCopyAndOpen = False
        self._compositeAttributes = OrderedDict()
        self._uniqueCompositeAttributes = None
        self._updatedTraits = {}
        self.OnInit()
        
    def OnInit(self):
        pass 
        
    def __Validator(self):
        return self._validator
    
    def DealPackage(self):
        return self._dealPackage
        
    def InstrumentPackage(self):
        return self.DealPackage().InstrumentPackage()
    
    def HandleNoDefaultValue(self, attrName):
        if self._GetObjMapping(attrName):
            methodChains = self._GetObjMapping(attrName)
            self._UpdateTraitValuesCache(attrName, methodChains)
        
    '''******************************** 
    CALCULATION SPACE
    ********************************''' 
    def _GetCalcSpace(self, sheetType = "FDealSheet"):
        return self._dealPackageCalculations.CalcSpace(sheetType)
                
    def _GetStdCalcSpace(self):
        return acm.FCalculationMethods().CreateStandardCalculationsSpaceCollection()
 
    
    '''******************************** 
    METHODS TO EXTRACT DEAL PACKAGE PARTS
    ********************************''' 
    def __DealPackageInstrumentPartImpl(self, dealPackage, name):
        try:
            return dealPackage.InstrumentAt(name)
        except Exception as e:
            raise DealPackageException("Deal Package instrument part " + name + " missing")
            
    def InstrumentAt(self, name):
        return self.__DealPackageInstrumentPartImpl(self.DealPackage(), name)
            
    def __DealPackageTradePartImpl(self, dealPackage, name):
        try:
            return dealPackage.TradeAt(name)
        except Exception as e:
            raise DealPackageException("Deal Package trade part " + name + " missing")
            
    def TradeAt(self, name):
        return self.__DealPackageTradePartImpl(self.DealPackage(), name)
       
    def CombinationMapAt(self, name, combinationKey = None):
        try:
            return self.DealPackage().CombinationMapAt(name, combinationKey)
        except Exception as e:
            raise DealPackageException("Deal Package combination map part " + name + " missing")

    def B2BTradeParamsAt(self, name):
        try:
            b2bParams = self.DealPackage().B2BTradeParamsAt(name)
            b2bParams.Refresh()
            return b2bParams
        except Exception as e:
            raise DealPackageException("Deal Package B2B part " + name + " missing. " + str(e))
            
    def FxConstellationParamsAt(self, name):
        try:
            fxConstellationParams = self.DealPackage().FxConstellationParamsAt(name)
            return fxConstellationParams
        except Exception as e:
            raise DealPackageException("Deal Package FX constellation part " + name + " missing. " + str(e))
            
    def DeltaHedgeParamsAt(self, name):
        try:
            deltaHedgeParams = self.DealPackage().DeltaHedgeParamsAt(name)
            return deltaHedgeParams
        except Exception as e:
            raise DealPackageException("Deal Package Delta Hedge part " + name + " missing")
    
    def PremiumTranslationParamsAt(self, name):
        try:
            premiumTranslationParams = self.DealPackage().PremiumTranslationParamsAt(name)
            return premiumTranslationParams
        except Exception as e:
            raise DealPackageException("Deal Package Premium Translation part " + name + "missing ")
            
    def ChildDealPackageAt(self, name):
        try:
            return self.DealPackage().ChildDealPackageAt(name)
        except Exception as e:
            raise DealPackageException("Deal Package Child part " + name + " missing")

    def Trades(self):
        return self.DealPackage().Trades()
        
    def Instruments(self):
        return self.DealPackage().Instruments()
        
    def Confirmations(self):
        return self.DealPackage().Confirmations()    
        
    def Settlements(self):
        return self.DealPackage().Settlements()    
    
    def ChildDealPackages(self):
        return self.DealPackage().ChildDealPackages()
    
    def LifeCyclePackages(self):
        return self.DealPackage().LifeCyclePackages()
    
    def OpeningDealPackages(self):
        return self.DealPackage().OpeningDealPackages()
        
    def LiveTrades(self):
        return list(filter( self.DealPackage().IsLiveTrade, self.DealPackage().Trades() ))

    '''******************************** 
    TRAIT MAPPINGS (INTERNAL METHODS)
    ********************************'''   
    def __ApplyAttributeMappingChange(self, traitName, newValue):
        traitMethodChain = self._GetAttributeMapping(traitName)
        if traitMethodChain:
            for chain in traitMethodChain.split("|"):
                map = self._GetCallableTraitsFromChain(traitName, chain)
                for object, traitValue, _ in map:
                    if not self._TraitValuesAreEqual(newValue, traitValue):
                        mapTraitName = self.__GetTraitNameFromChain(chain)
                        object.SetAttribute(mapTraitName, newValue)
            if self.ONCHANGED_MODE == 2:
                self.__OnObjectMappingTraitChange(traitName, None, None, None)

    def __GetTraitNameFromChain(self, chain):
        return chain.split(".")[-1]
    
    @ThrowOrAccumulate(None, Exception)
    def _GetAttrValueFromChain(self, traitName, traitMethodChain):
        val = None
        for chain in traitMethodChain.split("|"):
            map = self._GetCallableTraitsFromChain(traitName, chain)
            for object, traitValue, _ in map:
                if not val:
                    val = traitValue
                if not self._TraitValuesAreEqual(val, traitValue):
                    if self.GetAttributeMetaData(traitName, 'validateMapping')():
                        error = "Value cannot be set, diverging values for, "
                        raise AttributeException(error + str(traitName))
                    else:
                        return None #Early exit on mismatch
        return val
        
    @ThrowOrAccumulate(None, Exception)
    def __GetAttrValueFromInstrumentPartOfChain(self, traitName):
        traitMethodChain = self._GetAttributeMapping(traitName)
        insPartOfChain = []
        for chain in traitMethodChain.split("|"):
            map = self._GetCallableTraitsFromChain(traitName, chain, 'objMapping')
            for object, traitValue, objMapping in map:
                objMapping = objMapping()
                if isinstance(objMapping, ObjMappingSplitter) and objMapping._GetInstrumentPart():
                    insPartOfChain.append(objMapping)
        return self._GetAttrValueFromChain('|'.join(insPartOfChain))
    
    def _IsDelegatable(self, traitName, traitMethodChain):
        isDelegatable = True
        if self._GetCalcMapping(traitName):
            count = 0
            for chain in traitMethodChain.split("|"):
                map = self._GetCallableTraitsFromChain(traitName, chain)
                count += len(map)
                if count > 1:
                    return False
            isDelegatable = count == 1
            if isDelegatable:
                val = self._GetAttrValueFromChain(traitName, traitMethodChain)
                if val == None:
                    isDelegatable = False
        return isDelegatable
        
    def _DelegateAttributeMappingDefaultValuesToParent(self):
        with ApplyTraitChangeAndCallObjMappingSetMethodWithSafeExit(self):
            for traitName in self._GetTraitNames():
                traitMethodChain = self._GetAttributeMapping(traitName)
                if traitMethodChain:
                    if self._IsDelegatable(traitName, traitMethodChain):
                        self._GetTrait(traitName).set_dirty(self)
                        
    def _DelegateAttributeMappingValuesToChildren(self):
        with MuteParentDealPackageDelegateUpdates(self):
            for traitName in self._GetTraitNames():
                traitMethodChain = self._GetAttributeMapping(traitName)
                if traitMethodChain:
                    if not self._GetCalcMapping(traitName):
                        self.__ApplyAttributeMappingChange(traitName, self.get_trait_value(traitName))
                    
    def __RegisterAllAttributeMappings(self):
        self._DelegateAttributeMappingDefaultValuesToParent()
              
    '''******************************** 
    OBJECT MAPPINGS (INTERNAL METHODS)
    ********************************'''            
    def _ApplyValueToTrait(self, traitName, value, silent=False):
        if value != "NoVal":
            self.SetAttribute(traitName, value, silent)
    
    def _ParseValueToCorrectDomainValue(self, traitName, domain, newValue):
        return self.__Validator().GetValueFromParseDomainValue(traitName, domain, newValue)

    def _GetObjectMappingValueAndValidateEqual(self, traitName, methodChains):
        objectValue = "NoVal"
        validationVal = "NoVal"
        for chain in methodChains.split("|"):
            objAndMethods = self.GetCallableMethodsFromChain(chain, traitName)
            for callObject, callableMethod in objAndMethods:
                objectValue = callableMethod()
                domain = self.__Validator().TraitBasedDealPackage()._GetDomain(traitName)
                if domain.IsKindOf(acm.FTimeDomain) and objectValue is not None:
                    objectValue = acm.Time().DateTimeFromTime(objectValue)
                try:
                    validationVal = self.__Validator().ValidateGetTraitValue(traitName, chain, callableMethod, objectValue, validationVal)
                except AttributeException:
                    validateMapping = not self._registeringAllObjMappingsOnNew
                    if validateMapping:
                        if self.GetAttributeMetaData(traitName, 'validateMapping')():
                            raise
                        else:
                            return None #Early exit on mismatch
                    else:
                        return "NoVal"
        return objectValue
    
    @ThrowOrAccumulate(True, AttributeException)
    def _UpdateTraitValuesCache(self, traitName, methodChains):
        self._GetTrait(traitName).dirty = False
        objectValue = self._GetObjectMappingValueAndValidateEqual(traitName, methodChains)
        if objectValue != "NoVal":
            self._trait_values[traitName] = objectValue
        return objectValue
 
    @ThrowOrAccumulate(["NoVal", None], AttributeException)
    def __UpdateTraitValueFromObjMappingIfValueHasChanged(self, traitName, methodChains):
        currentVal = self.get_trait_value(traitName)
        updatedVal = self._UpdateTraitValuesCache(traitName, methodChains)
        if not self._TraitValuesAreEqual(updatedVal, currentVal):
            newVal = updatedVal
        else:
            newVal = "NoVal" # No new value, value has not changed.
        return newVal, currentVal
        
    def __HasImplicitOnChanged(self, traitName):
        return self.HasOnChanged(traitName) and self.GetAttributeMetaData(traitName, 'onChangedIsImplicit')()
        
    def __IsTraitNameWithOnChanged(self, traitName):
        result = False
        methodChains = self._GetObjMapping(traitName)
        if methodChains and (self.ONCHANGED_MODE == 2 or self.__HasImplicitOnChanged(traitName)):
            result = True
        return result
    
    def __GetTraitNamesWithOnChanged(self, userInputTraitName):
        traits = []
        if self.ONCHANGED_MODE < 2:
            for traitName in self._GetTraitNames():
                if self.__IsTraitNameWithOnChanged(traitName):
                    traits.append(traitName)
        return traits
        
    def __UpdateTraitValuesForTraitsWithOnChanged(self, userInputTraitName):
        traitNamesWithOnChanged = self.__GetTraitNamesWithOnChanged(userInputTraitName)
        for traitName in traitNamesWithOnChanged:
            self._GetTrait(traitName).get_value(self)
                
    def __SetDirtyAndFindAllOtherTraitsAffectedByTheTraitChange(self, userInputTraitName):
        traitsAffectedByChange = {}
        recreateCalcSpaceOnChangeIsCalled = (not self._calculationsRegistered) or userInputTraitName and self._GetRecreateCalcSpaceOnChange(userInputTraitName)
        for traitName in self._GetTraitNames():
            if traitName != userInputTraitName:
                methodChains = self._GetObjMapping(traitName)
                if methodChains:
                    if self.__IsTraitNameWithOnChanged(traitName) or (not recreateCalcSpaceOnChangeIsCalled and self._GetRecreateCalcSpaceOnChange(traitName) and self.GetAttributeMetaData(traitName, 'onChangedIsImplicit')()):
                        newTraitValue, oldTraitValue = self.__UpdateTraitValueFromObjMappingIfValueHasChanged(traitName, methodChains)
                        if newTraitValue != "NoVal":
                            traitsAffectedByChange[traitName] = (newTraitValue, oldTraitValue)
                    else:
                        self._GetTrait(traitName).set_dirty(self)
                elif self._IsGrid(traitName):
                    self._GetTrait(traitName).set_dirty(self)
        return traitsAffectedByChange
    
    def _ApplyLatestValueFromObjMapping(self, traitName):
        methodChains = self._GetObjMapping(traitName)
        if methodChains:
            self._UpdateTraitValuesCache(traitName, methodChains)
            
    def _ApplyLatestValueFromAttributeMapping(self, traitName):
        traitMethodChain = self._GetAttributeMapping(traitName)
        if traitMethodChain:
            if self._IsDelegatable(traitName, traitMethodChain):
                val = self._GetAttrValueFromChain(traitName, traitMethodChain)
                #Throw if attributes differ
                self._GetTrait(traitName).AttributeExceptionAccumulator().Raise()
                self._trait_values[traitName] = val
                return True
        return False
                
    def _UpdateAndRegisterAllObjectMappings(self, userInputTraitName):
        """
        if self.ONCHANGED_MODE == 0:
            for traitName in self._GetTraitNames():
                methodChains = self._GetObjMapping(traitName)
                if methodChains or self._IsGrid(traitName):
                    self._GetTrait(traitName).set_dirty(self)
        else:
        """
        with ApplyTraitChangeAndCallObjMappingSetMethodWithSafeExit(self):
            self._updatedTraits = self.__SetDirtyAndFindAllOtherTraitsAffectedByTheTraitChange(userInputTraitName)
            
            with MuteNotificationsWithSafeExit(self):
                for traitName in self._updatedTraits:
                    self._ApplyValueToTrait(traitName, self._updatedTraits.get(traitName)[0])
        self.__SendNotifications(userInputTraitName, self._updatedTraits)
        """
        if not self._isSolverDealPackage:
            with ApplyTraitChangeAndCallObjMappingSetMethodWithSafeExit(self):
                self._updatedTraits = self.__SetDirtyAndFindAllOtherTraitsAffectedByTheTraitChange(userInputTraitName)
                with MuteNotificationsWithSafeExit(self):
                    for traitName in self._updatedTraits:
                        self._ApplyValueToTrait(traitName, self._updatedTraits.get(traitName)[0])
            self.__SendNotifications(userInputTraitName, self._updatedTraits)
        """
    def _ValidateTraits(self, accumulator):
        for traitName in self._GetTraitNames():
            trait = self._GetTrait(traitName)
            trait.TraitIsValid(self, accumulator)
            
    def _RegisterAllObjectMappings(self):
        for traitName in self._GetTraitNames():
            methodChains = self._GetObjMapping(traitName)
            if methodChains:
                self._GetTrait(traitName).set_dirty(self)
                        
    def _ValidateAndSetTraitValueToObjMapping(self, traitName, callableMethod, callObject, newValue, doReturnVal):
        objectValue = None
        if self.__Validator().ValidateNewValueInDomainOfCallableMethod(traitName, callObject, newValue):
            try:
                # Todo handle, diverging results 
                callableMethod(newValue)
            except Exception as e:
                raise DealPackageException("'%s' not a valid value for attribute '%s'. %s" % (str(newValue), traitName, str(e)))
        
        if doReturnVal:
            objectValue = callableMethod()
            domain = self.__Validator().TraitBasedDealPackage()._GetDomain(traitName)
            if domain.IsKindOf(acm.FTimeDomain) and objectValue is not None:
                objectValue = acm.Time().DateTimeFromTime(objectValue)
    
        return objectValue
        
    def _AssignValueToObjMappingMethodChain(self, traitName, methodChains, newValue, doReturnVal = True):
        val = "NoVal"
        for chain in methodChains.split("|"):
            methods = self.GetCallableMethodsFromChain(chain, traitName)
            for callObject, callableMethod in methods:
                val = self._ValidateAndSetTraitValueToObjMapping(traitName, callableMethod, callObject, newValue, doReturnVal)
        return val
        
    def __ApplyTraitValueToObjMapping(self, traitName, newValue):
        methodChains = self._GetObjMapping(traitName)
        if methodChains:
            self._AssignValueToObjMappingMethodChain(traitName, methodChains, newValue, False)

    def __GetDefaultValue(self, trait):
        defaultValue = trait.get_default_value(self)
        defaultValue = trait.transform(self, defaultValue)
        return defaultValue

    def _RegisterObjectMappingDefaultValues(self, traits, newFromInstrumentPackage):
        for trait in traits:
            if trait.has_explicit_default_value():
                try:
                    defaultValue = self.__GetDefaultValue(trait)
                    if self._GetObjMapping(trait.get_name()):
                        self.__SetDefaultOnObjMapping(trait.get_name(), defaultValue, newFromInstrumentPackage)
                        self._GetTrait(trait.get_name()).set_dirty(self)
                    else:
                        if newFromInstrumentPackage and self._GetAttributeMapping(trait.get_name()):
                            insAttrMappingValue = self.__GetAttrValueFromInstrumentPartOfChain(trait.get_name())
                            if insAttrMappingValue != "NoVal":
                                defaultValue = insAttrMappingValue
                        setattr(self, trait.get_name(), defaultValue)
                except Exception as e:
                    msg = "Default value for attribute '%s': '%s'" % (trait.get_name(), e)
                    if self._registeringAllObjMappingsOnNew:
                        self.Log().Verbose(msg)
                    else:
                        self.Log().Error(msg)

    def __SetDefaultOnObjMapping(self, traitName, defaultValue, newFromInstrumentPackage):
        objMapping = self._GetObjMapping(traitName)
        insStringPart = objMapping._GetInstrumentPart() if isinstance(objMapping, ObjMappingSplitter) else None
        if newFromInstrumentPackage and insStringPart:
            val = self._GetObjectMappingValueAndValidateEqual(traitName, insStringPart)
            if objMapping._GetDealPart():
                self._AssignValueToObjMappingMethodChain(traitName, objMapping._GetDealPart(), val, False)
        else:
            if self.__Validator().ValidateNewValueInDomainOfCallableMethod(traitName, self.DealPackage(), defaultValue):
                self.__ApplyTraitValueToObjMapping(traitName, defaultValue)

    def _RegisterDefaultValuesInOtherDomains(self, attributes, newFromInstrumentPackage):
        domains = [acm.GetDomain('date'), acm.GetDomain('datetime'), acm.GetDomain('double')]
        traits = self._GetAttributesExcludeDomains(attributes, domains)
        self._RegisterObjectMappingDefaultValues(traits, newFromInstrumentPackage)
        
    def _RegisterDefaultValuesInDateDomains(self, attributes, newFromInstrumentPackage):
        domains = [acm.GetDomain('date'), acm.GetDomain('datetime')]
        traits = self._GetAttributesInDomains(attributes, domains)
        self._RegisterObjectMappingDefaultValues(traits, newFromInstrumentPackage)

    def _RegisterDefaultValuesInDoubleDomain(self, attributes, newFromInstrumentPackage):
        domains = [acm.GetDomain('double')]
        traits = self._GetAttributesInDomains(attributes, domains)
        self._RegisterObjectMappingDefaultValues(traits, newFromInstrumentPackage)
       
    def _RegisterAllCalcValSolverDefaultValues(self):
        domains = [acm.GetDomain(acm.FCalculation)]
        allAttributes = self._GetTraitWithDefaultValueSeqNbrOrdered()
        for trait in self._GetAttributesInDomains(allAttributes, domains):
            if self._GetSolverTopValue(trait.get_name()):
                try:
                    setattr(self, trait.get_name(), trait.get_default_value(self))
                except Exception as e:
                    self.Log().Verbose(e)
                    
    def _RegisterAllObjectMappingDefaultValues(self, newFromInstrumentPackage):
        attributes = self._GetTraitWithDefaultValueSeqNbrOrdered()
        self._RegisterDefaultValues( attributes, newFromInstrumentPackage )
    
    def _RegisterDefaultValues(self, attributes, newFromInstrumentPackage=False):
        #Default Values should be applied to Traits in order:
        #  - Starting with all domains where order is not important
        #  - Date domains default values should be applied after that (to make sure calendars etc are set before)
        #  - At last doubles should be set, these might be dependent on dates (e.g. par rate calculations)
        self._RegisterDefaultValuesInOtherDomains( attributes, newFromInstrumentPackage )
        self._RegisterDefaultValuesInDateDomains( attributes, newFromInstrumentPackage )
        self._RegisterDefaultValuesInDoubleDomain( attributes, newFromInstrumentPackage )
        
    def RestoreDefaultValues(self, *attributeNames):
        attributes = []
        for attr in self._GetTraitWithDefaultValueSeqNbrOrdered():
            if attr.get_name() in attributeNames:
                attributes.append(attr)
        
        self._RegisterDefaultValues( attributes )

    def RegisterCallbackOnAttributeChanged(self, callback, attributes = None, last = False):
        if last:
            self.on_post_trait_change(callback, attributes)
        else:
            self.on_trait_change(callback, attributes)
    
    '''******************************** 
    CALCULATION MAPPINGS (EXTERNAL METHODS)
    ********************************'''
    
    def CreateCalculation(self, name, calcInfo, configurationCb = None):
        if name in self.GetAttributes():
            raise DealPackageException("CreateCalculation - The name '%s' is an attribute on the deal package" % name)
        self.__CreateCalculation(name, calcInfo, configurationCb)
    
    def RemoveCalculation(self, name):
        if name in self.GetAttributes():
            raise DealPackageException("RemoveCalculation - The name '%s' is an attribute on the deal package" % name)
        self._dealPackageCalculations.RemoveCalculation(name)
        
    def SimulateCalculation(self, name, newValue):
        self._dealPackageCalculations.SimulateValue(name, newValue)
        
    def IsCalculationSimulated(self, name):
        return self._dealPackageCalculations.IsSimulated(name)
    
    def GetSimulatedCalculationValue(self, name):
        return self._dealPackageCalculations.SimulatedValue(name)
        
    def GetCalculation(self, name):
        return self._dealPackageCalculations.Value(name)
        
    def RemoveAllSimulations(self):
        self._dealPackageCalculations.RemoveAllSimulations()

    '''******************************** 
    CALCULATION MAPPINGS (INTERNAL METHODS)
    ********************************'''
    
    def _OnRefreshCalcCounterChanged(self, attrRefreshCalc, oldValue, newValue,*args):
        self._RegisterAllCalculations()
        self._RefreshAllCalculations()
        setattr(self, attrRefreshCalc, newValue)
        
    def _GetCalcSpecFromTraitInfo(self, calcInfo):
        calcSpace = None
        columnIdCb = None
        calcObjName, sheetType, columnId = calcInfo.split(":")
        if calcObjName:
            calcObjCb = getattr(self, calcObjName)
        if columnId:
            if IsCallable(self, columnId):
                columnIdCb = getattr(self, columnId)
                columnId = None
        return calcObjCb, columnId, columnIdCb, sheetType   
    
    def __CreateCalculation(self, name, calcInfo, configurationCb):
        calcObjCb, columnId, columnIdCb, sheetType = self._GetCalcSpecFromTraitInfo(calcInfo)
        self._dealPackageCalculations.CreateCalculation(name, calcObjCb, sheetType, columnId, columnIdCb, configurationCb)
    
    def __CreateTraitCalculation(self, traitName, calcInfo):
        trait = self._GetTrait(traitName)
        if not trait.__class__ == CalcVal:
            raise DealPackageException("When using calcMapping, the attribute class should be CalcVal")
        configurationCb = self._GetAttributeMetaDataCallback(traitName, "calcConfiguration")
        self.__CreateCalculation(traitName, calcInfo, configurationCb)
        
    def __InitCalculations(self):
        for traitName in self._GetTraitNames():
            trait = self._GetTrait(traitName)
            if trait.__class__ == CalcVal:
                calcInfo = self.GetAttributeMetaData(traitName, 'calcMapping')()
                if calcInfo and not self.GetAttributeMetaData(traitName, 'attributeMapping')():
                    self.__CreateTraitCalculation(traitName, calcInfo)
                
    def __SetCalculations(self):
        for traitName in self._dealPackageCalculations.CalculationKeys():
            if traitName in self._GetTraitNames():
                value = self._dealPackageCalculations.Value(traitName)
                trait = self._GetTrait(traitName)
                trait.SetCalculation(self, value)

    def _RegisterAllCalculations(self):
        if not self._calculationsRegistered:
            with MuteNotificationsWithSafeExit(self):
                if self._dealPackageCalculations:
                    self._dealPackageCalculations.Tag(self._privateCalculations)
                    for calc in self._dealPackageCalculations.CalculationKeys():
                        self._dealPackageCalculations.RemoveCalculation(calc)
                    if not self.DealPackage().ParentDealPackage():
                        self._dealPackageCalculations.Clear()
                    self.__InitCalculations()
                    self._dealPackageCalculations.RecreateCalculations()
                    self._dealPackageCalculations.Calc().ReapplySimulations()
                    self.__SetCalculations()
                else:
                    self._dealPackageCalculations = DealPackageCalculations(self, tag = self._privateCalculations)
                    self.__InitCalculations()
                    self.__SetCalculations()
                self._calculationsRegistered = True
        
    def _RefreshAllCalculations(self):
        refreshNeeded = False
        if self._dealPackageCalculations:
            refreshNeeded = self._dealPackageCalculations.IsInvalidated()
            self._dealPackageCalculations.IsInvalidated(False)
        return refreshNeeded

    '''******************************** 
    COMPOSITE ATTRIBUTES (INTERNAL METHODS)
    ********************************'''
    
    def _CompositeAttributes(self):
        return self._compositeAttributes
    
    def __RegisterCompositeAttributes(self, overrideAccumulator, clsDict = None):
        
        def CreateClassDictImpl(baseClasses, clsDict, classList):
            for cl in baseClasses:
                if cl not in classList:
                    CreateClassDictImpl(cl.__bases__, clsDict, classList)
            for cl in baseClasses:
                if cl not in classList:
                    clsDict.update(cl.__dict__)
                    classList.append(cl)
            
        def CreateClassDict(obj):
            classList = []
            clsDict = OrderedDict()
            CreateClassDictImpl([obj.__class__], clsDict, classList)
            return clsDict
        
        def GetOverrides(attrDict):
            for attrName, attr in attrDict.items():
                if isinstance(attr, CompositeAttributeBase):
                    overrideAccumulator.get_overrides_from(attr, attr.get_name())
            
        clsDict = CreateClassDict(self)
        instanceCompositeDict = self.__CreateCompositeAttributeInstances(clsDict)
        self._compositeAttributes.update(instanceCompositeDict)
        for attrName, attr in instanceCompositeDict.items():
            setattr(self, attrName, attr)
            clsDict = attr.GetClassDict()                
            self.__AddAttributesToSelf(clsDict) 
        GetOverrides(self._compositeAttributes)

        # Need to recreate the cached name key
        self._sortedTraitNames = None

    def __CreateCompositeAttributeInstances(self, classAttributeDict):
        instanceCompositeDict = OrderedDict()
        for attrName, attr in classAttributeDict.items():
            if isinstance(attr, CompositeAttributeBase):
                attr = attr.__class__(*attr._PrivateArgs(), **attr._PrivateKwargs())
                instanceCompositeDict[attrName] = attr
                attr.set_name(attrName)
                attr.SetOwner(self)
        return instanceCompositeDict
    
    def __AddAttributesToSelf(self, clsDict):
        for k in clsDict:
            v = clsDict[k]
            if isinstance(v, TraitType):
                setattr(v, 'this_class', self.__class__)
                v.instance_init(self)
                self.UpdateInstanceTraits(k, v)
            if isinstance(v, CompositeAttributeBase):
                self._compositeAttributes[k] = v
            setattr(self, k, v)
    
    def _RegisterOnChangeCallbacks(self):
        traits = self.traits()
        for traitName in traits:
            if self.trait_metadata(traitName, 'onChanged'):
                callback = self._GetOnChanged(traitName)
                if not callback.IsDefault():
                    self.on_trait_change(callback, traitName)
    
    '''******************************** 
    INTERFACE METHODS
    ********************************'''
    def _RefreshCalculations(self):
        refreshNeeded = False
        try:
            if self.get_trait_value("autoRefreshCalc"):
                self._RegisterAllCalculations()
                refreshNeeded = self._RefreshAllCalculations()
        except:
            pass
        return refreshNeeded
        
    def _UpdateDelegations(self, *args):
        for attrName in self.metaData:
            if not self.GetAttributeMetaData(attrName, 'attributeMapping').IsDefault():
                self.metaData[attrName] = {}
    
    def _RebuildCalculations(self):
        self._calculationsRegistered = False
        
    def _ShareCalculations(self):
        self._privateCalculations = False

    def _RebuildCalculationsNeeded(self):
        return not self._calculationsRegistered

    def _RebuildCalculationsIfNeeded(self, traitName, oldValue, newValue):
        recreateCalcSpaceOnChange = self._GetRecreateCalcSpaceOnChange(traitName)
        if (oldValue != newValue and recreateCalcSpaceOnChange) or (self._dealPackageCalculations and self._dealPackageCalculations.AnyCalcObjectReplaced()):
            self._calculationsRegistered = False
            if not self.get_trait_value("autoRefreshCalc") and traitName not in ['refreshCalcCounter']:
                current = self.get_trait_value("refreshCalcCounter")
                setattr(self, "refreshCalcCounter", current + 1)
        
    def _MinorChange(self, traitName):
        return self._GetNoDealPackageRefreshOnChange(traitName)
    
    def __SetGraphCoordinatesNeedsRefresh(self, traitName, oldValue, newValue):
        refreshNeeded = False
        if not self._MinorChange(traitName):
            if newValue != oldValue and self.get_trait_value('autoRefreshCalc'):
                refreshNeeded = True
        return refreshNeeded
        
    def __SetRefreshGraph(self, traitName, oldValue, newValue):
        if self.__SetGraphCoordinatesNeedsRefresh(traitName, oldValue, newValue):
            self._RecalcGraphCoordinates()
    
    def _RepopulateSheet(self):
        self.SetAttribute("sheetNeedsRefresh", True)
    
    def _RecalcGraphCoordinates(self):
        self.SetAttribute("graphCoordinatesNeedsRefresh", True)
    
    def __CopyTransientValues(self, attributesToCopy):
        if attributesToCopy:
            for name in attributesToCopy:
                if name not in ['solverValue', 'solverParameter', 'solverTopValue']: # Should not be here. See SPR 391246
                    value = attributesToCopy[name]
                    self.SetAttribute(name, value, silent=True)
    
    def __HandleOverrides(self, overrideAccumulator):
        overrides = overrideAccumulator.processed_overrides()
        for attrName, metadata in overrides.items():
            attrName = self.__GetActualTraitName(attrName)
            # Make copy of attribute and put on class
            attr = copy.copy(self.traits().get(attrName, None))
            if attr is None:
                if acm.LogStatus('deal package - debug'):
                    acm.Log('Deal Package Debug: Failed to override metadata. No attribute named %s.' % attrName)
            else:
                # Init attribute
                setattr(attr, 'this_class', self.__class__)
                attr.instance_init(self)
                self.UpdateInstanceTraits(attrName, attr)
                # Set attribute on self
                setattr(self, attrName, attr)
                for mdkey, toMergeList in metadata.items():
                    current = attr.get_metadata(mdkey)
                    for toMerge in toMergeList:
                        attr.append_metadata(self, mdkey, MergeMetaData(mdkey, current, toMerge))
                        current = attr.get_metadata(mdkey)
                    self.metaData.setdefault(attrName, {})[mdkey] = None
    
    def _PrivateOnNew(self, newFromInstrumentPackage = False, optArg = NOT_IMPLEMENTED):
        with RegisterAllObjMappingsOnNewWithSafeExit(self, newFromInstrumentPackage):
            if not newFromInstrumentPackage:
                if isinstance(optArg, NotImplemented) or optArg == None:
                    self.AssemblePackage()
                else:
                    self.AssemblePackage(optArg)
            oa = AttributeOverrideAccumulator(self)
            self.__RegisterCompositeAttributes(oa)
            self.__HandleOverrides(oa)
            self._RegisterOnChangeCallbacks()
            self._RegisterAllObjectMappingDefaultValues(newFromInstrumentPackage)
            self.DealPackage().Refresh()
            self._RecalcGraphCoordinates()
        self._CallOnComposites('OnNew')
        self.OnNew()
    
    def _PrivateRefresh(self):
        self.Refresh()
        self._CallOnComposites('Refresh')
    
    def _DoOpen(self):
        with MuteNotificationsWithSafeExit(self):
            oa = AttributeOverrideAccumulator(self)
            self.__RegisterCompositeAttributes(oa)
            self.__HandleOverrides(oa)
            self._RegisterOnChangeCallbacks()
            self.__RegisterAllAttributeMappings()
            self._RegisterAllCalculations()
            self._RecalcGraphCoordinates()
    
    def _CallOnComposites(self, methodName, *args, **kwargs):
        for compName in self._CompositeAttributes():
            if hasattr(self, compName):
                comp = getattr(self, compName)
                getattr(comp, methodName)(*args, **kwargs)
    
    def _PrivateOnOpen(self):
        with MuteParentDealPackageDelegateUpdatesOnCopyAndOpen(self):
            self._DoOpen()
            self._CallOnComposites('OnOpen')
            self.OnOpen()
    
    def _PrivateOnSave(self, config):
        toReturn = None
        try:
            self._SetDealPackageSaveConfiguration(config)
            toReturn = self.OnSave(config)
        except:
            self._SetDealPackageSaveConfiguration(None)
            raise
            
        self._SetDealPackageSaveConfiguration(None)
        if hasattr(self, 'SwapInstrument'):
            swap = self.SwapInstrument()
            for a in swap.Difference(swap.OriginalOrSelf(), True):
                print(1321323, a)
        return toReturn
    
    def _PrivateSaveQuestions(self, config):
        toReturn = []
        saveQuestions = self.SaveQuestions(config)
        if saveQuestions and hasattr(saveQuestions, "__len__"):
            for saveQuestion in saveQuestions:
                toReturn.append(saveQuestion)
        return toReturn
        
    def _PrivateDeleteQuestions(self):
        toReturn = []
        deleteQuestions = self.DeleteQuestions()
        if deleteQuestions and hasattr(deleteQuestions, "__len__"):
            for deleteQuestion in deleteQuestions:
                toReturn.append(deleteQuestion)
        return toReturn
    
    def _PrivateOnCopy(self, originalDealPackage, anAspectSymbol, calcDict):
        with MuteParentDealPackageDelegateUpdatesOnCopyAndOpen(self):
            self._privateCalculations = True
            self._DoOpen()
            self._isSolverDealPackage = str(anAspectSymbol) == 'solving'
            self.__CopyTransientValues(calcDict['attributesToCopy'])
            self._AppendDealPackageCalculations(calcDict['dealPackageCalculations'])
            self.OnCopy(originalDealPackage, anAspectSymbol)
    
    def _PrivateIsValid(self, aspect):
        isValid = True
        try:
            accumulator = ValidationExceptionAccumulator()
            self.IsValid(accumulator, aspect)
            self._ValidateTraits(accumulator)
            self.__ValidateCompositeAttributes(accumulator, aspect)
            isValid = accumulator.ValidationResult()
        except Exception as e:
            isValid = [FormatException(e)]
        self.Log().Verbose('IsValid: %s' % isValid)
        return isValid
    
    def __ValidateCompositeAttributes(self, exceptionAccumulator, aspect):
        for member in inspect.getmembers(self):
            if issubclass(member[1].__class__, CompositeAttributeBase):
                getattr(self, member[0]).IsValid(exceptionAccumulator, aspect)
        
    def _PrivateDismantle(self):
        if self._dealPackageCalculations:
            self._dealPackageCalculations.TearDown()
        self._CallOnComposites('_PrivateDismantle')
        self.OnDismantle()
        self._compositeAttributes.clear()
        self._dealPackage = None
        self._validator._traitBasedDealPackage = None
        self._validator = None
    
    def _PrivateSetDealPackage(self, dealPackage):
        if dealPackage:
            self._dealPackage = dealPackage
        
    @classmethod
    def _PrivateSetUp(cls, definitionName, gui):
        from DealPackageSetUp import DealPackageSetUp
        definitionSetUp = DealPackageSetUp(definitionName, gui)
        try:
            cls.SetUp( definitionSetUp )
            # Compsite attributes SetUp-methods
            for member in inspect.getmembers(cls):
                if issubclass(member[1].__class__, CompositeAttributeBase):
                    getattr(cls, member[0]).SetUp(definitionSetUp)
            definitionSetUp.SetUp()
        except Exception as e:
            msg = 'Deal Package can not be instantiated: %s' % FormatException(e)
            raise DealPackageException( msg )
            
    def __SetDealPackageRefreshNeeded(self, traitName, oldValue, newValue):
        if not self._MinorChange(traitName):
            self.DealPackage().RefreshNeeded(True)

    def __IsTraitChanging(self, traitName, userInputTraitName):
        return (not userInputTraitName) or (self._traitsChanging and traitName in self._traitsChanging)
            
    def __OnObjectMappingTraitChange(self, traitName, oldValue, newValue, userInputTraitName):
        if self.__IsTraitChanging(traitName, userInputTraitName):
            if self._applyTraitChangeAndCallObjMappingSetMethod:
                if not self._registeringAllObjMappingsOnNew:
                    if not self._IsCalcVal(traitName):
                        self._UpdateAndRegisterAllObjectMappings(traitName)
                        if self.ONCHANGED_MODE > 0:
                            i = 0
                            while len(self._updatedTraits) and i < 5:
                                self._UpdateAndRegisterAllObjectMappings(traitName)
                                i += 1
        
    def __UpdateDelegateTraitOnParentDealPackage(self, traitName, oldValue, newValue, userInputTraitName):
        if (not self._muteParentNotificationsOnCopyAndOpen):
            parent = self.DealPackage().ParentDealPackage() if hasattr(self.DealPackage(), 'ParentDealPackage') else None
            if  parent and (parent.IsStorageImage() or parent.IsInfant()) and self.__IsTraitChanging(traitName, userInputTraitName):
                parent.GetAttribute('updateParentDelegateTraits')()
    
    def __OnAnyTraitChange(self, traitName, oldValue, newValue, userInputTraitName):
        with MuteParentDealPackageDelegateUpdates(self):
            self.__ApplyAttributeMappingChange(traitName, newValue)
            self._RebuildCalculationsIfNeeded(traitName, oldValue, newValue)
            self.__RegisterAllAttributeMappings()
            self.__SetRefreshGraph(traitName, oldValue, newValue)
            self.__SetDealPackageRefreshNeeded(traitName, oldValue, newValue)
            self.__UpdateDelegateTraitOnParentDealPackage(traitName, oldValue, newValue, userInputTraitName)
        
    def _ApplyCalcMappingSimulation(self, traitName, newValue):
        if not self._calculationsRegistered: 
            self._RegisterAllCalculations()   

        if self._GetSolverTopValue(traitName):
            self._SolveForTrait(traitName, newValue)
        else:
            transformCb = self._GetTransform(traitName)
            isSimulated = self._dealPackageCalculations.IsSimulated(traitName)
            oldValue = self.get_trait_value(traitName).Value()
            newValue = transformCb(newValue)
            self.SimulateCalculation(traitName, newValue)
            if isSimulated != self._dealPackageCalculations.IsSimulated(traitName) or oldValue != self.get_trait_value(traitName).Value():
                self.__SendNotification(traitName, oldValue, self.get_trait_value(traitName).Value())
        self._RecalcGraphCoordinates()
    
    def _GetAttributesToCopy(self):
        allAttributeNames = self.trait_names() # including private attributes
        attributesToCopy = {}
        for name in allAttributeNames:
            attr = self._GetTrait(name)
            if attr.__class__ in (Action, Box, CalcVal, DelegateAttribute, Label, Link):
                continue
            elif self._GetObjMapping(name) != None and name != 'uxCallbacks':
                continue
            attributesToCopy[name] = self.GetAttribute(name)
        return attributesToCopy
        
    def _GetSimulations(self):
        simulations = None
        if self._dealPackageCalculations:
            simulations = self._dealPackageCalculations.GetSimulations()
        return simulations
    
    def _SetSimulations(self, simulations):
        # BOE TODO: obsolete
        raise RuntimeError('_SetSimulations is not implemented')
    
    def _GetCalculations(self):
        # BOE TODO: obsolete
        raise RuntimeError('_SetCalculations is not implemented')
        
    def _SetCalculations(self, calculations):
        # BOE TODO: obsolete
        raise RuntimeError('_SetCalculations is not implemented')
            
    def _AppendDealPackageCalculations(self, other):
        if self._dealPackageCalculations and other:
            self._dealPackageCalculations.Append(other)
            
    def _GetDealPackageCalculations(self):
        return self._dealPackageCalculations
    
    def _SetDealPackageSaveConfiguration(self, config):
        self.m_dealPackageSaveConfiguration = config
        
    def force_apply_obj_mappings(self, traitName):
        return self._muteParentNotificationsOnCopyAndOpen or (traitName in ['solverParameter', 'solverValue', 'solverTopValue']) or self._GetSolverParameter(traitName) or self._GetSolverTopValue(traitName)
        
    '''******************************** 
    IMPLEMENTATION OF DEAL PACKAGE METHODS
       GetAttribute/SetAttribute/GetAttributes/GetAttributeMetaData
    ********************************'''
    def GetAttribute(self, traitName):
        self._GetTrait(traitName).AttributeExceptionAccumulator().Raise()
        attr =  getattr(self, traitName)
        self._GetTrait(traitName).AttributeExceptionAccumulator().Raise()
        return attr
        
    def SetAttribute(self, traitName, newValue, silent=False):
        if silent or self.GetAttributeMetaData(traitName, 'silent')():
            with MuteNotificationsWithSafeExit(self):
                setattr(self, traitName, newValue)
        else:
            if not self._registeringAllObjMappingsOnNew:
                oldValue =  getattr(self, traitName)
                if not self._TraitValuesAreEqual(newValue, oldValue):
                    self.__UpdateTraitValuesForTraitsWithOnChanged(traitName)
            setattr(self, traitName, newValue)
            
    def RefreshAttribute(self, traitName):
        self.DealPackage().RefreshAttribute(traitName)
    
    # DO NOT CALL FROM PY
    def __GetAttributeMetaDataImpl(self, traitName, metaKey=''):
        return self.GetAttributeMetaDataOrThrow(traitName, metaKey)
    
    # DO NOT CALL FROM PY
    def __GetAttributesImpl(self):
        return self.GetAttributesOrThrow()
    
    # DO NOT CALL FROM PY
    def __GetAttributeMetaDataImpl(self, traitName='', metaKey=''):
        if traitName == '' and metaKey == '':
            return self.GetAttributeMetaData
        else:
            return self.GetAttributeMetaDataOrThrow(traitName, metaKey)
            
    def __InitUniqueCompositeAttributes(self):
        if self._uniqueCompositeAttributes is None:
            self._uniqueCompositeAttributes = OrderedDict()
            for compositeAttribute in self._compositeAttributes:
                uniqueCompositeAttribute = None
                for attr in self.GetAttributes():
                    if compositeAttribute in attr:
                        if uniqueCompositeAttribute is None:
                            uniqueCompositeAttribute = attr
                        else:
                            uniqueCompositeAttribute = None
                            break
                if uniqueCompositeAttribute:
                    self._uniqueCompositeAttributes[compositeAttribute] = uniqueCompositeAttribute
            
    # If trait is a composite attribute with just one single attribute, use that instead
    def __GetActualTraitName(self, traitName):
        self.__InitUniqueCompositeAttributes()
        if traitName in self._uniqueCompositeAttributes:
            traitName = self._uniqueCompositeAttributes[traitName]
        return traitName
        
    # DO NOT CALL FROM PY
    def __GetAttributeFromC(self, traitName=''):
        if traitName == '':
            return self.GetAttribute
        else:
            traitName = self.__GetActualTraitName(traitName)
            self._AssertPublicTrait(self, traitName)
            return self.GetAttribute(traitName)
        
    # DO NOT CALL FROM PY
    def __SetAttributeFromC(self, traitName, newValue):
        traitName = self.__GetActualTraitName(traitName)
        self._AssertPublicTrait(self, traitName)
        self.SetAttribute(traitName, newValue)
    
    # DO NOT CALL FROM PY
    def __SetAttributesFromC(self, attributesAndValues):
        for traitName in attributesAndValues.Keys():
            traitName = self.__GetActualTraitName(traitName)
            self._AssertPublicTrait(self, traitName)
        for traitName in attributesAndValues.Keys():
            self.SetAttribute(self.__GetActualTraitName(traitName), attributesAndValues.At(traitName))
    
    # DO NOT CALL FROM PY
    def __HasAttributeFromC(self, traitName):
        return IsPublicTrait(self, traitName)
    
    # DO NOT CALL FROM PY
    def __CallUserActionFromC(self, traitName):
        traitName = self.__GetActualTraitName(traitName)
        self._AssertPublicTrait(self, traitName)
        if self.uxCallbacks:
            dialogCb = self.uxCallbacks['dialog']
            if dialogCb:
                dialogCb(self.DealPackage(), traitName)
                return acm.FSymbol('callUserAction')
        return None

    GetAttributeFromC = __GetAttributeFromC
    SetAttributeFromC = __SetAttributeFromC
    SetAttributesFromC = __SetAttributesFromC
    HasAttributeFromC = __HasAttributeFromC
    GetAttributes = __GetAttributesImpl
    GetAttributeMetaData = __GetAttributeMetaDataImpl
    CallUserActionFromC = __CallUserActionFromC
    '''******************************** 
    EO IMPLEMENTATION OF DEAL PACKAGE METHODS
    ********************************'''
    
    __SendNotification = TraitBase._notify_trait
    _TraitValuesAreEqual = TraitBase._trait_values_are_equal
    __SendNotifications = TraitBase._send_notifications
    _GetTraitNames = TraitBase.get_trait_names

# Help methods/classes

class AttributeOverrideAccumulator(object):
    def __init__(self, obj=None):
        self.overrides = {}
        self.name_prefix = ''
        if obj is not None:
            self.get_overrides_from(obj)
        
    def __call__(self, attr_dict):
        for name in attr_dict:
            pf_name = self.get_prefixed_name(name)
            self.overrides.setdefault(pf_name, []).append(attr_dict[name])
    
    def get_overrides_from(self, inst, prefix=''):
        self.name_prefix = prefix
        for klass in type(inst).mro():
            if 'AttributeOverrides' in klass.__dict__:
                klass.AttributeOverrides(inst, self)
        self.name_prefix = ''
    
    def get_prefixed_name(self, name):
        if self.name_prefix:
            if name.startswith('_'):
                return '_' + self.name_prefix + name
            else:
                return self.name_prefix + '_' + name
        else:
            return name
    
    def processed_overrides(self):
        output = {}
        for attrName, overrides in self.overrides.items():
            output[attrName] = {}
            for o in overrides[::-1]: # loop backwards
                for mdkey in o:
                    last = output[attrName].setdefault(mdkey, [])
                    last = last[-1] if last else None
                    output[attrName][mdkey].append( MergeMetaData(mdkey, last, o[mdkey]) )
        return output

def MergeMetaData(metaDataKey, current, toMerge):
    if current is None or current == toMerge:
        return toMerge # Nothing to merge with
    
    if not MetaDataMergePossible(metaDataKey):
        return toMerge # Override instead of merge
    
    validTypes = (str, ObjMappingSplitter)
    if not isinstance(current, validTypes):
        raise AttributeException("Current metadata has to be of type string, got %s, type %s"% (str(current), str(type(current))))
    if not isinstance(toMerge, validTypes):
        raise AttributeException("Merging metadata has to be of type string, got %s, type %s"% (str(toMerge), str(type(toMerge))))
    
    if isinstance(current, ObjMappingSplitter) or isinstance(toMerge, ObjMappingSplitter):
        return ObjMappingSplitter.Merge(current, toMerge)
    else:
        return MergeMetaDataStrings(current, toMerge)

...

}

