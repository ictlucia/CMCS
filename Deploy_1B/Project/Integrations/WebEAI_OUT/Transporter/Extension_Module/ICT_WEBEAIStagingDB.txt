#
# Front Arena exported extension module.
# source          ""
# timestamp (utc) "2024-10-17 04:55:29.5"
# ***** DO NOT EDIT! *****
#
name        "ICT_WEBEAIStagingDB"
description "$Id$"

groups {
}

decls[FExtensionValue] {
}

clx FObject [FExtensionValue] {
  GWM_PAYMENT_LOG
2024-09-10 20:16:57
...

  GWMV_FI_TRANSACTION_LOG
2024-09-10 20:16:29
...

  GWMV_NOSTRO_TRANSACTION_LOG
2024-09-10 20:16:21
...

  LM_FI_TRANSACTION_INTERFACE_LOG
2024-09-10 20:17:43
...

  LM_FI_TRANSACTION_LOG
2024-09-10 20:17:03
...

  LM_FX_TRANSACTION_INTERFACE_LOG
2024-09-10 20:17:58
...

  LM_FX_TRANSACTION_LOG
2024-09-10 20:17:19
...

  LM_MM_TRANSACTION_INTERFACE_LOG
2024-09-10 20:18:05
...

  LM_MM_TRANSACTION_LOG
2024-09-10 20:16:37
...

  PDN_CALLSPREAD_LOG
2024-09-10 20:18:14
...

  PDN_DCI_LOG
2024-09-10 20:17:53
...

  PDN_FX_TRANSACTION_LOG
2024-09-10 20:16:46
...

  PDN_FXOPTION_LOG
2024-09-10 20:17:11
...

  PDN_PAR_FORWARD_LOG
2024-09-10 20:16:24
...

  SMTR_CCS_LOG
2024-09-10 20:16:51
...

  SMTR_FX_TRANSACTION_CUSTOMER_LOG
2024-09-24 09:50:45
...

  SMTR_FX_TRANSACTION_KCDN_LOG
2024-09-10 20:18:09
...

  SMTR_OPTION_CALLSPREAD_LOG
2024-09-10 20:17:49
...

  SMTR_PARFWD_LOG
2024-09-10 20:16:32
...

  STATIC_ACCOUNTING_TYPE_LOG
2024-09-10 20:15:09
...

  STATIC_CUSTOMER_LOG
2024-09-10 20:16:08
...

  STATIC_HLDY_LOG
2024-09-10 20:15:36
...

  STATIC_NOSTRO_LOG
2024-09-19 09:11:37
...

  STATIC_OPER_LOG
2024-09-10 20:15:59
...

  STATIC_PORTOFOLIO_LOG
2024-09-12 16:54:16
...

  STATIC_RATE_LOG
2024-09-21 13:58:45
...

  STATIC_SECURITIES_LOG
2024-09-10 20:15:13
...

  STATIC_STANDARD_INDUSTRY_CODE_LOG
2024-09-10 20:15:06
...

  STATIC_SYSTEMDATE_LOG
2024-09-12 14:12:30
...

  STATIC_TRAD_LOG
2024-09-10 20:15:55
...

  TMS_CCS_IRS_LOG
2024-07-26 08:00:04
...

  TMS_FI_TRANSACTION_INTERFACE_LOG
2024-07-25 17:00:59
...

  TMS_FI_TRANSACTION_LOG
2024-07-25 17:00:31
...

  TMS_FIXING_LOG
2024-07-25 17:01:00
...

  TMS_FX_TRANSACTION_INTERFACE_LOG
2024-07-25 17:01:05
...

  TMS_FX_TRANSACTION_LOG
2024-07-25 17:01:02
...

  TMS_MM_TRANSACTION_INTERFACE_LOG
2024-07-25 17:01:12
...

  TMS_MM_TRANSACTION_LOG
2024-07-25 17:01:08
...

  TMS_OPTION_CALLSPREAD_LOG
2024-07-25 17:01:14
...

  TMS_REUTERS_CONVERSATION_LOG
2024-07-25 17:01:46
...

}

decls[FParameters] {
}

clx FObject [FParameters] {
  StagingDBConfig =
  DB_NAME=InterfaceDB_Functional
  DRIVER={SQL Server}
  PASSWORD=PTap2013$$
  PORT=1433
  SERVER_NAME=10.243.200.72
  USER=WEBEAI


}

decls[FPythonCode] {
}

clx FObject [FPythonCode] {
  DataStager

import acm, ael, pyodbc
import QuerySupplier
reload(QuerySupplier)

context = acm.GetDefaultContext()

def getFilePathSelection():
    """ Directory selector dialog """
    selection = acm.FFileSelection()
    selection.PickDirectory(True)
    selection.SelectedDirectory = 'c:\\'
    return selection   
    
def ReadParams(paramName):
    values = {}
    p = acm.GetDefaultContext().GetExtension('FParameters', 'FObject', paramName)
    params = p.Value()
    for k in params.Keys():
        k = str(k)
        value = str( params.At(k) )
        value = None if value == "" else value
        values[ str(k) ] = value

    return values

def getLogExtensionValue(extension_value_name):
    content = acm.GetDefaultValueFromName(context, "FObject", extension_value_name)
    return content
    
def storeToExtensionValue(extension_value_name, text_result):
    extClass   = "FObject"
    moduleName = "ICT_WEBEAIStagingDB"
    emodule    = acm.FExtensionModule[moduleName]    
    update_time = acm.Time.TimeNow()[0:19]

    new_log_text = '[%s]%s:%s\n%s' %(moduleName, extClass, extension_value_name, update_time)

    context.EditImport('FExtensionValue', new_log_text, False, emodule)   
    try: 
        emodule.Commit()
        context.Commit()
    except Exception as e:
        print(e)
    
def write_log_file(file_path, extension_value_name, text_result):
        
    full_path = file_path+"\\"+extension_value_name+".txt"
    execution_time = getLogExtensionValue(extension_value_name)

    try:
        f = open(full_path, "r")
        current_content = f.read()
        f.close()
    except:
        current_content = ''
    
    log_file = open(full_path, "w")
    new_content = execution_time + "\n" + text_result + "-"*50 + '\n' + current_content
    try:
        log_file.write(new_content)
    except Exception as e:
        log_file.write(e)
    log_file.close()

    print('Log file succesfully created. File path : ' + full_path + '\n')
    print("-"*50 + " END OF LOG " + "-"*50 + "\n")
    
def filter_query_folder(sheet_type):
    
    dict_sheet_type = {
    "Trade" : acm.FTrade, 
    "Settlement" : acm.FSettlement,
    "Choice List" : acm.FChoiceList,
    "T-Account" : acm.FTAccount,
    "Currency Pair": acm.FPrice,
    "Instrument": acm.FInstrument,
    "Party" : acm.FParty,
    "Portfolio" : acm.FPortfolio,
    "Trader" : acm.FUser,
    "Calendar" : acm.FCalendar,
    "Trx History" : acm.FTransactionHistory
    }
    
    all_qf = acm.FStoredASQLQuery.Select('')
    filtered_qf = []
    
    for qf in all_qf:
        try:
            if qf.QueryClass() == dict_sheet_type[sheet_type] :
                filtered_qf.append(qf.Name())
        except:
            pass
    
    filtered_qf.sort()
    return filtered_qf
    
class TableManipulator:
    
    def __init__(self, param_name='StagingDBConfig'):
        self.params     = ReadParams(param_name)
        self.connection = None
        self.cursor     = None
        self.driver     = self.params['DRIVER']
        self.server     = self.params['SERVER_NAME']
        self.port       = self.params['PORT']
        self.database   = self.params['DB_NAME']
        self.uid        = self.params['USER']
        self.pwd        = self.params['PASSWORD']
        
    def connect(self):
        cursor ="Error"
        text_result = ''
        
        try:
            self.connection = pyodbc.connect(
                                'DRIVER='+self.driver
                                +';SERVER='+self.server
                                +';DATABASE='+self.database
                                +';UID='+self.uid
                                +';PWD='+ self.pwd
                                )
            self.cursor = self.connection.cursor()
            text_result = "Connection to database "+self.database+" has been established.\n"
    
        except Exception as e:
            text_result = "Failed to connect to database: %s\n"%str(e)
        
        return cursor, text_result
    
    def get_formatted_data(self,data):
        data = data.replace('[','')
        data = data.replace(']','')
        data = data.replace('(','')
        data = data.replace(')','')
        data = data.replace('\'','')
        return data
        
    def delete(self, tables):
        queries = []
        str_result, count = '', 0
        
        for table in tables:
            query = QuerySupplier.prepare_delete_query(table)
            queries.append(query)

        for query in queries:
            try:
                self.cursor.execute(query)
                str_result += 'Result: Delete ' +tables[count]+' Success.\n'
            except Exception as e:
                tr_result += 'Result : Truncate ' +tables[count]+' Failed.\n'
                str_result += 'Error : '+str(e)
            
            str_result += 'Query: ' + query + '\n'
            str_result += '#\n'
            
        self.connection.commit()
        return str_result
        
    
    def truncate(self, tables):
        queries = []
        str_result, count = '', 0
        for table in tables:
            query = QuerySupplier.prepare_truncate_query(table)
            queries.append(query)
            
        for query in queries:
            try:
                self.cursor.execute(query)
                str_result += 'Result: Truncate ' +tables[count]+' Success.\n'
            except Exception as e:
                str_result += 'Result: Truncate' +tables[count]+'Failed.\n'
                str_result += 'Error: '+str(e)
            
            str_result += 'Query: ' + query + '\n'
            str_result += '#\n'
            count+= 1
            
        self.connection.commit()
        return str_result
    
    def upsert(self, table_name, columns, data, unique_key=None):
        query = QuerySupplier.prepare_upsert_query(table_name, columns, unique_key)
        text_result = self.execute_query(query, 'Inserted/Updated.', data=data)
        return text_result
    
    def execute_query(self, query, text, data=None, silent=False, commit=True):
        if not self.cursor:
            str_result = 'Cannot execute query. Please check the connection to database.\n'
            return str_result
        
        str_result, count_del, count_failed, count_upsert = "Data : \n", 0, 0, 0
        for i in range(len(data)):
            if data[i]:
                text_result = ""
                text_result += "{}.".format(str(i+1)) + str(data[i]) + "\n"
                try:
                    if text == 'Deleted.' :
                        self.cursor.execute(query, data[0])
                        text_result += "\t{} has been deleted".format('Row' if len(data[0])==1 else 'Rows')
                        count_del += len(data[0])
                    else:
                        self.cursor.execute(query, data[i])
                        text_result += "\tSuccessfully Inserted/Updated Data"
                        count_upsert += 1
                    self.connection.commit()
                    text_result += '. Query has been executed successfully.\n'
                    str_result += text_result
                    
                except pyodbc.Error as e:
                    count_failed += 1
                    text_result += "\tERROR: Cannot Execute Query for Row {}: ".format(str(i+1)) + str(e) + "\n"
                    str_result += text_result
                  
        str_result+="\n"
        if count_del:
            str_result+= "{} {} Deleted\n".format(count_del, 'Row' if count_del==1 else 'Rows')
        if count_upsert:
            str_result+= "{} {} Inserted/Updated\n".format(count_upsert, 'Row' if count_upsert==1 else 'Rows')
        if count_failed:
            str_result+= "{} {} Failed to Execute\n".format(count_failed, 'Row' if count_failed==1 else 'Rows')
        
        """
        ### Bulk Version of Execute using ExecuteMany ###
        try:
            if data:
                self.cursor.executemany(query,data)
                
                text_result = ''
                if text == 'Deleted.' :
                    text_result = "Rows has been deleted."
                else:
                    text_result = "{} row {}".format(len(data), text)
                
                text_result += '. Query has been executed successfully.\n'
                
                self.connection.commit()
                str_result += 'Query : ' + query + '\n'
                str_result += text_result
                
        except Exception as e:
            text_result = 'Failed to execute the query: ' + str(e) + '\n'
            str_result += 'Query : ' + query + '\n'
            str_result += text_result
        """
        
        return str_result
    
    def delete_row_from_table(self, table_name, tuple_key, unique_key):
        query = QuerySupplier.prepare_delete_rows_from_table(table_name, tuple_key, unique_key)
        text_result = self.execute_query(query,'Deleted.', data=[tuple_key])
        
        return text_result
    
    def disconnect(self):
        text_result = "Succesfully disconnected from database " + self.database +".\n"
        try:
            self.cursor.close()
            del self.cursor
            self.connection.close()
        except Exception as e:
            text_result = 'Failed to disconnect from database: %s\n'%str(e)
        
        return text_result

...

  GWM

import acm, ael, time

class GWM_Modules:
    
    def __init__(self):
        pass
    
    def set_settlement(self, settle):
        self.settlement = settle
    
    def dealno(self):
        try:
            return self.settlement.Trade().Oid()
            #return self.settlement.Trade().AdditionalInfo().DealNO()
        except:
            return None
        
    def product(self):
        try :
            return self.settlement.Trade().OptKey3().Name()
        except:
            return None
        
    def prodtype(self):
        try :
            return self.settlement.Trade().OptKey4().Name()
        except:
            return None
        
    def br(self):
        try :
            return self.settlement.Trade().OptKey1().Name()
        except:
            return None
        
    def settdate(self):
        return self.settlement.ValueDay()
    
    def ccy(self):
        try:
            return self.settlement.Currency().Name()
        except:
            return None
        
    def amt(self):
        try:
            return self.settlement.Trade().Nominal()
        except:
            return None
    
    def cno(self):
        try:
            party = self.settlement.Counterparty()
            hostId = party.HostId()
            if hostId.strip():
                return hostId
            else:
                alias = party.Id2()
                if alias.isdigit():
                    return alias
                else:
                    return party.Id().split("_")[0]
        except:
            return None
    
    def sn(self):
        try:
            return self.settlement.Counterparty().Fullname()[:50]
        except:
            return None

    def bic(self):
        try:
            return self.settlement.Counterparty().Swift()
        except:
            return None
    
    def payrec(self):
        try:
            if self.settlement.Trade().Quantity() >= 0:
                return 'P'
            else:
                return 'R'
        except:
            return None
    
    def setmeans(self):
        try:
            s = ael.Settlement[self.settlement.Oid()]
            return s.acquirer_account_network_name
        except:
            return None
        
    def setacct(self):
        try:
            return self.settlement.AcquirerAccName()
        except:
            return None

...

  GWM_PAYMENT

from DataStager import *
from GWM import *

ael_gui_parameters={'runButtonLabel':'&&Run',
                    'hideExtraControls': True,
                    'windowCaption':'GWM_PAYMENT'}

ael_variables=[
['query_folder','Query Folders','string', filter_query_folder('Settlement'), 'WEBEAI_GWM_PAYMENT', 1,0],
['file_path', 'Log Folder Path', getFilePathSelection(), None, getFilePathSelection(), 1, 1]]

def ael_main(parameter):
    text_result = ''
    table_name = 'GWM_PAYMENT'
    columns = ('DEALNO', 'PRODUCT', 'PRODTYPE', 'BR', 'SETTDATE', 'CCY', 'AMOUNT', 'CNO', 'SN', 'BIC', 'PAYREC', 'SETMEANS', 'SETACCT')
    file_path = str(parameter['file_path'])
    query_folder = parameter['query_folder']
    
    db_query = acm.FStoredASQLQuery[query_folder].Query()
    settlements = db_query.Select()
    data = []
    
    gwm = GWM_Modules()
   
    for i in settlements:
        gwm.set_settlement(i)
        
        temp_result = (
            gwm.dealno(),
            gwm.product(),
            gwm.prodtype(),
            gwm.br(),
            gwm.settdate(),
            gwm.ccy(),
            gwm.amt(),
            gwm.cno(),
            gwm.sn(),
            gwm.bic(),
            gwm.payrec(),
            gwm.setmeans(),
            gwm.setacct()
        )
        if temp_result[0] != None:
            data.append(temp_result)
        else:
            continue
    
    data = list(set(data))
    text_result += "Table : " + table_name + "\n"
    text_result += "Columns : " + str(columns) + "\n"
    
    if data == [] :
        text_result += '\nNo new data to be inserted/updated.\n'
    else:
        dbOps = TableManipulator()
        cursor, text_connect = dbOps.connect()

        text_result += text_connect
        text_result += dbOps.upsert(table_name, columns, data, [columns[0]])
        #text_result += dbOps.delete_row_from_table(table_name, tuple(void_trades), columns[0])
        #text_result += dbOps.truncate([table_name])
        text_result += dbOps.disconnect()
        
    print(text_result)
    extension_value_name = table_name + '_LOG'
    storeToExtensionValue(extension_value_name, text_result)
    write_log_file(file_path, extension_value_name, text_result)


...

  GWMV

import acm, ael, time

class GWMV_Modules:
    
    def __init__(self):
        pass
    
    def set_trade(self, trade):
        self.trade = trade
    
    def dealno(self):
        return self.trade.Oid()
        #return self.trade.AdditionalInfo().DealNO()
    
    def valuedate(self):
        try:
            if str(self.trade.InstrumentSubType()) == 'NDF':
                return self.trade.RightDate()
            return self.trade.ValueDay()
        except:
            return None
        
    def cno(self):
        try:
            party = self.trade.Counterparty()
            hostId = party.HostId()
            if hostId.strip():
                return hostId
            else:
                alias = party.Id2()
                if alias.isdigit():
                    return alias
                else:
                    return party.Id().split("_")[0]
        except:
            return None
        
    def dealdate(self):
        temp_time = self.trade.TradeTime()
        temp_time = acm.Time.DateTimeToTime(temp_time)
        formatted_time = time.strftime("%Y-%m-%d %H:%M:%S", time.strptime(time.ctime(temp_time)))
        return formatted_time
    
    def inputdate(self):
        temp_time = self.trade.CreateTime()
        formatted_time = time.strftime("%Y-%m-%d %H:%M:%S", time.strptime(time.ctime(temp_time)))
        return formatted_time
        
    def product(self):
        try :
            return self.trade.OptKey3().Name()
        except:
            return None

    def prodtype(self):
        try :
            return self.trade.OptKey4().Name()
        except:
            return None
    
    def ccy(self):
        if not self.trade.PositionOrInstrumentPair():
            return self.trade.Currency().Name()
        else:
            return self.trade.PositionOrInstrumentPair().Instrument1().Name()
    
    def trfamt(self):
        return self.trade.Nominal()
            
    def proceedamt(self):
        return self.trade.Premium()
        
    def faceamt(self):
        return self.trade.Instrument().FaceValue()
        
    def costamt(self):
        return self.trade.Nominal()
        
    def qty(self):
        return self.trade.Quantity()
        
    def purchintamt(self):
        try:
            stand_calc = acm.FStandardCalculationsSpaceCollection()
            facevalue = self.trade.FaceValue()
            mfs = self.trade.MoneyFlows()
            total_proj = 0.0
            for mf in mfs:
                if mf.Type() in ['Fixed Rate', 'Float Rate']:
                    value = mf.Calculation().Projected(stand_calc).Value().Number()
                    if not acm.Operations().IsValueInfNanOrQNan(value):
                        proj = float(value)
                        total_proj += proj
            total_proj += facevalue
            return total_proj
        except:
            return None
        
    def acctngtype_securities(self):
        try:
            return self.trade.Instrument().AddInfoValue('AccountingType')
        except:
            return None
        
    def price_8(self):
        return self.trade.Price()
        
    def secsacct(self):
        try:
            return self.trade.RegulatoryInfos().Last().ClearingHouse().Name()
        except:
            return None
    
    def payacct(self):
        return None
    
    def recacct(self):
        return None
    
    def ps(self):
        if self.trade.Quantity() >= 0:
            return 'P'
        else:
            return 'S'
            
    def invtype(self):
        try:
            return self.trade.Portfolio().TypeChlItem().Name()
        except:
            return None

    def beneficiary(self):
        try:
            return self.trade.Counterparty().Swift()
        except:
            return None
        
    def account(self):
        try:
            return self.trade.AccountId()
        except:
            return None
        
    def intermediary(self):
        try:
            return self.trade.Counterparty().Cls()
        except:
            return None
        
    def amend_date(self):
        def convert_status(status):
            try:
                status = str(int(status))
                status = acm.FTradeStatusValue.Select(f"enumValue={status}").First().NiceName()
            except:
                pass
            return status
        try:
            r = ael.asql(f"""
            SELECT 
                t.seqnbr, t.creat_time 
            FROM 
                TransHst t 
            WHERE 
                t.trans_record_type = 'Trade' 
                AND t.record_id = {self.trade.Oid()}
            ORDER BY 
                t.creat_time ASC
            """)
            state = False
            for result in r[1][0]:
                transhst_id = result[0]
                TransactionHistory = acm.FTransactionHistory[transhst_id]
                newValue = convert_status(TransactionHistory.NewFieldValue('Status', 'Trade'))
                oldValue = convert_status(TransactionHistory.OldFieldValue('Status', 'Trade'))
                if state and newValue == 'FO Confirmed':
                    return acm.Time.UtcToLocal(result[1])
                elif not oldValue:
                    continue
                elif oldValue == 'BO Rejected':
                    state = True
                    continue
            return None
        except:
            return None
    
    def port(self):
        try:
            return self.trade.Portfolio().Name()[:50]
        except:
            return None
        
    def trad(self):
        try:
            return self.trade.Trader().Oid()
        except:
            return None
        
    def cost(self):
        try:
            return self.trade.Portfolio().AddInfoValue('COST CENTER')
        except:
            return None
        
    def ioper(self):
        try:
            return self.trade.CreateUser().Oid()
        except:
            return None
        
    def voper(self):
        try:
            return self.trade.UpdateUser().Oid()
        except:
            return None
    
    def payoper(self):
        try:
            return self.trade.Payments().Last().CreateUser().Oid()
        except:
            return None
            
    def authoper(self):
        try:
            return self.trade.Authorizer().Oid()
        except:
            return None
    
    def revoper(self):
        try:
            return self.trade.UpdateUser().Oid()
        except:
            return None

    def revauth(self):
        try:
            return self.trade.Authorizer().Oid()
        except:
            return None
        
    def dealtext(self):
        return self.trade.Text1()
    
    def fedealno(self):
        try:
            return self.trade.OptionalKey()
        except:
            return None
        
    def whtamt(self):
        return self.trade.Instrument().DividendFactor()

    def get_account(self, account_object):
        network = self.convert_network_name(account_object)
        if network == 'EMARETL':
            return account_object.Account()
        elif network == 'NOS':
            return account_object.Name()
        else:
            return None
            
    def ccysacct(self):
        try:   
            moneyFlows = self.trade.MoneyFlows()
            if moneyFlows:
                for mf in moneyFlows:
                    party_account = mf.AcquirerAccount()
                    if self.trade.TradeInstrumentType().lower() == 'curr':
                        if mf.Currency() == self.trade.Instrument():
                            return self.get_account(party_account)
                        else:
                            continue
                    else:
                        if mf.Currency() == self.trade.Currency():
                            return self.get_account(party_account)
                        else:
                            continue
                return None
            else:
                return None
        except:
            return None
    
    def br(self):
        try :
            return self.trade.OptKey1().Name()
        except:
            return None
        
    def status(self):
        return self.trade.Status()
    
    def broker(self):
        try:
            return self.trade.Broker().Oid()
        except:
            return None
    
    def brokername(self):
        try:
            return self.trade.Broker().Name()
        except:
            return None
        
    def mdate(self):
        return self.trade.ValueDay()

    def secid(self):
        try:
            return self.trade.Instrument().Name()[:50]
        except:
            return None
        
    def brokeramt(self):
        return self.trade.Fee()
    
    def lstmntdate(self):
        temp_time = self.trade.UpdateTime()
        formatted_time = time.strftime("%Y-%m-%d %H:%M:%S", time.strptime(time.ctime(temp_time)))
        return formatted_time
        
    def yield_8(self):
        try:
            return acm.Calculations().CreateCalculationSpace(acm.GetDefaultContext(),'FTradeSheet'). CreateCalculation(self.trade, 'Trade Yield').Value().Number() 
        except:
            return None
        
    def verdate(self):
        temp_time = self.trade.UpdateTime()
        formatted_time = time.strftime("%Y-%m-%d %H:%M:%S", time.strptime(time.ctime(temp_time)))
        return formatted_time
        
    def revdate(self):
        if ('void' not in self.status().lower()):
            return None
        else:
            ths = acm.FTransactionHistory.Select('transRecordType="Trade" and recordId={}'.format(self.trade.Oid()))
            for th in ths:
                newVal = th.NewFieldValue('status', 'Trade')
                if (newVal is not None):
                    if ('void' in newVal.lower()):
                        temp_time = th.UpdateTime()
                        return time.strftime("%Y-%m-%d %H:%M:%S", time.strptime(time.ctime(temp_time)))
        
    def settdate(self):
        try:
            return self.trade.ValueDay()
        except:
            return None
            
    def reverse_date(self):
        if ('void' not in self.status().lower()):
            return None
        else:
            ths = acm.FTransactionHistory.Select('transRecordType="Trade" and recordId={}'.format(self.trade.Oid()))
            for th in ths:
                newVal = th.NewFieldValue('status', 'Trade')
                if (newVal is not None):
                    if ('void' in newVal.lower()):
                        temp_time = th.UpdateTime()
                        return time.strftime("%Y-%m-%d %H:%M:%S", time.strptime(time.ctime(temp_time)))

...

  GWMV_FI_TRANSACTION

from DataStager import *
from GWMV import *

ael_gui_parameters={'runButtonLabel':'&&Run',
                    'hideExtraControls': True,
                    'windowCaption':'GWMV_FI_TRANSACTION'}

ael_variables=[
['query_folder','Query Folders','string', filter_query_folder('Trade'), 'WEBEAI_GWMV_FI_TRANSACTION', 1,0],
['file_path', 'Log Folder Path', getFilePathSelection(), None, getFilePathSelection(), 1, 1]]

def ael_main(parameter):
    text_result = ''
    table_name = 'GWMV_FI_TRANSACTION'
    columns = ('DEALNO', 'VDATE', 'SETTDATE', 'MDATE', 'DEALDATE', 'INPUTDATE', 'CNO', 'SECID', 'PRODUCT', 'PRODTYPE', 'CCY', 'PROCEEDAMT', 'FACEAMT', 'COSTAMT', 'QTY', 'PURCHINTAMT', 'ACCTNGTYPE_SECURITIES', 'YIELD_8_YIELD', 'PRICE_8_PRICE', 'SECSACCT_CUSTODIAN', 'CCYSACCT', 'DEALTEXT', 'FEDEALNO', 'WHTAMT_TAX', 'PORT', 'TRAD', 'COST', 'IOPER', 'VOPER', 'PAYOPER', 'AUTHOPER', 'REVOPER', 'REVAUTH', 'PS', 'INVTYPE', 'BENEFICIARY', 'ACCOUNT', 'INTERMEDIARY', 'REVERSE_DATE', 'AMEND_DATE', 'BR', 'STATUS', 'BROKER', 'BROKERAMT')
    file_path = str(parameter['file_path'])
    query_folder = parameter['query_folder']
    
    db_query = acm.FStoredASQLQuery[query_folder].Query()
    objects = db_query.Select()
    data = []
    
    gwmv_mod = GWMV_Modules()
    
    for i in objects:
        gwmv_mod.set_trade(i)
        
        temp_result = (
            gwmv_mod.dealno(),
            gwmv_mod.valuedate(),
            gwmv_mod.settdate(),
            gwmv_mod.mdate(),
            gwmv_mod.dealdate(),
            gwmv_mod.inputdate(),
            gwmv_mod.cno(),
            gwmv_mod.secid(),
            gwmv_mod.product(),
            gwmv_mod.prodtype(),
            gwmv_mod.ccy(),
            gwmv_mod.proceedamt(),
            gwmv_mod.faceamt(),
            gwmv_mod.costamt(),
            gwmv_mod.qty(),
            gwmv_mod.purchintamt(),
            gwmv_mod.acctngtype_securities(),
            gwmv_mod.yield_8(),
            gwmv_mod.price_8(),
            gwmv_mod.secsacct(),
            gwmv_mod.ccysacct(),
            gwmv_mod.dealtext(),
            gwmv_mod.fedealno(),
            gwmv_mod.whtamt(),
            gwmv_mod.port(),
            gwmv_mod.trad(),
            gwmv_mod.cost(),
            gwmv_mod.ioper(),
            gwmv_mod.voper(),
            gwmv_mod.payoper(),
            gwmv_mod.authoper(),
            gwmv_mod.revoper(),
            gwmv_mod.revauth(),
            gwmv_mod.ps(),
            gwmv_mod.invtype(),
            gwmv_mod.beneficiary(),
            gwmv_mod.account(),
            gwmv_mod.intermediary(),
            gwmv_mod.reverse_date(),
            gwmv_mod.amend_date(),
            gwmv_mod.br(),
            gwmv_mod.status(),
            gwmv_mod.broker(),
            gwmv_mod.brokeramt()
        )
        data.append(temp_result)
    
    data = list(set(data))
    text_result += "Table : " + table_name + "\n"
    text_result += "Columns : " + str(columns) + "\n"
    
    if data == [] :
        text_result += '\nNo new data to be inserted/updated.\n'
    else:
        dbOps = TableManipulator()
        cursor, text_connect = dbOps.connect()

        text_result += text_connect
        text_result += dbOps.upsert(table_name, columns, data, [columns[0]])
        #text_result += dbOps.delete_row_from_table(table_name, tuple(void_trades), columns[0])
        #text_result += dbOps.truncate([table_name])
        text_result += dbOps.disconnect()
        
    print(text_result)
    extension_value_name = table_name + '_LOG'
    storeToExtensionValue(extension_value_name, text_result)
    write_log_file(file_path, extension_value_name, text_result)



...

  GWMV_NOSTRO_TRANSACTION

from DataStager import *
from GWMV import *

ael_gui_parameters={'runButtonLabel':'&&Run',
                    'hideExtraControls': True,
                    'windowCaption':'GWMV_NOSTRO_TRANSACTION'}

ael_variables=[
['query_folder','Query Folders','string', filter_query_folder('Trade'), 'WEBEAI_GWMV_NOSTRO_TRANSACTION', 1,0],
['file_path', 'Log Folder Path', getFilePathSelection(), None, getFilePathSelection(), 1, 1]]

def ael_main(parameter):
    text_result = ''
    table_name = 'GWMV_NOSTRO_TRANSACTION'
    columns = ('BR', 'DEALNO', 'CCY', 'VDATE', 'PAYACCT', 'RECACCT', 'TRFAMT', 'IOPER', 'VOPER', 'ROPER', 'RVOPER', 'INPUTDATE', 'LSTMNTDATE', 'VERDATE', 'REVDATE')
    file_path = str(parameter['file_path'])
    query_folder = parameter['query_folder']
    
    db_query = acm.FStoredASQLQuery[query_folder].Query()
    objects = db_query.Select()
    data = []
    
    gwmv_mod = GWMV_Modules()
    
    for i in objects:
        gwmv_mod.set_trade(i)
        
        temp_result = (
            gwmv_mod.br(),
            gwmv_mod.dealno(),
            gwmv_mod.ccy(),
            gwmv_mod.valuedate(),
            gwmv_mod.payacct(),
            gwmv_mod.recacct(),
            gwmv_mod.trfamt(),
            gwmv_mod.ioper(),
            gwmv_mod.voper(),
            gwmv_mod.revoper(),
            gwmv_mod.revauth(),
            gwmv_mod.inputdate(),
            gwmv_mod.lstmntdate(),
            gwmv_mod.verdate(),
            gwmv_mod.revdate(),
        )
        data.append(temp_result)
    
    data = list(set(data))
    text_result += "Table : " + table_name + "\n"
    text_result += "Columns : " + str(columns) + "\n"
    
    if data == [] :
        text_result += '\nNo new data to be inserted/updated.\n'
    else:
        dbOps = TableManipulator()
        cursor, text_connect = dbOps.connect()

        text_result += text_connect
        text_result += dbOps.upsert(table_name, columns, data, [columns[1]])
        #text_result += dbOps.delete_row_from_table(table_name, tuple(void_trades), columns[0])
        #text_result += dbOps.truncate([table_name])
        text_result += dbOps.disconnect()
        
    print(text_result)
    extension_value_name = table_name + '_LOG'
    storeToExtensionValue(extension_value_name, text_result)
    write_log_file(file_path, extension_value_name, text_result)


...

  LIQMON

import acm, ael, time

dateToday = acm.Time.DateToday()
calc = acm.FStandardCalculationsSpaceCollection()

class LIQMON_Modules:

    def __init__(self):
        pass
    
    def set_trade(self, trade):
        self.trade = trade
        
    def set_leg(self, leg):     
        self.leg = leg
        
    def set_cashflow(self, cashflow):
        self.cashflow = cashflow    
        
    def set_moneyflow(self, moneyflow):
        self.moneyflow = moneyflow
        
    def moneyflows(self):
        return self.trade.MoneyFlows()
        
    def clear(self):
        return calc.Clear()
        
    def mfccy(self):
        try:
            return self.moneyflow.Currency().Name()
        except:
            return None
    
    def mfdeliverytype(self):
        return self.moneyflow.DeliveryType()
        
    def mfinstrument(self):
        try:
            return self.moneyflow.Instrument().Name()
        except:
            return None
    
    def mfstartdate(self):
        return self.moneyflow.MoneyFlowStartDate()
        
    def mfenddate(self):
        return self.moneyflow.MoneyFlowEndDate()
        
    def mfsettlestatus(self):
        return self.moneyflow.MoneyFlowSettleStatus()

    def mftype(self):
        return str(self.moneyflow.Type())
        
    def mfpaydate(self):
        return self.moneyflow.PayDate()
        
    def mfdealno(self):
        return self.moneyflow.Trade().Oid()
    
    def mfsource(self):
        return self.moneyflow.SourceObject().RecordType()
    
    def acquireraccount(self):
        try:   
            acquirer_account = self.moneyflow.AcquirerAccount()
            if acquirer_account:
                return acquirer_account.Name()
            else:
                return None
        except:
            return None
            
    def counterpartyaccount(self):
        try:   
            cpty_account = self.moneyflow.CounterpartyAccount()
            if cpty_account:
                return cpty_account.Name()
            else:
                return None
        except:
            return None
    
    def get_cashflow(self):
        source = self.moneyflow.SourceObject()
        if source.Class() == acm.FCashFlow:
            return source
                
    def cfid(self):
        try:
            return self.cashflow.Oid()
        except:
            return None
    
    def cftype(self):
        try:
            return self.cashflow.CashFlowType()
        except:
            return None
                
    def get_leg(self):
        try:
            return self.cashflow.Leg()
        except:
            return None
        
    def legtype(self):
        try:
            return self.leg.LegType()
        except:
            return None
        
    def paytype(self):
        try:
            return self.leg.PayType()
        except:
            return None
        
    def projection(self):
        proj = self.moneyflow.Calculation().Projected(calc).Number()
        if acm.Operations().IsValueInfNanOrQNan(proj):
            return None
        else:
            return proj
            
    def dealno(self):
        return self.trade.Oid()
        #return self.trade.AdditionalInfo().DealNO()
        
    def valuedate(self):
        try:
            if str(self.trade.InstrumentSubType()) == 'NDF':
                return self.trade.RightDate()
            return self.trade.ValueDay()
        except:
            return None
        
    def mdate(self):
        return self.trade.Instrument().ExpiryDate()
        
    def dealdate(self):
        temp_time = self.trade.TradeTime()
        temp_time = acm.Time.DateTimeToTime(temp_time)
        formatted_time = time.strftime("%Y-%m-%d %H:%M:%S", time.strptime(time.ctime(temp_time)))
        return formatted_time
        
    def inputdate(self):
        temp_time = self.trade.CreateTime()
        formatted_time = time.strftime("%Y-%m-%d %H:%M:%S", time.strptime(time.ctime(temp_time)))
        return formatted_time
        
    def cno(self):
        try:
            party = self.trade.Counterparty()
            hostId = party.HostId()
            if hostId.strip():
                return hostId
            else:
                alias = party.Id2()
                if alias.isdigit():
                    return alias
                else:
                    return party.Id().split("_")[0]
        except:
            return None
        
    def ccode(self):
        try:
            return self.trade.Counterparty().Country()
        except:
            return None
        
    def acctngtype(self):
        try:
            return self.trade.OptKey3().Name()
        except:
            return None
        
    def secid(self):
        try:
            return self.trade.Instrument().Name()[:50]
        except:
            return None
        
    def product(self):
        try :
            return self.trade.OptKey3().Name()
        except:
            return None

    def prodtype(self):
        try :
            return self.trade.OptKey4().Name()
        except:
            return None
            
    def pay_ccy(self):
        try:
            return self.trade.Instrument().PayLeg().Currency().Name()
        except:
            return None
            
    def pay_amt(self):
        try:
            return self.trade.Instrument().ContractSize()
        except:
            return None
            
    def receive_ccy(self):
        try:
            return self.trade.Instrument().RecLeg().Currency().Name()
        except:
            return None
            
    def receive_amt(self):
        try:
            return self.pay_amt() * self.trade.Instrument().RecLeg().NominalFactor()
        except:
            return None 
        
    def ccy(self):
        if not self.trade.PositionOrInstrumentPair():
            return self.trade.Currency().Name()
        else:
            return self.trade.PositionOrInstrumentPair().Instrument1().Name()
        
    def ctrccy(self):
        if not self.trade.PositionOrInstrumentPair():
            return None
        else:
            return self.trade.PositionOrInstrumentPair().Instrument2().Name()
        
    def ccyamt(self):
        try:
            return self.trade.Position()
        except:
            return None
        
    def ctramt(self):
        try:
            if self.trade.InstrumentSubType().Text().lower() == 'fx option':
                return (-1) * self.ccyamt() * self.trade.Instrument().StrikePrice()
            else:
                return (-1) * self.ccyamt() * self.trade.Price()
        except:
            return None
      
    def totpayamt(self):
        try:
            trade_valuedate = self.valuedate()
            trade_mdate = self.mdate()
            if dateToday < trade_mdate:
                return self.trade.StartCash()
            else:
                return self.totendcash()
        except:
            return None
        
    def totendcash(self):
        return self.purchintamt()
        
    def intamt(self):
        return self.trade.InterestRateAtTradeTime()
    
    def intrate_8(self):
        return self.trade.InterestRateAtTradeTime()
    
    def smeans(self):
        return self.trade.AccountId()
        
    def sacct(self):
        return self.trade.AccountId()
        
    def intsmeans(self):
        return self.trade.AccountId()
        
    def intsacct(self):
        return self.trade.AccountId()
        
    def intenddate(self):
        try:
            trade_valuedate = self.valuedate()
            trade_mdate = self.mdate()
            if dateToday < trade_mdate:
                return trade_valuedate
            else:
                return trade_mdate
        except:
            return None
            
    def reverse_date(self):
        if ('void' not in self.status().lower()):
            return None
        else:
            ths = acm.FTransactionHistory.Select('transRecordType="Trade" and recordId={}'.format(self.trade.Oid()))
            for th in ths:
                newVal = th.NewFieldValue('status', 'Trade')
                if (newVal is not None):
                    if ('void' in newVal.lower()):
                        temp_time = th.UpdateTime()
                        return time.strftime("%Y-%m-%d %H:%M:%S", time.strptime(time.ctime(temp_time)))
  
    def proceedamt(self):
        return self.trade.Premium()
        
    def faceamt(self):
        return self.trade.Instrument().FaceValue()
        
    def costamt(self):
        return self.trade.Nominal()
        
    def qty(self):
        return self.trade.Quantity()
        
    def purchintamt(self):
        try:
            stand_calc = acm.FStandardCalculationsSpaceCollection()
            facevalue = self.trade.FaceValue()
            mfs = self.trade.MoneyFlows()
            total_proj = 0.0
            for mf in mfs:
                if mf.Type() in ['Fixed Rate', 'Float Rate']:
                    value = mf.Calculation().Projected(stand_calc).Value().Number()
                    if not acm.Operations().IsValueInfNanOrQNan(value):
                        proj = float(value)
                        total_proj += proj
            total_proj += facevalue
            return total_proj
        except:
            return None
        
    def acctngtype_securities(self):
        try:
            return self.trade.Instrument().AddInfoValue('AccountingType')
        except:
            return None
        
    def price_8(self):
        return self.trade.Price()
        
    def secsacct(self):
        try:
            return self.trade.RegulatoryInfos().Last().ClearingHouse().Name()
        except:
            return None
        
    def dealtext(self):
        return self.trade.Text1()
        
    def fedealno(self):
        try:
            return self.trade.OptionalKey()
        except:
            return None
        
    def whtamt(self):
        return self.trade.Instrument().DividendFactor()
        
    def rate(self):
        try:
            if self.trade.TradeInstrumentType().lower() == 'option':
                return self.trade.Instrument().StrikePrice()
            elif self.trade.TradeInstrumentType().lower() == 'currswap':
                return self.trade.Instrument().RecLeg().NominalFactor()
            else:
                return self.trade.Price()
        except:
            return None
        
    def port(self):
        try:
            return self.trade.Portfolio().Name()[:50]
        except:
            return None
        
    def trad(self):
        try:
            return self.trade.Trader().Oid()
        except:
            return None
        
    def cost(self):
        try:
            return self.trade.Portfolio().AddInfoValue('COST CENTER')
        except:
            return None
        
    def ioper(self):
        try:
            return self.trade.CreateUser().Oid()
        except:
            return None
        
    def voper(self):
        try:
            return self.trade.UpdateUser().Oid()
        except:
            return None
    
    def payoper(self):
        try:
            return self.trade.Payments().Last().CreateUser().Oid()
        except:
            return None
            
    def authoper(self):
        try:
            return self.trade.Authorizer().Oid()
        except:
            return None
    
    def revoper(self):
        try:
            return self.trade.UpdateUser().Oid()
        except:
            return None

    def revauth(self):
        try:
            return self.trade.Authorizer().Oid()
        except:
            return None
        
    def ps(self):
        if self.trade.Quantity() >= 0:
            return 'P'
        else:
            return 'S'
        
    def invtype(self):
        try:
            return self.trade.Portfolio().TypeChlItem().Name()
        except:
            return None
        
    def br(self):
        try :
            return self.trade.OptKey1().Name()
        except:
            return None
        
    def status(self):
        return self.trade.Status()
        
    def pay_rate_type(self):
        try:
            return self.trade.Instrument().PayLeg().LegType()
        except:
            return None
    
    def receive_rate_type(self):
        try:
            return self.trade.Instrument().RecLeg().LegType()
        except:
            return None
    
    def pay_rate_value(self):
        try:
            return self.trade.Instrument().PayLeg().FixedRate()
        except:
            return None
    
    def receive_rate_value(self):
        try:
            return self.trade.Instrument().RecLeg().FixedRate()
        except:
            return None
            
    def spotdate(self):
        try:
            date, period = acm.Time.AsDate(self.trade.TradeTime()), 2
            calendar = acm.FCalendar['Jakarta']
            for n in range(period):
                date = acm.Time.DateAdjustPeriod(date, '1d', calendar, 'Following')
            return date
        except:
            return None
        
    def beneficiary(self):
        try:
            return self.trade.Counterparty().Swift()
        except:
            return None
        
    def account(self):
        try:
            return self.trade.AccountId()
        except:
            return None
        
    def intermediary(self):
        try:
            return self.trade.Counterparty().Cls()
        except:
            return None
        
    def amend_date(self):
        def convert_status(status):
            try:
                status = str(int(status))
                status = acm.FTradeStatusValue.Select(f"enumValue={status}").First().NiceName()
            except:
                pass
            return status
        try:
            r = ael.asql(f"""
            SELECT 
                t.seqnbr, t.creat_time 
            FROM 
                TransHst t 
            WHERE 
                t.trans_record_type = 'Trade' 
                AND t.record_id = {self.trade.Oid()}
            ORDER BY 
                t.creat_time ASC
            """)
            state = False
            for result in r[1][0]:
                transhst_id = result[0]
                TransactionHistory = acm.FTransactionHistory[transhst_id]
                newValue = convert_status(TransactionHistory.NewFieldValue('Status', 'Trade'))
                oldValue = convert_status(TransactionHistory.OldFieldValue('Status', 'Trade'))
                if state and newValue == 'FO Confirmed':
                    return acm.Time.UtcToLocal(result[1])
                elif not oldValue:
                    continue
                elif oldValue == 'BO Rejected':
                    state = True
                    continue
            return None
        except:
            return None
        
    def revdate(self):
        if ('void' not in self.status().lower()):
            return None
        else:
            ths = acm.FTransactionHistory.Select('transRecordType="Trade" and recordId={}'.format(self.trade.Oid()))
            for th in ths:
                newVal = th.NewFieldValue('status', 'Trade')
                if (newVal is not None):
                    if ('void' in newVal.lower()):
                        temp_time = th.UpdateTime()
                        return time.strftime("%Y-%m-%d %H:%M:%S", time.strptime(time.ctime(temp_time)))
                    
    def broker(self):
        try:
            return self.trade.Broker().Oid()
        except:
            return None
            
    def brokeramt(self):
        return self.trade.Fee()
    
    def settdate(self):
        try:
            return self.trade.ValueDay()
        except:
            return None
        
    def convert_network_name(self, account_object):
        network_name = account_object.NetworkAliasType().Name().lower()
        if network_name == 'emas':
            return 'EMARETL'
        elif network_name in ('swift', 'rtgs'):
            return 'NOS'
        else:
            return None
    
    def get_account(self, account_object):
        network = self.convert_network_name(account_object)
        if network == 'EMARETL':
            return account_object.Account()
        elif network == 'NOS':
            return account_object.Name()
        else:
            return None

    def ccysmeans(self):
        try:   
            moneyFlows = self.trade.MoneyFlows()
            if moneyFlows:
                for mf in moneyFlows:
                    party_account = mf.AcquirerAccount()
                    if self.trade.TradeInstrumentType().lower() == 'curr':
                        if mf.Currency() == self.trade.Instrument():
                            return self.convert_network_name(party_account)
                        else:
                            continue
                    else:
                        if mf.Currency() == self.trade.Currency():
                            return self.convert_network_name(party_account)
                        else:
                            continue
                return None
            else:
                return None
        except:
            return None
        
    def ctrccysmeans(self):
        try:   
            moneyFlows = self.trade.MoneyFlows()
            if moneyFlows:
                for mf in moneyFlows:
                    party_account = mf.AcquirerAccount()
                    if self.trade.TradeInstrumentType().lower() == 'curr':
                        if mf.Currency() == self.trade.Currency():
                            return self.convert_network_name(party_account)
                        else:
                            continue
                    else:
                        return None
                return None
            else:
                return None
        except:
            return None
    
    def ccysacct(self):
        try:   
            moneyFlows = self.trade.MoneyFlows()
            if moneyFlows:
                for mf in moneyFlows:
                    party_account = mf.AcquirerAccount()
                    if self.trade.TradeInstrumentType().lower() == 'curr':
                        if mf.Currency() == self.trade.Instrument():
                            return self.get_account(party_account)
                        else:
                            continue
                    else:
                        if mf.Currency() == self.trade.Currency():
                            return self.get_account(party_account)
                        else:
                            continue
                return None
            else:
                return None
        except:
            return None
        
    def ctrsacct(self):
        try:   
            moneyFlows = self.trade.MoneyFlows()
            if moneyFlows:
                for mf in moneyFlows:
                    party_account = mf.AcquirerAccount()
                    if self.trade.TradeInstrumentType().lower() == 'curr':
                        if mf.Currency() == self.trade.Currency():
                            return self.get_account(party_account)
                        else:
                            continue
                    else:
                        return None
                return None
            else:
                return None
        except:
            return None

    def spotfwd(self):
        try:
            if self.product().lower() == 'fx':
                if self.prodtype().lower() in ('tod', 'tom', 'spot'):
                    return 'S'
                elif self.prodtype().lower() == 'fwd':
                    return 'F'
                elif self.prodtype().lower() == 'swap':
                    farleg = self.trade.IsFxSwapFarLeg()
                    return 'F' if farleg else 'S'
                elif self.trade.TradeInstrumentType().lower() == 'future/forward':
                    if self.trade.Type().lower() == 'normal':
                        return 'F'
                    elif self.trade.Type().lower() == 'closing':
                        return 'S'
                    else:
                        return None
            else:
                return None
        except:
            return None
            
    def farnearind(self):
        if self.trade.IsFxSwapFarLeg():
            return 'F'
        else:
            return 'N'
    
    def yield_8(self):
        try:
            return acm.Calculations().CreateCalculationSpace(acm.GetDefaultContext(),'FTradeSheet'). CreateCalculation(self.trade, 'Trade Yield').Value().Number() 
        except:
            return None
        
    def swapdealno(self):
        try:
            if self.trade.OptKey3().Name().lower() == 'fx' and self.trade.OptKey4().Name().lower() == 'swap':
                if self.trade.ConnectedTrades().IsEmpty():
                    return self.trade.ConnectedTrade().Oid()
                else: 
                    if len(self.trade.ConnectedTrades()) == 1:
                        return None
                    else:
                        for connection in self.trade.TradeConnections():
                            if connection.Type().Text().lower() =='fxswap' and connection.FromTrade() == self.trade and connection.ToTrade() != self.trade:
                                return connection.ToTrade().Oid()
            else:
                return None
        except:
            return None
    
    def swapvdate(self):
        try:
            if self.trade.OptKey3().Name().lower() == 'fx' and self.trade.OptKey4().Name().lower() == 'swap':
                if self.trade.ConnectedTrades().IsEmpty():
                    return self.trade.ConnectedTrade().ValueDay()
                else: 
                    if len(self.trade.ConnectedTrades()) == 1:
                        return None
                    else:
                        for connection in self.trade.TradeConnections():
                            if connection.Type().Text().lower() =='fxswap' and connection.FromTrade() == self.trade and connection.ToTrade() != self.trade:
                                return connection.ToTrade().ValueDay()
            else:
                return None
        except:
            return None
    
    def verind(self):
        try:
            return self.trade.Authorizer().Oid()
        except:
            return None
        
    def revreason(self):
        return self.trade.Text1()
    
    def settccy(self):
        try:
            return self.trade.Settlements().Last().Currency().Name()
        except:
            return None

    def server(self):
        try :
            return self.trade.OptKey2().Name()
        except:
            return None
    
    def ndealno(self):
        return self.trade.Oid()
    
    def fdealno(self):
        return self.trade.Oid()
    
    def nprodcode(self):
        try :
            return self.trade.OptKey3().Name()
        except:
            return None
        
    def fprodcode(self):
        try :
            return self.trade.OptKey3().Name()
        except:
            return None

    def ncno(self):
        try:
            return self.trade.Counterparty().Oid()
        except:
            return None
    
    def fcno(self):
        try:
            return self.trade.Counterparty().Oid()
        except:
            return None
    
    def nprodtype(self):
        try :
            return self.trade.OptKey4().Name()
        except:
            return None
        
    def fprodtype(self):
        try :
            return self.trade.OptKey4().Name()
        except:
            return None
        
    def nvdate(self):
        return self.trade.ValueDay()
    
    def fvdate(self):
        return self.trade.ValueDay()

    def brokerccy(self):
        try:
            return self.trade.Currency().Name()
        except:
            return None

    def corpport(self):
        try:
            return self.trade.Portfolio().Name()[:50]
        except:
            return None
    
    def corptrad(self):
        try:
            return self.trade.Trader().Oid()
        except:
            return None
    
    def corpcost(self):
        try:
            return self.trade.Portfolio().AddInfoValue('COST CENTER')
        except:
            return None
    
    def verdate(self):
        temp_time = self.trade.UpdateTime()
        formatted_time = time.strftime("%Y-%m-%d %H:%M:%S", time.strptime(time.ctime(temp_time)))
        return formatted_time
    
    def corpspreadamt(self):
        try:
            return acm.Calculations().CreateCalculationSpace(acm.GetDefaultContext(),'FTradeSheet'). CreateCalculation(self.trade, 'Trade Yield').Value().Number() 
        except:
            return None
    
    def fixratecode(self):
        try:
            return self.trade.Instrument().MainLeg().FloatRateReference().Name()
        except:
            return None
    
    def ratecode(self):
        try:
            return self.trade.Instrument().FixFxRate()
        except:
            return None
        
    def basis(self):
        try:
            return self.trade.Instrument().Legs().First().DayCountMethod()
        except:
            return None
    
    def spread_8(self):
        try:
            return acm.Calculations().CreateCalculationSpace(acm.GetDefaultContext(),'FTradeSheet'). CreateCalculation(self.trade, 'Trade Yield').Value().Number() 
        except:
            return None
            
    def agreementlinks(self):
        try:   
            return self.trade.AgreementLinks().First()
        except:
            return None
            
    def masteragreement(self):
        try:
            agreementLinks = self.agreementlinks()
            if agreementLinks:
                masterAgreement = agreementLinks.MasterAgreement()
                if masterAgreement:
                    return masterAgreement.Name()
                else:
                    return None
            else:
                return None
        except:
            return None
            
    def collateralannex(self):
        try:
            agreementLinks = self.agreementlinks()
            if agreementLinks:
                marginingSet = agreementLinks.MarginingSet()
                collateralAnnex = marginingSet.CollateralAnnex()
                if collateralAnnex:
                    return collateralAnnex.Name()
                else:
                    return None
            else:
                return None
        except:
            return None
            
    def marginingset(self):
        try:
            agreementLinks = self.agreementlinks()
            if agreementLinks:
                marginingSet = agreementLinks.MarginingSet()
                if marginingSet:
                    return marginingSet.Name()
                else:
                    return None
            else:
                return None
        except:
            return None

...

  LM_FI_TRANSACTION

from DataStager import *
from LIQMON import *

ael_gui_parameters={'runButtonLabel':'&&Run',
                    'hideExtraControls': True,
                    'windowCaption':'LM_FI_TRANSACTION'}

ael_variables=[
['query_folder','Query Folders','string', filter_query_folder('Trade'), 'WEBEAI_LM_FI_TRANSACTION', 1,0],
['file_path', 'Log Folder Path', getFilePathSelection(), None, getFilePathSelection(), 1, 1]]

def ael_main(parameter):
    text_result = ''
    table_name = 'LM_FI_TRANSACTION'
    columns = ('DEALNO', 'VDATE', 'SETTDATE', 'MDATE', 'DEALDATE', 'INPUTDATE', 'CNO', 'SECID', 'PRODUCT', 'PRODTYPE', 'CCY', 'PROCEEDAMT', 'FACEAMT', 'COSTAMT', 'QTY', 'PURCHINTAMT', 'ACCTNGTYPE_SECURITIES', 'YIELD_8_YIELD', 'PRICE_8_PRICE', 'SECSACCT_CUSTODIAN', 'CCYSACCT', 'DEALTEXT', 'FEDEALNO', 'WHTAMT_TAX', 'PORT', 'TRAD', 'COST', 'IOPER', 'VOPER', 'PAYOPER', 'AUTHOPER', 'REVOPER', 'REVAUTH', 'PS', 'INVTYPE', 'BENEFICIARY', 'ACCOUNT', 'INTERMEDIARY', 'REVERSE_DATE', 'AMEND_DATE', 'BR', 'STATUS', 'BROKER', 'BROKERAMT')
    file_path = str(parameter['file_path'])
    query_folder = parameter['query_folder']
    
    db_query = acm.FStoredASQLQuery[query_folder].Query()
    objects = db_query.Select()
    data = []
    
    liqmon_mod = LIQMON_Modules()
    
    for i in objects:
        liqmon_mod.set_trade(i)
        
        temp_result = (
            liqmon_mod.dealno(),
            liqmon_mod.valuedate(),
            liqmon_mod.settdate(),
            liqmon_mod.mdate(),
            liqmon_mod.dealdate(),
            liqmon_mod.inputdate(),
            liqmon_mod.cno(),
            liqmon_mod.secid(),
            liqmon_mod.product(),
            liqmon_mod.prodtype(),
            liqmon_mod.ccy(),
            liqmon_mod.proceedamt(),
            liqmon_mod.faceamt(),
            liqmon_mod.costamt(),
            liqmon_mod.qty(),
            liqmon_mod.purchintamt(),
            liqmon_mod.acctngtype_securities(),
            liqmon_mod.yield_8(),
            liqmon_mod.price_8(),
            liqmon_mod.secsacct(),
            liqmon_mod.ccysacct(),
            liqmon_mod.dealtext(),
            liqmon_mod.fedealno(),
            liqmon_mod.whtamt(),
            liqmon_mod.port(),
            liqmon_mod.trad(),
            liqmon_mod.cost(),
            liqmon_mod.ioper(),
            liqmon_mod.voper(),
            liqmon_mod.payoper(),
            liqmon_mod.authoper(),
            liqmon_mod.revoper(),
            liqmon_mod.revauth(),
            liqmon_mod.ps(),
            liqmon_mod.invtype(),
            liqmon_mod.beneficiary(),
            liqmon_mod.account(),
            liqmon_mod.intermediary(),
            liqmon_mod.reverse_date(),
            liqmon_mod.amend_date(),
            liqmon_mod.br(),
            liqmon_mod.status(),
            liqmon_mod.broker(),
            liqmon_mod.brokeramt(),
        )
        data.append(temp_result)
    

    data = list(set(data))
    text_result += "Table : " + table_name + "\n"
    text_result += "Columns : " + str(columns) + "\n"
    
    if data == [] :
        text_result += '\nNo new data to be inserted/updated.\n'
    else:
        dbOps = TableManipulator()
        cursor, text_connect = dbOps.connect()

        text_result += text_connect
        text_result += dbOps.upsert(table_name, columns, data, [columns[0]])
        #text_result += dbOps.delete_row_from_table(table_name, tuple(void_trades), columns[0])
        #text_result += dbOps.truncate([table_name])
        text_result += dbOps.disconnect()
        
    print(text_result)
    extension_value_name = table_name + '_LOG'
    storeToExtensionValue(extension_value_name, text_result)
    write_log_file(file_path, extension_value_name, text_result)



...

  LM_FI_TRANSACTION_INTERFACE

from DataStager import *
from LIQMON import *

ael_gui_parameters={'runButtonLabel':'&&Run',
                    'hideExtraControls': True,
                    'windowCaption':'LM_FI_TRANSACTION_INTERFACE'}

ael_variables=[
['query_folder','Query Folders','string', filter_query_folder('Trade'), 'WEBEAI_LM_FI_TRANSACTION_INTERFACE', 1,0],
['file_path', 'Log Folder Path', getFilePathSelection(), None, getFilePathSelection(), 1, 1]]

def ael_main(parameter):
    text_result = ''
    table_name = 'LM_FI_TRANSACTION_INTERFACE'
    columns = ('FEDEALNO', 'DEALNO', 'CNO', 'SECSACCT', 'PS', 'INVTYPE', 'PORT', 'TRAD', 'SECID', 'ORIGQTY', 'PRICE_8', 'SETTDATE', 'BROKFEEAMT', 'BROK', 'COST', 'RATECODE', 'INPUTDATE', 'DEALTEXT', 'VERIND', 'VERDATE', 'REVREASON', 'SETTCCY', 'SERVER', 'DEALDATE', 'AMENDTIME')
    file_path = str(parameter['file_path'])
    query_folder = parameter['query_folder']
    
    db_query = acm.FStoredASQLQuery[query_folder].Query()
    objects = db_query.Select()
    data = []
    
    liqmon_mod = LIQMON_Modules()
    
    for i in objects:
        liqmon_mod.set_trade(i)
        
        temp_result = (
            liqmon_mod.fedealno(),
            liqmon_mod.dealno(),
            liqmon_mod.cno(),
            liqmon_mod.secsacct(),
            liqmon_mod.ps(),
            liqmon_mod.invtype(),
            liqmon_mod.port(),
            liqmon_mod.trad(),
            liqmon_mod.secid(),
            liqmon_mod.qty(),
            liqmon_mod.price_8(),
            liqmon_mod.settdate(),
            liqmon_mod.brokeramt(),
            liqmon_mod.broker(),
            liqmon_mod.cost(),
            liqmon_mod.ratecode(),
            liqmon_mod.inputdate(),
            liqmon_mod.dealtext(),
            liqmon_mod.verind(),
            liqmon_mod.verdate(),
            liqmon_mod.revreason(),
            liqmon_mod.settccy(),
            liqmon_mod.server(),
            liqmon_mod.dealdate(),
            liqmon_mod.amend_date()
        )
        data.append(temp_result)
    

    data = list(set(data))
    text_result += "Table : " + table_name + "\n"
    text_result += "Columns : " + str(columns) + "\n"
    
    if data == [] :
        text_result += '\nNo new data to be inserted/updated.\n'
    else:
        dbOps = TableManipulator()
        cursor, text_connect = dbOps.connect()

        text_result += text_connect
        text_result += dbOps.upsert(table_name, columns, data, [columns[1]])
        #text_result += dbOps.delete_row_from_table(table_name, tuple(void_trades), columns[0])
        #text_result += dbOps.truncate([table_name])
        text_result += dbOps.disconnect()
        
    print(text_result)
    extension_value_name = table_name + '_LOG'
    storeToExtensionValue(extension_value_name, text_result)
    write_log_file(file_path, extension_value_name, text_result)



...

  LM_FX_TRANSACTION

from DataStager import *
from LIQMON import *

ael_gui_parameters={'runButtonLabel':'&&Run',
                    'hideExtraControls': True,
                    'windowCaption':'LM_FX_TRANSACTION'}

ael_variables=[
['query_folder','Query Folders','string', filter_query_folder('Trade'), 'WEBEAI_LM_FX_TRANSACTION', 1,0],
['file_path', 'Log Folder Path', getFilePathSelection(), None, getFilePathSelection(), 1, 1]]

def ael_main(parameter):
    text_result = ''
    table_name = 'LM_FX_TRANSACTION'
    columns = ('DEALNO', 'VDATE', 'SWAPDEALNO', 'SWAPVDATE', 'CNO', 'DEALDATE', 'INPUTDATE', 'PRODCODE', 'PRODTYPE', 'FARNEARIND', 'CCY', 'CCYAMT', 'CTRCCY', 'CTRAMT', 'PS', 'CCODE', 'ACCTNGTYPE_CUSTOMER', 'PORT', 'TRAD', 'COST', 'IOPER', 'VOPER', 'PAYOPER', 'AUTHOPER', 'REVOPER', 'REVAUTH', 'DEALTEXT', 'FEDEALNO', 'CCYSMEANS', 'CCYSACCT', 'CTRCCYSMEANS', 'CTRSACCT', 'SPOTFWDIND', 'RATE', 'BR', 'STATUS', 'BROKER', 'REVERSE_DATE', 'AMEND_DATE', 'BROKERAMT')
        
    file_path = str(parameter['file_path'])
    query_folder = parameter['query_folder']
    
    db_query = acm.FStoredASQLQuery[query_folder].Query()
    objects = db_query.Select()
    data = []
    
    liqmon_mod = LIQMON_Modules()
    
    for i in objects:
        liqmon_mod.set_trade(i)
        
        temp_result = (
            liqmon_mod.dealno(), 
            liqmon_mod.valuedate(), 
            liqmon_mod.swapdealno(), 
            liqmon_mod.swapvdate(),     
            liqmon_mod.cno(),
            liqmon_mod.dealdate(),
            liqmon_mod.inputdate(),
            liqmon_mod.product(),
            liqmon_mod.prodtype(),
            liqmon_mod.farnearind(),
            liqmon_mod.ccy(),
            liqmon_mod.ccyamt(),
            liqmon_mod.ctrccy(),
            liqmon_mod.ctramt(),
            liqmon_mod.ps(),
            liqmon_mod.ccode(),
            liqmon_mod.acctngtype(),
            liqmon_mod.port(),
            liqmon_mod.trad(),
            liqmon_mod.cost(),
            liqmon_mod.ioper(),
            liqmon_mod.voper(),
            liqmon_mod.payoper(),
            liqmon_mod.authoper(),
            liqmon_mod.revoper(),
            liqmon_mod.revauth(),
            liqmon_mod.dealtext(),
            liqmon_mod.fedealno(),
            liqmon_mod.ccysmeans(),
            liqmon_mod.ccysacct(),
            liqmon_mod.ctrccysmeans(),
            liqmon_mod.ctrsacct(),
            liqmon_mod.spotfwd(),
            liqmon_mod.rate(),
            liqmon_mod.br(), 
            liqmon_mod.status(),
            liqmon_mod.broker(),
            liqmon_mod.reverse_date(),
            liqmon_mod.amend_date(),
            liqmon_mod.brokeramt()
        )
        data.append(temp_result)
    
    data = list(set(data))
    text_result += "Table : " + table_name + "\n"
    text_result += "Columns : " + str(columns) + "\n"
    
    if data == [] :
        text_result += '\nNo new data to be inserted/updated.\n'
    else:
        dbOps = TableManipulator()
        cursor, text_connect = dbOps.connect()

        text_result += text_connect
        text_result += dbOps.upsert(table_name, columns, data, [columns[0]])
        #text_result += dbOps.delete_row_from_table(table_name, tuple(void_trades), columns[0])
        #text_result += dbOps.truncate([table_name])
        text_result += dbOps.disconnect()
        
    print(text_result)
    extension_value_name = table_name + '_LOG'
    storeToExtensionValue(extension_value_name, text_result)
    write_log_file(file_path, extension_value_name, text_result)



...

  LM_FX_TRANSACTION_INTERFACE

from DataStager import *
from LIQMON import *

ael_gui_parameters={'runButtonLabel':'&&Run',
                    'hideExtraControls': True,
                    'windowCaption':'LM_FX_TRANSACTION_INTERFACE'}

ael_variables=[
['query_folder','Query Folders','string', filter_query_folder('Trade'), 'WEBEAI_LM_FX_TRANSACTION_INTERFACE', 1,0],
['file_path', 'Log Folder Path', getFilePathSelection(), None, getFilePathSelection(), 1, 1]]

def ael_main(parameter):
    text_result = ''
    table_name = 'LM_FX_TRANSACTION_INTERFACE'
    columns = ('SERVER', 'FEDEALNO', 'DEALNO', 'NDEALNO', 'FDEALNO', 'TRAD', 'VDATE', 'NVDATE', 'FVDATE', 'CNO', 'BROK', 'BROKCCY', 'BROKAMT', 'PORT', 'COST', 'DEALDATE', 'DEALTEXT', 'PS', 'CCY', 'CCYAMT', 'CTRCCY', 'CTRAMT', 'PRODCODE', 'PRODTYPE', 'REVREASON', 'CORPTRAD', 'CORPPORT', 'CORPCOST', 'INTERNALRATE_8', 'CORPSPREADAMT', 'FIXRATECODE', 'NPRODCODE', 'FPRODCODE', 'NPRODTYPE', 'FPRODTYPE', 'NCNO', 'FCNO', 'AMENDTIME')
        
    file_path = str(parameter['file_path'])
    query_folder = parameter['query_folder']
    
    db_query = acm.FStoredASQLQuery[query_folder].Query()
    objects = db_query.Select()
    data = []
    
    liqmon_mod = LIQMON_Modules()
    
    for i in objects:
        liqmon_mod.set_trade(i)
        
        temp_result = (
            liqmon_mod.server(), 
            liqmon_mod.fedealno(), 
            liqmon_mod.dealno(), 
            liqmon_mod.ndealno(),     
            liqmon_mod.fdealno(),
            liqmon_mod.trad(),
            liqmon_mod.valuedate(),
            liqmon_mod.nvdate(),
            liqmon_mod.fvdate(),
            liqmon_mod.cno(),
            liqmon_mod.broker(),
            liqmon_mod.brokerccy(),
            liqmon_mod.brokeramt(),
            liqmon_mod.port(),
            liqmon_mod.cost(),
            liqmon_mod.dealdate(),
            liqmon_mod.dealtext(),
            liqmon_mod.ps(),
            liqmon_mod.ccy(),
            liqmon_mod.ccyamt(),
            liqmon_mod.ctrccy(),
            liqmon_mod.ctramt(),
            liqmon_mod.product(),
            liqmon_mod.prodtype(),
            liqmon_mod.revreason(),
            liqmon_mod.corptrad(),
            liqmon_mod.corpport(),
            liqmon_mod.corpcost(),
            liqmon_mod.intrate_8(),
            liqmon_mod.corpspreadamt(),
            liqmon_mod.fixratecode(),
            liqmon_mod.nprodcode(),
            liqmon_mod.fprodcode(),
            liqmon_mod.nprodtype(),
            liqmon_mod.fprodtype(),
            liqmon_mod.ncno(), 
            liqmon_mod.fcno(),
            liqmon_mod.amend_date()
        )
        data.append(temp_result)
    
    data = list(set(data))
    text_result += "Table : " + table_name + "\n"
    text_result += "Columns : " + str(columns) + "\n"
    
    if data == [] :
        text_result += '\nNo new data to be inserted/updated.\n'
    else:
        dbOps = TableManipulator()
        cursor, text_connect = dbOps.connect()

        text_result += text_connect
        text_result += dbOps.upsert(table_name, columns, data, [columns[2]])
        #text_result += dbOps.delete_row_from_table(table_name, tuple(void_trades), columns[0])
        #text_result += dbOps.truncate([table_name])
        text_result += dbOps.disconnect()
        
    print(text_result)
    extension_value_name = table_name + '_LOG'
    storeToExtensionValue(extension_value_name, text_result)
    write_log_file(file_path, extension_value_name, text_result)



...

  LM_MM_TRANSACTION

from DataStager import *
from LIQMON import *

ael_gui_parameters={'runButtonLabel':'&&Run',
                    'hideExtraControls': True,
                    'windowCaption':'LM_MM_TRANSACTION'}

ael_variables=[
['query_folder','Query Folders','string', filter_query_folder('Trade'), 'WEBEAI_LM_MM_TRANSACTION', 1,0],
['file_path', 'Log Folder Path', getFilePathSelection(), None, getFilePathSelection(), 1, 1]]

def ael_main(parameter):
    text_result = ''
    table_name = 'LM_MM_TRANSACTION'
    columns = ('DEALNO', 'VDATE', 'MDATE', 'CNO', 'DEALDATE', 'INPUTDATE', 'PRODUCT', 'PRODTYPE', 'CCY', 'CCYAMT', 'TOTPAYAMT', 'INTAMT', 'INTRATE_8', 'PORT', 'TRAD', 'COST', 'IOPER', 'VOPER', 'PAYOPER', 'AUTHOPER', 'REVOPER', 'REVAUTH', 'DEALTEXT', 'FEDEALNO', 'SMEANS', 'SACCT', 'INTSMEANS', 'INTSACCT', 'INTENDDTE', 'BR', 'STATUS', 'BROKER', 'REVERSE_DATE', 'AMEND_DATE', 'BROKERAMT')
    file_path = str(parameter['file_path'])
    query_folder = parameter['query_folder']
    
    db_query = acm.FStoredASQLQuery[query_folder].Query()
    objects = db_query.Select()
    data = []
    
    liqmon_mod = LIQMON_Modules()
    
    for i in objects:
        liqmon_mod.set_trade(i)
        
        temp_result = (
            liqmon_mod.dealno(),
            liqmon_mod.valuedate(),
            liqmon_mod.mdate(),
            liqmon_mod.cno(),
            liqmon_mod.dealdate(),
            liqmon_mod.inputdate(),
            liqmon_mod.product(),
            liqmon_mod.prodtype(),
            liqmon_mod.ccy(),
            liqmon_mod.ccyamt(),            
            liqmon_mod.totpayamt(),   
            liqmon_mod.intamt(),
            liqmon_mod.intrate_8(),
            liqmon_mod.port(),
            liqmon_mod.trad(),
            liqmon_mod.cost(),
            liqmon_mod.ioper(),
            liqmon_mod.voper(),
            liqmon_mod.payoper(),
            liqmon_mod.authoper(),
            liqmon_mod.revoper(),
            liqmon_mod.revauth(),
            liqmon_mod.dealtext(),
            liqmon_mod.fedealno(),
            liqmon_mod.smeans(),
            liqmon_mod.sacct(),
            liqmon_mod.intsmeans(),
            liqmon_mod.intsacct(),
            liqmon_mod.intenddate(),
            liqmon_mod.br(),
            liqmon_mod.status(),
            liqmon_mod.broker(),
            liqmon_mod.reverse_date(),
            liqmon_mod.amend_date(),
            liqmon_mod.brokeramt(),
        )
        data.append(temp_result)

    data = list(set(data))
    text_result += "Table : " + table_name + "\n"
    text_result += "Columns : " + str(columns) + "\n"
    
    if data == [] :
        text_result += '\nNo new data to be inserted/updated.\n'
    else:
        dbOps = TableManipulator()
        cursor, text_connect = dbOps.connect()

        text_result += text_connect
        text_result += dbOps.upsert(table_name, columns, data, [columns[0]])
        #text_result += dbOps.delete_row_from_table(table_name, tuple(void_trades), columns[0])
        #text_result += dbOps.truncate([table_name])
        text_result += dbOps.disconnect()
        
    print(text_result)
    extension_value_name = table_name + '_LOG'
    storeToExtensionValue(extension_value_name, text_result)
    write_log_file(file_path, extension_value_name, text_result)





...

  LM_MM_TRANSACTION_INTERFACE

from DataStager import *
from LIQMON import *

ael_gui_parameters={'runButtonLabel':'&&Run',
                    'hideExtraControls': True,
                    'windowCaption':'LM_MM_TRANSACTION_INTERFACE'}

ael_variables=[
['query_folder','Query Folders','string', filter_query_folder('Trade'), 'WEBEAI_LM_MM_TRANSACTION_INTERFACE', 1,0],
['file_path', 'Log Folder Path', getFilePathSelection(), None, getFilePathSelection(), 1, 1]]

def ael_main(parameter):
    text_result = ''
    table_name = 'LM_MM_TRANSACTION_INTERFACE'
    columns = ('SERVER', 'FEDEALNO', 'DEALNO', 'PRODUCT', 'PRODTYPE', 'TRAD', 'VDATE', 'MDATE', 'CNO', 'CCY', 'CCYAMT', 'RATECODE', 'BASIS', 'INTRATE', 'SPREAD_8', 'BROK', 'BROKCCY', 'BROKAMT', 'PORT', 'COST', 'DEALDATE', 'DEALTEXT', 'VERIND', 'INPUTDATE', 'AMENDTIME')
    file_path = str(parameter['file_path'])
    query_folder = parameter['query_folder']
    
    db_query = acm.FStoredASQLQuery[query_folder].Query()
    objects = db_query.Select()
    data = []
    
    liqmon_mod = LIQMON_Modules()
    
    for i in objects:
        liqmon_mod.set_trade(i)
        
        temp_result = (
            liqmon_mod.server(),
            liqmon_mod.fedealno(),
            liqmon_mod.dealno(),
            liqmon_mod.product(),
            liqmon_mod.prodtype(),
            liqmon_mod.trad(),
            liqmon_mod.valuedate(),
            liqmon_mod.mdate(),
            liqmon_mod.cno(),
            liqmon_mod.ccy(),
            liqmon_mod.ccyamt(),
            liqmon_mod.ratecode(),
            liqmon_mod.basis(),
            liqmon_mod.intrate_8(),
            liqmon_mod.spread_8(),
            liqmon_mod.broker(),
            liqmon_mod.brokerccy(),
            liqmon_mod.brokeramt(),
            liqmon_mod.port(),
            liqmon_mod.cost(),
            liqmon_mod.dealdate(),
            liqmon_mod.dealtext(),
            liqmon_mod.verind(),
            liqmon_mod.inputdate(),
            liqmon_mod.amend_date()
        )
        data.append(temp_result)

    data = list(set(data))
    text_result += "Table : " + table_name + "\n"
    text_result += "Columns : " + str(columns) + "\n"
    
    if data == [] :
        text_result += '\nNo new data to be inserted/updated.\n'
    else:
        dbOps = TableManipulator()
        cursor, text_connect = dbOps.connect()

        text_result += text_connect
        text_result += dbOps.upsert(table_name, columns, data, [columns[2]])
        #text_result += dbOps.delete_row_from_table(table_name, tuple(void_trades), columns[0])
        #text_result += dbOps.truncate([table_name])
        text_result += dbOps.disconnect()
        
    print(text_result)
    extension_value_name = table_name + '_LOG'
    storeToExtensionValue(extension_value_name, text_result)
    write_log_file(file_path, extension_value_name, text_result)





...

  PDN

import acm, ael, time

class PDN_Modules:
    
    def __init__(self):
        pass
    
    def set_trade(self, trade):
        self.trade = trade

    def dealno(self):
        return self.trade.Oid()
        #return self.trade.AdditionalInfo().DealNO()
        
    def swapdealno(self):
        try:
            if self.trade.OptKey3().Name().lower() == 'fx' and self.trade.OptKey4().Name().lower() == 'swap':
                if self.trade.ConnectedTrades().IsEmpty():
                    return self.trade.ConnectedTrade().Oid()
                else: 
                    if len(self.trade.ConnectedTrades()) == 1:
                        return None
                    else:
                        for connection in self.trade.TradeConnections():
                            if connection.Type().Text().lower() =='fxswap' and connection.FromTrade() == self.trade and connection.ToTrade() != self.trade:
                                return connection.ToTrade().Oid()
            else:
                return None
        except:
            return None
            
    def premium_ccy(self):
        return self.trade.Currency().Name()

    def premium_amount(self):
        return self.trade.Premium()
        
    def valuedate(self):
        try:
            if str(self.trade.InstrumentSubType()) == 'NDF':
                return self.trade.RightDate()
            return self.trade.ValueDay()
        except:
            return None

    def swapvdate(self):
        try:
            if self.trade.OptKey3().Name().lower() == 'fx' and self.trade.OptKey4().Name().lower() == 'swap':
                if self.trade.ConnectedTrades().IsEmpty():
                    return self.trade.ConnectedTrade().ValueDay()
                else: 
                    if len(self.trade.ConnectedTrades()) == 1:
                        return None
                    else:
                        for connection in self.trade.TradeConnections():
                            if connection.Type().Text().lower() =='fxswap' and connection.FromTrade() == self.trade and connection.ToTrade() != self.trade:
                                return connection.ToTrade().ValueDay()
            else:
                return None
        except:
            return None
        
    def tradedate(self):
        return self.trade.TradeTime()
        
    def status(self):
        return self.trade.Status()
    
    def cno(self):
        try:
            party = self.trade.Counterparty()
            hostId = party.HostId()
            if hostId.strip():
                return hostId
            else:
                alias = party.Id2()
                if alias.isdigit():
                    return alias
                else:
                    return party.Id().split("_")[0]
        except:
            return None
        
    def dealdate(self):
        temp_time = self.trade.TradeTime()
        temp_time = acm.Time.DateTimeToTime(temp_time)
        formatted_time = time.strftime("%Y-%m-%d %H:%M:%S", time.strptime(time.ctime(temp_time)))
        return formatted_time
    
    def inputdate(self):
        temp_time = self.trade.CreateTime()
        formatted_time = time.strftime("%Y-%m-%d %H:%M:%S", time.strptime(time.ctime(temp_time)))
        return formatted_time
        
    def dealtext(self):
        return self.trade.Text1()
    
    def br(self):
        try:
            return self.trade.OptKey1().Name()
        except:
            return None
        
    def product(self):
        try:
            return self.trade.OptKey3().Name()
        except:
            return None
    
    def prodtype(self):
        try:
            return self.trade.OptKey4().Name()
        except:
            return None
        
    def ccy(self):
        if not self.trade.PositionOrInstrumentPair():
            return self.trade.Currency().Name()
        else:
            return self.trade.PositionOrInstrumentPair().Instrument1().Name()
    
    def ctrccy(self):
        if not self.trade.PositionOrInstrumentPair():
            return None
        else:
            return self.trade.PositionOrInstrumentPair().Instrument2().Name()
            
    def ccyamt(self):
        try:
            return self.trade.Position()
        except:
            return None
            
    def ctramt(self):
        try:
            if self.trade.InstrumentSubType().Text().lower() == 'fx option':
                return (-1) * self.ccyamt() * self.trade.Instrument().StrikePrice()
            else:
                return (-1) * self.ccyamt() * self.trade.Price()
        except:
            return None
        
    def ccode(self):
        try:
            return self.trade.Counterparty().Country()
        except:
            return None
    
    def spotfwd(self):
        try:
            if self.product().lower() == 'fx':
                if self.prodtype().lower() in ('tod', 'tom', 'spot'):
                    return 'S'
                elif self.prodtype().lower() == 'fwd':
                    return 'F'
                elif self.prodtype().lower() == 'swap':
                    farleg = self.trade.IsFxSwapFarLeg()
                    return 'F' if farleg else 'S'
                elif self.trade.TradeInstrumentType().lower() == 'future/forward':
                    if self.trade.Type().lower() == 'normal':
                        return 'F'
                    elif self.trade.Type().lower() == 'closing':
                        return 'S'
                    else:
                        return None
            else:
                return None
        except:
            return None
        
    def rate(self):
        try:
            if self.trade.TradeInstrumentType().lower() == 'option':
                return self.trade.Instrument().StrikePrice()
            elif self.trade.TradeInstrumentType().lower() == 'currswap':
                return self.trade.Instrument().RecLeg().NominalFactor()
            else:
                return self.trade.Price()
        except:
            return None
        
    def ctrrate(self):
        try:
            baseCurr = self.trade.Currency().Name()
            if baseCurr == 'IDR':
                return 1.0
            else:
                try:
                    currPair_idr = '{}/IDR'.format(baseCurr)
                    currPair_idr = acm.FCurrencyPair[currPair_idr]
                    spotPrice = currPair_idr.SpotPrice(acm.Time.DateToday(), False)
                    return spotPrice
                except:
                    return None
                
        except:
            return None
    
    def farnearind(self):
        if self.trade.IsFxSwapFarLeg():
            return 'F'
        else:
            return 'N'
        
    def cost(self):
        try:
            return self.trade.Portfolio().AddInfoValue('COST CENTER')
        except:
            return None
        
    def fedealno(self):
        try:
            return self.trade.OptionalKey()
        except:
            return None
        
    def ps(self):
        if self.trade.Quantity() >= 0:
            return 'P'
        else:
            return 'S'
    
    def port(self):
        try:
            return self.trade.Portfolio().Name()[:50]
        except:
            return None
    
    def trad(self):
        try:
            return self.trade.Trader().Oid()
        except:
            return None
    
    def ioper(self):
        try:
            return self.trade.CreateUser().Oid()
        except:
            return None
        
    def voper(self):
        try:
            return self.trade.UpdateUser().Oid()
        except:
            return None
    
    def payoper(self):
        try:
            return self.trade.Payments().Last().CreateUser().Oid()
        except:
            return None
            
    def authoper(self):
        try:
            return self.trade.Authorizer().Oid()
        except:
            return None
    
    def revoper(self):
        try:
            return self.trade.UpdateUser().Oid()
        except:
            return None

    def revauth(self):
        try:
            return self.trade.Authorizer().Oid()
        except:
            return None

    def revdate(self):
        if ('void' not in self.status().lower()):
            return None
        else:
            ths = acm.FTransactionHistory.Select('transRecordType="Trade" and recordId={}'.format(self.trade.Oid()))
            for th in ths:
                newVal = th.NewFieldValue('status', 'Trade')
                if (newVal is not None):
                    if ('void' in newVal.lower()):
                        temp_time = th.UpdateTime()
                        return time.strftime("%Y-%m-%d %H:%M:%S", time.strptime(time.ctime(temp_time)))
    
    def convert_network_name(self, account_object):
        network_name = account_object.NetworkAliasType().Name().lower()
        if network_name == 'emas':
            return 'EMARETL'
        elif network_name in ('swift', 'rtgs'):
            return 'NOS'
        else:
            return None
    
    def get_account(self, account_object):
        network = self.convert_network_name(account_object)
        if network == 'EMARETL':
            return account_object.Account()
        elif network == 'NOS':
            return account_object.Name()
        else:
            return None

    def ccysmeans(self):
        try:   
            moneyFlows = self.trade.MoneyFlows()
            if moneyFlows:
                for mf in moneyFlows:
                    party_account = mf.AcquirerAccount()
                    if self.trade.TradeInstrumentType().lower() == 'curr':
                        if mf.Currency() == self.trade.Instrument():
                            return self.convert_network_name(party_account)
                        else:
                            continue
                    else:
                        if mf.Currency() == self.trade.Currency():
                            return self.convert_network_name(party_account)
                        else:
                            continue
                return None
            else:
                return None
        except:
            return None
        
    def ctrccysmeans(self):
        try:   
            moneyFlows = self.trade.MoneyFlows()
            if moneyFlows:
                for mf in moneyFlows:
                    party_account = mf.AcquirerAccount()
                    if self.trade.TradeInstrumentType().lower() == 'curr':
                        if mf.Currency() == self.trade.Currency():
                            return self.convert_network_name(party_account)
                        else:
                            continue
                    else:
                        return None
                return None
            else:
                return None
        except:
            return None
    
    def ccysacct(self):
        try:   
            moneyFlows = self.trade.MoneyFlows()
            if moneyFlows:
                for mf in moneyFlows:
                    party_account = mf.AcquirerAccount()
                    if self.trade.TradeInstrumentType().lower() == 'curr':
                        if mf.Currency() == self.trade.Instrument():
                            return self.get_account(party_account)
                        else:
                            continue
                    else:
                        if mf.Currency() == self.trade.Currency():
                            return self.get_account(party_account)
                        else:
                            continue
                return None
            else:
                return None
        except:
            return None
        
    def ctrsacct(self):
        try:   
            moneyFlows = self.trade.MoneyFlows()
            if moneyFlows:
                for mf in moneyFlows:
                    party_account = mf.AcquirerAccount()
                    if self.trade.TradeInstrumentType().lower() == 'curr':
                        if mf.Currency() == self.trade.Currency():
                            return self.get_account(party_account)
                        else:
                            continue
                    else:
                        return None
                return None
            else:
                return None
        except:
            return None
    
    def acctngtype(self):
        try:
            return self.trade.OptKey3().Name()
        except:
            return None
        

...

  PDN_CALLSPREAD

from DataStager import *
from PDN import *

ael_gui_parameters={'runButtonLabel':'&&Run',
                    'hideExtraControls': True,
                    'windowCaption':'PDN_CALLSPREAD'}

ael_variables=[
['query_folder','Query Folders','string', filter_query_folder('Trade'), 'WEBEAI_PDN_CALLSPREAD', 1,0],
['file_path', 'Log Folder Path', getFilePathSelection(), None, getFilePathSelection(), 1, 1]]

def ael_main(parameter):
    text_result = ''
    table_name = 'PDN_CALLSPREAD'
    columns = ('DEALNO', 'PREMIUM_CCY', 'PREMIUM_AMOUNT', 'VALUEDATE', 'TRADEDATE', 'TRADESTATUS')
    file_path = str(parameter['file_path'])
    query_folder = parameter['query_folder']
    
    db_query = acm.FStoredASQLQuery[query_folder].Query()
    trades = db_query.Select()
    data = []
    pdn_mod = PDN_Modules()
    
    for i in trades:
        pdn_mod.set_trade(i)
        temp_result = (
            pdn_mod.dealno(),
            pdn_mod.premium_ccy(),
            pdn_mod.premium_amount(),
            pdn_mod.valuedate(),
            pdn_mod.tradedate(),
            pdn_mod.status()
        )
        data.append(temp_result)

    data = list(set(data))
    text_result += "Table : " + table_name + "\n"
    text_result += "Columns : " + str(columns) + "\n"
    
    if data == [] :
        text_result += '\nNo new data to be inserted/updated.\n'
    else:
        dbOps = TableManipulator()
        cursor, text_connect = dbOps.connect()

        text_result += text_connect
        text_result += dbOps.upsert(table_name, columns, data, [columns[0]])
        #text_result += dbOps.delete_row_from_table(table_name, tuple(void_trades), columns[0])
        #text_result += dbOps.truncate([table_name])
        text_result += dbOps.disconnect()
        
    print(text_result)
    extension_value_name = table_name + '_LOG'
    storeToExtensionValue(extension_value_name, text_result)
    write_log_file(file_path, extension_value_name, text_result)

        

...

  PDN_DCI

from DataStager import *
from PDN import *

ael_gui_parameters={'runButtonLabel':'&&Run',
                    'hideExtraControls': True,
                    'windowCaption':'PDN_DCI'}

ael_variables=[
['query_folder','Query Folders','string', filter_query_folder('Trade'), 'WEBEAI_PDN_DCI', 1,0],
['file_path', 'Log Folder Path', getFilePathSelection(), None, getFilePathSelection(), 1, 1]]

def ael_main(parameter):
    text_result = ''
    table_name = 'PDN_DCI'
    columns = ('DEALNO', 'PREMIUM_CCY', 'PREMIUM_AMOUNT', 'VALUEDATE', 'TRADEDATE', 'TRADESTATUS')
    file_path = str(parameter['file_path'])
    query_folder = parameter['query_folder']
    
    
    db_query = acm.FStoredASQLQuery[query_folder].Query()
    trades = db_query.Select()
    data = []
    pdn_mod = PDN_Modules()
    
    for i in trades:
        pdn_mod.set_trade(i)
        temp_result = (
            pdn_mod.dealno(),
            pdn_mod.premium_ccy(),
            pdn_mod.premium_amount(),
            pdn_mod.valuedate(),
            pdn_mod.tradedate(),
            pdn_mod.status()
        )
        data.append(temp_result)

    data = list(set(data))
    text_result += "Table : " + table_name + "\n"
    text_result += "Columns : " + str(columns) + "\n"
    
    if data == [] :
        text_result += '\nNo new data to be inserted/updated.\n'
    else:
        dbOps = TableManipulator()
        cursor, text_connect = dbOps.connect()

        text_result += text_connect
        text_result += dbOps.upsert(table_name, columns, data, [columns[0]])
        #text_result += dbOps.delete_row_from_table(table_name, tuple(void_trades), columns[0])
        #text_result += dbOps.truncate([table_name])
        text_result += dbOps.disconnect()
        
    print(text_result)
    extension_value_name = table_name + '_LOG'
    storeToExtensionValue(extension_value_name, text_result)
    write_log_file(file_path, extension_value_name, text_result)

        

...

  PDN_FX_TRANSACTION

from DataStager import *
from PDN import *

ael_gui_parameters={'runButtonLabel':'&&Run',
                    'hideExtraControls': True,
                    'windowCaption':'PDN_FX_TRANSACTION'}

ael_variables=[
['query_folder','Query Folders','string', filter_query_folder('Trade'), 'WEBEAI_PDN_FX_TRANSACTION', 1,0],
['file_path', 'Log Folder Path', getFilePathSelection(), None, getFilePathSelection(), 1, 1]]

def ael_main(parameter):
    text_result = ''
    table_name = 'PDN_FX_TRANSACTION'
    columns = ('DEALNO', 'VDATE', 'SWAPDEALNO', 'SWAPVDATE', 'CNO', 'DEALDATE', 'INPUTDATE', 'PRODCODE', 'PRODTYPE', 'FARNEARIND', 'CCY', 'CCYAMT', 'CTRCCY', 'CTRAMT', 'PS', 'CCODE', 'ACCTNGTYPE_CUSTOMER', 'PORT', 'TRAD', 'COST', 'IOPER', 'VOPER', 'PAYOPER', 'AUTHOPER', 'REVOPER', 'REVAUTH', 'REVDATE', 'DEALTEXT', 'FEDEALNO', 'CCYSMEANS', 'CCYSACCT', 'CTRCCYSMEANS', 'CTRSACCT', 'SPOTFWDIND', 'RATE', 'CTRRATE', 'BR', 'STATUS')
    file_path = str(parameter['file_path'])
    query_folder = parameter['query_folder']
    
    db_query = acm.FStoredASQLQuery[query_folder].Query()
    objects = db_query.Select()
    data = []
    
    pdn_mod = PDN_Modules()
    
    for i in objects:
        pdn_mod.set_trade(i)
        
        temp_result = (
            pdn_mod.dealno(), 
            pdn_mod.valuedate(), 
            pdn_mod.swapdealno(), 
            pdn_mod.swapvdate(),     
            pdn_mod.cno(),
            pdn_mod.dealdate(),
            pdn_mod.inputdate(),
            pdn_mod.product(),
            pdn_mod.prodtype(),
            pdn_mod.farnearind(), 
            pdn_mod.ccy(),
            pdn_mod.ccyamt(),
            pdn_mod.ctrccy(),
            pdn_mod.ctramt(),
            pdn_mod.ps(),
            pdn_mod.ccode(),
            pdn_mod.acctngtype(),
            pdn_mod.port(),
            pdn_mod.trad(),
            pdn_mod.cost(),
            pdn_mod.ioper(),
            pdn_mod.voper(),
            pdn_mod.payoper(),
            pdn_mod.authoper(),
            pdn_mod.revoper(),
            pdn_mod.revauth(),
            pdn_mod.revdate(),
            pdn_mod.dealtext(),
            pdn_mod.fedealno(),
            pdn_mod.ccysmeans(),
            pdn_mod.ccysacct(),
            pdn_mod.ctrccysmeans(),
            pdn_mod.ctrsacct(),
            pdn_mod.spotfwd(),
            pdn_mod.rate(),
            pdn_mod.ctrrate(),
            pdn_mod.br(), 
            pdn_mod.status()
        )
        data.append(temp_result)
    
    data = list(set(data))
    text_result += "Table : " + table_name + "\n"
    text_result += "Columns : " + str(columns) + "\n"
    
    if data == [] :
        text_result += '\nNo new data to be inserted/updated.\n'
    else:
        dbOps = TableManipulator()
        cursor, text_connect = dbOps.connect()

        text_result += text_connect
        text_result += dbOps.upsert(table_name, columns, data, [columns[0]])
        #text_result += dbOps.delete_row_from_table(table_name, tuple(void_trades), columns[0])
        #text_result += dbOps.truncate([table_name])
        text_result += dbOps.disconnect()
        
    print(text_result)
    extension_value_name = table_name + '_LOG'
    storeToExtensionValue(extension_value_name, text_result)
    write_log_file(file_path, extension_value_name, text_result)

    


        
    
        
    

...

  PDN_FXOPTION

from DataStager import *
from PDN import *

ael_gui_parameters={'runButtonLabel':'&&Run',
                    'hideExtraControls': True,
                    'windowCaption':'PDN_FXOPTION'}

ael_variables=[
['query_folder','Query Folders','string', filter_query_folder('Trade'), 'WEBEAI_PDN_FXOPTION', 1,0],
['file_path', 'Log Folder Path', getFilePathSelection(), None, getFilePathSelection(), 1, 1]]

def ael_main(parameter):
    text_result = ''
    table_name = 'PDN_FXOPTION'
    columns = ('DEALNO', 'PREMIUM_CCY', 'PREMIUM_AMOUNT', 'VALUEDATE', 'TRADEDATE', 'TRADESTATUS')
    file_path = str(parameter['file_path'])
    query_folder = parameter['query_folder']
    
    
    db_query = acm.FStoredASQLQuery[query_folder].Query()
    trades = db_query.Select()
    data = []
    pdn_mod = PDN_Modules()
    
    for i in trades:
        pdn_mod.set_trade(i)
        temp_result = (
            pdn_mod.dealno(),
            pdn_mod.premium_ccy(),
            pdn_mod.premium_amount(),
            pdn_mod.valuedate(),
            pdn_mod.tradedate(),
            pdn_mod.status()
        )
        data.append(temp_result)

    data = list(set(data))
    text_result += "Table : " + table_name + "\n"
    text_result += "Columns : " + str(columns) + "\n"
    
    if data == [] :
        text_result += '\nNo new data to be inserted/updated.\n'
    else:
        dbOps = TableManipulator()
        cursor, text_connect = dbOps.connect()

        text_result += text_connect
        text_result += dbOps.upsert(table_name, columns, data, [columns[0]])
        #text_result += dbOps.delete_row_from_table(table_name, tuple(void_trades), columns[0])
        #text_result += dbOps.truncate([table_name])
        text_result += dbOps.disconnect()
        
    print(text_result)
    extension_value_name = table_name + '_LOG'
    storeToExtensionValue(extension_value_name, text_result)
    write_log_file(file_path, extension_value_name, text_result)

        

...

  PDN_PAR_FORWARD

from DataStager import *
from PDN import *

ael_gui_parameters={'runButtonLabel':'&&Run',
                    'hideExtraControls': True,
                    'windowCaption':'PDN_PAR_FORWARD'}

ael_variables=[
['query_folder','Query Folders','string', filter_query_folder('Trade'), 'WEBEAI_PDN_PAR_FORWARD', 1,0],
['file_path', 'Log Folder Path', getFilePathSelection(), None, getFilePathSelection(), 1, 1]]

def ael_main(parameter):
    text_result = ''
    table_name = 'PDN_PAR_FORWARD'
    columns = ('DEALNO', 'VDATE', 'CNO', 'DEALDATE', 'INPUTDATE', 'PRODCODE', 'PRODTYPE', 'CCY', 'CCYAMT', 'CTRCCY', 'CTRAMT')
    file_path = str(parameter['file_path'])
    query_folder = parameter['query_folder']
    
    
    db_query = acm.FStoredASQLQuery[query_folder].Query()
    trades = db_query.Select()
    data = []
    pdn_mod = PDN_Modules()
    
    for i in trades:
        pdn_mod.set_trade(i)
        temp_result = (
            pdn_mod.dealno(),
            pdn_mod.valuedate(),
            pdn_mod.cno(),
            pdn_mod.dealdate(),
            pdn_mod.inputdate(),
            pdn_mod.product(),
            pdn_mod.prodtype(),
            pdn_mod.ccy(),
            pdn_mod.ccyamt(),
            pdn_mod.ctrccy(),
            pdn_mod.ctramt()
        )
        data.append(temp_result)
    
    data = list(set(data))
    text_result += "Table : " + table_name + "\n"
    text_result += "Columns : " + str(columns) + "\n"
    
    if data == [] :
        text_result += '\nNo new data to be inserted/updated.\n'
    else:
        dbOps = TableManipulator()
        cursor, text_connect = dbOps.connect()

        text_result += text_connect
        text_result += dbOps.upsert(table_name, columns, data, [columns[0]])
        #text_result += dbOps.delete_row_from_table(table_name, tuple(void_trades), columns[0])
        #text_result += dbOps.truncate([table_name])
        text_result += dbOps.disconnect()
        
    print(text_result)
    extension_value_name = table_name + '_LOG'
    storeToExtensionValue(extension_value_name, text_result)
    write_log_file(file_path, extension_value_name, text_result)

        

...

  QuerySupplier


def prepare_upsert_query(table_name, header, unique_key_list=None):
    query = ''
    if not unique_key_list:
        query = prepare_insert_query(table_name, header)
            
    else:
        upsert_query = """
        MERGE INTO {table_name} AS D
        USING (SELECT * FROM (VALUES ({rows})) AS TEMP ({columns})) AS S
        
        ON {holding_keys}
        
        WHEN MATCHED THEN
            UPDATE SET {update_clause}
        WHEN NOT MATCHED BY TARGET THEN
            INSERT ({columns}) 
            VALUES ({rows1});
        """
        
        def prepare_insert_clause(header):
            return str('S.'+', S.'.join(header))
        
        def prepare_update_clause(header):
            clause = []
            condition = 'D.{0}=S.{0}'
            for col in header:
                clause.append(condition.format(col))
            return str(', '.join(clause))
        
        insert_clause       = prepare_insert_clause(header)
        update_clause_str   = prepare_update_clause(header)
        keys = ("D."+str(key)+"=S."+str(key) for key in unique_key_list)
        query = upsert_query.format(table_name=table_name, \
                                    columns = ','.join(header), \
                                    rows=','.join('?'*len(header)), \
                                    rows1=insert_clause, \
                                    holding_keys=' AND '.join(keys), \
                                    update_clause= update_clause_str)
    return query 


def format_DB_column_headers(header):
    header = header.replace('[','(')
    header = header.replace(']',')')
    header = header.replace('\'','')
    return header

def prepare_insert_query(tableName, header):
    query = 'insert into {0} ({1}) values ({2})'
    query = query.format(tableName,','.join(header), ','.join('?' * len(header)))
    return query

def prepare_truncate_query(tableName):
    query = 'TRUNCATE TABLE ' + tableName
    return query

def prepare_delete_query(tableName):
    query = 'DELETE from ' + tableName
    return query

def prepare_delete_rows_from_table(table_name, tuple_key, unique_key):
    query = 'DELETE from ' + table_name + ' WHERE ' + unique_key + ' in (' + ','.join('?' * len(tuple_key)) + ')'
    return query

def convert_sec_to_string(seconds, format):
    import time
    return time.strftime(format, time.strptime(time.ctime(seconds)))

def get_dateTimeString_from_ADSTimeStamp(timeStampInSecs):
    date = convertSecToString(timeStampInSecs, format='%Y-%m-%d %H:%M:%S') if timeStampInSecs else ''
    return 'TO_TIMESTAMP(\'' + date + '\',\'YYYY-MM-DD HH24:MI:SS\')' if date else ''

def get_dateString_from_ADSTimeStamp(timeStampInSecs):
    date = convertSecToString(timeStampInSecs, format='%Y-%m-%d') if timeStampInSecs else ''
    return 'TO_DATE(\'' + date + '\',\'YYYY-MM-DD\')' if date else ''
    

...

  SISMONTAVAR

import acm, ael, time

class SISMONTAVAR_Modules:

    def __init__(self):
        pass
    
    def set_trade(self, trade):
        self.trade = trade
        
    def dealno(self):
        return self.trade.Oid()
        #return self.trade.AdditionalInfo().DealNO()
        
    def valuedate(self):
        try:
            if str(self.trade.InstrumentSubType()) == 'NDF':
                return self.trade.RightDate()
            return self.trade.ValueDay()
        except:
            return None
        
    def cno(self):
        try:
            party = self.trade.Counterparty()
            hostId = party.HostId()
            if hostId.strip():
                return hostId
            else:
                alias = party.Id2()
                if alias.isdigit():
                    return alias
                else:
                    return party.Id().split("_")[0]
        except:
            return None
        
    def dealdate(self):
        temp_time = self.trade.TradeTime()
        temp_time = acm.Time.DateTimeToTime(temp_time)
        formatted_time = time.strftime("%Y-%m-%d %H:%M:%S", time.strptime(time.ctime(temp_time)))
        return formatted_time
        
    def inputdate(self):
        temp_time = self.trade.CreateTime()
        formatted_time = time.strftime("%Y-%m-%d %H:%M:%S", time.strptime(time.ctime(temp_time)))
        return formatted_time
        
    def product(self):
        try :
            return self.trade.OptKey3().Name()
        except:
            return None
    
        return optkey3
        
    def prodtype(self):
        try :
            return self.trade.OptKey4().Name()
        except:
            return None
        
    def pay_ccy(self):
        try:
            return self.trade.Instrument().PayLeg().Currency().Name()
        except:
            return None
    
    def pay_amt(self):
        try:
            return self.trade.Instrument().ContractSize()
        except:
            return None
    
    def receive_ccy(self):
        try:
            return self.trade.Instrument().RecLeg().Currency().Name()
        except:
            return None
    
    def receive_amt(self):
        try:
            return self.pay_amt() * self.trade.Instrument().RecLeg().NominalFactor()
        except:
            return None        
            
    def farnearind(self):
        if self.trade.IsFxSwapFarLeg():
            return 'F'
        else:
            return 'N'
        
    def ccy(self):
        if not self.trade.PositionOrInstrumentPair():
            return self.trade.Currency().Name()
        else:
            return self.trade.PositionOrInstrumentPair().Instrument1().Name()
        
    def ctrccy(self):
        if not self.trade.PositionOrInstrumentPair():
            return None
        else:
            return self.trade.PositionOrInstrumentPair().Instrument2().Name()
        
    def ccyamt(self):
        try:
            return self.trade.Position()
        except:
            return None
        
    def ctramt(self):
        try:
            if self.trade.InstrumentSubType().Text().lower() == 'fx option':
                return (-1) * self.ccyamt() * self.trade.Instrument().StrikePrice()
            else:
                return (-1) * self.ccyamt() * self.trade.Price()
        except:
            return None
        
    def ps(self):
        if self.trade.Quantity() >= 0:
            return 'P'
        else:
            return 'S'
        
    def ccode(self):
        try:
            return self.trade.Counterparty().Country()
        except:
            return None
        
    def port(self):
        try:
            return self.trade.Portfolio().Name()[:50]
        except:
            return None
        
    def trad(self):
        try:
            return self.trade.Trader().Oid()
        except:
            return None
        
    def cost(self):
        try:
            return self.trade.Portfolio().AddInfoValue('COST CENTER')
        except:
            return None
        
    def ioper(self):
        try:
            return self.trade.CreateUser().Oid()
        except:
            return None
        
    def voper(self):
        try:
            return self.trade.UpdateUser().Oid()
        except:
            return None
    
    def payoper(self):
        try:
            return self.trade.Payments().Last().CreateUser().Oid()
        except:
            return None
            
    def authoper(self):
        try:
            return self.trade.Authorizer().Oid()
        except:
            return None
    
    def revoper(self):
        try:
            return self.trade.UpdateUser().Oid()
        except:
            return None

    def revauth(self):
        try:
            return self.trade.Authorizer().Oid()
        except:
            return None
        
    def dealtext(self):
        return self.trade.Text1()
        
    def spotfwd(self):
        try:
            if self.product().lower() == 'fx':
                if self.prodtype().lower() in ('tod', 'tom', 'spot'):
                    return 'S'
                elif self.prodtype().lower() == 'fwd':
                    return 'F'
                elif self.prodtype().lower() == 'swap':
                    farleg = self.trade.IsFxSwapFarLeg()
                    return 'F' if farleg else 'S'
                elif self.trade.TradeInstrumentType().lower() == 'future/forward':
                    if self.trade.Type().lower() == 'normal':
                        return 'F'
                    elif self.trade.Type().lower() == 'closing':
                        return 'S'
                    else:
                        return None
            else:
                return None
        except:
            return None
        
    def rate(self):
        try:
            if self.trade.TradeInstrumentType().lower() == 'option':
                return self.trade.Instrument().StrikePrice()
            elif self.trade.TradeInstrumentType().lower() == 'currswap':
                return self.trade.Instrument().RecLeg().NominalFactor()
            else:
                return self.trade.Price()
        except:
            return None
        
    def br(self):
        try :
            return self.trade.OptKey1().Name()
        except:
            return None
        
    def status(self):
        return self.trade.Status()
    
    def amend_date(self):
        def convert_status(status):
            try:
                status = str(int(status))
                status = acm.FTradeStatusValue.Select(f"enumValue={status}").First().NiceName()
            except:
                pass
            return status
        try:
            r = ael.asql(f"""
            SELECT 
                t.seqnbr, t.creat_time 
            FROM 
                TransHst t 
            WHERE 
                t.trans_record_type = 'Trade' 
                AND t.record_id = {self.trade.Oid()}
            ORDER BY 
                t.creat_time ASC
            """)
            state = False
            for result in r[1][0]:
                transhst_id = result[0]
                TransactionHistory = acm.FTransactionHistory[transhst_id]
                newValue = convert_status(TransactionHistory.NewFieldValue('Status', 'Trade'))
                oldValue = convert_status(TransactionHistory.OldFieldValue('Status', 'Trade'))
                if state and newValue == 'FO Confirmed':
                    return acm.Time.UtcToLocal(result[1])
                elif not oldValue:
                    continue
                elif oldValue == 'BO Rejected':
                    state = True
                    continue
            return None
        except:
            return None
    
    def mdate(self):
        return self.trade.ValueDay()
        
    def swapdealno(self):
        try:
            if self.trade.OptKey3().Name().lower() == 'fx' and self.trade.OptKey4().Name().lower() == 'swap':
                if self.trade.ConnectedTrades().IsEmpty():
                    return self.trade.ConnectedTrade().Oid()
                else: 
                    if len(self.trade.ConnectedTrades()) == 1:
                        return None
                    else:
                        for connection in self.trade.TradeConnections():
                            if connection.Type().Text().lower() =='fxswap' and connection.FromTrade() == self.trade and connection.ToTrade() != self.trade:
                                return connection.ToTrade().Oid()
            else:
                return None
        except:
            return None
        
    def swapvdate(self):
        try:
            if self.trade.OptKey3().Name().lower() == 'fx' and self.trade.OptKey4().Name().lower() == 'swap':
                if self.trade.ConnectedTrades().IsEmpty():
                    return self.trade.ConnectedTrade().ValueDay()
                else: 
                    if len(self.trade.ConnectedTrades()) == 1:
                        return None
                    else:
                        for connection in self.trade.TradeConnections():
                            if connection.Type().Text().lower() =='fxswap' and connection.FromTrade() == self.trade and connection.ToTrade() != self.trade:
                                return connection.ToTrade().ValueDay()
            else:
                return None
        except:
            return None
    
    def fedealno(self):
        try:
            return self.trade.OptionalKey()
        except:
            return None
    
    def convert_network_name(self, account_object):
        network_name = account_object.NetworkAliasType().Name().lower()
        if network_name == 'emas':
            return 'EMARETL'
        elif network_name in ('swift', 'rtgs'):
            return 'NOS'
        else:
            return None
    
    def get_account(self, account_object):
        network = self.convert_network_name(account_object)
        if network == 'EMARETL':
            return account_object.Account()
        elif network == 'NOS':
            return account_object.Name()
        else:
            return None

    def ccysmeans(self):
        try:   
            moneyFlows = self.trade.MoneyFlows()
            if moneyFlows:
                for mf in moneyFlows:
                    party_account = mf.AcquirerAccount()
                    if self.trade.TradeInstrumentType().lower() == 'curr':
                        if mf.Currency() == self.trade.Instrument():
                            return self.convert_network_name(party_account)
                        else:
                            continue
                    else:
                        if mf.Currency() == self.trade.Currency():
                            return self.convert_network_name(party_account)
                        else:
                            continue
                return None
            else:
                return None
        except:
            return None
        
    def ctrccysmeans(self):
        try:   
            moneyFlows = self.trade.MoneyFlows()
            if moneyFlows:
                for mf in moneyFlows:
                    party_account = mf.AcquirerAccount()
                    if self.trade.TradeInstrumentType().lower() == 'curr':
                        if mf.Currency() == self.trade.Currency():
                            return self.convert_network_name(party_account)
                        else:
                            continue
                    else:
                        return None
                return None
            else:
                return None
        except:
            return None
    
    def ccysacct(self):
        try:   
            moneyFlows = self.trade.MoneyFlows()
            if moneyFlows:
                for mf in moneyFlows:
                    party_account = mf.AcquirerAccount()
                    if self.trade.TradeInstrumentType().lower() == 'curr':
                        if mf.Currency() == self.trade.Instrument():
                            return self.get_account(party_account)
                        else:
                            continue
                    else:
                        if mf.Currency() == self.trade.Currency():
                            return self.get_account(party_account)
                        else:
                            continue
                return None
            else:
                return None
        except:
            return None
        
    def ctrsacct(self):
        try:   
            moneyFlows = self.trade.MoneyFlows()
            if moneyFlows:
                for mf in moneyFlows:
                    party_account = mf.AcquirerAccount()
                    if self.trade.TradeInstrumentType().lower() == 'curr':
                        if mf.Currency() == self.trade.Currency():
                            return self.get_account(party_account)
                        else:
                            continue
                    else:
                        return None
                return None
            else:
                return None
        except:
            return None
        
    def parent_dealno(self):
        try:
            return self.trade.DealPackage().TradeLinks().Oid()
        except:
            return None
        
    def parent_vdate(self):
        return self.trade.ValueDay()
        
    def beneficiary(self):
        try:
            return self.trade.Counterparty().Swift()
        except:
            return None
        
    def account(self):
        return self.trade.AccountId()
        
    def intermediary(self):
        try:
            return self.trade.Counterparty().Cls()
        except:
            return None
    
    def effdate(self):
        return self.trade.ValueDay()
        
    def pay_rate_type(self):
        try:
            return self.trade.Instrument().PayLeg().LegType()
        except:
            return None
    
    def receive_rate_type(self):
        try:
            return self.trade.Instrument().RecLeg().LegType()
        except:
            return None
    
    def pay_rate_value(self):
        try:
            return self.trade.Instrument().PayLeg().FixedRate()
        except:
            return None
    
    def receive_rate_value(self):
        try:
            return self.trade.Instrument().RecLeg().FixedRate()
        except:
            return None
        
    def strike(self):
        try:
            return self.trade.Instrument().Legs().First().StrikePrice()
        except:
            return None
    
    def option_status(self):
        return self.trade.TradeProcessesToString()
    
    def spotdate(self):
        try:
            date, period = acm.Time.AsDate(self.trade.TradeTime()), 2
            calendar = acm.FCalendar['Jakarta']
            for n in range(period):
                date = acm.Time.DateAdjustPeriod(date, '1d', calendar, 'Following')
            return date
        except:
            return None
        
    def verdate(self):
        temp_time = self.trade.UpdateTime()
        formatted_time = time.strftime("%Y-%m-%d %H:%M:%S", time.strptime(time.ctime(temp_time)))
        return formatted_time
        
    def revdate(self):
        if ('void' not in self.status().lower()):
            return None
        else:
            ths = acm.FTransactionHistory.Select('transRecordType="Trade" and recordId={}'.format(self.trade.Oid()))
            for th in ths:
                newVal = th.NewFieldValue('status', 'Trade')
                if (newVal is not None):
                    if ('void' in newVal.lower()):
                        temp_time = th.UpdateTime()
                        return time.strftime("%Y-%m-%d %H:%M:%S", time.strptime(time.ctime(temp_time)))

    def call_ccy(self):
        try:
            if self.trade.Instrument().OptionType().lower() == "put":
                return self.trade.Instrument().Currency().Name()
            elif self.trade.Instrument().OptionType().lower() == "call":
                return self.trade.Instrument().Underlying().Name()
        except:
            return None
    
    def call_amt(self):
        try:
            return self.put_amt() * self.trade.Instrument().StrikePrice()
        except:
            return None
    
    def put_ccy(self):
        try:
            if self.trade.Instrument().OptionType().lower() == "put":
                return self.trade.Instrument().Underlying().Name()
            elif self.trade.Instrument().OptionType().lower() == "call":
                return self.trade.Instrument().Currency().Name()
        except:
            return None
    
    def put_amt(self):
        try:
            return self.trade.FaceValue()
        except:
            return None

    def premium_ccy(self):
        try:
            return self.trade.Currency().Name()
        except:
            return None
        
    def premium_amt(self):
        return self.trade.Premium()

...

  SMTR_CCS

from DataStager import *
from SISMONTAVAR import *

ael_gui_parameters={'runButtonLabel':'&&Run',
                    'hideExtraControls': True,
                    'windowCaption':'SMTR_CCS'}

ael_variables=[
['query_folder','Query Folders','string', filter_query_folder('Trade'), 'WEBEAI_SMTR_CCS', 1,0],
['file_path', 'Log Folder Path', getFilePathSelection(), None, getFilePathSelection(), 1, 1]]

def ael_main(parameter):
    text_result = ''
    table_name = 'SMTR_CCS'
    columns = ('DEALNO', 'EFFDATE', 'MDATE', 'CNO', 'DEALDATE', 'INPUTDATE', 'PRODCODE', 'PRODTYPE', 'PAY_CCY', 'PAY_AMT', 'RECEIVE_CCY', 'RECEIVE_AMT', 'PORT', 'TRAD', 'COST', 'IOPER', 'VOPER', 'PAYOPER', 'AUTHOPER', 'REVOPER', 'REVAUTH', 'DEALTEXT', 'FEDEALNO', 'CCYSMEANS', 'CCYSACCT', 'CTRCCYSMEANS', 'CTRSACCT', 'RATE', 'BENEFICIARY', 'ACCOUNT', 'INTERMEDIARY', 'ACCOUNT_NUMBER', 'BR', 'STATUS', 'PAY_RATE_TYPE', 'RECEIVE_RATE_TYPE', 'PAY_RATE_VALUE', 'RECEIVE_RATE_VALUE', 'SPOTDATE', 'AMENDTIME', 'VERDATE', 'REVDATE')
    file_path = str(parameter['file_path'])
    query_folder = parameter['query_folder']
    
    db_query = acm.FStoredASQLQuery[query_folder].Query()
    trades = db_query.Select()
    data = []

    sismontavar_mod = SISMONTAVAR_Modules()

    for i in trades:
        sismontavar_mod.set_trade(i)

        temp_result = (
            sismontavar_mod.dealno(),
            sismontavar_mod.effdate(),
            sismontavar_mod.mdate(),
            sismontavar_mod.cno(),
            sismontavar_mod.dealdate(),
            sismontavar_mod.inputdate(),
            sismontavar_mod.product(),
            sismontavar_mod.prodtype(),
            sismontavar_mod.pay_ccy(),
            sismontavar_mod.pay_amt(),
            sismontavar_mod.receive_ccy(),
            sismontavar_mod.receive_amt(),
            sismontavar_mod.port(),
            sismontavar_mod.trad(),
            sismontavar_mod.cost(),
            sismontavar_mod.ioper(),
            sismontavar_mod.voper(),
            sismontavar_mod.payoper(),
            sismontavar_mod.authoper(),
            sismontavar_mod.revoper(),
            sismontavar_mod.revauth(),
            sismontavar_mod.dealtext(),
            sismontavar_mod.fedealno(),
            sismontavar_mod.ccysmeans(),
            sismontavar_mod.ccysacct(),
            sismontavar_mod.ctrccysmeans(),
            sismontavar_mod.ctrsacct(),
            sismontavar_mod.rate(),
            sismontavar_mod.beneficiary(),
            sismontavar_mod.account(),
            sismontavar_mod.intermediary(),
            sismontavar_mod.account(),
            sismontavar_mod.br(),
            sismontavar_mod.status(),
            sismontavar_mod.pay_rate_type(),
            sismontavar_mod.receive_rate_type(),
            sismontavar_mod.pay_rate_value(),
            sismontavar_mod.receive_rate_value(),
            sismontavar_mod.spotdate(),
            sismontavar_mod.amend_date(),
            sismontavar_mod.verdate(),
            sismontavar_mod.revdate()
        )
        data.append(temp_result)
    
    
    data = list(set(data))
    text_result += "Table : " + table_name + "\n"
    text_result += "Columns : " + str(columns) + "\n"
    
    if data == [] :
        text_result += '\nNo new data to be inserted/updated.\n'
    else:
        dbOps = TableManipulator()
        cursor, text_connect = dbOps.connect()

        text_result += text_connect
        text_result += dbOps.upsert(table_name, columns, data, [columns[0]])
        #text_result += dbOps.delete_row_from_table(table_name, tuple(void_trades), columns[0])
        #text_result += dbOps.truncate([table_name])
        text_result += dbOps.disconnect()
        
    print(text_result)
    extension_value_name = table_name + '_LOG'
    storeToExtensionValue(extension_value_name, text_result)
    write_log_file(file_path, extension_value_name, text_result)


...

  SMTR_FX_TRANSACTION_CUSTOMER

from DataStager import *
from SISMONTAVAR import *

ael_gui_parameters={'runButtonLabel':'&&Run',
                    'hideExtraControls': True,
                    'windowCaption':'SMTR_FX_TRANSACTION_CUSTOMER'}

ael_variables=[
['query_folder','Query Folders','string', filter_query_folder('Trade'), 'WEBEAI_SMTR_FX_TRANSACTION_CUSTOMER', 1,0],
['file_path', 'Log Folder Path', getFilePathSelection(), None, getFilePathSelection(), 1, 1]]

def ael_main(parameter):
    text_result = ''
    table_name = 'SMTR_FX_TRANSACTION_CUSTOMER'
    columns = ('DEALNO', 'VDATE', 'SWAPDEALNO', 'SWAPVDATE', 'CNO', 'DEALDATE', 'INPUTDATE', 'PRODCODE', 'PRODTYPE', 'FARNEARIND', 'CCY', 'CCYAMT', 'CTRCCY', 'CTRAMT', 'PS', 'CCODE', 'PORT', 'TRAD', 'COST', 'IOPER', 'VOPER', 'PAYOPER', 'AUTHOPER', 'REVOPER', 'REVAUTH', 'DEALTEXT', 'FEDEALNO', 'CCYSMEANS', 'CCYSACCT', 'CTRCCYSMEANS', 'CTRSACCT', 'SPOTFWDIND', 'RATE', 'BR', 'STATUS', 'SPOTDATE', 'AMENDTIME', 'VERDATE', 'REVDATE')
    file_path = str(parameter['file_path'])
    query_folder = parameter['query_folder']
    
    db_query = acm.FStoredASQLQuery[query_folder].Query()
    objects = db_query.Select()
    data = []
    
    sismontavar_mod = SISMONTAVAR_Modules()
    
    for i in objects:
        sismontavar_mod.set_trade(i)
        
        temp_result = (
                sismontavar_mod.dealno(),
                sismontavar_mod.valuedate(),
                sismontavar_mod.swapdealno(),
                sismontavar_mod.swapvdate(),
                sismontavar_mod.cno(),
                sismontavar_mod.dealdate(),
                sismontavar_mod.inputdate(),
                sismontavar_mod.product(),
                sismontavar_mod.prodtype(),
                sismontavar_mod.farnearind(),
                sismontavar_mod.ccy(),
                sismontavar_mod.ccyamt(),
                sismontavar_mod.ctrccy(),
                sismontavar_mod.ctramt(),
                sismontavar_mod.ps(),
                sismontavar_mod.ccode(),
                sismontavar_mod.port(),
                sismontavar_mod.trad(),
                sismontavar_mod.cost(),
                sismontavar_mod.ioper(),
                sismontavar_mod.voper(),
                sismontavar_mod.payoper(),
                sismontavar_mod.authoper(),
                sismontavar_mod.revoper(),
                sismontavar_mod.revauth(),
                sismontavar_mod.dealtext(),
                sismontavar_mod.fedealno(),
                sismontavar_mod.ccysmeans(),
                sismontavar_mod.ccysacct(),
                sismontavar_mod.ctrccysmeans(),
                sismontavar_mod.ctrsacct(),
                sismontavar_mod.spotfwd(),
                sismontavar_mod.rate(),
                sismontavar_mod.br(),
                sismontavar_mod.status(),
                sismontavar_mod.spotdate(),
                sismontavar_mod.amend_date(),
                sismontavar_mod.verdate(),
                sismontavar_mod.revdate(),
        )
        data.append(temp_result)
        
    data = list(set(data))
    text_result += "Table : " + table_name + "\n"
    text_result += "Columns : " + str(columns) + "\n"
    
    if data == [] :
        text_result += '\nNo new data to be inserted/updated.\n'
    else:
        dbOps = TableManipulator()
        cursor, text_connect = dbOps.connect()

        text_result += text_connect
        text_result += dbOps.upsert(table_name, columns, data, [columns[0]])
        #text_result += dbOps.delete_row_from_table(table_name, tuple(void_trades), columns[0])
        #text_result += dbOps.truncate([table_name])
        text_result += dbOps.disconnect()
        
    print(text_result)
    extension_value_name = table_name + '_LOG'
    storeToExtensionValue(extension_value_name, text_result)
    write_log_file(file_path, extension_value_name, text_result)




...

  SMTR_FX_TRANSACTION_KCDN

from DataStager import *
from SISMONTAVAR import *

ael_gui_parameters={'runButtonLabel':'&&Run',
                    'hideExtraControls': True,
                    'windowCaption':'SMTR_FX_TRANSACTION_KCDN'}

ael_variables=[
['query_folder','Query Folders','string', filter_query_folder('Trade'), 'WEBEAI_SMTR_FX_TRANSACTION_KCDN', 1,0],
['file_path', 'Log Folder Path', getFilePathSelection(), None, getFilePathSelection(), 1, 1]]

def ael_main(parameter):
    text_result = ''
    table_name = 'SMTR_FX_TRANSACTION_KCDN'
    columns = ('DEALNO', 'VDATE', 'SWAPDEALNO', 'SWAPVDATE', 'CNO', 'DEALDATE', 'INPUTDATE', 'PRODCODE', 'PRODTYPE', 'FARNEARIND', 'CCY', 'CCYAMT', 'CTRCCY', 'CTRAMT', 'PS', 'CCODE', 'PORT', 'TRAD', 'COST', 'IOPER', 'VOPER', 'PAYOPER', 'AUTHOPER', 'REVOPER', 'REVAUTH', 'DEALTEXT', 'FEDEALNO', 'CCYSMEANS', 'CCYSACCT', 'CTRCCYSMEANS', 'CTRSACCT', 'SPOTFWDIND', 'RATE', 'BR', 'STATUS', 'SPOTDATE', 'AMENDTIME', 'VERDATE', 'REVDATE')
    file_path = str(parameter['file_path'])
    query_folder = parameter['query_folder']
    
    db_query = acm.FStoredASQLQuery[query_folder].Query()
    objects = db_query.Select()
    data = []
    
    sismontavar_mod = SISMONTAVAR_Modules()
    
    for i in objects:
        sismontavar_mod.set_trade(i)
        
        temp_result = (
                sismontavar_mod.dealno(),
                sismontavar_mod.valuedate(),
                sismontavar_mod.swapdealno(),
                sismontavar_mod.swapvdate(),
                sismontavar_mod.cno(),
                sismontavar_mod.dealdate(),
                sismontavar_mod.inputdate(),
                sismontavar_mod.product(),
                sismontavar_mod.prodtype(),
                sismontavar_mod.farnearind(),
                sismontavar_mod.ccy(),
                sismontavar_mod.ccyamt(),
                sismontavar_mod.ctrccy(),
                sismontavar_mod.ctramt(),
                sismontavar_mod.ps(),
                sismontavar_mod.ccode(),
                sismontavar_mod.port(),
                sismontavar_mod.trad(),
                sismontavar_mod.cost(),
                sismontavar_mod.ioper(),
                sismontavar_mod.voper(),
                sismontavar_mod.payoper(),
                sismontavar_mod.authoper(),
                sismontavar_mod.revoper(),
                sismontavar_mod.revauth(),
                sismontavar_mod.dealtext(),
                sismontavar_mod.fedealno(),
                sismontavar_mod.ccysmeans(),
                sismontavar_mod.ccysacct(),
                sismontavar_mod.ctrccysmeans(),
                sismontavar_mod.ctrsacct(),
                sismontavar_mod.spotfwd(),
                sismontavar_mod.rate(),
                sismontavar_mod.br(),
                sismontavar_mod.status(),
                sismontavar_mod.spotdate(),
                sismontavar_mod.amend_date(),
                sismontavar_mod.verdate(),
                sismontavar_mod.revdate(),
        )
        data.append(temp_result)
        
    data = list(set(data))
    text_result += "Table : " + table_name + "\n"
    text_result += "Columns : " + str(columns) + "\n"
    
    if data == [] :
        text_result += '\nNo new data to be inserted/updated.\n'
    else:
        dbOps = TableManipulator()
        cursor, text_connect = dbOps.connect()

        text_result += text_connect
        text_result += dbOps.upsert(table_name, columns, data, [columns[0]])
        #text_result += dbOps.delete_row_from_table(table_name, tuple(void_trades), columns[0])
        #text_result += dbOps.truncate([table_name])
        text_result += dbOps.disconnect()
        
    print(text_result)
    extension_value_name = table_name + '_LOG'
    storeToExtensionValue(extension_value_name, text_result)
    write_log_file(file_path, extension_value_name, text_result)




...

  SMTR_OPTION_CALLSPREAD

from DataStager import *
from SISMONTAVAR import *

ael_gui_parameters={'runButtonLabel':'&&Run',
                    'hideExtraControls': True,
                    'windowCaption':'SMTR_OPTION_CALLSPREAD'}

ael_variables=[
['query_folder','Query Folders','string', filter_query_folder('Trade'), 'WEBEAI_SMTR_OPTION_CALLSPREAD', 1,0],
['file_path', 'Log Folder Path', getFilePathSelection(), None, getFilePathSelection(), 1, 1]]

def ael_main(parameter):
    text_result = ''
    table_name = 'SMTR_OPTION_CALLSPREAD'
    columns = ('DEALNO', 'PARENT_VDATE', 'EFFDATE', 'MDATE', 'CNO', 'DEALDATE', 'INPUTDATE', 'PRODCODE', 'PRODTYPE', 'PUT_CCY', 'PUT_AMT', 'CALL_CCY', 'CALL_AMT', 'PREMIUM_CCY', 'PREMIUM_AMT', 'PS', 'PORT', 'TRAD', 'COST', 'IOPER', 'VOPER', 'PAYOPER', 'AUTHOPER', 'REVOPER', 'REVAUTH', 'DEALTEXT', 'FEDEALNO', 'CCYSMEANS', 'CCYSACCT', 'CTRCCYSMEANS', 'CTRSACCT', 'RATE', 'STRIKE', 'BENEFICIARY', 'ACCOUNT', 'INTERMEDIARY', 'BR', 'STATUS', 'AMENDDATE', 'OPTION_STATUS', 'SPOTDATE', 'VERDATE', 'REVDATE')
    file_path = str(parameter['file_path'])
    query_folder = parameter['query_folder']
    
    db_query = acm.FStoredASQLQuery[query_folder].Query()
    trades = db_query.Select()
    data = []

    sismontavar_mod = SISMONTAVAR_Modules()

    for i in trades:
        sismontavar_mod.set_trade(i)

        temp_result = (
            sismontavar_mod.dealno(),
            sismontavar_mod.parent_vdate(),
            sismontavar_mod.effdate(),
            sismontavar_mod.mdate(),
            sismontavar_mod.cno(),
            sismontavar_mod.dealdate(),
            sismontavar_mod.inputdate(),
            sismontavar_mod.product(),
            sismontavar_mod.prodtype(),
            sismontavar_mod.put_ccy(),
            sismontavar_mod.put_amt(),
            sismontavar_mod.call_ccy(),
            sismontavar_mod.call_amt(),
            sismontavar_mod.premium_ccy(),
            sismontavar_mod.premium_amt(),
            sismontavar_mod.ps(),
            sismontavar_mod.port(),
            sismontavar_mod.trad(),
            sismontavar_mod.cost(),
            sismontavar_mod.ioper(),
            sismontavar_mod.voper(),
            sismontavar_mod.payoper(),
            sismontavar_mod.authoper(),
            sismontavar_mod.revoper(),
            sismontavar_mod.revauth(),
            sismontavar_mod.dealtext(),
            sismontavar_mod.fedealno(),
            sismontavar_mod.ccysmeans(),
            sismontavar_mod.ccysacct(),
            sismontavar_mod.ctrccysmeans(),
            sismontavar_mod.ctrsacct(),
            sismontavar_mod.rate(),
            sismontavar_mod.strike(),
            sismontavar_mod.beneficiary(),
            sismontavar_mod.account(),
            sismontavar_mod.intermediary(),
            sismontavar_mod.br(),
            sismontavar_mod.status(),
            sismontavar_mod.amend_date(),
            sismontavar_mod.option_status(),
            sismontavar_mod.spotdate(),
            sismontavar_mod.verdate(),
            sismontavar_mod.revdate()
        )
        data.append(temp_result)
    
    data = list(set(data))
    text_result += "Table : " + table_name + "\n"
    text_result += "Columns : " + str(columns) + "\n"
    
    if data == [] :
        text_result += '\nNo new data to be inserted/updated.\n'
    else:
        dbOps = TableManipulator()
        cursor, text_connect = dbOps.connect()

        text_result += text_connect
        text_result += dbOps.upsert(table_name, columns, data, [columns[0]])
        #text_result += dbOps.delete_row_from_table(table_name, tuple(void_trades), columns[0])
        #text_result += dbOps.truncate([table_name])
        text_result += dbOps.disconnect()
        
    print(text_result)
    extension_value_name = table_name + '_LOG'
    storeToExtensionValue(extension_value_name, text_result)
    write_log_file(file_path, extension_value_name, text_result)



...

  SMTR_PARFWD

from DataStager import *
from SISMONTAVAR import *

ael_gui_parameters={'runButtonLabel':'&&Run',
                    'hideExtraControls': True,
                    'windowCaption':'SMTR_PARFWD'}

ael_variables=[
['query_folder','Query Folders','string', filter_query_folder('Trade'), 'WEBEAI_SMTR_PARFWD', 1,0],
['file_path', 'Log Folder Path', getFilePathSelection(), None, getFilePathSelection(), 1, 1]]

def ael_main(parameter):
    text_result = ''
    table_name = 'SMTR_PARFWD'
    columns = ('PARENT_DEALNO', 'PARENT_VDATE', 'DEALNO', 'VDATE', 'CNO', 'DEALDATE', 'INPUTDATE', 'PRODCODE', 'PRODTYPE', 'CCY', 'CCYAMT', 'CTRCCY', 'CTRAMT', 'PS', 'PORT', 'TRAD', 'COST', 'IOPER', 'VOPER', 'PAYOPER', 'AUTHOPER', 'REVOPER', 'REVAUTH', 'DEALTEXT', 'FEDEALNO', 'CCYSMEANS', 'CCYSACCT', 'CTRCCYSMEANS', 'CTRSACCT', 'RATE', 'BENEFICIARY', 'ACCOUNT_NUMBER', 'INTERMEDIARY', 'BR', 'STATUS', 'AMENDTIME', 'SPOTDATE', 'VERTDATE', 'REVDATE')
    file_path = str(parameter['file_path'])
    query_folder = parameter['query_folder']
    
    db_query = acm.FStoredASQLQuery[query_folder].Query()
    objects = db_query.Select()
    data = []
    
    sismontavar_mod = SISMONTAVAR_Modules()
    
    for i in objects:
        sismontavar_mod.set_trade(i)
        
        temp_result = (
                sismontavar_mod.parent_dealno(),
                sismontavar_mod.parent_vdate(),
                sismontavar_mod.dealno(),
                sismontavar_mod.valuedate(),
                sismontavar_mod.cno(),
                sismontavar_mod.dealdate(),
                sismontavar_mod.inputdate(),
                sismontavar_mod.product(),
                sismontavar_mod.prodtype(),
                sismontavar_mod.ccy(),
                sismontavar_mod.ccyamt(),
                sismontavar_mod.ctrccy(),
                sismontavar_mod.ctramt(),
                sismontavar_mod.ps(),
                sismontavar_mod.port(),
                sismontavar_mod.trad(),
                sismontavar_mod.cost(),
                sismontavar_mod.ioper(),
                sismontavar_mod.voper(),
                sismontavar_mod.payoper(),
                sismontavar_mod.authoper(),
                sismontavar_mod.revoper(),
                sismontavar_mod.revauth(),
                sismontavar_mod.dealtext(),
                sismontavar_mod.fedealno(),
                sismontavar_mod.ccysmeans(),
                sismontavar_mod.ccysacct(),
                sismontavar_mod.ctrccysmeans(),
                sismontavar_mod.ctrsacct(),
                sismontavar_mod.rate(),
                sismontavar_mod.beneficiary(),
                sismontavar_mod.account(),
                sismontavar_mod.intermediary(),
                sismontavar_mod.br(),
                sismontavar_mod.status(),
                sismontavar_mod.amend_date(),
                sismontavar_mod.spotdate(),
                sismontavar_mod.verdate(),
                sismontavar_mod.revdate()
        )
        data.append(temp_result)
        
    data = list(set(data))
    text_result += "Table : " + table_name + "\n"
    text_result += "Columns : " + str(columns) + "\n"
    
    if data == [] :
        text_result += '\nNo new data to be inserted/updated.\n'
    else:
        dbOps = TableManipulator()
        cursor, text_connect = dbOps.connect()

        text_result += text_connect
        text_result += dbOps.upsert(table_name, columns, data, [columns[2]])
        #text_result += dbOps.delete_row_from_table(table_name, tuple(void_trades), columns[0])
        #text_result += dbOps.truncate([table_name])
        text_result += dbOps.disconnect()
        
    print(text_result)
    extension_value_name = table_name + '_LOG'
    storeToExtensionValue(extension_value_name, text_result)
    write_log_file(file_path, extension_value_name, text_result)



...

  STATIC

import acm, time

dateToday = acm.Time.DateToday()
datePrevMonth = acm.Time.DateAddDelta(dateToday, 0, -1, 0) 
dateNextMonth = acm.Time.DateAddDelta(dateToday, 0, 1, 0)

class Static_Modules:
    
    def __init__(self):
        pass
    
    def set_trade(self, trade):
        self.trade = trade
        
    def set_account(self, account):
        self.account = account
    
    def set_choicelist(self, choicelist):
        self.choicelist = choicelist
        
    def set_pair(self, price):
        self.price = price
        
    def set_instrument(self, instrument):
        self.instrument = instrument
        
    def set_party(self, party):
        self.party = party
    
    def set_portfolio(self, portfolio):
        self.portfolio = portfolio
        
    def set_user(self, user):
        self.user = user

    def set_calendar(self, calendar):
        self.calendar = calendar
        
    def nostro_id(self):
        return self.account.Name()[:50]
        
    def nostro_ccy(self):
        try:
            return self.account.Currency().Name()
        except:
            return None
        
    def nostro_party(self):
        try:
            return self.account.Party().Name()
        except:
            return None
        
    def rate_ccy(self):
        try:
            if self.price.Instrument().Name().lower() != 'idr':
                return self.price.Instrument().Name()
            else:
                return self.price.Currency().Name()
        except:
            return None
        
    def secid(self):
        return self.instrument.Name()[:50]
        
    def sec_acctngtype(self):
        try:
            return self.instrument.ProductTypeChlItem().Name()[:50]
        except:
            return None

    def couprate_8(self):
        try:
            rate = self.instrument.CouponRate()
            if acm.Operations().IsValueInfNanOrQNan(rate):
                return None
            else:
                return rate
        except:
            return None

    def sec_ccy(self):
        try:
            return self.instrument.Currency().Name()
        except:
            return None
    
    def ccy(self):
        return self.instrument.Name()
    
    def denom(self):
        try:
            return self.instrument.NominalAmount() / 1_000_000
        except:
            return None
    
    def firstipaydate(self):
        try:
            return self.instrument.Legs().First().StartDate()
        except:
            return None
    
    def basis(self):
        return self.instrument.Legs().First().DayCountMethod()
    
    def issdate(self):
        try:
            issueDate = self.instrument.IssueDay()
            if issueDate == '':
                return None
            else:
                return issueDate
        except:
            return None
            
    def issuer(self):
        try:
            party = self.instrument.Issuer()
            hostId = party.HostId()
            if hostId.strip():
                return hostId
            else:
                alias = party.Id2()
                if alias.isdigit():
                    return alias
                else:
                    return party.Id().split("_")[0]
        except:
            return None
    
    def lstmntdate(self):
        try:
            temp_time = self.instrument.Trades().Last().UpdateTime()
            formatted_time = time.strftime("%Y-%m-%d %H:%M:%S", time.strptime(time.ctime(temp_time)))
        except:
            formatted_time = None
        return formatted_time
    
    def mdate(self):
        try:
            mdate = self.instrument.ActualUnderlyingMaturityDay()
            if mdate == '':
                return None
            else:
                return mdate
        except:
            return None
    
    def prod(self):
        try:
            return self.instrument.Trades().Last().OptKey3().Name()
        except:
            return None
    
    def prodtype(self):
        try:
            return self.instrument.Trades().Last().OptKey4().Name()
        except:
            return None
    
    def valuedate(self):
        try:
            return self.instrument.Trades().Last().ValueDay()
        except:
            return None
    
    def isin(self):
        return self.instrument.Isin()
        
    def cno(self):
        try:
            party = self.party
            hostId = party.HostId()
            if hostId.strip():
                return hostId
            else:
                alias = party.Id2()
                if alias.isdigit():
                    return alias
                else:
                    return party.Id().split("_")[0]
        except:
            return None

    def bic(self):
        return self.party.Swift()
    
    def ccode(self):
        return self.party.Country()
    
    def sn(self):
        return self.party.Fullname()[:50]
    
    def cfn1(self):
        return self.party.Fullname()[:35]
        
    def ca(self):
        return self.party.Address()
        
    def ctype(self):
        try :
            return self.party.Free2ChoiceList().Description()
        except:
            return None
    
    def port(self):
        try:
            return self.portfolio.Name()[:50]
        except:
            return None
        
    def trader_id(self):
        try:
            return self.user.Oid()
        except:
            return None
    
    def acctngtype(self):
        return self.choicelist.Name()[:50]
    
    def acctdesc(self):
        return self.choicelist.Description()

    def rate_spotrate(self):
        try:
            bid = self.price.Bid()
            ask = self.price.Ask()
            price = (bid + ask)/2
            if acm.Operations().IsValueInfNanOrQNan(price):
                return None
            else:
                if self.price.Instrument().Name().lower() != 'idr':
                    return price
                else:
                    return 1/price
        except:
            return None
        
    def rate_term(self):
        return 'M'
    
    def rate_date(self):
        return self.price.Day()
        
    def rate_type(self):
        return 'FX'
        
    def sec_descr(self):
        return self.instrument.FreeText()
        
    def ratecode(self):
        return None
        
    def mutfundind(self):
        return None
    
    def fixrate_8(self):
        return float(self.instrument.Coupons())
        
    def lhbu_id(self):
        try:
            return self.party.AddInfoValue('LHBU')
        except:
            return None
    
    def cmne(self):
        try:
            return self.party.AddInfoValue('CMNE')[:10]
        except:
            return None
        
    def cust_sic(self):
        try:
            lbut_name = self.party.AddInfoValue('LBUT_GOL PIHAKLAWAN')
            lbut_code = acm.FChoiceList[lbut_name].Description()
            return lbut_code
        except:
            return None
        
    def taxid(self):
        try:
            return self.party.AddInfoValue('TaxID')
        except:
            return None
        
    def cust_acctngtype(self):
        try:
            return self.party.AddInfoValue('ACCTNGTYPE')[:50]
        except:
            return None

    def sic(self):
        return self.choicelist.Description()
        
    def sd(self):
        return self.choicelist.Name()[:50]
        
    def port_desc(self):
        try:
            return self.portfolio.AssignInfo()
        except:
            return None
    
    def trader_name(self):
        try:
            return self.user.Name()
        except:
            return None
        
    def operator(self):
        try:
            return self.user.Oid()
        except:
            return None
    
    def oper_name(self):
        try:
            return self.user.Name()
        except:
            return None
    
    def ldapid(self):
        return None
    
    def branprcdate(self):
        return dateToday
    
    def prevbranprcdate(self):
        return self.calendar.AdjustBankingDays(dateToday, -1)
    
    def prevprevbranprcdate(self):
        return self.calendar.AdjustBankingDays(dateToday, -2)
    
    def nextbranprcdate(self):
        return self.calendar.AdjustBankingDays(dateToday, 1)
        
    def nextnextbranprcdate(self):
        return self.calendar.AdjustBankingDays(dateToday, 2)
    
    def monthenddate(self):
        date = acm.Time.LastDayOfMonth(dateToday)
        if self.calendar.IsNonBankingDay(self.calendar, self.calendar, date):
            return self.calendar.AdjustBankingDays(date, -1)
        else:
            return date
    
    def monthstartdate(self):
        date = acm.Time.FirstDayOfMonth(dateToday)
        if self.calendar.IsNonBankingDay(self.calendar, self.calendar, date):
            return self.calendar.AdjustBankingDays(date, 1)
        else:
            return date
    
    def yearenddate(self):
        date = acm.Time.LastDayOfYear(dateToday)
        if self.calendar.IsNonBankingDay(self.calendar, self.calendar, date):
            return self.calendar.AdjustBankingDays(date, -1)
        else:
            return date
        
    def yearstartdate(self):
        date = acm.Time.FirstDayOfYear(dateToday)
        if self.calendar.IsNonBankingDay(self.calendar, self.calendar, date):
            return self.calendar.AdjustBankingDays(date, 1)
        else:
            return date
    
    def nextmonthenddate(self):
        date = acm.Time.LastDayOfMonth(dateNextMonth)
        if self.calendar.IsNonBankingDay(self.calendar, self.calendar, date):
            return self.calendar.AdjustBankingDays(date, -1)
        else:
            return date
        
    def nextmonthstartdate(self):
        date = acm.Time.FirstDayOfMonth(dateNextMonth)
        if self.calendar.IsNonBankingDay(self.calendar, self.calendar, date):
            return self.calendar.AdjustBankingDays(date, 1)
        else:
            return date
    
    def prevmonthenddate(self):
        date = acm.Time.LastDayOfMonth(datePrevMonth)
        if self.calendar.IsNonBankingDay(self.calendar, self.calendar, date):
            return self.calendar.AdjustBankingDays(date, -1)
        else:
            return date

    def prevmonthstartdate(self):
        date = acm.Time.FirstDayOfMonth(datePrevMonth)
        if self.calendar.IsNonBankingDay(self.calendar, self.calendar, date):
            return self.calendar.AdjustBankingDays(date, 1)
        else:
            return date

...

  STATIC_ACCOUNTING_TYPE

from DataStager import *
from STATIC import *

ael_gui_parameters={'runButtonLabel':'&&Run',
                    'hideExtraControls': True,
                    'windowCaption':'STATIC_ACCOUNTING_TYPE'}

ael_variables=[
['query_folder','Query Folders','string', filter_query_folder('Choice List'), 'WEBEAI_STATIC_ACCOUNTING_TYPE', 1,0],
['file_path', 'Log Folder Path', getFilePathSelection(), None, getFilePathSelection(), 1, 1]]

def ael_main(parameter):
    text_result = ''
    table_name = 'STATIC_ACCOUNTING_TYPE'
    columns = ('ACCTNGTYPE', 'ACCTDESC')
    file_path = str(parameter['file_path'])
    query_folder = parameter['query_folder']
    
    db_query = acm.FStoredASQLQuery[query_folder].Query()
    acctngs = db_query.Select()
    data = []
    
    stt = Static_Modules()
   
    for i in acctngs:
        stt.set_choicelist(i)
        
        temp_result = (
            stt.acctngtype(),
            stt.acctdesc()
        )
        if temp_result[0] != None:
            data.append(temp_result)
        else:
            continue
    
    data = list(set(data))
    text_result += "Table : " + table_name + "\n"
    text_result += "Columns : " + str(columns) + "\n"
    
    if data == [] :
        text_result += '\nNo new data to be inserted/updated.\n'
    else:
        dbOps = TableManipulator()
        cursor, text_connect = dbOps.connect()

        text_result += text_connect
        text_result += dbOps.upsert(table_name, columns, data, [columns[0]])
        #text_result += dbOps.delete_row_from_table(table_name, tuple(void_trades), columns[0])
        #text_result += dbOps.truncate([table_name])
        text_result += dbOps.disconnect()
        
    print(text_result)
    extension_value_name = table_name + '_LOG'
    storeToExtensionValue(extension_value_name, text_result)
    write_log_file(file_path, extension_value_name, text_result)


...

  STATIC_CUSTOMER

from DataStager import *
from STATIC import *

ael_gui_parameters={'runButtonLabel':'&&Run',
                    'hideExtraControls': True,
                    'windowCaption':'STATIC_CUSTOMER'}

ael_variables=[
['query_folder','Query Folders','string', filter_query_folder('Party'), 'WEBEAI_STATIC_CUSTOMER', 1,0],
['file_path', 'Log Folder Path', getFilePathSelection(), None, getFilePathSelection(), 1, 1]]

def ael_main(parameter):
    text_result = ''
    table_name = 'STATIC_CUSTOMER'
    columns = ('CNO', 'LHBU_ID', 'CMNE', 'BIC', 'CCODE', 'SIC', 'SN', 'CFN1', 'CA', 'CTYPE', 'TAXID', 'ACCTNGTYPE')
    file_path = str(parameter['file_path'])
    query_folder = parameter['query_folder']
    
    db_query = acm.FStoredASQLQuery[query_folder].Query()
    parties = db_query.Select()
    data = []
    
    stt = Static_Modules()
   
    for i in parties:
        stt.set_party(i)
        
        temp_result = (
            stt.cno(),
            stt.lhbu_id(),
            stt.cmne(),
            stt.bic(),
            stt.ccode(),
            stt.cust_sic(),
            stt.sn(),
            stt.cfn1(),
            stt.ca(),
            stt.ctype(),
            stt.taxid(),
            stt.cust_acctngtype()
        )
        if temp_result[0] != None:
            data.append(temp_result)
        else:
            continue
    
    data = list(set(data))
    text_result += "Table : " + table_name + "\n"
    text_result += "Columns : " + str(columns) + "\n"
    
    if data == [] :
        text_result += '\nNo new data to be inserted/updated.\n'
    else:
        dbOps = TableManipulator()
        cursor, text_connect = dbOps.connect()

        text_result += text_connect
        text_result += dbOps.upsert(table_name, columns, data, [columns[0]])
        #text_result += dbOps.delete_row_from_table(table_name, tuple(void_trades), columns[0])
        #text_result += dbOps.truncate([table_name])
        text_result += dbOps.disconnect()
        
    print(text_result)
    extension_value_name = table_name + '_LOG'
    storeToExtensionValue(extension_value_name, text_result)
    write_log_file(file_path, extension_value_name, text_result)


...

  STATIC_HLDY

from DataStager import *
from STATIC import *

ael_gui_parameters={'runButtonLabel':'&&Run',
                    'hideExtraControls': True,
                    'windowCaption':'STATIC_HLDY'}

ael_variables=[
['query_folder','Query Folders','string', filter_query_folder('Instrument'), 'WEBEAI_STATIC_HLDY', 1,0],
['file_path', 'Log Folder Path', getFilePathSelection(), None, getFilePathSelection(), 1, 1]]

def ael_main(parameter):
    text_result = ''
    table_name = 'STATIC_HLDY'
    columns = ('CCY', 'HOLIDATE')
    file_path = str(parameter['file_path'])
    query_folder = parameter['query_folder']
    
    db_query = acm.FStoredASQLQuery[query_folder].Query()
    instruments = db_query.Select()
    data = []
    
    stt = Static_Modules()
    
    thisYear = acm.Time.DateToday().split('-')[0]
    startDate = acm.Time.AsDate('{}-01-01'.format(thisYear))
    endDate = acm.Time.AsDate('{}-12-31'.format(thisYear))

    for i in instruments:
        stt.set_instrument(i)
        ccy = stt.ccy()
        
        if ccy != None:
            date = startDate
            while date <= endDate:
                calendar = acm.FCalendar[i.Calendar().Name()]
                if calendar.IsNonBankingDay(None, None, date):
                    temp_result = (
                        ccy, date
                    )
                    data.append(temp_result)
                date = acm.Time.DateAddDelta(date, 0, 0, 1)
        else:
            continue
    
    data = list(set(data))
    text_result += "Table : " + table_name + "\n"
    text_result += "Columns : " + str(columns) + "\n"
    
    if data == [] :
        text_result += '\nNo new data to be inserted/updated.\n'
    else:
        dbOps = TableManipulator()
        cursor, text_connect = dbOps.connect()

        text_result += text_connect
        text_result += dbOps.delete([table_name])
        text_result += dbOps.upsert(table_name, columns, data, [columns[0], columns[1]])
        #text_result += dbOps.delete_row_from_table(table_name, tuple(void_trades), columns[0])
        #text_result += dbOps.truncate([table_name])
        text_result += dbOps.disconnect()
        
    print(text_result)
    extension_value_name = table_name + '_LOG'
    storeToExtensionValue(extension_value_name, text_result)
    write_log_file(file_path, extension_value_name, text_result)


...

  STATIC_NOSTRO

from DataStager import *
from STATIC import *

ael_gui_parameters={'runButtonLabel':'&&Run',
                    'hideExtraControls': True,
                    'windowCaption':'STATIC_NOSTRO'}

ael_variables=[
['query_folder','Query Folders','string', filter_query_folder('Account'), 'WEBEAI_STATIC_NOSTRO', 1,0],
['file_path', 'Log Folder Path', getFilePathSelection(), None, getFilePathSelection(), 1, 1]]

def ael_main(parameter):
    text_result = ''
    table_name = 'STATIC_NOSTRO'
    columns = ('NOSTRO_ID', 'CCY', 'NOSTRO_PARTY')
    file_path = str(parameter['file_path'])
    query_folder = parameter['query_folder']
    
    db_query = acm.FStoredASQLQuery[query_folder].Query()
    accounts = db_query.Select()
    data = []
    
    stt = Static_Modules()
   
    for i in accounts:
        stt.set_account(i)
        
        temp_result = (
            stt.nostro_id(),
            stt.nostro_ccy(),
            stt.nostro_party()
        )
        if (temp_result[0] != None) & (temp_result[1] != None):
            data.append(temp_result)
        else:
            continue
    
    data = list(set(data))
    text_result += "Table : " + table_name + "\n"
    text_result += "Columns : " + str(columns) + "\n"
    
    if data == [] :
        text_result += '\nNo new data to be inserted/updated.\n'
    else:
        dbOps = TableManipulator()
        cursor, text_connect = dbOps.connect()

        text_result += text_connect
        text_result += dbOps.upsert(table_name, columns, data, [columns[0]])
        #text_result += dbOps.delete_row_from_table(table_name, tuple(void_trades), columns[0])
        #text_result += dbOps.truncate([table_name])
        text_result += dbOps.disconnect()
        
    print(text_result)
    extension_value_name = table_name + '_LOG'
    storeToExtensionValue(extension_value_name, text_result)
    write_log_file(file_path, extension_value_name, text_result)


...

  STATIC_OPER

from DataStager import *
from STATIC import *

ael_gui_parameters={'runButtonLabel':'&&Run',
                    'hideExtraControls': True,
                    'windowCaption':'STATIC_OPER'}

ael_variables=[
['query_folder','Query Folders','string', filter_query_folder('Trx History'), 'WEBEAI_STATIC_OPER', 1,0],
['file_path', 'Log Folder Path', getFilePathSelection(), None, getFilePathSelection(), 1, 1]]

def ael_main(parameter):
    text_result = ''
    table_name = 'STATIC_OPER'
    columns = ('OPERATOR', 'NAME', 'LDAPID')
    file_path = str(parameter['file_path'])
    query_folder = parameter['query_folder']
    
    db_query = acm.FStoredASQLQuery[query_folder].Query()
    users = db_query.Select()
    data = []
    
    stt = Static_Modules()
   
    for i in users:
        stt.set_user(i)
        
        temp_result = (
            stt.operator(),
            stt.oper_name(),
            stt.ldapid()
        )
        if temp_result[0] != None:
            data.append(temp_result)
        else:
            continue
    
    data = list(set(data))
    text_result += "Table : " + table_name + "\n"
    text_result += "Columns : " + str(columns) + "\n"
    
    if data == [] :
        text_result += '\nNo new data to be inserted/updated.\n'
    else:
        dbOps = TableManipulator()
        cursor, text_connect = dbOps.connect()

        text_result += text_connect
        text_result += dbOps.upsert(table_name, columns, data, [columns[0]])
        #text_result += dbOps.delete_row_from_table(table_name, tuple(void_trades), columns[0])
        #text_result += dbOps.truncate([table_name])
        text_result += dbOps.disconnect()
        
    print(text_result)
    extension_value_name = table_name + '_LOG'
    storeToExtensionValue(extension_value_name, text_result)
    write_log_file(file_path, extension_value_name, text_result)


...

  STATIC_PORTOFOLIO

from DataStager import *
from STATIC import *

ael_gui_parameters={'runButtonLabel':'&&Run',
                    'hideExtraControls': True,
                    'windowCaption':'STATIC_PORTOFOLIO'}

ael_variables=[
['query_folder','Query Folders','string', filter_query_folder('Portfolio'), 'WEBEAI_STATIC_PORTOFOLIO', 1,0],
['file_path', 'Log Folder Path', getFilePathSelection(), None, getFilePathSelection(), 1, 1]]

def ael_main(parameter):
    text_result = ''
    table_name = 'STATIC_PORTOFOLIO'
    columns = ('PORT', 'DESCRIPTION')
    file_path = str(parameter['file_path'])
    query_folder = parameter['query_folder']
    
    db_query = acm.FStoredASQLQuery[query_folder].Query()
    prfs = db_query.Select()
    data = []
    
    stt = Static_Modules()
   
    for i in prfs:
        stt.set_portfolio(i)
        
        temp_result = (
            stt.port(),
            stt.port_desc()
        )
        if temp_result[0] != None:
            data.append(temp_result)
        else:
            continue
    
    data = list(set(data))
    text_result += "Table : " + table_name + "\n"
    text_result += "Columns : " + str(columns) + "\n"
    
    if data == [] :
        text_result += '\nNo new data to be inserted/updated.\n'
    else:
        dbOps = TableManipulator()
        cursor, text_connect = dbOps.connect()

        text_result += text_connect
        text_result += dbOps.upsert(table_name, columns, data, [columns[0]])
        #text_result += dbOps.delete_row_from_table(table_name, tuple(void_trades), columns[0])
        #text_result += dbOps.truncate([table_name])
        text_result += dbOps.disconnect()
        
    print(text_result)
    extension_value_name = table_name + '_LOG'
    storeToExtensionValue(extension_value_name, text_result)
    write_log_file(file_path, extension_value_name, text_result)


...

  STATIC_RATE

from DataStager import *
from STATIC import *

ael_gui_parameters={'runButtonLabel':'&&Run',
                    'hideExtraControls': True,
                    'windowCaption':'STATIC_RATE'}

ael_variables=[
['query_folder','Query Folders','string', filter_query_folder('Currency Pair'), 'WEBEAI_STATIC_RATE', 1,0],
['file_path', 'Log Folder Path', getFilePathSelection(), None, getFilePathSelection(), 1, 1]]

def ael_main(parameter):
    text_result = ''
    table_name = 'STATIC_RATE'
    columns = ('CCY', 'SPOTRATE', 'TERM', 'DATE', 'RATETYPE')
    file_path = str(parameter['file_path'])
    query_folder = parameter['query_folder']
    
    db_query = acm.FStoredASQLQuery[query_folder].Query()
    currencypairs = db_query.Select()
    data = []
    
    stt = Static_Modules()
   
    for i in currencypairs:
        stt.set_pair(i)
        
        temp_result = (
            stt.rate_ccy(),
            stt.rate_spotrate(),
            stt.rate_term(),
            stt.rate_date(),
            stt.rate_type()
        )
        if temp_result[0] != None:
            data.append(temp_result)
        else:
            continue
    
    data = list(set(data))
    text_result += "Table : " + table_name + "\n"
    text_result += "Columns : " + str(columns) + "\n"
    
    if data == [] :
        text_result += '\nNo new data to be inserted/updated.\n'
    else:
        dbOps = TableManipulator()
        cursor, text_connect = dbOps.connect()

        text_result += text_connect
        text_result += dbOps.upsert(table_name, columns, data, [columns[0], columns[3]])
        #text_result += dbOps.delete_row_from_table(table_name, tuple(void_trades), columns[0])
        #text_result += dbOps.truncate([table_name])
        text_result += dbOps.disconnect()
        
    print(text_result)
    extension_value_name = table_name + '_LOG'
    storeToExtensionValue(extension_value_name, text_result)
    write_log_file(file_path, extension_value_name, text_result)


...

  STATIC_SECURITIES

from DataStager import *
from STATIC import *

ael_gui_parameters={'runButtonLabel':'&&Run',
                    'hideExtraControls': True,
                    'windowCaption':'STATIC_SECURITIES'}

ael_variables=[
['query_folder','Query Folders','string', filter_query_folder('Instrument'), 'WEBEAI_STATIC_SECURITIES', 1,0],
['file_path', 'Log Folder Path', getFilePathSelection(), None, getFilePathSelection(), 1, 1]]

def ael_main(parameter):
    text_result = ''
    table_name = 'STATIC_SECURITIES'
    columns = ('SECID', 'ACCTNGTYPE', 'COUPRATE_8', 'CCY', 'DENOM', 'DESCR', 'FIRSTIPAYDATE', 'BASIS', 'RATECODE', 'ISSDATE', 'ISSUER', 'LSTMNTDATE', 'MDATE', 'MUTFUNDIND', 'PRODUCT', 'PRODTYPE', 'VDATE', 'FIXRATE_8', 'ISIN')
    file_path = str(parameter['file_path'])
    query_folder = parameter['query_folder']
    
    db_query = acm.FStoredASQLQuery[query_folder].Query()
    instruments = db_query.Select()
    data = []
    
    stt = Static_Modules()
   
    for i in instruments:
        stt.set_instrument(i)
        
        temp_result = (
            stt.secid(),
            stt.sec_acctngtype(),
            stt.couprate_8(),
            stt.sec_ccy(),
            stt.denom(),
            stt.sec_descr(),
            stt.firstipaydate(),
            stt.basis(),
            stt.ratecode(),
            stt.issdate(),
            stt.issuer(),
            stt.lstmntdate(),
            stt.mdate(),
            stt.mutfundind(),
            stt.prod(),
            stt.prodtype(),
            stt.valuedate(),
            stt.fixrate_8(),
            stt.isin()
        )
        if temp_result[0] != None:
            data.append(temp_result)
        else:
            continue
    
    data = list(set(data))
    text_result += "Table : " + table_name + "\n"
    text_result += "Columns : " + str(columns) + "\n"
    
    if data == [] :
        text_result += '\nNo new data to be inserted/updated.\n'
    else:
        dbOps = TableManipulator()
        cursor, text_connect = dbOps.connect()

        text_result += text_connect
        text_result += dbOps.upsert(table_name, columns, data, [columns[0]])
        #text_result += dbOps.delete_row_from_table(table_name, tuple(void_trades), columns[0])
        #text_result += dbOps.truncate([table_name])
        text_result += dbOps.disconnect()
        
    print(text_result)
    extension_value_name = table_name + '_LOG'
    storeToExtensionValue(extension_value_name, text_result)
    write_log_file(file_path, extension_value_name, text_result)


...

  STATIC_STANDARD_INDUSTRY_CODE

from DataStager import *
from STATIC import *

ael_gui_parameters={'runButtonLabel':'&&Run',
                    'hideExtraControls': True,
                    'windowCaption':'STATIC_STANDARD_INDUSTRY_CODE'}

ael_variables=[
['query_folder','Query Folders','string', filter_query_folder('Choice List'), 'WEBEAI_STATIC_STANDARD_INDUSTRY_CODE', 1,0],
['file_path', 'Log Folder Path', getFilePathSelection(), None, getFilePathSelection(), 1, 1]]

def ael_main(parameter):
    text_result = ''
    table_name = 'STATIC_STANDARD_INDUSTRY_CODE'
    columns = ('SIC', 'SD')
    file_path = str(parameter['file_path'])
    query_folder = parameter['query_folder']
    
    db_query = acm.FStoredASQLQuery[query_folder].Query()
    inds = db_query.Select()
    data = []
    
    stt = Static_Modules()
   
    for i in inds:
        stt.set_choicelist(i)
        
        temp_result = (
            stt.sic(),
            stt.sd()
        )
        if temp_result[0] != None:
            data.append(temp_result)
        else:
            continue
    
    data = list(set(data))
    text_result += "Table : " + table_name + "\n"
    text_result += "Columns : " + str(columns) + "\n"
    
    if data == [] :
        text_result += '\nNo new data to be inserted/updated.\n'
    else:
        dbOps = TableManipulator()
        cursor, text_connect = dbOps.connect()

        text_result += text_connect
        text_result += dbOps.upsert(table_name, columns, data, [columns[0]])
        #text_result += dbOps.delete_row_from_table(table_name, tuple(void_trades), columns[0])
        #text_result += dbOps.truncate([table_name])
        text_result += dbOps.disconnect()
        
    print(text_result)
    extension_value_name = table_name + '_LOG'
    storeToExtensionValue(extension_value_name, text_result)
    write_log_file(file_path, extension_value_name, text_result)


...

  STATIC_SYSTEMDATE

from DataStager import *
from STATIC import *

ael_gui_parameters={'runButtonLabel':'&&Run',
                    'hideExtraControls': True,
                    'windowCaption':'STATIC_SYSTEMDATE'}

ael_variables=[
['query_folder','Query Folders','string', filter_query_folder('Calendar'), 'WEBEAI_STATIC_SYSTEMDATE', 1,0],
['file_path', 'Log Folder Path', getFilePathSelection(), None, getFilePathSelection(), 1, 1]]

def ael_main(parameter):
    text_result = ''
    table_name = 'STATIC_SYSTEMDATE'
    columns = ('BRANPRCDATE', 'PREVBRANPRCDATE', 'PREVPREVBRANPRCDATE', 'NEXTBRANPRCDATE', 'NEXTNEXTBRANPRCDATE', 'MONTHENDDATE', 'MONTHSTARTDATE', 'YEARENDDATE', 'YEARSTARTDATE', 'NEXTMONTHENDDATE', 'NEXTMONTHSTARTDATE', 'PREVMONTHENDDATE', 'PREVMONTHSTARTDATE')
    file_path = str(parameter['file_path'])
    query_folder = parameter['query_folder']
    
    db_query = acm.FStoredASQLQuery[query_folder].Query()
    calendars = db_query.Select()
    data = []
    
    stt = Static_Modules()
   
    for i in calendars:
        stt.set_calendar(i)
        
        temp_result = (
            stt.branprcdate(),
            stt.prevbranprcdate(),
            stt.prevprevbranprcdate(),
            stt.nextbranprcdate(),
            stt.nextnextbranprcdate(),
            stt.monthenddate(),
            stt.monthstartdate(),
            stt.yearenddate(),
            stt.yearstartdate(),
            stt.nextmonthenddate(),
            stt.nextmonthstartdate(),
            stt.prevmonthenddate(),
            stt.prevmonthstartdate()
        )
        data.append(temp_result)
    
    data = list(set(data))
    text_result += "Table : " + table_name + "\n"
    text_result += "Columns : " + str(columns) + "\n"
    
    if data == [] :
        text_result += '\nNo new data to be inserted/updated.\n'
    else:
        dbOps = TableManipulator()
        cursor, text_connect = dbOps.connect()

        text_result += text_connect
        text_result += dbOps.delete([table_name])
        text_result += dbOps.upsert(table_name, columns, data)
        #text_result += dbOps.delete_row_from_table(table_name, tuple(void_trades), columns[0])
        #text_result += dbOps.truncate([table_name])
        text_result += dbOps.disconnect()
        
    print(text_result)
    extension_value_name = table_name + '_LOG'
    storeToExtensionValue(extension_value_name, text_result)
    write_log_file(file_path, extension_value_name, text_result)


...

  STATIC_TRAD

from DataStager import *
from STATIC import *

ael_gui_parameters={'runButtonLabel':'&&Run',
                    'hideExtraControls': True,
                    'windowCaption':'STATIC_TRAD'}

ael_variables=[
['query_folder','Query Folders','string', filter_query_folder('Trade'), 'WEBEAI_STATIC_TRAD', 1,0],
['file_path', 'Log Folder Path', getFilePathSelection(), None, getFilePathSelection(), 1, 1]]

def ael_main(parameter):
    text_result = ''
    table_name = 'STATIC_TRAD'
    columns = ('TRADER', 'NAME')
    file_path = str(parameter['file_path'])
    query_folder = parameter['query_folder']
    
    db_query = acm.FStoredASQLQuery[query_folder].Query()
    trader = db_query.Select()
    data = []
    
    stt = Static_Modules()
    
    for each_trader in trader:
        stt.set_user(each_trader)
        
        temp_result = (
        stt.trader_id(),
        stt.trader_name()
        )
        
        if temp_result[0] != None:
            data.append(temp_result)
        else:
            continue
    
    data = list(set(data))
    
    text_result += "Table : " + table_name + "\n"
    text_result += "Columns : " + str(columns) + "\n"
    
    if data == [] :
        text_result += '\nNo new data to be inserted/updated.\n'
    else:
        dbOps = TableManipulator()
        cursor, text_connect = dbOps.connect()

        text_result += text_connect
        text_result += dbOps.upsert(table_name, columns, data, [columns[0]])
        #text_result += dbOps.delete_row_from_table(table_name, tuple(void_trades), columns[0])
        #text_result += dbOps.truncate([table_name])
        text_result += dbOps.disconnect()
        
    print(text_result)
    extension_value_name = table_name + '_LOG'
    storeToExtensionValue(extension_value_name, text_result)
    write_log_file(file_path, extension_value_name, text_result)


...

  TMS

import acm, ael, time

dateToday = acm.Time.DateToday()

class TMS_Modules:
    
    def __init__(self):
        pass
    
    def set_trade(self, trade):
        self.trade = trade
    
    def dealno(self):
        return self.trade.Oid()
        #return self.trade.AdditionalInfo().DealNO()
    
    def valuedate(self):
        try:
            if str(self.trade.InstrumentSubType()) == 'NDF':
                return self.trade.RightDate()
            return self.trade.ValueDay()
        except:
            return None
        
    def cno(self):
        try:
            party = self.trade.Counterparty()
            hostId = party.HostId()
            if hostId.strip():
                return hostId
            else:
                alias = party.Id2()
                if alias.isdigit():
                    return alias
                else:
                    return party.Id().split("_")[0]
        except:
            return None
        
    def dealdate(self):
        temp_time = self.trade.TradeTime()
        temp_time = acm.Time.DateTimeToTime(temp_time)
        formatted_time = time.strftime("%Y-%m-%d %H:%M:%S", time.strptime(time.ctime(temp_time)))
        return formatted_time
    
    def inputdate(self):
        temp_time = self.trade.CreateTime()
        formatted_time = time.strftime("%Y-%m-%d %H:%M:%S", time.strptime(time.ctime(temp_time)))
        return formatted_time
        
    def product(self):
        try :
            return self.trade.OptKey3().Name()
        except:
            return None

    def prodtype(self):
        try :
            return self.trade.OptKey4().Name()
        except:
            return None
    
    def farnearind(self):
        if self.trade.IsFxSwapFarLeg():
            return 'F'
        else:
            return 'N'
            
    def ccy(self):
        if not self.trade.PositionOrInstrumentPair():
            return self.trade.Currency().Name()
        else:
            return self.trade.PositionOrInstrumentPair().Instrument1().Name()
    
    def ctrccy(self):
        if not self.trade.PositionOrInstrumentPair():
            return None
        else:
            return self.trade.PositionOrInstrumentPair().Instrument2().Name()
        
    def ccyamt(self):
        try:
            return self.trade.Position()
        except:
            return None
        
    def ctramt(self):
        try:
            if self.trade.InstrumentSubType().Text().lower() == 'fx option':
                return (-1) * self.ccyamt() * self.trade.Instrument().StrikePrice()
            else:
                return (-1) * self.ccyamt() * self.trade.Price()
        except:
            return None
        
    def ccybamt(self):
        try:
            return self.trade.Currency().NominalAmount()
        except:
            return None
    
    def totpayamt(self):
        try:
            trade_valuedate = self.valuedate()
            trade_mdate = self.mdate()
            if dateToday < trade_mdate:
                return self.trade.StartCash()
            else:
                return self.totendcash()
        except:
            return None

    def totendcash(self):
        return self.purchintamt()
            
    def intamt(self):
        return self.trade.InterestRateAtTradeTime()
    
    def intrate_8(self):
        return self.trade.InterestRateAtTradeTime()
    
    def smeans(self):
        return self.trade.AccountId()
        
    def sacct(self):
        return None
        
    def intsmeans(self):
        return self.trade.AccountId()
    
    def intsacct(self):
        return None
        
    def pay_ccy(self):
        try:
            return self.trade.Instrument().PayLeg().Currency().Name()
        except:
            return None

    def pay_amt(self):
        try:
            return self.trade.Instrument().ContractSize()
        except:
            return None
    
    def receive_ccy(self):
        try:
            return self.trade.Instrument().RecLeg().Currency().Name()
        except:
            return None

    def receive_amt(self):
        try:
            return self.pay_amt() * self.trade.Instrument().RecLeg().NominalFactor()
        except:
            return None 
            
    def proceedamt(self):
        return self.trade.Premium()
        
    def faceamt(self):
        return self.trade.Instrument().FaceValue()
        
    def costamt(self):
        return self.trade.Nominal()
        
    def qty(self):
        return self.trade.Quantity()
        
    def purchintamt(self):
        try:
            stand_calc = acm.FStandardCalculationsSpaceCollection()
            facevalue = self.trade.FaceValue()
            mfs = self.trade.MoneyFlows()
            total_proj = 0.0
            for mf in mfs:
                if mf.Type() in ['Fixed Rate', 'Float Rate']:
                    value = mf.Calculation().Projected(stand_calc).Value().Number()
                    if not acm.Operations().IsValueInfNanOrQNan(value):
                        proj = float(value)
                        total_proj += proj
            total_proj += facevalue
            return total_proj
        except:
            return None
        
    def acctngtype_securities(self):
        try:
            return self.trade.Instrument().AddInfoValue('AccountingType')
        except:
            return None
        
    def price_8(self):
        return self.trade.Price()
        
    def secsacct(self):
        try:
            return self.trade.RegulatoryInfos().Last().ClearingHouse().Name()
        except:
            return None
    
    def ps(self):
        if self.trade.Quantity() >= 0:
            return 'P'
        else:
            return 'S'
            
    def ccode(self):
        try:
            return self.trade.Counterparty().Country()
        except:
            return None
    
    def acctngtype(self):
        try:
            return self.trade.OptKey3().Name()
        except:
            return None
        
    def invtype(self):
        try:
            return self.trade.Portfolio().TypeChlItem().Name()
        except:
            return None

    def beneficiary(self):
        try:
            return self.trade.Counterparty().Swift()
        except:
            return None
        
    def account(self):
        try:
            return self.trade.AccountId()
        except:
            return None
        
    def intermediary(self):
        try:
            return self.trade.Counterparty().Cls()
        except:
            return None
        
    def amend_date(self):
        def convert_status(status):
            try:
                status = str(int(status))
                status = acm.FTradeStatusValue.Select(f"enumValue={status}").First().NiceName()
            except:
                pass
            return status
        try:
            r = ael.asql(f"""
            SELECT 
                t.seqnbr, t.creat_time 
            FROM 
                TransHst t 
            WHERE 
                t.trans_record_type = 'Trade' 
                AND t.record_id = {self.trade.Oid()}
            ORDER BY 
                t.creat_time ASC
            """)
            state = False
            for result in r[1][0]:
                transhst_id = result[0]
                TransactionHistory = acm.FTransactionHistory[transhst_id]
                newValue = convert_status(TransactionHistory.NewFieldValue('Status', 'Trade'))
                oldValue = convert_status(TransactionHistory.OldFieldValue('Status', 'Trade'))
                if state and newValue == 'FO Confirmed':
                    return acm.Time.UtcToLocal(result[1])
                elif not oldValue:
                    continue
                elif oldValue == 'BO Rejected':
                    state = True
                    continue
            return None
        except:
            return None
    
    def port(self):
        try:
            return self.trade.Portfolio().Name()[:50]
        except:
            return None
        
    def trad(self):
        try:
            return self.trade.Trader().Oid()
        except:
            return None
        
    def cost(self):
        try:
            return self.trade.Portfolio().AddInfoValue('COST CENTER')
        except:
            return None
        
    def ioper(self):
        try:
            return self.trade.CreateUser().Oid()
        except:
            return None
        
    def voper(self):
        try:
            return self.trade.UpdateUser().Oid()
        except:
            return None
    
    def payoper(self):
        try:
            return self.trade.Payments().Last().CreateUser().Oid()
        except:
            return None
            
    def authoper(self):
        try:
            return self.trade.Authorizer().Oid()
        except:
            return None
    
    def revoper(self):
        try:
            return self.trade.UpdateUser().Oid()
        except:
            return None

    def revauth(self):
        try:
            return self.trade.Authorizer().Oid()
        except:
            return None
        
    def dealtext(self):
        return self.trade.Text1()
    
    def fedealno(self):
        try:
            return self.trade.OptionalKey()
        except:
            return None
        
    def whtamt(self):
        return self.trade.Instrument().DividendFactor()
    
    def convert_network_name(self, account_object):
        network_name = account_object.NetworkAliasType().Name().lower()
        if network_name == 'emas':
            return 'EMARETL'
        elif network_name in ('swift', 'rtgs'):
            return 'NOS'
        else:
            return None
    
    def get_account(self, account_object):
        network = self.convert_network_name(account_object)
        if network == 'EMARETL':
            return account_object.Account()
        elif network == 'NOS':
            return account_object.Name()
        else:
            return None

    def ccysmeans(self):
        try:   
            moneyFlows = self.trade.MoneyFlows()
            if moneyFlows:
                for mf in moneyFlows:
                    party_account = mf.AcquirerAccount()
                    if self.trade.TradeInstrumentType().lower() == 'curr':
                        if mf.Currency() == self.trade.Instrument():
                            return self.convert_network_name(party_account)
                        else:
                            continue
                    else:
                        if mf.Currency() == self.trade.Currency():
                            return self.convert_network_name(party_account)
                        else:
                            continue
                return None
            else:
                return None
        except:
            return None
    
    def ctrccysmeans(self):
        try:   
            moneyFlows = self.trade.MoneyFlows()
            if moneyFlows:
                for mf in moneyFlows:
                    party_account = mf.AcquirerAccount()
                    if self.trade.TradeInstrumentType().lower() == 'curr':
                        if mf.Currency() == self.trade.Currency():
                            return self.convert_network_name(party_account)
                        else:
                            continue
                    else:
                        return None
                return None
            else:
                return None
        except:
            return None

    def ccysacct(self):
        try:   
            moneyFlows = self.trade.MoneyFlows()
            if moneyFlows:
                for mf in moneyFlows:
                    party_account = mf.AcquirerAccount()
                    if self.trade.TradeInstrumentType().lower() == 'curr':
                        if mf.Currency() == self.trade.Instrument():
                            return self.get_account(party_account)
                        else:
                            continue
                    else:
                        if mf.Currency() == self.trade.Currency():
                            return self.get_account(party_account)
                        else:
                            continue
                return None
            else:
                return None
        except:
            return None
        
    def ctrsacct(self):
        try:   
            moneyFlows = self.trade.MoneyFlows()
            if moneyFlows:
                for mf in moneyFlows:
                    party_account = mf.AcquirerAccount()
                    if self.trade.TradeInstrumentType().lower() == 'curr':
                        if mf.Currency() == self.trade.Currency():
                            return self.get_account(party_account)
                        else:
                            continue
                    else:
                        return None
                return None
            else:
                return None
        except:
            return None
    
    def spotfwd(self):
        try:
            if self.product().lower() == 'fx':
                if self.prodtype().lower() in ('tod', 'tom', 'spot'):
                    return 'S'
                elif self.prodtype().lower() == 'fwd':
                    return 'F'
                elif self.prodtype().lower() == 'swap':
                    farleg = self.trade.IsFxSwapFarLeg()
                    return 'F' if farleg else 'S'
                elif self.trade.TradeInstrumentType().lower() == 'future/forward':
                    if self.trade.Type().lower() == 'normal':
                        return 'F'
                    elif self.trade.Type().lower() == 'closing':
                        return 'S'
                    else:
                        return None
            else:
                return None
        except:
            return None
            
    def rate(self):
        try:
            if self.trade.TradeInstrumentType().lower() == 'option':
                return self.trade.Instrument().StrikePrice()
            elif self.trade.TradeInstrumentType().lower() == 'currswap':
                return self.trade.Instrument().RecLeg().NominalFactor()
            else:
                return self.trade.Price()
        except:
            return None
    
    def br(self):
        try :
            return self.trade.OptKey1().Name()
        except:
            return None
        
    def status(self):
        return self.trade.Status()
    
    def broker(self):
        try:
            return self.trade.Broker().Oid()
        except:
            return None
    
    def brokername(self):
        try:
            return self.trade.Broker().Name()
        except:
            return None
            
    def brokerccy(self):
        try:
            return self.trade.Currency().Name()
        except:
            return None
        
    def corpport(self):
        try:
            return self.trade.Portfolio().Name()[:50]
        except:
            return None
    
    def corptrad(self):
        try:
            return self.trade.Trader().Oid()
        except:
            return None
    
    def corpcost(self):
        try:
            return self.trade.Portfolio().AddInfoValue('COST CENTER')
        except:
            return None

    def lstmntdate(self):
        temp_time = self.trade.UpdateTime()
        formatted_time = time.strftime("%Y-%m-%d %H:%M:%S", time.strptime(time.ctime(temp_time)))
        return formatted_time
        
    def mdate(self):
        return self.trade.ValueDay()

    def secid(self):
        try:
            return self.trade.Instrument().Name()[:50]
        except:
            return None
        
    def server(self):
        try :
            return self.trade.OptKey2().Name()
        except:
            return None

    def ndealno(self):
        return self.trade.Oid()
    
    def fdealno(self):
        return self.trade.Oid()
        
    def nprodcode(self):
        try :
            return self.trade.OptKey3().Name()
        except:
            return None
        
    def fprodcode(self):
        try :
            return self.trade.OptKey3().Name()
        except:
            return None

    def ncno(self):
        try:
            return self.trade.Counterparty().Oid()
        except:
            return None
    
    def fcno(self):
        try:
            return self.trade.Counterparty().Oid()
        except:
            return None
    
    def nprodtype(self):
        try :
            return self.trade.OptKey4().Name()
        except:
            return None
        
    def fprodtype(self):
        try :
            return self.trade.OptKey4().Name()
        except:
            return None
        
    def nvdate(self):
        return self.trade.ValueDay()
    
    def fvdate(self):
        return self.trade.ValueDay()
        
    def brokeramt(self):
        return self.trade.Fee()
    
    def effdate(self):
        return self.trade.ValueDay()
    
    def revreason(self):
        return self.trade.Text1()
            
    def ratecode(self):
        try:
            return self.trade.Instrument().FixFxRate()
        except:
            return None
        
    def basis(self):
        try:
            return self.trade.Instrument().Legs().First().DayCountMethod()
        except:
            return None
    
    def spread_8(self):
        try:
            return acm.Calculations().CreateCalculationSpace(acm.GetDefaultContext(),'FTradeSheet'). CreateCalculation(self.trade, 'Trade Yield').Value().Number() 
        except:
            return None
            
    def yield_8(self):
        try:
            return 100*acm.Calculations().CreateCalculationSpace(acm.GetDefaultContext(),'FTradeSheet'). CreateCalculation(self.trade, 'Trade Yield').Value().Number() 
        except:
            return None
    
    def swapdealno(self):
        try:
            if self.trade.OptKey3().Name().lower() == 'fx' and self.trade.OptKey4().Name().lower() == 'swap':
                if self.trade.ConnectedTrades().IsEmpty():
                    return self.trade.ConnectedTrade().Oid()
                else: 
                    if len(self.trade.ConnectedTrades()) == 1:
                        return None
                    else:
                        for connection in self.trade.TradeConnections():
                            if connection.Type().Text().lower() =='fxswap' and connection.FromTrade() == self.trade and connection.ToTrade() != self.trade:
                                return connection.ToTrade().Oid()
            else:
                return None
        except:
            return None
    
    def swapvdate(self):
        try:
            if self.trade.OptKey3().Name().lower() == 'fx' and self.trade.OptKey4().Name().lower() == 'swap':
                if self.trade.ConnectedTrades().IsEmpty():
                    return self.trade.ConnectedTrade().ValueDay()
                else: 
                    if len(self.trade.ConnectedTrades()) == 1:
                        return None
                    else:
                        for connection in self.trade.TradeConnections():
                            if connection.Type().Text().lower() =='fxswap' and connection.FromTrade() == self.trade and connection.ToTrade() != self.trade:
                                return connection.ToTrade().ValueDay()
            else:
                return None
        except:
            return None
    
    def verind(self):
        try:
            return self.trade.Authorizer().Oid()
        except:
            return None
    
    def spotdate(self):
        try:
            date, period = acm.Time.AsDate(self.trade.TradeTime()), 2
            calendar = acm.FCalendar['Jakarta']
            for n in range(period):
                date = acm.Time.DateAdjustPeriod(date, '1d', calendar, 'Following')
            return date
        except:
            return None
        
    def verdate(self):
        temp_time = self.trade.UpdateTime()
        formatted_time = time.strftime("%Y-%m-%d %H:%M:%S", time.strptime(time.ctime(temp_time)))
        return formatted_time
        
    def corpspreadamt(self):
        try:
            return acm.Calculations().CreateCalculationSpace(acm.GetDefaultContext(),'FTradeSheet'). CreateCalculation(self.trade, 'Trade Yield').Value().Number() 
        except:
            return None
    
    def fixratecode(self):
        try:
            return self.trade.Instrument().MainLeg().FloatRateReference().Name()
        except:
            return None
            
    def settdate(self):
        try:
            return self.trade.ValueDay()
        except:
            return None
            
    def settccy(self):
        try:
            return self.trade.Settlements().Last().Currency().Name()
        except:
            return None
    
    def strike(self):
        try:
            return self.trade.Instrument().Legs().First().StrikePrice()
        except:
            return None
        
    def option_status(self):
        return self.trade.TradeProcessesToString()
    
    def origqty(self):
        return self.trade.Quantity()
        
    def parent_vdate(self):
        try:
            return self.trade.ValueDay()
        except:
            return None
        
    def last_fixing(self):
        try:
            return self.trade.Instrument().Legs().Last().Cashflows().Last().Resets().Last().FixingDate()
        except:
            return None
    
    def next_fixing(self):
        try:
            return self.trade.Instrument().Legs().Last().Cashflows().Last().Resets().Last().FixingDate()
        except:
            return None
    
    def user_fixing(self):
        try:
            return self.trade.Instrument().Legs().Last().CalculationPeriodDateRule().UpdateUser().Oid()
        except:
            return None

    def conversation(self):
        return self.trade.Text1()
        
    def book(self):
        try:
            return self.trade.Portfolio().Name()
        except:
            return None
            
    def reverse_date(self):
        if ('void' not in self.status().lower()):
            return None
        else:
            ths = acm.FTransactionHistory.Select('transRecordType="Trade" and recordId={}'.format(self.trade.Oid()))
            for th in ths:
                newVal = th.NewFieldValue('status', 'Trade')
                if (newVal is not None):
                    if ('void' in newVal.lower()):
                        temp_time = th.UpdateTime()
                        return time.strftime("%Y-%m-%d %H:%M:%S", time.strptime(time.ctime(temp_time)))
        
    def call_ccy(self):
        try:
            if self.trade.Instrument().OptionType().lower() == "put":
                return self.trade.Instrument().Currency().Name()
            elif self.trade.Instrument().OptionType().lower() == "call":
                return self.trade.Instrument().Underlying().Name()
        except:
            return None
    
    def call_amt(self):
        try:
            return self.put_amt() * self.trade.Instrument().StrikePrice()
        except:
            return None
    
    def put_ccy(self):
        try:
            if self.trade.Instrument().OptionType().lower() == "put":
                return self.trade.Instrument().Underlying().Name()
            elif self.trade.Instrument().OptionType().lower() == "call":
                return self.trade.Instrument().Currency().Name()
        except:
            return None
    
    def put_amt(self):
        try:
            return self.trade.FaceValue()
        except:
            return None

    def premium_ccy(self):
        try:
            return self.trade.Currency().Name()
        except:
            return None
        
    def premium_amt(self):
        return self.trade.Premium()
    
    def intenddate(self):
        try:
            trade_valuedate = self.valuedate()
            trade_mdate = self.mdate()
            if dateToday < trade_mdate:
                return trade_valuedate
            else:
                return trade_mdate
        except:
            return None
        
    def schdtype(self):
        try:
            return self.trade.Instrument().Legs().Last().RollingPeriod()
        except:
            return None

...

  TMS_CCS_IRS

from DataStager import *
from TMS import *

ael_gui_parameters={'runButtonLabel':'&&Run',
                    'hideExtraControls': True,
                    'windowCaption':'TMS_CCS_IRS'}

ael_variables=[
['query_folder','Query Folders','string', filter_query_folder('Trade'), 'WEBEAI_TMS_CCS_IRS', 1,0],
['file_path', 'Log Folder Path', getFilePathSelection(), None, getFilePathSelection(), 1, 1]]

def ael_main(parameter):
    text_result = ''
    table_name = 'TMS_CCS_IRS'
    columns = ('DEALNO', 'EFFDATE', 'MDATE', 'CNO', 'DEALDATE', 'INPUTDATE', 'PRODCODE', 'PRODTYPE', 'PAY_CCY', 'PAY_AMT', 'RECEIVE_CCY', 'RECEIVE_AMT', 'PORT', 'TRAD', 'COST', 'IOPER', 'VOPER', 'PAYOPER', 'AUTHOPER', 'REVOPER', 'REVAUTH', 'DEALTEXT', 'FEDEALNO', 'CCYSMEANS', 'CCYSACCT', 'CTRCCYSMEANS', 'CTRSACCT', 'RATE', 'BENEFICIARY', 'ACCOUNT', 'INTERMEDIARY', 'BR', 'STATUS', 'AMENDTIME', 'PS', 'BOOK')
    file_path = str(parameter['file_path'])
    query_folder = parameter['query_folder']
    
    db_query = acm.FStoredASQLQuery[query_folder].Query()
    trades = db_query.Select()
    data = []

    tms_mod = TMS_Modules()

    for i in trades:
        tms_mod.set_trade(i)

        temp_result = (
            tms_mod.dealno(),
            tms_mod.effdate(),
            tms_mod.mdate(),
            tms_mod.cno(),
            tms_mod.dealdate(),
            tms_mod.inputdate(),
            tms_mod.product(),
            tms_mod.prodtype(),
            tms_mod.pay_ccy(),
            tms_mod.pay_amt(),
            tms_mod.receive_ccy(),
            tms_mod.receive_amt(),
            tms_mod.port(),
            tms_mod.trad(),
            tms_mod.cost(),
            tms_mod.ioper(),
            tms_mod.voper(),
            tms_mod.payoper(),
            tms_mod.authoper(),
            tms_mod.revoper(),
            tms_mod.revauth(),
            tms_mod.dealtext(),
            tms_mod.fedealno(),
            tms_mod.ccysmeans(),
            tms_mod.ccysacct(),
            tms_mod.ctrccysmeans(),
            tms_mod.ctrsacct(),
            tms_mod.rate(),
            tms_mod.beneficiary(),
            tms_mod.account(),
            tms_mod.intermediary(),
            tms_mod.br(),
            tms_mod.status(),
            tms_mod.amend_date(),
            tms_mod.ps(),
            tms_mod.book()
        )
        data.append(temp_result)
    
    
    data = list(set(data))
    text_result += "Table : " + table_name + "\n"
    text_result += "Columns : " + str(columns) + "\n"
    
    if data == [] :
        text_result += '\nNo new data to be inserted/updated.\n'
    else:
        dbOps = TableManipulator()
        cursor, text_connect = dbOps.connect()

        text_result += text_connect
        text_result += dbOps.upsert(table_name, columns, data, [columns[0]])
        #text_result += dbOps.delete_row_from_table(table_name, tuple(void_trades), columns[0])
        #text_result += dbOps.truncate([table_name])
        text_result += dbOps.disconnect()
        
    print(text_result)
    extension_value_name = table_name + '_LOG'
    storeToExtensionValue(extension_value_name, text_result)
    write_log_file(file_path, extension_value_name, text_result)




...

  TMS_FI_TRANSACTION

from DataStager import *
from TMS import *

ael_gui_parameters={'runButtonLabel':'&&Run',
                    'hideExtraControls': True,
                    'windowCaption':'TMS_FI_TRANSACTION'}

ael_variables=[
['query_folder','Query Folders','string', filter_query_folder('Trade'), 'WEBEAI_TMS_FI_TRANSACTION', 1,0],
['file_path', 'Log Folder Path', getFilePathSelection(), None, getFilePathSelection(), 1, 1]]

def ael_main(parameter):
    text_result = ''
    table_name = 'TMS_FI_TRANSACTION'
    columns = ('DEALNO', 'VDATE', 'SETTDATE', 'MDATE', 'DEALDATE', 'INPUTDATE', 'CNO', 'SECID', 'PRODUCT', 'PRODTYPE', 'CCY', 'PROCEEDAMT', 'FACEAMT', 'COSTAMT', 'QTY', 'PURCHINTAMT', 'ACCTNGTYPE_SECURITIES', 'YIELD_8_YIELD', 'PRICE_8_PRICE', 'SECSACCT_CUSTODIAN', 'CCYSACCT', 'DEALTEXT', 'FEDEALNO', 'WHTAMT_TAX', 'PORT', 'TRAD', 'COST', 'IOPER', 'VOPER', 'PAYOPER', 'AUTHOPER', 'REVOPER', 'REVAUTH', 'PS', 'INVTYPE', 'BENEFICIARY', 'ACCOUNT', 'INTERMEDIARY', 'REVERSE_DATE', 'AMEND_DATE', 'BR', 'STATUS', 'BROKER', 'BROKERAMT')
    file_path = str(parameter['file_path'])
    query_folder = parameter['query_folder']
    
    db_query = acm.FStoredASQLQuery[query_folder].Query()
    objects = db_query.Select()
    data = []
    
    tms_mod = TMS_Modules()
    
    for i in objects:
        tms_mod.set_trade(i)
        
        temp_result = (
            tms_mod.dealno(),
            tms_mod.valuedate(),
            tms_mod.settdate(),
            tms_mod.mdate(),
            tms_mod.dealdate(),
            tms_mod.inputdate(),
            tms_mod.cno(),
            tms_mod.secid(),
            tms_mod.product(),
            tms_mod.prodtype(),
            tms_mod.ccy(),
            tms_mod.proceedamt(),
            tms_mod.faceamt(),
            tms_mod.costamt(),
            tms_mod.qty(),
            tms_mod.purchintamt(),
            tms_mod.acctngtype_securities(),
            tms_mod.yield_8(),
            tms_mod.price_8(),
            tms_mod.secsacct(),
            tms_mod.ccysacct(),
            tms_mod.dealtext(),
            tms_mod.fedealno(),
            tms_mod.whtamt(),
            tms_mod.port(),
            tms_mod.trad(),
            tms_mod.cost(),
            tms_mod.ioper(),
            tms_mod.voper(),
            tms_mod.payoper(),
            tms_mod.authoper(),
            tms_mod.revoper(),
            tms_mod.revauth(),
            tms_mod.ps(),
            tms_mod.invtype(),
            tms_mod.beneficiary(),
            tms_mod.account(),
            tms_mod.intermediary(),
            tms_mod.reverse_date(),
            tms_mod.amend_date(),
            tms_mod.br(),
            tms_mod.status(),
            tms_mod.broker(),
            tms_mod.brokeramt(),
        )
        data.append(temp_result)

    data = list(set(data))
    text_result += "Table : " + table_name + "\n"
    text_result += "Columns : " + str(columns) + "\n"
    
    if data == [] :
        text_result += '\nNo new data to be inserted/updated.\n'
    else:
        dbOps = TableManipulator()
        cursor, text_connect = dbOps.connect()

        text_result += text_connect
        text_result += dbOps.upsert(table_name, columns, data, [columns[0]])
        #text_result += dbOps.delete_row_from_table(table_name, tuple(void_trades), columns[0])
        #text_result += dbOps.truncate([table_name])
        text_result += dbOps.disconnect()
        
    print(text_result)
    extension_value_name = table_name + '_LOG'
    storeToExtensionValue(extension_value_name, text_result)
    write_log_file(file_path, extension_value_name, text_result)





...

  TMS_FI_TRANSACTION_INTERFACE

from DataStager import *
from TMS import *

ael_gui_parameters={'runButtonLabel':'&&Run',
                    'hideExtraControls': True,
                    'windowCaption':'TMS_FI_TRANSACTION_INTERFACE'}

ael_variables=[
['query_folder','Query Folders','string', filter_query_folder('Trade'), 'WEBEAI_TMS_FI_TRANSACTION_INTERFACE', 1,0],
['file_path', 'Log Folder Path', getFilePathSelection(), None, getFilePathSelection(), 1, 1]]

def ael_main(parameter):
    text_result = ''
    table_name = 'TMS_FI_TRANSACTION_INTERFACE'
    columns = ('FEDEALNO', 'DEALNO', 'CNO', 'SECSACCT', 'PS', 'INVTYPE', 'PORT', 'TRAD', 'SECID', 'ORIGQTY', 'PRICE_8', 'SETTDATE', 'BROKFEEAMT', 'BROK', 'COST', 'RATECODE', 'INPUTDATE', 'DEALTEXT', 'VERIND', 'VERDATE', 'REVREASON', 'SETTCCY', 'SERVER', 'DEALDATE', 'AMENDTIME')
    file_path = str(parameter['file_path'])
    query_folder = parameter['query_folder']
    
    db_query = acm.FStoredASQLQuery[query_folder].Query()
    trades = db_query.Select()
    data = []

    tms_mod = TMS_Modules()

    for i in trades:
        tms_mod.set_trade(i)

        temp_result = (
            tms_mod.fedealno(),
            tms_mod.dealno(),
            tms_mod.cno(),
            tms_mod.secsacct(),
            tms_mod.ps(),
            tms_mod.invtype(),
            tms_mod.port(),
            tms_mod.trad(),
            tms_mod.secid(),
            tms_mod.origqty(),
            tms_mod.price_8(),
            tms_mod.settdate(),
            tms_mod.brokeramt(),
            tms_mod.broker(),
            tms_mod.cost(),
            tms_mod.ratecode(),
            tms_mod.inputdate(),
            tms_mod.dealtext(),
            tms_mod.verind(),
            tms_mod.verdate(),
            tms_mod.revreason(),
            tms_mod.settccy(),
            tms_mod.server(),
            tms_mod.dealdate(),
            tms_mod.amend_date(),
        )
        data.append(temp_result)
    

    data = list(set(data))
    text_result += "Table : " + table_name + "\n"
    text_result += "Columns : " + str(columns) + "\n"
    
    if data == [] :
        text_result += '\nNo new data to be inserted/updated.\n'
    else:
        dbOps = TableManipulator()
        cursor, text_connect = dbOps.connect()

        text_result += text_connect
        text_result += dbOps.upsert(table_name, columns, data, [columns[1]])
        #text_result += dbOps.delete_row_from_table(table_name, tuple(void_trades), columns[0])
        #text_result += dbOps.truncate([table_name])
        text_result += dbOps.disconnect()
        
    print(text_result)
    extension_value_name = table_name + '_LOG'
    storeToExtensionValue(extension_value_name, text_result)
    write_log_file(file_path, extension_value_name, text_result)



...

  TMS_FIXING

from DataStager import *
from TMS import *

ael_gui_parameters={'runButtonLabel':'&&Run',
                    'hideExtraControls': True,
                    'windowCaption':'TMS_FIXING'}

ael_variables=[
['query_folder','Query Folders','string', filter_query_folder('Trade'), 'WEBEAI_TMS_FIXING', 1,0],
['file_path', 'Log Folder Path', getFilePathSelection(), None, getFilePathSelection(), 1, 1]]

def ael_main(parameter):
    text_result = ''
    table_name = 'TMS_FIXING'
    columns = ('DEALNO', 'RATECODE', 'LAST_FIXING', 'NEXT_FIXING', 'PRODUCT', 'PRODTYPE', 'USER_FIXING')
    file_path = str(parameter['file_path'])
    query_folder = parameter['query_folder']
    
    db_query = acm.FStoredASQLQuery[query_folder].Query()
    trades = db_query.Select()
    data = []

    tms_mod = TMS_Modules()

    for i in trades:
        tms_mod.set_trade(i)

        temp_result = (
            tms_mod.dealno(),
            tms_mod.ratecode(),
            tms_mod.last_fixing(),
            tms_mod.next_fixing(),
            tms_mod.product(),
            tms_mod.prodtype(),
            tms_mod.user_fixing()
        )
        data.append(temp_result)
    
    
    data = list(set(data))
    text_result += "Table : " + table_name + "\n"
    text_result += "Columns : " + str(columns) + "\n"
    
    if data == [] :
        text_result += '\nNo new data to be inserted/updated.\n'
    else:
        dbOps = TableManipulator()
        cursor, text_connect = dbOps.connect()

        text_result += text_connect
        text_result += dbOps.upsert(table_name, columns, data, [columns[0]])
        #text_result += dbOps.delete_row_from_table(table_name, tuple(void_trades), columns[0])
        #text_result += dbOps.truncate([table_name])
        text_result += dbOps.disconnect()
        
    print(text_result)
    extension_value_name = table_name + '_LOG'
    storeToExtensionValue(extension_value_name, text_result)
    write_log_file(file_path, extension_value_name, text_result)




...

  TMS_FX_TRANSACTION

from DataStager import *
from TMS import *

ael_gui_parameters={'runButtonLabel':'&&Run',
                    'hideExtraControls': True,
                    'windowCaption':'TMS_FX_TRANSACTION'}

ael_variables=[
['query_folder','Query Folders','string', filter_query_folder('Trade'), 'WEBEAI_TMS_FX_TRANSACTION', 1,0],
['file_path', 'Log Folder Path', getFilePathSelection(), None, getFilePathSelection(), 1, 1]]

def ael_main(parameter):
    text_result = ''
    table_name = 'TMS_FX_TRANSACTION'
    columns = ('DEALNO', 'VDATE', 'SWAPDEALNO', 'SWAPVDATE', 'CNO', 'DEALDATE', 'INPUTDATE', 'PRODCODE', 'PRODTYPE', 'FARNEARIND', 'CCY', 'CCYAMT', 'CTRCCY', 'CTRAMT', 'CCYBAMT', 'CORPSPREADAMT', 'PS', 'CCODE', 'ACCTNGTYPE_CUSTOMER', 'PORT', 'TRAD', 'COST', 'IOPER', 'VOPER', 'PAYOPER', 'AUTHOPER', 'REVOPER', 'REVAUTH', 'DEALTEXT', 'FEDEALNO', 'CCYSMEANS', 'CCYSACCT', 'CTRCCYSMEANS', 'CTRSACCT', 'SPOTFWDIND', 'RATE', 'BR', 'STATUS', 'BROKER', 'REVERSE_DATE', 'AMEND_DATE', 'BROKERAMT', 'LSTMNTDATE', 'SETTDATE', 'SPOTDATE')
    
    file_path = str(parameter['file_path'])
    query_folder = parameter['query_folder']
    
    db_query = acm.FStoredASQLQuery[query_folder].Query()
    trades = db_query.Select()
    data = []

    tms_mod = TMS_Modules()

    for i in trades:
        tms_mod.set_trade(i)

        temp_result = (
            tms_mod.dealno(),
            tms_mod.valuedate(),
            tms_mod.swapdealno(),
            tms_mod.swapvdate(),
            tms_mod.cno(),
            tms_mod.dealdate(),
            tms_mod.inputdate(),
            tms_mod.product(),
            tms_mod.prodtype(),
            tms_mod.farnearind(),
            tms_mod.ccy(),
            tms_mod.ccyamt(),
            tms_mod.ctrccy(),
            tms_mod.ctramt(),
            tms_mod.ccybamt(),
            tms_mod.corpspreadamt(),
            tms_mod.ps(),
            tms_mod.ccode(),
            tms_mod.acctngtype(),
            tms_mod.port(),
            tms_mod.trad(),
            tms_mod.cost(),
            tms_mod.ioper(),
            tms_mod.voper(),
            tms_mod.payoper(),
            tms_mod.authoper(),
            tms_mod.revoper(),
            tms_mod.revauth(),
            tms_mod.dealtext(),
            tms_mod.fedealno(),
            tms_mod.ccysmeans(),
            tms_mod.ccysacct(),
            tms_mod.ctrccysmeans(),
            tms_mod.ctrsacct(),
            tms_mod.spotfwd(),
            tms_mod.rate(),
            tms_mod.br(),
            tms_mod.status(),
            tms_mod.broker(),
            tms_mod.reverse_date(),
            tms_mod.amend_date(),
            tms_mod.brokeramt(),
            tms_mod.lstmntdate(),
            tms_mod.settdate(),
            tms_mod.spotdate(),
        )
        data.append(temp_result)
    
    
    data = list(set(data))
    text_result += "Table : " + table_name + "\n"
    text_result += "Columns : " + str(columns) + "\n"
    
    if data == [] :
        text_result += '\nNo new data to be inserted/updated.\n'
    else:
        dbOps = TableManipulator()
        cursor, text_connect = dbOps.connect()

        text_result += text_connect
        text_result += dbOps.upsert(table_name, columns, data, [columns[0]])
        #text_result += dbOps.delete_row_from_table(table_name, tuple(void_trades), columns[0])
        #text_result += dbOps.truncate([table_name])
        text_result += dbOps.disconnect()
        
    print(text_result)
    extension_value_name = table_name + '_LOG'
    storeToExtensionValue(extension_value_name, text_result)
    write_log_file(file_path, extension_value_name, text_result)


...

  TMS_FX_TRANSACTION_INTERFACE

from DataStager import *
from TMS import *

ael_gui_parameters={'runButtonLabel':'&&Run',
                    'hideExtraControls': True,
                    'windowCaption':'TMS_FX_TRANSACTION_INTERFACE'}

ael_variables=[
['query_folder','Query Folders','string', filter_query_folder('Trade'), 'WEBEAI_TMS_FX_TRANSACTION_INTERFACE', 1,0],
['file_path', 'Log Folder Path', getFilePathSelection(), None, getFilePathSelection(), 1, 1]]

def ael_main(parameter):
    text_result = ''
    table_name = 'TMS_FX_TRANSACTION_INTERFACE'
    columns = ('SERVER', 'FEDEALNO', 'DEALNO', 'NDEALNO', 'FDEALNO', 'TRAD', 'VDATE', 'NVDATE', 'FVDATE', 'CNO', 'BROK', 'BROKCCY', 'BROKAMT', 'PORT', 'COST', 'DEALDATE', 'DEALTEXT', 'PS', 'CCY', 'CCYAMT', 'CTRCCY', 'CTRAMT', 'PRODCODE', 'PRODTYPE', 'REVREASON', 'CORPTRAD', 'CORPPORT', 'CORPCOST', 'INTERNALRATE_8', 'CORPSPREADAMT', 'FIXRATECODE', 'NPRODCODE', 'FPRODCODE', 'NPRODTYPE', 'FPRODTYPE', 'NCNO', 'FCNO', 'AMENDTIME')
 
    file_path = str(parameter['file_path'])
    query_folder = parameter['query_folder']
    
    db_query = acm.FStoredASQLQuery[query_folder].Query()
    trades = db_query.Select()
    data = []

    tms_mod = TMS_Modules()

    for i in trades:
        tms_mod.set_trade(i)

        temp_result = (
            tms_mod.server(),
            tms_mod.fedealno(),
            tms_mod.dealno(),
            tms_mod.ndealno(),
            tms_mod.fdealno(),
            tms_mod.trad(),
            tms_mod.valuedate(),
            tms_mod.nvdate(),
            tms_mod.fvdate(),
            tms_mod.cno(),
            tms_mod.broker(),
            tms_mod.brokerccy(),
            tms_mod.brokeramt(),
            tms_mod.port(),
            tms_mod.cost(),
            tms_mod.dealdate(),
            tms_mod.dealtext(),
            tms_mod.ps(),
            tms_mod.ccy(),
            tms_mod.ccyamt(),
            tms_mod.ctrccy(),
            tms_mod.ctramt(),
            tms_mod.product(),
            tms_mod.prodtype(),
            tms_mod.revreason(),
            tms_mod.corptrad(),
            tms_mod.corpport(),
            tms_mod.corpcost(),
            tms_mod.intrate_8(),
            tms_mod.corpspreadamt(),
            tms_mod.fixratecode(),
            tms_mod.nprodcode(),
            tms_mod.fprodcode(),
            tms_mod.nprodtype(),
            tms_mod.fprodtype(),
            tms_mod.ncno(),
            tms_mod.fcno(),
            tms_mod.amend_date()
        )
        data.append(temp_result)
    
    
    data = list(set(data))
    text_result += "Table : " + table_name + "\n"
    text_result += "Columns : " + str(columns) + "\n"
    
    if data == [] :
        text_result += '\nNo new data to be inserted/updated.\n'
    else:
        dbOps = TableManipulator()
        cursor, text_connect = dbOps.connect()

        text_result += text_connect
        text_result += dbOps.upsert(table_name, columns, data, [columns[2]])
        #text_result += dbOps.delete_row_from_table(table_name, tuple(void_trades), columns[0])
        #text_result += dbOps.truncate([table_name])
        text_result += dbOps.disconnect()
        
    print(text_result)
    extension_value_name = table_name + '_LOG'
    storeToExtensionValue(extension_value_name, text_result)
    write_log_file(file_path, extension_value_name, text_result)


...

  TMS_MM_TRANSACTION

from DataStager import *
from TMS import *

ael_gui_parameters={'runButtonLabel':'&&Run',
                    'hideExtraControls': True,
                    'windowCaption':'TMS_MM_TRANSACTION'}

ael_variables=[
['query_folder','Query Folders','string', filter_query_folder('Trade'), 'WEBEAI_TMS_MM_TRANSACTION', 1,0],
['file_path', 'Log Folder Path', getFilePathSelection(), None, getFilePathSelection(), 1, 1]]

def ael_main(parameter):
    text_result = ''
    table_name = 'TMS_MM_TRANSACTION'
    columns = ('DEALNO', 'VDATE', 'MDATE', 'CNO', 'DEALDATE', 'INPUTDATE', 'PRODUCT', 'PRODTYPE', 'CCY', 'CCYAMT', 'TOTPAYAMT', 'INTAMT', 'INTRATE_8', 'PORT', 'TRAD', 'COST', 'IOPER', 'VOPER', 'PAYOPER', 'AUTHOPER', 'REVOPER', 'REVAUTH', 'DEALTEXT', 'FEDEALNO', 'SMEANS', 'SACCT', 'INTSMEANS', 'INTSACCT', 'INTENDDTE', 'SCHDTYPE', 'BR', 'STATUS', 'BROKER', 'REVERSE_DATE', 'AMEND_DATE', 'BROKERAMT', 'LSTMNTDATE', 'RATE', 'BROKNAME')
    
    file_path = str(parameter['file_path'])
    query_folder = parameter['query_folder']
    
    db_query = acm.FStoredASQLQuery[query_folder].Query()
    trades = db_query.Select()
    data = []

    tms_mod = TMS_Modules()

    for i in trades:
        tms_mod.set_trade(i)

        temp_result = (
            tms_mod.dealno(),
            tms_mod.valuedate(),
            tms_mod.mdate(),
            tms_mod.cno(),
            tms_mod.dealdate(),
            tms_mod.inputdate(),
            tms_mod.product(),
            tms_mod.prodtype(),
            tms_mod.ccy(),
            tms_mod.ccyamt(),
            tms_mod.totpayamt(),
            tms_mod.intamt(),
            tms_mod.intrate_8(),
            tms_mod.port(),
            tms_mod.trad(),
            tms_mod.cost(),
            tms_mod.ioper(),
            tms_mod.voper(),
            tms_mod.payoper(),
            tms_mod.authoper(),
            tms_mod.revoper(),
            tms_mod.revauth(),
            tms_mod.dealtext(),
            tms_mod.fedealno(),
            tms_mod.smeans(),
            tms_mod.sacct(),
            tms_mod.intsmeans(),
            tms_mod.intsacct(),
            tms_mod.intenddate(),
            tms_mod.schdtype(),
            tms_mod.br(),
            tms_mod.status(),
            tms_mod.broker(),
            tms_mod.reverse_date(),
            tms_mod.amend_date(),
            tms_mod.brokeramt(),
            tms_mod.lstmntdate(),
            tms_mod.rate(),
            tms_mod.brokername()
        )
        data.append(temp_result)
    
    
    data = list(set(data))
    text_result += "Table : " + table_name + "\n"
    text_result += "Columns : " + str(columns) + "\n"
    
    if data == [] :
        text_result += '\nNo new data to be inserted/updated.\n'
    else:
        dbOps = TableManipulator()
        cursor, text_connect = dbOps.connect()

        text_result += text_connect
        text_result += dbOps.upsert(table_name, columns, data, [columns[0]])
        #text_result += dbOps.delete_row_from_table(table_name, tuple(void_trades), columns[0])
        #text_result += dbOps.truncate([table_name])
        text_result += dbOps.disconnect()
        
    print(text_result)
    extension_value_name = table_name + '_LOG'
    storeToExtensionValue(extension_value_name, text_result)
    write_log_file(file_path, extension_value_name, text_result)


...

  TMS_MM_TRANSACTION_INTERFACE

from DataStager import *
from TMS import *

ael_gui_parameters={'runButtonLabel':'&&Run',
                    'hideExtraControls': True,
                    'windowCaption':'TMS_MM_TRANSACTION_INTERFACE'}

ael_variables=[
['query_folder','Query Folders','string', filter_query_folder('Trade'), 'WEBEAI_TMS_MM_TRANSACTION_INTERFACE', 1,0],
['file_path', 'Log Folder Path', getFilePathSelection(), None, getFilePathSelection(), 1, 1]]

def ael_main(parameter):
    text_result = ''
    table_name = 'TMS_MM_TRANSACTION_INTERFACE'
    columns = ('FEDEALNO', 'DEALNO', 'PRODUCT', 'PRODTYPE', 'TRAD', 'VDATE', 'MDATE', 'CNO', 'CCY', 'CCYAMT', 'RATECODE', 'BASIS', 'INTRATE', 'SPREAD_8', 'BROK', 'BROKCCY', 'BROKAMT', 'PORT', 'COST', 'DEALDATE', 'DEALTEXT', 'VERIND', 'INPUTDATE', 'SERVER', 'AMENDTIME')
    
    file_path = str(parameter['file_path'])
    query_folder = parameter['query_folder']
    
    db_query = acm.FStoredASQLQuery[query_folder].Query()
    trades = db_query.Select()
    data = []

    tms_mod = TMS_Modules()

    for i in trades:
        tms_mod.set_trade(i)

        temp_result = (
            tms_mod.fedealno(),
            tms_mod.dealno(),
            tms_mod.product(),
            tms_mod.prodtype(),
            tms_mod.trad(),
            tms_mod.valuedate(),
            tms_mod.mdate(),
            tms_mod.cno(),
            tms_mod.ccy(),
            tms_mod.ccyamt(),
            tms_mod.ratecode(),
            tms_mod.basis(),
            tms_mod.intrate_8(),
            tms_mod.spread_8(),
            tms_mod.broker(),
            tms_mod.brokerccy(),
            tms_mod.brokeramt(),
            tms_mod.port(),
            tms_mod.cost(),
            tms_mod.dealdate(),
            tms_mod.dealtext(),
            tms_mod.verind(),
            tms_mod.inputdate(),
            tms_mod.server(),
            tms_mod.amend_date(),
        )
        data.append(temp_result)
    
    
    data = list(set(data))
    text_result += "Table : " + table_name + "\n"
    text_result += "Columns : " + str(columns) + "\n"
    
    if data == [] :
        text_result += '\nNo new data to be inserted/updated.\n'
    else:
        dbOps = TableManipulator()
        cursor, text_connect = dbOps.connect()

        text_result += text_connect
        text_result += dbOps.upsert(table_name, columns, data, [columns[1]])
        #text_result += dbOps.delete_row_from_table(table_name, tuple(void_trades), columns[0])
        #text_result += dbOps.truncate([table_name])
        text_result += dbOps.disconnect()
        
    print(text_result)
    extension_value_name = table_name + '_LOG'
    storeToExtensionValue(extension_value_name, text_result)
    write_log_file(file_path, extension_value_name, text_result)


...

  TMS_OPTION_CALLSPREAD

from DataStager import *
from TMS import *

ael_gui_parameters={'runButtonLabel':'&&Run',
                    'hideExtraControls': True,
                    'windowCaption':'TMS_OPTION_CALLSPREAD'}

ael_variables=[
['query_folder','Query Folders','string', filter_query_folder('Trade'), 'WEBEAI_TMS_OPTION_CALLSPREAD', 1,0],
['file_path', 'Log Folder Path', getFilePathSelection(), None, getFilePathSelection(), 1, 1]]

def ael_main(parameter):
    text_result = ''
    table_name = 'TMS_OPTION_CALLSPREAD'
    columns = ('PARENT_VDATE', 'DEALNO', 'EFFDATE', 'MDATE', 'CNO', 'DEALDATE', 'INPUTDATE', 'PRODCODE', 'PRODTYPE', 'PUT_CCY', 'PUT_AMT', 'CALL_CCY', 'CALL_AMT', 'PREMIUM_CCY', 'PREMIUM_AMT', 'PS', 'AUTHOPER', 'REVOPER', 'REVAUTH', 'DEALTEXT', 'FEDEALNO', 'CCYSMEANS', 'CCYSACCT', 'CTRCCYSMEANS', 'CTRSACCT', 'RATE', 'STRIKE', 'BENEFICIARY', 'ACCOUNT', 'INTERMEDIARY', 'BR', 'STATUS', 'AMENDTIME', 'OPTION_STATUS')
    file_path = str(parameter['file_path'])
    query_folder = parameter['query_folder']
    
    db_query = acm.FStoredASQLQuery[query_folder].Query()
    trades = db_query.Select()
    data = []

    tms_mod = TMS_Modules()

    for i in trades:
        tms_mod.set_trade(i)

        temp_result = (
            tms_mod.parent_vdate(),
            tms_mod.dealno(),
            tms_mod.effdate(),
            tms_mod.mdate(),
            tms_mod.cno(),
            tms_mod.dealdate(),
            tms_mod.inputdate(),
            tms_mod.product(),
            tms_mod.prodtype(),
            tms_mod.put_ccy(),
            tms_mod.put_amt(),
            tms_mod.call_ccy(),
            tms_mod.call_amt(),
            tms_mod.premium_ccy(),
            tms_mod.premium_amt(),
            tms_mod.ps(),
            tms_mod.authoper(),
            tms_mod.revoper(),
            tms_mod.revauth(),
            tms_mod.dealtext(),
            tms_mod.fedealno(),
            tms_mod.ccysmeans(),
            tms_mod.ccysacct(),
            tms_mod.ctrccysmeans(),
            tms_mod.ctrsacct(),
            tms_mod.rate(),
            tms_mod.strike(),
            tms_mod.beneficiary(),
            tms_mod.account(),
            tms_mod.intermediary(),
            tms_mod.br(),
            tms_mod.status(),
            tms_mod.amend_date(),
            tms_mod.option_status(),
        )
        data.append(temp_result)

    data = list(set(data))
    text_result += "Table : " + table_name + "\n"
    text_result += "Columns : " + str(columns) + "\n"
    
    if data == [] :
        text_result += '\nNo new data to be inserted/updated.\n'
    else:
        dbOps = TableManipulator()
        cursor, text_connect = dbOps.connect()

        text_result += text_connect
        text_result += dbOps.upsert(table_name, columns, data, [columns[1]])
        #text_result += dbOps.delete_row_from_table(table_name, tuple(void_trades), columns[0])
        #text_result += dbOps.truncate([table_name])
        text_result += dbOps.disconnect()
        
    print(text_result)
    extension_value_name = table_name + '_LOG'
    storeToExtensionValue(extension_value_name, text_result)
    write_log_file(file_path, extension_value_name, text_result)




...

  TMS_REUTERS_CONVERSATION

from DataStager import *
from TMS import *

ael_gui_parameters={'runButtonLabel':'&&Run',
                    'hideExtraControls': True,
                    'windowCaption':'TMS_REUTERS_CONVERSATION'}

ael_variables=[
['query_folder','Query Folders','string', filter_query_folder('Trade'), 'WEBEAI_TMS_REUTERS_CONVERSATION', 1,0],
['file_path', 'Log Folder Path', getFilePathSelection(), None, getFilePathSelection(), 1, 1]]

def ael_main(parameter):
    text_result = ''
    table_name = 'TMS_REUTERS_CONVERSATION'
    columns = ('FEDEALNO', 'DEALNO', 'CONVERSATION')
    file_path = str(parameter['file_path'])
    query_folder = parameter['query_folder']
    
    db_query = acm.FStoredASQLQuery[query_folder].Query()
    trades = db_query.Select()
    data = []

    tms_mod = TMS_Modules()

    for i in trades:
        tms_mod.set_trade(i)

        temp_result = (
            tms_mod.fedealno(),
            tms_mod.dealno(),
            tms_mod.conversation()
        )
        data.append(temp_result)
    
    
    data = list(set(data))
    text_result += "Table : " + table_name + "\n"
    text_result += "Columns : " + str(columns) + "\n"
    
    if data == [] :
        text_result += '\nNo new data to be inserted/updated.\n'
    else:
        dbOps = TableManipulator()
        cursor, text_connect = dbOps.connect()

        text_result += text_connect
        text_result += dbOps.upsert(table_name, columns, data, [columns[1]])
        #text_result += dbOps.delete_row_from_table(table_name, tuple(void_trades), columns[0])
        #text_result += dbOps.truncate([table_name])
        text_result += dbOps.disconnect()
        
    print(text_result)
    extension_value_name = table_name + '_LOG'
    storeToExtensionValue(extension_value_name, text_result)
    write_log_file(file_path, extension_value_name, text_result)




...

}

